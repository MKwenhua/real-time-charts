/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 98);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (process.env.NODE_ENV === 'production') {
  module.exports = __webpack_require__(162);
} else {
  module.exports = __webpack_require__(161);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 1 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = newInterval;
var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(new Date(+start)); while (offseti(start, step), floori(start), start < stop)
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) while (--step >= 0) while (offseti(date, 1), !test(date)) {} // eslint-disable-line no-empty
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return durationSecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return durationMinute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return durationHour; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return durationDay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return durationWeek; });
var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
function Canvas2DContext(canvas) {
   if (!(this instanceof Canvas2DContext)) {
      return new Canvas2DContext(canvas);
   }
   this.context = this.ctx = canvas.getContext('2d');
   if (!Canvas2DContext.prototype.arc) {
      Canvas2DContext.setup.call(this, this.ctx);
   }
}
Canvas2DContext.setup = function () {
   var methods = ['arc', 'arcTo', 'beginPath', 'bezierCurveTo', 'clearRect', 'clip', 'closePath', 'drawImage', 'fill', 'fillRect', 'fillText', 'lineTo', 'moveTo', 'quadraticCurveTo', 'rect', 'restore', 'rotate', 'save', 'scale', 'setTransform', 'stroke', 'strokeRect', 'strokeText', 'transform', 'translate'];

   var getterMethods = ['createPattern', 'drawFocusRing', 'isPointInPath', 'measureText', 'createImageData', 'createLinearGradient', 'createRadialGradient', 'getImageData', 'putImageData'];

   var properties = ['canvas', 'fillStyle', 'font', 'globalAlpha', 'globalCompositeOperation', 'lineCap', 'lineJoin', 'lineWidth', 'miterLimit', 'shadowOffsetX', 'shadowOffsetY', 'shadowBlur', 'shadowColor', 'strokeStyle', 'textAlign', 'textBaseline'];

   var _iteratorNormalCompletion = true;
   var _didIteratorError = false;
   var _iteratorError = undefined;

   try {
      var _loop = function _loop() {
         var m = _step.value;

         var method = m;
         Canvas2DContext.prototype[method] = function () {
            this.ctx[method].apply(this.ctx, arguments);
            return this;
         };
      };

      for (var _iterator = methods[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
         _loop();
      }
   } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
   } finally {
      try {
         if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
         }
      } finally {
         if (_didIteratorError) {
            throw _iteratorError;
         }
      }
   }

   var _iteratorNormalCompletion2 = true;
   var _didIteratorError2 = false;
   var _iteratorError2 = undefined;

   try {
      var _loop2 = function _loop2() {
         var m = _step2.value;

         var method = m;
         Canvas2DContext.prototype[method] = function () {
            return this.ctx[method].apply(this.ctx, arguments);
         };
      };

      for (var _iterator2 = getterMethods[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
         _loop2();
      }
   } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
   } finally {
      try {
         if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
         }
      } finally {
         if (_didIteratorError2) {
            throw _iteratorError2;
         }
      }
   }

   var _iteratorNormalCompletion3 = true;
   var _didIteratorError3 = false;
   var _iteratorError3 = undefined;

   try {
      var _loop3 = function _loop3() {
         var p = _step3.value;

         var prop = p;
         Canvas2DContext.prototype[prop] = function (value) {
            if (value === undefined) return this.ctx[prop];
            this.ctx[prop] = value;
            return this;
         };
      };

      for (var _iterator3 = properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
         _loop3();
      }
   } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
   } finally {
      try {
         if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
         }
      } finally {
         if (_didIteratorError3) {
            throw _iteratorError3;
         }
      }
   }
};
exports.default = Canvas2DContext;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Provider__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_connectAdvanced__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__connect_connect__ = __webpack_require__(153);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Provider", function() { return __WEBPACK_IMPORTED_MODULE_0__components_Provider__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "createProvider", function() { return __WEBPACK_IMPORTED_MODULE_0__components_Provider__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "connectAdvanced", function() { return __WEBPACK_IMPORTED_MODULE_1__components_connectAdvanced__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "connect", function() { return __WEBPACK_IMPORTED_MODULE_2__connect_connect__["a"]; });






/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(4);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 11 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var ADD_CHART = 'ADD_CHART';
var CLOSE_CHART = 'CLOSE_CHART';
var CHART_STATE_UPDATE = 'CHART_STATE_UPDATE';
var WATCHED_POSITIONS = 'WATCHED_POSITIONS';
var FEED_START = 'FEED_START';
var OPTS_VIEW = 'OPTS_VIEW';
var SWITCH_INDICES = 'SWITCH_INDICES';
var TOGGLE_CHART_MENU = 'TOGGLE_CHART_MENU';
var CONNECTION_LOST = 'CONNECTION_LOST';
var CONNECTED = 'CONNECTED';

exports.ADD_CHART = ADD_CHART;
exports.CLOSE_CHART = CLOSE_CHART;
exports.CHART_STATE_UPDATE = CHART_STATE_UPDATE;
exports.WATCHED_POSITIONS = WATCHED_POSITIONS;
exports.FEED_START = FEED_START;
exports.OPTS_VIEW = OPTS_VIEW;
exports.SWITCH_INDICES = SWITCH_INDICES;
exports.TOGGLE_CHART_MENU = TOGGLE_CHART_MENU;
exports.CONNECTION_LOST = CONNECTION_LOST;
exports.CONNECTED = CONNECTED;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _xhr = __webpack_require__(175);

var _xhr2 = _interopRequireDefault(_xhr);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DATASOURCE = function () {
  function DATASOURCE() {
    var _this = this;

    var instanceName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Default';

    _classCallCheck(this, DATASOURCE);

    this.getRealTimeXHR = function (cb) {
      _this.xhrGet('getusers', cb);
    };

    this.getListTypeXHR = function (param, cb) {
      console.log('used sockets for getListType');
      var route = 'listparams/' + param;
      _this.xhrGet(route, cb);
    };

    this.getIndicatorXHR = function (country, cb) {
      var route = 'indicator/' + country;
      _this.xhrGet(route, cb);
    };

    this.getMarketDataXHR = function (symbol, cb) {
      var route = 'marketdata/' + symbol.toUpperCase();
      _this.xhrGet(route, cb);
    };

    this.instanceName = instanceName;
  }

  _createClass(DATASOURCE, [{
    key: 'xhrGet',
    value: function xhrGet(route, cb) {
      var theURL = '/xhrs/' + route;

      var request = new XMLHttpRequest();
      request.open('GET', theURL, true);
      request.onload = function () {
        if (request.status >= 200 && request.status < 400) {
          var resp = request.responseText;
          cb(JSON.parse(resp));
        }
      };
      request.onerror = function () {
        console.log('things happened');
      };
      request.send();
    }
  }, {
    key: 'xhrPost',
    value: function xhrPost(route, data, cb) {
      var theURL = '/xhrs/' + route;
      (0, _xhr2.default)({
        body: JSON.stringify(data),
        uri: theURL,
        headers: {
          'Content-Type': 'application/json'
        }
      }, function (err, resp, body) {
        return cb(JSON.parse(body));
      });
    }
  }]);

  return DATASOURCE;
}();

exports.default = new DATASOURCE('main');

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
     true ? factory(exports, __webpack_require__(105), __webpack_require__(125), __webpack_require__(110)) :
    typeof define === 'function' && define.amd ? define(['exports', 'd3-random', 'd3fc-rebind', 'd3-time'], factory) :
    (factory((global.fc = global.fc || {}),global.d3,global.fc,global.d3));
}(this, (function (exports,d3Random,d3fcRebind,d3Time) { 'use strict';

var geometricBrownianMotion = function () {
    var period = 1;
    var steps = 20;
    var mu = 0.1;
    var sigma = 0.1;
    var randomNormal$$1 = d3Random.randomNormal();

    var geometricBrownianMotion = function geometricBrownianMotion(value) {
        var timeStep = period / steps;
        var pathData = [];

        for (var i = 0; i < steps + 1; i++) {
            pathData.push(value);
            var increment = randomNormal$$1() * Math.sqrt(timeStep) * sigma + (mu - sigma * sigma / 2) * timeStep;
            value = value * Math.exp(increment);
        }

        return pathData;
    };

    geometricBrownianMotion.period = function () {
        if (!arguments.length) {
            return period;
        }
        period = arguments.length <= 0 ? undefined : arguments[0];
        return geometricBrownianMotion;
    };

    geometricBrownianMotion.steps = function () {
        if (!arguments.length) {
            return steps;
        }
        steps = arguments.length <= 0 ? undefined : arguments[0];
        return geometricBrownianMotion;
    };

    geometricBrownianMotion.mu = function () {
        if (!arguments.length) {
            return mu;
        }
        mu = arguments.length <= 0 ? undefined : arguments[0];
        return geometricBrownianMotion;
    };

    geometricBrownianMotion.sigma = function () {
        if (!arguments.length) {
            return sigma;
        }
        sigma = arguments.length <= 0 ? undefined : arguments[0];
        return geometricBrownianMotion;
    };

    geometricBrownianMotion.randomNormal = function () {
        if (!arguments.length) {
            return randomNormal$$1;
        }
        randomNormal$$1 = arguments.length <= 0 ? undefined : arguments[0];
        return geometricBrownianMotion;
    };

    return geometricBrownianMotion;
};

function functor(v) {
    return typeof v === 'function' ? v : function () {
        return v;
    };
}

var financial = function () {
    var startDate = new Date();
    var startPrice = 100;
    var interval = d3Time.timeDay;
    var intervalStep = 1;
    var unitInterval = d3Time.timeYear;
    var unitIntervalStep = 1;
    var filter = null;
    var volume = function volume() {
        var normal = d3Random.randomNormal(1, 0.1);
        return Math.ceil(normal() * 1000);
    };
    var gbm = geometricBrownianMotion();

    var getOffsetPeriod = function getOffsetPeriod(date) {
        var unitMilliseconds = unitInterval.offset(date, unitIntervalStep) - date;
        return (interval.offset(date, intervalStep) - date) / unitMilliseconds;
    };

    var calculateOHLC = function calculateOHLC(start, price) {
        var period = getOffsetPeriod(start);
        var prices = gbm.period(period)(price);
        var ohlc = {
            date: start,
            open: prices[0],
            high: Math.max.apply(Math, prices),
            low: Math.min.apply(Math, prices),
            close: prices[gbm.steps()]
        };
        ohlc.volume = volume(ohlc);
        return ohlc;
    };

    var getNextDatum = function getNextDatum(ohlc) {
        var date = void 0,
            price = void 0,
            filtered = void 0;
        do {
            date = ohlc ? interval.offset(ohlc.date, intervalStep) : new Date(startDate.getTime());
            price = ohlc ? ohlc.close : startPrice;
            ohlc = calculateOHLC(date, price);
            filtered = filter && !filter(ohlc);
        } while (filtered);
        return ohlc;
    };

    var makeStream = function makeStream() {
        var latest = void 0;
        var stream = {};
        stream.next = function () {
            var ohlc = getNextDatum(latest);
            latest = ohlc;
            return ohlc;
        };
        stream.take = function (numPoints) {
            return stream.until(function (d, i) {
                return !numPoints || numPoints < 0 || i === numPoints;
            });
        };
        stream.until = function (comparison) {
            var data = [];
            var index = 0;
            var ohlc = getNextDatum(latest);
            var compared = comparison && !comparison(ohlc, index);
            while (compared) {
                data.push(ohlc);
                latest = ohlc;
                ohlc = getNextDatum(latest);
                index += 1;
                compared = comparison && !comparison(ohlc, index);
            }
            return data;
        };
        return stream;
    };

    var financial = function financial(numPoints) {
        return makeStream().take(numPoints);
    };
    financial.stream = makeStream;
    financial[Symbol.iterator] = function () {
        var stream = makeStream();
        return {
            next: function next() {
                return {
                    value: stream.next(),
                    done: false
                };
            }
        };
    };

    financial.startDate = function () {
        if (!arguments.length) {
            return startDate;
        }
        startDate = arguments.length <= 0 ? undefined : arguments[0];
        return financial;
    };
    financial.startPrice = function () {
        if (!arguments.length) {
            return startPrice;
        }
        startPrice = arguments.length <= 0 ? undefined : arguments[0];
        return financial;
    };
    financial.interval = function () {
        if (!arguments.length) {
            return interval;
        }
        interval = arguments.length <= 0 ? undefined : arguments[0];
        return financial;
    };
    financial.intervalStep = function () {
        if (!arguments.length) {
            return intervalStep;
        }
        intervalStep = arguments.length <= 0 ? undefined : arguments[0];
        return financial;
    };
    financial.unitInterval = function () {
        if (!arguments.length) {
            return unitInterval;
        }
        unitInterval = arguments.length <= 0 ? undefined : arguments[0];
        return financial;
    };
    financial.unitIntervalStep = function () {
        if (!arguments.length) {
            return unitIntervalStep;
        }
        unitIntervalStep = arguments.length <= 0 ? undefined : arguments[0];
        return financial;
    };
    financial.filter = function () {
        if (!arguments.length) {
            return filter;
        }
        filter = arguments.length <= 0 ? undefined : arguments[0];
        return financial;
    };
    financial.volume = function () {
        if (!arguments.length) {
            return volume;
        }
        volume = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return financial;
    };

    d3fcRebind.rebind(financial, gbm, 'steps', 'mu', 'sigma');

    return financial;
};

var skipWeekends = function (datum) {
    var day = datum.date.getDay();
    return !(day === 0 || day === 6);
};

exports.randomFinancial = financial;
exports.randomGeometricBrownianMotion = geometricBrownianMotion;
exports.randomSkipWeekends = skipWeekends;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getPrototype_js__ = __webpack_require__(140);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__ = __webpack_require__(145);




/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__["a" /* default */])(value) || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a" /* default */])(value) != objectTag) {
    return false;
  }
  var proto = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__getPrototype_js__["a" /* default */])(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/* harmony default export */ __webpack_exports__["a"] = (isPlainObject);


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(6);
  var warning = __webpack_require__(10);
  var ReactPropTypesSecret = __webpack_require__(17);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__createStore__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__combineReducers__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__bindActionCreators__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__applyMiddleware__ = __webpack_require__(167);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__compose__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_warning__ = __webpack_require__(44);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "createStore", function() { return __WEBPACK_IMPORTED_MODULE_0__createStore__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "combineReducers", function() { return __WEBPACK_IMPORTED_MODULE_1__combineReducers__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "bindActionCreators", function() { return __WEBPACK_IMPORTED_MODULE_2__bindActionCreators__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "applyMiddleware", function() { return __WEBPACK_IMPORTED_MODULE_3__applyMiddleware__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return __WEBPACK_IMPORTED_MODULE_4__compose__["a"]; });







/*
* This is a dummy function to check if the function name has been altered by minification.
* If the function has been minified and NODE_ENV !== 'production', warn the user.
*/
function isCrushed() {}

if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils_warning__["a" /* default */])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
}


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(1)))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var WIDGET_DROP = 'WIDGET_DROP';
var WIDGET_DRAGGED = 'WIDGET_DRAGGED';
var GOT_MESSAGE = 'GOT_MESSAGE';
var GOT_DATA = 'GOT_DATA';

exports.WIDGET_DROP = WIDGET_DROP;
exports.WIDGET_DRAGGED = WIDGET_DRAGGED;
exports.GOT_MESSAGE = GOT_MESSAGE;
exports.GOT_DATA = GOT_DATA;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Graph = function (_React$PureComponent) {
  _inherits(Graph, _React$PureComponent);

  function Graph() {
    _classCallCheck(this, Graph);

    return _possibleConstructorReturn(this, (Graph.__proto__ || Object.getPrototypeOf(Graph)).apply(this, arguments));
  }

  _createClass(Graph, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'container' },
        _react2.default.createElement(
          'div',
          { className: 'col-xs-12 just-so-you-know' },
          _react2.default.createElement(
            'p',
            null,
            'Note: I temporarily removed the historical graph for two reasons'
          ),
          _react2.default.createElement(
            'ol',
            null,
            _react2.default.createElement(
              'li',
              null,
              'The market data API free trial expired(so I don\'t have up-to-date data to display)'
            ),
            _react2.default.createElement(
              'li',
              null,
              'Removing this will allow me to cut off generally unused dependencies'
            )
          ),
          _react2.default.createElement(
            'p',
            null,
            _react2.default.createElement(
              'strong',
              null,
              'Sorry!'
            )
          )
        )
      );
    }
  }]);

  return Graph;
}(_react2.default.PureComponent);

exports.default = Graph;
;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _datasource = __webpack_require__(13);

var _datasource2 = _interopRequireDefault(_datasource);

var _countries = __webpack_require__(88);

var _countries2 = _interopRequireDefault(_countries);

var _indicators = __webpack_require__(92);

var _indicators2 = _interopRequireDefault(_indicators);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Map = function (_React$PureComponent) {
   _inherits(Map, _React$PureComponent);

   function Map(props) {
      _classCallCheck(this, Map);

      var _this = _possibleConstructorReturn(this, (Map.__proto__ || Object.getPrototypeOf(Map)).call(this, props));

      _this.gotData = function (data) {
         console.log('got indicators', data);
         var theData = {};
         theData.sec1 = data[0][0];
         theData.sec2 = data[1].reduce(function (ob, itm, i) {
            var t = 'index_' + i;
            ob[t] = itm;
            return ob;
         }, {});
         var dta = JSON.stringify(theData, undefined, 2);
         _this.refs.regionSelect;
         _this.setState({ dataBlob: dta });
      };

      _this.getDataCall = function (country) {
         _this.dbSource.getIndicatorXHR(country, _this.gotData);
      };

      _this.countryChange = function (e) {
         var ex = e.target.value;

         _this.setState({ country: ex });
      };

      _this.continentChange = function (e) {
         var ex = e.target.value;

         _this.setState({ continent: ex, country: _countries2.default[ex][0]
         });
      };

      _this.getIndicator = function () {
         var cntry = _this.refs.countrySelect.value;
         _this.getDataCall(cntry);
      };

      _this.dbSource = _datasource2.default;
      _this.state = {
         continent: 'ASIA',
         country: 'China',
         dataBlob: null
      };
      return _this;
   }

   _createClass(Map, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
         this.getDataCall('china');
         console.log('Countries', _countries2.default);
      }
   }, {
      key: 'render',
      value: function render() {
         var _state = this.state,
             continent = _state.continent,
             country = _state.country,
             dataBlob = _state.dataBlob;

         var countryOpts = _countries2.default[continent].map(function (cntry, ii) {

            return _react2.default.createElement(
               'option',
               { key: cntry + '_' + ii, value: cntry },
               cntry
            );
         });
         return _react2.default.createElement(
            'div',
            { id: 'mapContainer', className: 'container' },
            _react2.default.createElement(
               'h2',
               null,
               'Econ Indicators'
            ),
            _react2.default.createElement(
               'div',
               { className: 'row col-center-sele' },
               _react2.default.createElement(
                  'div',
                  { className: 'select-col-maps' },
                  _react2.default.createElement(
                     'strong',
                     null,
                     'Continent:'
                  ),
                  _react2.default.createElement(
                     'select',
                     { ref: 'regionSelect', className: 'symbol-pick live-sym', value: continent, onChange: this.continentChange },
                     _react2.default.createElement(
                        'option',
                        { key: 'AFRICA-KEY', value: 'AFRICA' },
                        'AFRICA'
                     ),
                     _react2.default.createElement(
                        'option',
                        { key: 'AMERICA-KEY', value: 'AMERICA' },
                        'AMERICA'
                     ),
                     _react2.default.createElement(
                        'option',
                        { key: 'ASIA-KEY', value: 'ASIA' },
                        'ASIA'
                     ),
                     _react2.default.createElement(
                        'option',
                        { key: 'AUSTRALIA-KEY', value: 'AUSTRALIA' },
                        'AUS/PACIFIC'
                     ),
                     _react2.default.createElement(
                        'option',
                        { key: 'EUROPE-KEY', value: 'EUROPE' },
                        'EUROPE'
                     )
                  )
               ),
               _react2.default.createElement(
                  'div',
                  { className: 'select-col-maps' },
                  _react2.default.createElement(
                     'strong',
                     null,
                     'Country:'
                  ),
                  _react2.default.createElement(
                     'select',
                     { ref: 'countrySelect', value: country, className: 'symbol-pick live-sym', onChange: this.countryChange },
                     countryOpts
                  )
               )
            ),
            _react2.default.createElement(
               'div',
               { className: 'row text-center' },
               _react2.default.createElement(
                  'div',
                  { onClick: this.getIndicator, className: 'big-butt get-indicators-butt' },
                  'Get Indicators'
               )
            ),
            _react2.default.createElement(
               'pre',
               { className: 'row jsonblob' },
               dataBlob
            )
         );
      }
   }]);

   return Map;
}(_react2.default.PureComponent);

exports.default = Map;
;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(8);

var _loadbars = __webpack_require__(75);

var _loadbars2 = _interopRequireDefault(_loadbars);

var _ctxChart = __webpack_require__(50);

var _ctxChart2 = _interopRequireDefault(_ctxChart);

var _spreadCTX = __webpack_require__(54);

var _spreadCTX2 = _interopRequireDefault(_spreadCTX);

var _cardctx = __webpack_require__(48);

var _cardctx2 = _interopRequireDefault(_cardctx);

var _positionTile = __webpack_require__(53);

var _positionTile2 = _interopRequireDefault(_positionTile);

var _depositamt = __webpack_require__(52);

var _depositamt2 = _interopRequireDefault(_depositamt);

var _graph_controller = __webpack_require__(94);

var _graph_controller2 = _interopRequireDefault(_graph_controller);

var _statSVG = __webpack_require__(84);

var _statSVG2 = _interopRequireDefault(_statSVG);

var _datasource = __webpack_require__(13);

var _datasource2 = _interopRequireDefault(_datasource);

var _gowebsocket = __webpack_require__(91);

var _gowebsocket2 = _interopRequireDefault(_gowebsocket);

var _canvaschart = __webpack_require__(62);

var _canvaschart2 = _interopRequireDefault(_canvaschart);

var _chart_container = __webpack_require__(56);

var _chart_container2 = _interopRequireDefault(_chart_container);

var _livestart = __webpack_require__(79);

var _livestart2 = _interopRequireDefault(_livestart);

var _spinload = __webpack_require__(76);

var _spinload2 = _interopRequireDefault(_spinload);

var _forexlist = __webpack_require__(77);

var _forexlist2 = _interopRequireDefault(_forexlist);

var _socklist = __webpack_require__(78);

var _socklist2 = _interopRequireDefault(_socklist);

var _activespreads = __webpack_require__(64);

var _activespreads2 = _interopRequireDefault(_activespreads);

var _widgetblock = __webpack_require__(69);

var _widgetblock2 = _interopRequireDefault(_widgetblock);

var _sideoptions = __webpack_require__(67);

var _sideoptions2 = _interopRequireDefault(_sideoptions);

var _transactionlist = __webpack_require__(68);

var _transactionlist2 = _interopRequireDefault(_transactionlist);

var _livetickers = __webpack_require__(63);

var _livetickers2 = _interopRequireDefault(_livetickers);

var _watchedspreads = __webpack_require__(66);

var _watchedspreads2 = _interopRequireDefault(_watchedspreads);

var _dashboard = __webpack_require__(12);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Clock = __webpack_require__(49);


function select(store) {
  // How Diffrent Redux stores get mapped to props
  return { rt: store.rt, trades: store.trades, trn: store.transactions };
}

var RealTime = function (_React$PureComponent) {
  _inherits(RealTime, _React$PureComponent);

  function RealTime(props) {
    _classCallCheck(this, RealTime);

    var _this = _possibleConstructorReturn(this, (RealTime.__proto__ || Object.getPrototypeOf(RealTime)).call(this, props));

    _this.wbClosed = function (event) {
      console.log('Connection Closed');
      _this.props.dispatch({
        type: _dashboard.CONNECTION_LOST,
        payload: {
          connected: false
        }
      });
    };

    _this.depositChanged = function (amt) {
      var deposit = _this.props.trades.deposit;

      var newAmount = deposit - Math.round(amt);
      window.showDiff(deposit, newAmount);
      _this.props.dispatch({ type: 'DEPOSIT_CHANGE', payload: newAmount });
    };

    _this.addChartMenu = function () {
      _this.props.dispatch({
        type: _dashboard.TOGGLE_CHART_MENU,
        payload: !_this.props.rt.chartAddOpen
      });
    };

    _this.closeCrt = function (chrtSym) {
      var _this$props$rt = _this.props.rt,
          chartList = _this$props$rt.chartList,
          totalCharts = _this$props$rt.totalCharts;

      var stateUpdates = {
        chartList: chartList.filter(function (itm, i) {
          return itm.symb !== chrtSym;
        }),
        totalCharts: totalCharts - 1,
        platformView: 'live graphs'

      };
      _this.props.dispatch({ type: _dashboard.CLOSE_CHART, payload: stateUpdates });
    };

    _this.switchIndices = function (indexType, alreadySelected) {
      return function () {
        if (alreadySelected !== true) {
          _this.props.dispatch({ type: _dashboard.SWITCH_INDICES, payload: indexType });
        }
      };
    };

    _this.setSpreadRef = function (spreadCntrl) {
      return _this.spreadRef = spreadCntrl;
    };

    _this.optView = function (type) {
      var dashview = _this.props.rt.platformView;
      var _this$props$rt2 = _this.props.rt,
          optsComponent = _this$props$rt2.optsComponent,
          tradViewClass = _this$props$rt2.tradViewClass;


      switch (type) {
        case 'spreads':
          {
            _this.spreadRef.setting(type);
            var currentClass = optsComponent === 'current-bids' ? 'half-view' : tradViewClass === 'full-view' ? 'half-view' : 'full-view';
            currentClass === 'half-view' ? _this.spreadRef.inView() : _this.spreadRef.outView();
            _positionTile2.default.outView();
            _this.setDashboardLayout(currentClass, type, dashview);
            return true;
          }
        case 'current-bids':
          {
            var _currentClass = optsComponent === 'spreads' ? 'half-view' : tradViewClass === 'full-view' ? 'half-view' : 'full-view';
            _currentClass === 'half-view' ? _positionTile2.default.inView() : _positionTile2.default.outView();
            _this.spreadRef.outView();
            _this.setDashboardLayout(_currentClass, type, dashview);
            return true;
          }
        case 'past-pos':
          {
            _ctxChart2.default.outOfView();
            Clock.outView();
            _this.cardCtx.outView();
            _this.spreadRef.outView();
            _graph_controller2.default.renderCharts();
            _this.SvgCB.inViewBool = true;
            _this.SvgCB.inView();
            _this.setDashboardLayout('full-view', type, 'trade list');
            return true;
          }
        case 'charts':
          {
            _this.spreadRef.outView();
            _this.cardCtx.outView();
            Clock.inView();
            _positionTile2.default.outView();
            _ctxChart2.default.backInView();
            _this.SvgCB.inViewBool = false;
            _this.setDashboardLayout('full-view', type, 'live graphs');
            return true;
          }
        case 'live options':
          {
            _ctxChart2.default.outOfView();
            Clock.outView();
            _positionTile2.default.outView();
            _this.cardCtx.inView();
            _this.SvgCB.inViewBool = false;
            _this.spreadRef.outView();
            _this.setDashboardLayout('full-view', type, 'live options');
            return true;
          }
        case 'overview':
          {
            _ctxChart2.default.outOfView();
            Clock.outView();
            _positionTile2.default.outView();
            _this.cardCtx.outView();
            _this.spreadRef.outView();
            _this.setDashboardLayout('full-view', type, 'trade history');
            return true;
          }

      }
      _this.setDashboardLayout('half-view', type, dashview);
    };

    _this.setDashboardLayout = function (tradViewClass, optsComponent, platformView) {
      return _this.props.dispatch({
        type: _dashboard.OPTS_VIEW,
        payload: {
          tradViewClass: tradViewClass,
          optsComponent: optsComponent,
          platformView: platformView
        }
      });
    };

    _this.liveFeedStarted = function (symbFeed) {
      var seriesWatch = _this.props.rt.seriesWatch;
      seriesWatch.push(symbFeed);
      _this.props.dispatch({
        type: _dashboard.FEED_START,
        payload: {
          seriesWatch: seriesWatch,
          addButton: true
        }
      });
    };

    _this.addNewChart = function (symb, index) {
      var _this$props$rt3 = _this.props.rt,
          chartList = _this$props$rt3.chartList,
          totalCharts = _this$props$rt3.totalCharts,
          chartPositions = _this$props$rt3.chartPositions,
          chartStates = _this$props$rt3.chartStates;

      var keyy = symb + '_canvas';

      var stateUpdates = {
        chartPositions: _extends({}, chartPositions, _defineProperty({}, symb, {
          trades: [],
          position: {},
          total: 0.0,
          current: null
        })),
        chartStates: _extends({}, chartStates, _defineProperty({}, symb, {
          modalOpen: false,
          dataLength: 500,
          onStart: true,
          optsOpen: false,
          chartType: 'candlestick',
          mainSymbol: symb,
          callPut: null,
          seriesWatch: []
        })),
        chartList: chartList.concat({ symb: symb, keyy: keyy }),
        totalCharts: totalCharts + 1,
        onStart: false,
        addButton: true,
        newSet: null,
        chartAddOpen: false
      };

      _this.props.dispatch({ type: _dashboard.ADD_CHART, payload: stateUpdates });
    };

    _this.renderCanvasCharts = function () {
      return _this.props.rt.chartList.map(function (chart, i, chartList) {
        return _react2.default.createElement(
          _chart_container2.default,
          { key: chart.keyy, chartQnty: chartList.length, index: i },
          _react2.default.createElement(_canvaschart2.default, { newPos: _this.newPos, depChg: _this.depositChanged, ctx: _ctxChart2.default.passCTXconstructor(), clock: Clock, positions: _this.props.rt.chartPositions[chart.symb], dispatch: _this.props.dispatch, state: _this.props.rt.chartStates[chart.symb], clCtx: _this.closeCrt, dataSource: _this.dbSource, mainSym: chart.symb, whenMounted: _this.canvasPlaced })
        );
      });
    };

    _this.canvasPlaced = function (newSymb) {
      _this.tradePostions = Object.assign({}, _this.tradePostions, newSymb);
    };

    _this.tradeExpired = function (pos) {
      var _this$props$trades = _this.props.trades,
          pastTrades = _this$props$trades.pastTrades,
          deposit = _this$props$trades.deposit,
          currentPos = _this$props$trades.currentPos,
          totalRev = _this$props$trades.totalRev,
          todayTotalNet = _this$props$trades.todayTotalNet;

      var nwPnt = pos.getLatestPoint();
      var diff = (nwPnt.data[3] - pos.unitPrice) * pos.qty;
      var newNet = todayTotalNet + diff;
      var newDeoposit = Math.round(deposit + nwPnt.data[3] * pos.qty);
      var newCrntPos = currentPos.filter(function (itm) {
        return itm.ctxid !== pos.ctxid;
      });
      var pstTRD = [{
        position: pos.symb,
        volume: pos.qty,
        date: new Date().toDateString(),
        short: pos.type === 'PUT',
        pricestart: Math.round(pos.unitPrice * 100) / 100,
        priceend: Math.round(nwPnt.data[3] * 100) / 100,
        profit: diff
      }].concat(pastTrades);
      var posCTXcntrl = _this.tradePostions[pos.symb].ctxChart;
      posCTXcntrl.posExpired(pos);
      window.showDiff(deposit, newDeoposit);

      _this.SvgCB.upDate(pstTRD, totalRev + diff);
      _this.props.dispatch({
        type: 'TRADE_COMPLETE',
        payload: {
          deposit: newDeoposit,
          currentPos: newCrntPos,
          pastTrades: pstTRD,
          todayTotalNet: newNet,
          totalRev: totalRev + diff
        }
      });
    };

    _this.newPos = function (pos) {
      var _this$props$trades2 = _this.props.trades,
          deposit = _this$props$trades2.deposit,
          currentPos = _this$props$trades2.currentPos,
          weeklyTradeCount = _this$props$trades2.weeklyTradeCount,
          todayTradeCount = _this$props$trades2.todayTradeCount;

      var newCurrentPos = [pos].concat(currentPos);
      var newAmount = deposit - Math.round(pos.unitPrice * pos.qty);
      window.showDiff(deposit, newAmount);
      _this.tradePostions[pos.symb].open[pos.posId] = pos;
      var posCTXcntrl = _this.tradePostions[pos.symb].ctxChart;
      posCTXcntrl.addNewPos(pos);
      _this.props.dispatch({
        type: 'ADD_TRADE',
        payload: {
          currentPos: newCurrentPos,
          weeklyTradeCount: weeklyTradeCount + 1,
          todayTradeCount: todayTradeCount + 1,
          deposit: newAmount
        }
      });
      setTimeout(function () {
        return _this.tradeExpired(pos);
      }, 60000 * pos.time);
    };

    _this.canvasOut = function () {
      return _this.ctxChart.shutdown();
    };

    _this.componentDidMount = function () {
      _this.dbSource.onopen = function (event) {
        return _this.props.dispatch({ type: _dashboard.CONNECTED });
      };
      window.addEventListener('online', function (e) {
        return _this.props.dispatch({ type: _dashboard.CONNECTED });
      }, false);
      window.addEventListener('offline', function (e) {
        return _this.props.dispatch({ type: _dashboard.CONNECTION_LOST });
      }, false);
      (0, _depositamt2.default)(_this.props.trades.deposit);
    };

    _this.tradePostions = {};
    _this.dbSource = (0, _gowebsocket2.default)();
    _this.spreadRef = null;
    _this.SvgCB = (0, _statSVG2.default)();
    _this.cardCtx = (0, _cardctx2.default)();

    _this.dbSource.on.liveFeedStarted = function (details) {
      return _this.liveFeedStarted(details);
    };
    _this.dbSource.onclose = function (event) {
      return _this.wbClosed(event);
    };
    return _this;
  }

  _createClass(RealTime, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      if (this.dbSource.readyState === 'OPEN') {
        this.props.dispatch({ type: _dashboard.CONNECTED });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props$rt = this.props.rt,
          optsComponent = _props$rt.optsComponent,
          onStart = _props$rt.onStart,
          platformView = _props$rt.platformView,
          tradViewClass = _props$rt.tradViewClass,
          addButton = _props$rt.addButton,
          connected = _props$rt.connected,
          seriesWatch = _props$rt.seriesWatch,
          chartAddOpen = _props$rt.chartAddOpen,
          selectUl = _props$rt.selectUl;

      var tdClass = tradViewClass === 'half-view';
      var onlineStatus = connected ? 'CONNECTED' : 'Not Connected';
      var blockStart = onStart ? _react2.default.createElement(_livestart2.default, { startChart: this.addNewChart }) : null;
      var blocked = this.props.rt.connected ? blockStart : _react2.default.createElement(_spinload2.default, null);
      return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(
          'div',
          { id: 'rtTopNavUI' },
          _react2.default.createElement(
            'div',
            { className: 'fake-logo' },
            _react2.default.createElement(
              'span',
              null,
              _react2.default.createElement(
                'i',
                { className: 'material-icons' },
                'language'
              )
            ),
            _react2.default.createElement(
              'span',
              { className: 'span-two' },
              'Trade Stuff'
            )
          ),
          _react2.default.createElement(
            'div',
            { className: addButton ? 'add-chart' : 'add-chart no-see-no-click', onClick: this.addChartMenu },
            _react2.default.createElement(
              'i',
              { className: 'material-icons' },
              'add'
            )
          ),
          _react2.default.createElement(
            'div',
            { id: 'chartAdOptions', className: chartAddOpen ? '' : 'hide-elm' },
            _react2.default.createElement(
              'div',
              { className: this.props.rt.totalCharts >= 4 ? 'add-chart-warn' : 'hide-elm' },
              _react2.default.createElement(
                'h3',
                null,
                'You can only have 4 charts at a time, sorry!'
              )
            ),
            _react2.default.createElement(
              'div',
              { className: this.props.rt.totalCharts < 4 ? 'add-chart-cnt' : 'hide-elm' },
              _react2.default.createElement(
                'div',
                { className: 'column-two type-nav' },
                _react2.default.createElement(
                  'strong',
                  null,
                  'Market'
                ),
                _react2.default.createElement(
                  'ul',
                  null,
                  _react2.default.createElement(
                    'li',
                    { onClick: this.switchIndices('stocks', selectUl === 'stocks'), className: selectUl === 'stocks' ? 'selected-li' : '' },
                    'Stocks'
                  ),
                  _react2.default.createElement(
                    'li',
                    { onClick: this.switchIndices('forex', selectUl === 'forex'), className: selectUl === 'forex' ? 'selected-li' : '' },
                    'Forex'
                  )
                )
              ),
              selectUl === 'stocks' && _react2.default.createElement(_socklist2.default, { used: seriesWatch, startChart: this.addNewChart }),
              selectUl === 'forex' && _react2.default.createElement(_forexlist2.default, { used: seriesWatch, startChart: this.addNewChart })
            )
          ),
          _react2.default.createElement(
            'div',
            { id: 'connectedState' },
            _react2.default.createElement('div', { className: connected ? 'online-state online' : 'online-state offline' }),
            _react2.default.createElement(
              'span',
              null,
              onlineStatus
            )
          )
        ),
        _react2.default.createElement(
          'div',
          { id: 'scorePoints', className: platformView !== 'trade history' && !onStart ? '' : 'hide-elm' },
          _react2.default.createElement(
            'span',
            { className: 'count span-green total-earnings' },
            _react2.default.createElement('canvas', { id: 'totalAccount', height: 40, width: 100 })
          ),
          _react2.default.createElement(
            'span',
            { className: 'deposit-span' },
            'DEPOSIT'
          )
        ),
        _react2.default.createElement(
          'section',
          { id: 'realTimeTheme' },
          blocked,
          _react2.default.createElement(_sideoptions2.default, { platformView: platformView, optsComponent: optsComponent, tdClass: tdClass, onStart: onStart, itmView: this.optView }),
          _react2.default.createElement(
            'section',
            { id: 'optionsView', className: onStart ? 'hide-elm' : 'ok' },
            _react2.default.createElement(
              'div',
              { className: optsComponent === 'spreads' ? 'in-view-opts' : 'hide-elm' },
              _react2.default.createElement(_activespreads2.default, { setSpreadRef: this.setSpreadRef, callCT: _spreadCTX2.default, dataSource: this.dbSource })
            ),
            _react2.default.createElement(
              'div',
              { className: optsComponent === 'current-bids' ? 'in-view-opts' : 'hide-elm' },
              _react2.default.createElement(_watchedspreads2.default, { PositionTiles: _positionTile2.default, activePosList: this.props.trades.currentPos })
            )
          ),
          _react2.default.createElement(
            'section',
            { id: 'tradingplatform', className: onStart ? 'hide-elm' : tradViewClass },
            _react2.default.createElement(
              'div',
              { className: platformView === 'live graphs' ? 'wrap-block' : 'hide-elm' },
              this.props.rt.totalCharts === 0 && _react2.default.createElement(_livestart2.default, { startChart: this.addNewChart }),
              this.renderCanvasCharts()
            ),
            _react2.default.createElement(
              'div',
              { id: 'dashView', className: platformView === 'trade history' ? 'wrap-block' : 'hide-elm' },
              _react2.default.createElement(_widgetblock2.default, { inView: platformView === 'trade history' })
            ),
            _react2.default.createElement(
              'div',
              { className: platformView === 'trade list' ? 'wrap-block history-list' : 'hide-elm' },
              _react2.default.createElement(_transactionlist2.default, { inView: platformView === 'trade list', GraphController: _graph_controller2.default, SvgCB: this.SvgCB, pastTrades: this.props.trades.pastTrades })
            ),
            _react2.default.createElement(
              'div',
              { className: platformView === 'live options' ? 'wrap-block history-list' : 'hide-elm' },
              _react2.default.createElement(_livetickers2.default, { cardCtx: this.cardCtx, inView: platformView === 'live options' })
            )
          )
        )
      );
    }
  }]);

  return RealTime;
}(_react2.default.PureComponent);

;

exports.default = (0, _reactRedux.connect)(select)(RealTime);

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TopNav = function (_React$PureComponent) {
  _inherits(TopNav, _React$PureComponent);

  function TopNav(props) {
    _classCallCheck(this, TopNav);

    var _this = _possibleConstructorReturn(this, (TopNav.__proto__ || Object.getPrototypeOf(TopNav)).call(this, props));

    _this.goState = function (path) {
      return function () {
        window.checkPath(path);
      };
    };

    return _this;
  }

  _createClass(TopNav, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'nav',
        { id: 'topNav', className: this.props.theClass },
        _react2.default.createElement(
          'span',
          { onClick: this.goState('/history'), className: this.props.pathName === '/history' || this.props.pathName === '/' ? 'blocked-at' : '' },
          'History'
        ),
        _react2.default.createElement(
          'span',
          { onClick: this.goState('/realtime'), className: this.props.pathName === '/realtime' ? 'blocked-at' : '' },
          'Real Time'
        ),
        _react2.default.createElement(
          'span',
          { onClick: this.goState('/map'), className: this.props.pathName === '/map' ? 'blocked-at' : '' },
          'Map Thing'
        )
      );
    }
  }]);

  return TopNav;
}(_react2.default.PureComponent);

exports.default = TopNav;
;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var MathFuncs = {
   getDigitLen: function getDigitLen(num) {
      return Math.log(Math.abs(num)) * Math.LOG10E + 1 | 0;
   },
   niceFloats: function niceFloats(num) {
      var res = num / 1000;
      if (res < 10) {
         return num.toFixed(2);
      }
      if (res < 100) {
         return res.toFixed(3) + 'k';
      }
      if (res < 1000) {
         return res.toFixed(2) + 'k';
      }
      if (res < 10000) {
         return res.toFixed(3) + 'm';
      }
      if (res < 100000) {
         return res.toFixed(2) + 'm';
      }
      return num;
   }
};

exports.default = MathFuncs;

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(n) {
  return function() {
    for (var sum = 0, i = 0; i < n; ++i) sum += Math.random();
    return sum;
  };
});


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(mu, sigma) {
  var x, r;
  mu = mu == null ? 0 : +mu;
  sigma = sigma == null ? 1 : +sigma;
  return function() {
    var y;

    // If available, use the second previously-generated uniform random.
    if (x != null) y = x, x = null;

    // Otherwise, generate a new x and y.
    else do {
      x = Math.random() * 2 - 1;
      y = Math.random() * 2 - 1;
      r = x * x + y * y;
    } while (!r || r > 1);

    return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
  };
});


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__(4);

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var isTextNode = __webpack_require__(132);

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */
function getActiveElement(doc) /*?DOMElement*/{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */



var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__root_js__ = __webpack_require__(144);


/** Built-in value references. */
var Symbol = __WEBPACK_IMPORTED_MODULE_0__root_js__["a" /* default */].Symbol;

/* harmony default export */ __webpack_exports__["a"] = (Symbol);


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(148)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(147)();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_hoist_non_react_statics__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_hoist_non_react_statics___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_hoist_non_react_statics__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_Subscription__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_PropTypes__ = __webpack_require__(39);
/* harmony export (immutable) */ __webpack_exports__["a"] = connectAdvanced;
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }








var hotReloadingVersion = 0;
var dummyState = {};
function noop() {}
function makeSelectorStateful(sourceSelector, store) {
  // wrap the selector in an object that tracks its results between runs.
  var selector = {
    run: function runComponentSelector(props) {
      try {
        var nextProps = sourceSelector(store.getState(), props);
        if (nextProps !== selector.props || selector.error) {
          selector.shouldComponentUpdate = true;
          selector.props = nextProps;
          selector.error = null;
        }
      } catch (error) {
        selector.shouldComponentUpdate = true;
        selector.error = error;
      }
    }
  };

  return selector;
}

function connectAdvanced(
/*
  selectorFactory is a func that is responsible for returning the selector function used to
  compute new props from state, props, and dispatch. For example:
     export default connectAdvanced((dispatch, options) => (state, props) => ({
      thing: state.things[props.thingId],
      saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
    }))(YourComponent)
   Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
  outside of their selector as an optimization. Options passed to connectAdvanced are passed to
  the selectorFactory, along with displayName and WrappedComponent, as the second argument.
   Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
  props. Do not use connectAdvanced directly without memoizing results between calls to your
  selector, otherwise the Connect component will re-render on every state or props change.
*/
selectorFactory) {
  var _contextTypes, _childContextTypes;

  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$getDisplayName = _ref.getDisplayName,
      getDisplayName = _ref$getDisplayName === undefined ? function (name) {
    return 'ConnectAdvanced(' + name + ')';
  } : _ref$getDisplayName,
      _ref$methodName = _ref.methodName,
      methodName = _ref$methodName === undefined ? 'connectAdvanced' : _ref$methodName,
      _ref$renderCountProp = _ref.renderCountProp,
      renderCountProp = _ref$renderCountProp === undefined ? undefined : _ref$renderCountProp,
      _ref$shouldHandleStat = _ref.shouldHandleStateChanges,
      shouldHandleStateChanges = _ref$shouldHandleStat === undefined ? true : _ref$shouldHandleStat,
      _ref$storeKey = _ref.storeKey,
      storeKey = _ref$storeKey === undefined ? 'store' : _ref$storeKey,
      _ref$withRef = _ref.withRef,
      withRef = _ref$withRef === undefined ? false : _ref$withRef,
      connectOptions = _objectWithoutProperties(_ref, ['getDisplayName', 'methodName', 'renderCountProp', 'shouldHandleStateChanges', 'storeKey', 'withRef']);

  var subscriptionKey = storeKey + 'Subscription';
  var version = hotReloadingVersion++;

  var contextTypes = (_contextTypes = {}, _contextTypes[storeKey] = __WEBPACK_IMPORTED_MODULE_4__utils_PropTypes__["a" /* storeShape */], _contextTypes[subscriptionKey] = __WEBPACK_IMPORTED_MODULE_4__utils_PropTypes__["b" /* subscriptionShape */], _contextTypes);
  var childContextTypes = (_childContextTypes = {}, _childContextTypes[subscriptionKey] = __WEBPACK_IMPORTED_MODULE_4__utils_PropTypes__["b" /* subscriptionShape */], _childContextTypes);

  return function wrapWithConnect(WrappedComponent) {
    __WEBPACK_IMPORTED_MODULE_1_invariant___default()(typeof WrappedComponent == 'function', 'You must pass a component to the function returned by ' + ('connect. Instead received ' + JSON.stringify(WrappedComponent)));

    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';

    var displayName = getDisplayName(wrappedComponentName);

    var selectorFactoryOptions = _extends({}, connectOptions, {
      getDisplayName: getDisplayName,
      methodName: methodName,
      renderCountProp: renderCountProp,
      shouldHandleStateChanges: shouldHandleStateChanges,
      storeKey: storeKey,
      withRef: withRef,
      displayName: displayName,
      wrappedComponentName: wrappedComponentName,
      WrappedComponent: WrappedComponent
    });

    var Connect = function (_Component) {
      _inherits(Connect, _Component);

      function Connect(props, context) {
        _classCallCheck(this, Connect);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

        _this.version = version;
        _this.state = {};
        _this.renderCount = 0;
        _this.store = props[storeKey] || context[storeKey];
        _this.propsMode = Boolean(props[storeKey]);
        _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);

        __WEBPACK_IMPORTED_MODULE_1_invariant___default()(_this.store, 'Could not find "' + storeKey + '" in either the context or props of ' + ('"' + displayName + '". Either wrap the root component in a <Provider>, ') + ('or explicitly pass "' + storeKey + '" as a prop to "' + displayName + '".'));

        _this.initSelector();
        _this.initSubscription();
        return _this;
      }

      Connect.prototype.getChildContext = function getChildContext() {
        var _ref2;

        // If this component received store from props, its subscription should be transparent
        // to any descendants receiving store+subscription from context; it passes along
        // subscription passed to it. Otherwise, it shadows the parent subscription, which allows
        // Connect to control ordering of notifications to flow top-down.
        var subscription = this.propsMode ? null : this.subscription;
        return _ref2 = {}, _ref2[subscriptionKey] = subscription || this.context[subscriptionKey], _ref2;
      };

      Connect.prototype.componentDidMount = function componentDidMount() {
        if (!shouldHandleStateChanges) return;

        // componentWillMount fires during server side rendering, but componentDidMount and
        // componentWillUnmount do not. Because of this, trySubscribe happens during ...didMount.
        // Otherwise, unsubscription would never take place during SSR, causing a memory leak.
        // To handle the case where a child component may have triggered a state change by
        // dispatching an action in its componentWillMount, we have to re-run the select and maybe
        // re-render.
        this.subscription.trySubscribe();
        this.selector.run(this.props);
        if (this.selector.shouldComponentUpdate) this.forceUpdate();
      };

      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        this.selector.run(nextProps);
      };

      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
        return this.selector.shouldComponentUpdate;
      };

      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
        if (this.subscription) this.subscription.tryUnsubscribe();
        this.subscription = null;
        this.notifyNestedSubs = noop;
        this.store = null;
        this.selector.run = noop;
        this.selector.shouldComponentUpdate = false;
      };

      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
        __WEBPACK_IMPORTED_MODULE_1_invariant___default()(withRef, 'To access the wrapped instance, you need to specify ' + ('{ withRef: true } in the options argument of the ' + methodName + '() call.'));
        return this.wrappedInstance;
      };

      Connect.prototype.setWrappedInstance = function setWrappedInstance(ref) {
        this.wrappedInstance = ref;
      };

      Connect.prototype.initSelector = function initSelector() {
        var sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions);
        this.selector = makeSelectorStateful(sourceSelector, this.store);
        this.selector.run(this.props);
      };

      Connect.prototype.initSubscription = function initSubscription() {
        if (!shouldHandleStateChanges) return;

        // parentSub's source should match where store came from: props vs. context. A component
        // connected to the store via props shouldn't use subscription from context, or vice versa.
        var parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey];
        this.subscription = new __WEBPACK_IMPORTED_MODULE_3__utils_Subscription__["a" /* default */](this.store, parentSub, this.onStateChange.bind(this));

        // `notifyNestedSubs` is duplicated to handle the case where the component is  unmounted in
        // the middle of the notification loop, where `this.subscription` will then be null. An
        // extra null check every change can be avoided by copying the method onto `this` and then
        // replacing it with a no-op on unmount. This can probably be avoided if Subscription's
        // listeners logic is changed to not call listeners that have been unsubscribed in the
        // middle of the notification loop.
        this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription);
      };

      Connect.prototype.onStateChange = function onStateChange() {
        this.selector.run(this.props);

        if (!this.selector.shouldComponentUpdate) {
          this.notifyNestedSubs();
        } else {
          this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate;
          this.setState(dummyState);
        }
      };

      Connect.prototype.notifyNestedSubsOnComponentDidUpdate = function notifyNestedSubsOnComponentDidUpdate() {
        // `componentDidUpdate` is conditionally implemented when `onStateChange` determines it
        // needs to notify nested subs. Once called, it unimplements itself until further state
        // changes occur. Doing it this way vs having a permanent `componentDidUpdate` that does
        // a boolean check every time avoids an extra method call most of the time, resulting
        // in some perf boost.
        this.componentDidUpdate = undefined;
        this.notifyNestedSubs();
      };

      Connect.prototype.isSubscribed = function isSubscribed() {
        return Boolean(this.subscription) && this.subscription.isSubscribed();
      };

      Connect.prototype.addExtraProps = function addExtraProps(props) {
        if (!withRef && !renderCountProp && !(this.propsMode && this.subscription)) return props;
        // make a shallow copy so that fields added don't leak to the original selector.
        // this is especially important for 'ref' since that's a reference back to the component
        // instance. a singleton memoized selector would then be holding a reference to the
        // instance, preventing the instance from being garbage collected, and that would be bad
        var withExtras = _extends({}, props);
        if (withRef) withExtras.ref = this.setWrappedInstance;
        if (renderCountProp) withExtras[renderCountProp] = this.renderCount++;
        if (this.propsMode && this.subscription) withExtras[subscriptionKey] = this.subscription;
        return withExtras;
      };

      Connect.prototype.render = function render() {
        var selector = this.selector;
        selector.shouldComponentUpdate = false;

        if (selector.error) {
          throw selector.error;
        } else {
          return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_react__["createElement"])(WrappedComponent, this.addExtraProps(selector.props));
        }
      };

      return Connect;
    }(__WEBPACK_IMPORTED_MODULE_2_react__["Component"]);

    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = displayName;
    Connect.childContextTypes = childContextTypes;
    Connect.contextTypes = contextTypes;
    Connect.propTypes = contextTypes;

    if (process.env.NODE_ENV !== 'production') {
      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
        var _this2 = this;

        // We are hot reloading!
        if (this.version !== version) {
          this.version = version;
          this.initSelector();

          // If any connected descendants don't hot reload (and resubscribe in the process), their
          // listeners will be lost when we unsubscribe. Unfortunately, by copying over all
          // listeners, this does mean that the old versions of connected descendants will still be
          // notified of state changes; however, their onStateChange function is a no-op so this
          // isn't a huge deal.
          var oldListeners = [];

          if (this.subscription) {
            oldListeners = this.subscription.listeners.get();
            this.subscription.tryUnsubscribe();
          }
          this.initSubscription();
          if (shouldHandleStateChanges) {
            this.subscription.trySubscribe();
            oldListeners.forEach(function (listener) {
              return _this2.subscription.listeners.subscribe(listener);
            });
          }
        }
      };
    }

    return __WEBPACK_IMPORTED_MODULE_0_hoist_non_react_statics___default()(Connect, WrappedComponent);
  };
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(1)))

/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_verifyPlainObject__ = __webpack_require__(40);
/* harmony export (immutable) */ __webpack_exports__["b"] = wrapMapToPropsConstant;
/* unused harmony export getDependsOnOwnProps */
/* harmony export (immutable) */ __webpack_exports__["a"] = wrapMapToPropsFunc;


function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    var constant = getConstant(dispatch, options);

    function constantSelector() {
      return constant;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}

// dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
// whether mapToProps needs to be invoked when props have changed.
// 
// A length of one signals that mapToProps does not depend on props from the parent component.
// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
// therefore not reporting its length accurately..
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}

// Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
// this function wraps mapToProps in a proxy function which does several things:
// 
//  * Detects whether the mapToProps function being called depends on props, which
//    is used by selectorFactory to decide if it should reinvoke on props changes.
//    
//  * On first call, handles mapToProps if returns another function, and treats that
//    new function as the true mapToProps for subsequent calls.
//    
//  * On first call, verifies the first result is a plain object, in order to warn
//    the developer that their mapToProps function is not returning a valid result.
//    
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, _ref) {
    var displayName = _ref.displayName;

    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
    };

    // allow detectFactoryAndVerify to get ownProps
    proxy.dependsOnOwnProps = true;

    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      var props = proxy(stateOrDispatch, ownProps);

      if (typeof props === 'function') {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }

      if (process.env.NODE_ENV !== 'production') __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_verifyPlainObject__["a" /* default */])(props, displayName, methodName);

      return props;
    };

    return proxy;
  };
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(1)))

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_prop_types__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_prop_types__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return subscriptionShape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return storeShape; });


var subscriptionShape = __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.shape({
  trySubscribe: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  tryUnsubscribe: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  notifyNestedSubs: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  isSubscribed: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired
});

var storeShape = __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.shape({
  subscribe: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  dispatch: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  getState: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired
});

/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_es_isPlainObject__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__warning__ = __webpack_require__(18);
/* harmony export (immutable) */ __webpack_exports__["a"] = verifyPlainObject;



function verifyPlainObject(value, displayName, methodName) {
  if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_lodash_es_isPlainObject__["a" /* default */])(value)) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__warning__["a" /* default */])(methodName + '() in ' + displayName + ' must return a plain object. Instead received ' + value + '.');
  }
}

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var repeat = exports.repeat = function repeat(str, times) {
  return new Array(times + 1).join(str);
};

var pad = exports.pad = function pad(num, maxLength) {
  return repeat("0", maxLength - num.toString().length) + num;
};

var formatTime = exports.formatTime = function formatTime(time) {
  return pad(time.getHours(), 2) + ":" + pad(time.getMinutes(), 2) + ":" + pad(time.getSeconds(), 2) + "." + pad(time.getMilliseconds(), 3);
};

// Use performance API if it's available in order to get better precision
var timer = exports.timer = typeof performance !== "undefined" && performance !== null && typeof performance.now === "function" ? performance : Date;

/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = compose;
/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(undefined, arguments));
    };
  });
}

/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_es_isPlainObject__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_symbol_observable__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_symbol_observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_symbol_observable__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ActionTypes; });
/* harmony export (immutable) */ __webpack_exports__["a"] = createStore;



/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = {
  INIT: '@@redux/INIT'

  /**
   * Creates a Redux store that holds the state tree.
   * The only way to change the data in the store is to call `dispatch()` on it.
   *
   * There should only be a single store in your app. To specify how different
   * parts of the state tree respond to actions, you may combine several reducers
   * into a single reducer function by using `combineReducers`.
   *
   * @param {Function} reducer A function that returns the next state tree, given
   * the current state tree and the action to handle.
   *
   * @param {any} [preloadedState] The initial state. You may optionally specify it
   * to hydrate the state from the server in universal apps, or to restore a
   * previously serialized user session.
   * If you use `combineReducers` to produce the root reducer function, this must be
   * an object with the same shape as `combineReducers` keys.
   *
   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
   * to enhance the store with third-party capabilities such as middleware,
   * time travel, persistence, etc. The only store enhancer that ships with Redux
   * is `applyMiddleware()`.
   *
   * @returns {Store} A Redux store that lets you read the state, dispatch actions
   * and subscribe to changes.
   */
};function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    return currentState;
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.');
    }

    var isSubscribed = true;

    ensureCanMutateNextListeners();
    nextListeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing what changed. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_lodash_es_isPlainObject__["a" /* default */])(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.INIT });
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */
  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return { unsubscribe: unsubscribe };
      }
    }, _ref[__WEBPACK_IMPORTED_MODULE_1_symbol_observable___default.a] = function () {
      return this;
    }, _ref;
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[__WEBPACK_IMPORTED_MODULE_1_symbol_observable___default.a] = observable, _ref2;
}

/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(8);

var _graph_temp = __webpack_require__(21);

var _graph_temp2 = _interopRequireDefault(_graph_temp);

var _realtime = __webpack_require__(23);

var _realtime2 = _interopRequireDefault(_realtime);

var _map = __webpack_require__(22);

var _map2 = _interopRequireDefault(_map);

var _topnav = __webpack_require__(24);

var _topnav2 = _interopRequireDefault(_topnav);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _applyListener = function _applyListener(type) {
  var histFunc = history[type];
  return function () {
    var rv = histFunc.apply(this, arguments);
    var e = new Event(type);
    e.arguments = arguments;
    window.dispatchEvent(e);
    return rv;
  };
};

function select(store) {
  // How Diffrent Redux stores get mapped to props
  return { routes: store.routes };
}

var Layout = function (_React$Component) {
  _inherits(Layout, _React$Component);

  function Layout(props) {
    _classCallCheck(this, Layout);

    var _this = _possibleConstructorReturn(this, (Layout.__proto__ || Object.getPrototypeOf(Layout)).call(this, props));

    history.pushState = _applyListener('pushState');
    window.onpopstate = function (e) {
      console.log(e);
      var newPath = e.state.Url;
      var comp = _this.props.routes.routeComponents[newPath];
      var topNav = _react2.default.createElement(_topnav2.default, { theClass: newPath === '/realtime' ? 'rt-alter' : '', pathName: newPath });
      _this.props.dispatch({
        type: 'NEW_PATH',
        payload: {
          pathName: newPath,
          blocked: comp,
          topNav: topNav
        }
      });
    };
    var eventHandler = function eventHandler(e) {
      console.log('State Changed!', e);
      var newPath = e.arguments[0].Url;
      var comp = _this.props.routes.routeComponents[newPath];
      var topNav = _react2.default.createElement(_topnav2.default, { theClass: newPath === '/realtime' ? 'rt-alter' : '', pathName: newPath });
      _this.props.dispatch({
        type: 'NEW_PATH',
        payload: {
          pathName: newPath,
          blocked: comp,
          topNav: topNav
        }
      });
    };
    window.addEventListener('pushState', eventHandler);
    return _this;
  }

  _createClass(Layout, [{
    key: 'newSet',
    value: function newSet(newPath) {
      var comp = thisScope.props.routes.routeComponents[newPath];
      this.props.dispatch({
        type: 'NEW_PATH',
        payload: {
          pathName: newPath,
          blocked: comp
        }
      });
    }
  }, {
    key: 'goState',
    value: function goState(pp) {
      window.checkPath(pp);
    }
  }, {
    key: 'render',
    value: function render() {
      console.log('routes', this.props.routes);
      var _props$routes = this.props.routes,
          pathName = _props$routes.pathName,
          blocked = _props$routes.blocked,
          topNav = _props$routes.topNav;

      return _react2.default.createElement(
        'div',
        null,
        topNav,
        blocked
      );
    }
  }]);

  return Layout;
}(_react2.default.Component);

;

exports.default = (0, _reactRedux.connect)(select)(Layout);

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _redux = __webpack_require__(19);

var _reduxLogger = __webpack_require__(166);

var _reduxLogger2 = _interopRequireDefault(_reduxLogger);

var _reducers = __webpack_require__(100);

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var composedStore = (0, _redux.compose)((0, _redux.applyMiddleware)((0, _reduxLogger2.default)()));

exports.default = composedStore(_redux.createStore)(_reducers2.default);

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (process.env.NODE_ENV !== 'production') {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (process.env.NODE_ENV === 'production') {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(150);
} else {
  module.exports = __webpack_require__(149);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _d3fcRandomData = __webpack_require__(14);

var _Canvas2DContext = __webpack_require__(5);

var _Canvas2DContext2 = _interopRequireDefault(_Canvas2DContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var areaChartConfig = function areaChartConfig(data) {
  return {
    axisX: {
      valueFormatString: ' ',
      tickLength: 0,
      margin: -3,
      lineThickness: 1
    },
    axisY: {
      valueFormatString: ' ',
      gridThickness: 0.3,
      includeZero: false,
      tickLength: 0.5,
      margin: -5,
      gridColor: '#224458',
      lineThickness: 1
    },
    interactivityEnabled: false,
    backgroundColor: '#18252e',
    width: 190,
    height: 170,
    animationEnabled: false,
    markerType: 'none',
    data: data
  };
};

var generateData = function generateData(pr) {
  return (0, _d3fcRandomData.randomFinancial)().startDate(new Date()).startPrice(pr)(30).map(function (itm, i) {
    return { x: i, y: itm.close };
  });
};

var CardCtx = function CardCtx() {
  var _inView = true;
  var callAll = [];

  var chartView = {
    symb: null,
    config: null,
    chart: null,
    ii: 0,
    priceSeed: null,
    data: [{
      type: 'area',
      markerType: 'none',
      fillOpacity: 0.3,
      lineColor: 'white',
      color: '#00FF00',
      dataPoints: []
    }],
    render: function render() {
      if (!this.data[0].dataPoints.length) {
        this.data[0].dataPoints = generateData(this.priceSeed);
      }
      this.config = areaChartConfig(this.data);
      this.ii = 29;
      this.chart = new CanvasJS.Chart('tickChart', this.config);
      this.chart.render();
    },
    newSet: function newSet(symbol, price) {
      this.symb = symbol;
      this.priceSeed = price;
      this.data[0].dataPoints = generateData(this.priceSeed);
      this.ii = 29;
      this.config.data = this.data;
      this.chart.render();
    },
    update: function update(newPnt) {
      this.data[0].dataPoints.shift();
      this.ii += 1;
      this.data[0].dataPoints.push({ x: this.ii, y: newPnt.close });
      this.config.data = this.data;
      this.chart.render();
    }

  };
  var askBid = {};
  var upTriangle = function upTriangle(ctx, prnChng) {
    ctx.beginPath().strokeStyle('#00FF00').fillStyle('#00FF00').moveTo(105, 35).lineTo(97, 41).lineTo(113, 41).lineTo(105, 35).stroke().fill().font('bold 13px Arial').textAlign('center').fillText(prnChng, 105, 30);
  };
  var downTriangle = function downTriangle(ctx, prnChng) {
    ctx.beginPath().strokeStyle('#FF2500').fillStyle('#FF2500').moveTo(105, 41).lineTo(97, 35).lineTo(113, 35).lineTo(105, 41).stroke().fill().font('bold 13px Arial').textAlign('center').fillText(prnChng, 105, 30);
  };

  var percentChange = function percentChange(ctx, last, current) {
    if (current > last) {
      upTriangle(ctx, '+' + String((current - last) / last * 100).slice(0, 4) + '%');
    } else {
      downTriangle(ctx, '-' + String((last - current) / last * 100).slice(0, 4) + '%');
    }
  };

  var renderChange = function renderChange(ctx, last, current, call, put) {
    var diff = call >= 100 || put >= 100 ? 20 : 0;
    ctx.clearRect(0, 0, 210, 60).font('45px Arial').textAlign('end').fillStyle('white').fillText(Math.floor(put), 75, 50).textAlign('start').fillText(Math.ceil(call), 135, 50).font('11px Arial').fillText('ASK', 150 + diff, 10).textAlign('end').fillText('BID', 66 - diff, 10);
    percentChange(ctx, last, current);
  };
  var setCard = function setCard(cardId) {
    var price = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 88;
    var symb = arguments[2];

    var c = document.getElementById(cardId);
    var ctx = (0, _Canvas2DContext2.default)(c);
    var pointStream = (0, _d3fcRandomData.randomFinancial)().startDate(new Date()).startPrice(price).stream();
    var last = pointStream.next();

    var start = function start() {
      var current = pointStream.next();

      window.requestAnimationFrame(function () {
        renderChange(ctx, last.close, current.close, current.high, current.low);
        last = current;
        if (chartView.symb === symb && false) {
          chartView.update(current);
        }
      });
    };

    var startLoop = function startLoop() {
      window.requestAnimationFrame(start);

      setTimeout(function () {
        if (_inView === true) {
          window.requestAnimationFrame(startLoop);
        }
      }, 1500);
    };
    callAll.push(startLoop.bind(undefined));

    var thisCard = {
      start: function start() {
        var current = pointStream.next();

        window.requestAnimationFrame(function () {
          renderChange(ctx, last.close, current.close, current.high, current.low);
        });

        setTimeout(startLoop, 1500);
      },
      startLoop: startLoop
    };

    return thisCard;
  };
  return {
    setCard: setCard,
    chartView: chartView,
    inView: function inView() {
      _inView = true;
      callAll.forEach(function (itm) {
        var tO = Math.floor(Math.random() * 1500 + 10);
        setTimeout(itm, tO);
      });
    },
    getView: function getView() {
      return _inView;
    },
    outView: function outView() {
      _inView = false;
    }
  };
};

exports.default = CardCtx;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Canvas2DContext = __webpack_require__(5);

var _Canvas2DContext2 = _interopRequireDefault(_Canvas2DContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var clock = function clock() {
  var _inView = true;
  var checkTime = function checkTime(i) {
    if (i < 10) {
      i = '0' + i;
    }; // add zero in front of numbers < 10
    return i;
  };

  var timer = function timer(ctxId) {
    var c = document.getElementById(ctxId);
    var ctx = (0, _Canvas2DContext2.default)(c);
    var startTime = function startTime() {
      if (_inView) {
        var today = new Date();
        var h = today.getHours();
        var m = today.getMinutes();
        var s = today.getSeconds();
        m = checkTime(m);
        s = checkTime(s);

        var tm = h + ':' + m + ':' + s;
        ctx.clearRect(0, 0, 66, 20).font('16px bold sans-serif').textAlign('center').fillStyle('white').fillText(tm, 34, 16);
      }
      setTimeout(startTime, 500);
    };

    return startTime;
  };
  return {
    setClock: timer,
    inView: function inView() {
      _inView = true;
    },
    getView: function getView() {
      return _inView;
    },
    outView: function outView() {
      _inView = false;
    }
  };
};

module.exports = clock();

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var trendLineCreate = __webpack_require__(55);

var lineDataTransform = function lineDataTransform(data, ln) {
  return data.map(function (itm, i) {
    return { x: itm.data.x, y: itm.data.y[3], lineColor: itm.lineColor };
  });
};

var ohlcDataTransform = function ohlcDataTransform(data, ln) {
  return data.slice(-ln).map(function (itm, i) {
    return { x: itm.data.x, y: itm.data.y };
  });
};

function CtxController() {
  var inView = true;
  this.outOfView = function () {
    inView = false;
  };
  this.backInView = function () {
    inView = true;
  };

  var CtxChrt = function CtxChrt(symbl) {
    var chartSettings = {
      cT: 'candlestick',
      setType: 0,
      types: ['area', 'line', 'candlestick', 'ohlc']
    };
    var dataFull = false;
    var lastXval = null;
    var TrendLine = trendLineCreate(symbl + '_trend');
    var fullDataPoints = [];
    var mainSymbol = symbl;
    var dataPoints = {};
    var aX = {
      labelFontSize: 10,
      margin: 20,
      valueFormatString: 'HH:mm:ss',
      lineThickness: 1
    };

    var aY = {
      minimum: 99999,
      labelFontSize: 14,
      gridThickness: 0.5,
      gridColor: '#224458',
      lineThickness: 1
    };
    var setAxMinMax = function setAxMinMax(x) {
      aX.minimum = x;
      aX.maximum = new Date(x.getTime() + chartSettings.setBack + 400);
    };
    var setAxMinMax2 = function setAxMinMax2(len) {
      var diff = chartSettings.dataLength - len;
      if (diff > 0) {
        var x = dataPoints[mainSymbol][1].x;
        aX.viewportMinimum = x;
        aX.minimum = x;
        aX.viewportMaximum = new Date(x.getTime() + diff * 100);
        aX.maximum = aX.viewportMaximum;
        dataFull = false;
      }
      // aX.maximum = new Date(dataPoints[mainSymbol][0].x.getTime() + chartSettings.setBack);
    };
    var chartConfigs = {
      area: function area() {
        chartSettings.setType = 1;
        chartSettings.dataLength = 594;
        chartSettings.setBack = 120000;
        return { type: 'area', markerSize: 0, cursor: 'pointer', axisYType: 'secondary', fillOpacity: .3 };
      },
      line: function line() {
        chartSettings.setType = 1;
        chartSettings.dataLength = 594;
        chartSettings.setBack = 120000;
        return { type: 'line', markerSize: 0, cursor: 'pointer', axisYType: 'secondary' };
      },
      ohlc: function ohlc() {
        chartSettings.setType = 0;
        chartSettings.dataLength = 130;
        chartSettings.setBack = 27000;
        return {
          type: 'ohlc',
          markerSize: 0,
          fillOpacity: 1,
          cursor: 'pointer',
          risingColor: '#00FF00',
          axisYType: 'secondary'

        };
      },
      candlestick: function candlestick() {
        //   aX.interval = 2;
        dataPoints[mainSymbol] = [];
        chartSettings.setType = 0;
        chartSettings.dataLength = 130;
        chartSettings.setBack = 27000;
        return {
          type: 'candlestick',
          markerSize: 0,
          fillOpacity: 1,
          cursor: 'pointer',
          risingColor: '#00FF00',
          axisYType: 'secondary'

        };
      }

    };

    var makeSeries = function makeSeries(type, symbol) {
      dataPoints[symbol] = [];
      var chartConfig = chartConfigs[type]();
      chartConfig.dataPoints = dataPoints[symbol];
      return chartConfig;
    };
    var series = [];
    series.push(makeSeries(chartSettings.cT, mainSymbol));

    var chart = new CanvasJS.Chart(mainSymbol, {
      title: {
        text: symbl,
        fontColor: '#00d8ff',
        fontSize: 20,
        verticalAlign: 'top',
        horizontalAlign: 'left'
      },
      toolTip: {
        enabled: true,
        animationEnabled: false
      },
      axisX: aX,
      axisY2: aY,
      backgroundColor: '#18252e',
      data: series
    });
    chart.setTrendLineCB(TrendLine.lineShift, TrendLine.callPutLines);
    chart.rectBsetColor = '#000000';
    var modifySeries = function modifySeries(type) {
      var chartConfig = chartConfigs[type]();
      var tyChange = {
        line: 1,
        area: 1,
        ohlc: 0,
        candlestick: 0
      };
      chartSettings.cT = type;
      if (tyChange[type] !== chartSettings.setType) {
        if (chartSettings.dataLength < dataPoints[mainSymbol].length) {
          var sliceTo = chartSettings.dataLength * -1;
          var a1 = dataPoints[mainSymbol].slice(sliceTo);
          dataPoints[mainSymbol] = a1;
          chartConfig.dataPoints = a1;
        }
      }
      delete aX.maximum;
      delete aX.minimum;
      chartConfig.dataPoints = dataPoints[mainSymbol];
      series[0] = chartConfig;
    };

    var lineCharts = function lineCharts(point) {
      var xVal = new Date(lastXval.getTime() + 200);
      lastXval = xVal;
      var lnColor = point.lastVal < point.data[3] ? '#1294ff' : '#ee5c5c';
      var data = {
        x: xVal,
        y: point.data[3],
        lineColor: lnColor
      };
      aY.minimum = aY.minimum > point.min ? Math.floor(point.min) : aY.minimum;

      if (!aX.maximum) {
        //  if (dataPoints[point.symb].length === 0){
        setAxMinMax(xVal);
        // }else{
        //setAxMinMax(dataPoints[point.symb][1].x, false)
        setAxMinMax(xVal);
        //}
      }
      dataPoints[point.symb].push(data);

      if (dataPoints[point.symb].length > chartSettings.dataLength) {

        aX.maximum = new Date(xVal.getTime() + 1200);
        dataFull = true;

        dataPoints[point.symb].shift();
        //fullDataPoints.shift();

        aX.minimum = dataPoints[point.symb][0].x;
      }
      if (inView) {
        chart.render();

        //  TrendLine(chart.getLastXY());
      }
    };
    var ohlcCharts = function ohlcCharts(point) {
      var xVal = new Date(lastXval.getTime() + 200);
      lastXval = xVal;
      var data = {
        x: xVal,
        y: point.data
      };
      aY.minimum = aY.minimum > point.min ? Math.floor(point.min * 0.975) : aY.minimum;

      if (!aX.maximum) {
        if (dataPoints[point.symb].length > 0) {
          setAxMinMax(xVal);
        } else {
          setAxMinMax(xVal);
        }
      }
      dataPoints[point.symb].push(data);
      // fullDataPoints.push({data:data, lineColor: point.lastVal < point.data[3] ? '#1294ff' : '#ee5c5c'});
      if (dataPoints[point.symb].length > chartSettings.dataLength) {
        aX.maximum = new Date(xVal.getTime() + 1200);
        dataFull = true;

        dataPoints[point.symb].shift();
        // fullDataPoints.shift();
        aX.minimum = dataPoints[point.symb][0].x;
      }
      if (inView) {
        chart.render();

        // TrendLine(chart.getLastXY());
      }
    };
    var lastPoint = null;

    return {

      dataStream: function dataStream(point) {
        lastPoint = point;
        if (point.data[2] < 1) {
          point.data[0] *= 1000;
          point.data[1] *= 1000;
          point.data[2] *= 1000;
          point.data[3] *= 1000;
          point.min *= 1000;
          point.lastVal *= 1000;
        }

        if (!lastXval) {
          lastXval = new Date(new Date().getTime() - 200);
        }
        if (chartSettings.cT === 'area' || chartSettings.cT === 'line') {
          lineCharts(point);
        }
        if (chartSettings.cT === 'candlestick' || chartSettings.cT === 'ohlc') {
          ohlcCharts(point);
        }
      },
      changeRectColor: function changeRectColor(color) {

        chart.rectBsetColor = color;
      },
      useSolids: function useSolids() {
        chart.rectBset = false;
      },
      addSeries: function addSeries(sym) {
        series.push(makeSeries('line', sym));
        console.log('series', series);
      },
      getLatestPoint: function getLatestPoint() {
        return lastPoint;
      },
      addNewPos: function addNewPos(pos) {
        TrendLine.newPos(pos);
      },
      getTrendLineCntrl: function getTrendLineCntrl() {},
      posExpired: function posExpired(pos) {
        TrendLine.posExpired(pos.timestamp);
      },
      removeSeries: function removeSeries(sym) {
        console.log('removeSeries');
      },
      getChartType: function getChartType() {
        return chartSettings.cT;
      },
      chartType: function chartType(type) {

        chartSettings.cT = type;
        modifySeries(type);
      },
      changeDataLength: function changeDataLength(len) {
        dataLength = len > 150 ? len : 150;
      },
      shutdown: function shutdown() {
        console.log('the component unmounted');
      }

    };
  };
  this.passCTXconstructor = function () {
    return CtxChrt;
  };
}

var CtxChart = new CtxController();

exports.default = CtxChart;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var makeGraph = function makeGraph(chartId, data, title) {
  var theData = {
    data: {
      type: 'doughnut',
      dataPoints: data
    },

    title: 'Top U.S Smartphone Operating Systems By Market Share, Q3 2012'
  };
  var chart = new CanvasJS.Chart(chartId, {
    height: 80,
    animationEnabled: true,
    animationDuration: 1300,
    data: [theData.data]
  });
  return {
    renderChart: function renderChart() {
      chart.render();
    },
    newData: function newData(data) {
      chart.render();
    }
  };
};

exports.default = makeGraph;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Canvas2DContext = __webpack_require__(5);

var _Canvas2DContext2 = _interopRequireDefault(_Canvas2DContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var totalAmountCtx = function totalAmountCtx(cash) {
  var startAmt = '$' + cash;
  var c = document.getElementById('totalAccount');
  var ctx = (0, _Canvas2DContext2.default)(c);
  ctx.font('23px sans-serif').textAlign('end').fillStyle('#30d94c').fillText(startAmt, 98, 28);
  var ctxFill = function ctxFill(amt, ii, unit) {
    var tO = ii * unit;
    setTimeout(function () {
      window.requestAnimationFrame(function () {
        ctx.clearRect(0, 0, 100, 40).fillStyle(amt.color).fillText(amt.text, 98, 28);
      });
    }, tO);
  };
  var showDiff = function showDiff(ogValue, newValue) {
    var values = [];
    var ogCPY = ogValue;
    var unit = Math.ceil(1 / Math.abs(ogValue - newValue) * 1000);
    var newVl = Math.floor(newValue);
    if (ogValue > newValue) {
      while (ogCPY > newVl) {
        ogCPY -= 1;
        values.push({
          text: '$' + ogCPY,
          color: ogCPY > 0 ? '#30d94c' : 'red'
        });
      }
    } else {
      while (ogCPY < newVl) {
        ogCPY += 1;

        values.push({
          text: '$' + ogCPY,
          color: ogCPY > 0 ? '#30d94c' : 'red'
        });
      }
    }
    values.forEach(function (itm, i) {
      ctxFill(itm, i, unit);
    });
  };

  window.showDiff = showDiff;
};

exports.default = totalAmountCtx;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Canvas2DContext = __webpack_require__(5);

var _Canvas2DContext2 = _interopRequireDefault(_Canvas2DContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CurrentPositions = function CurrentPositions() {
  var _inView = true;
  var upTriangle = function upTriangle(ctx) {
    ctx.beginPath().strokeStyle('#00FF00').fillStyle('#00FF00').moveTo(5, 12).lineTo(0, 18).lineTo(10, 18).lineTo(5, 12).stroke().fill();
  };

  var downTriangle = function downTriangle(ctx) {
    ctx.beginPath().strokeStyle('#FF2500').fillStyle('#FF2500').moveTo(5, 18).lineTo(0, 12).lineTo(10, 12).lineTo(5, 18).stroke().fill();
  };
  var percentChnge = function percentChnge(last, current) {
    var sign = current > last ? '+' : '-';
    return [current > last, sign + String(Math.abs((current - last) / last) * 100).slice(0, 4) + '%'];
  };

  var getTimeLeft = function getTimeLeft(d) {
    return d < 0 ? 'Ended' : parseInt(d / 60, 10) + ':' + ('0' + parseInt(d % 60, 10)).slice(-2);
  };

  var renderArrow = function renderArrow(upArrow, ctx) {
    return upArrow === true ? upTriangle(ctx) : downTriangle(ctx);
  };
  function startTimer(duration, ctx, prc, current) {
    var change = percentChnge(prc, current);
    var timeLeft = getTimeLeft(duration);

    ctx.clearRect(0, 0, 100, 30).textAlign('end').font('15px Arial').strokeStyle('white').fillStyle('white').fillText(timeLeft, 98, 20).textAlign('start').font('12px Arial').fillText(change[1], 15, 20);

    renderArrow(change[0], ctx);
  }

  function PostionTile(position, ctxId) {
    var _this = this;

    var c = document.getElementById(ctxId);
    var ctx = (0, _Canvas2DContext2.default)(c);

    this.position = position;
    this.expireTime = position.timestamp.getTime();
    this.setTimer = function () {
      var nowTime = new Date().getTime();
      if (_inView) {
        var current = _this.position.getLatestPoint();

        window.requestAnimationFrame(function () {
          startTimer((_this.expireTime - nowTime) / 1000, ctx, _this.position.unitPrice, current.data[3]);
        });
      }

      if (_this.expireTime > nowTime) {
        setTimeout(function () {
          return _this.setTimer();
        }, 1000);
      }
    };
    this.setTimer();
  }
  return {
    setTile: function setTile(position, ctxId) {
      return new PostionTile(position, ctxId);
    },
    inView: function inView() {
      _inView = true;
    },
    getView: function getView() {
      return _inView;
    },
    outView: function outView() {
      _inView = false;
    }
  };
};

var PositionTiles = CurrentPositions();

exports.default = PositionTiles;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _d3fcRandomData = __webpack_require__(14);

var _Canvas2DContext = __webpack_require__(5);

var _Canvas2DContext2 = _interopRequireDefault(_Canvas2DContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var seeds = [{
  symb: 'AUD/JPY',
  prc: 79.013
}, {
  symb: 'AUD/USD',
  prc: 0.7588
}, {
  symb: 'CAD/CHF',
  prc: 0.7514
}, {
  symb: 'CAD/JPY',
  prc: 80.757
}, {
  symb: 'CHF/JPY',
  prc: 107.342
}, {
  symb: 'EUR/AUD',
  prc: 1.4694
}, {
  symb: 'EUR/CAD',
  prc: 1.44065
}, {
  symb: 'EUR/GBP',
  prc: 0.8368
}, {
  symb: 'EUR/JPY',
  prc: 112.89
}, {
  symb: 'EUR/NOK',
  prc: 9.37867
}, {
  symb: 'EUR/SEK',
  prc: 9.49165
}, {
  symb: 'EUR/USD',
  prc: 1.1151
}, {
  symb: 'GBP/AUD',
  prc: 1.85303
}, {
  symb: 'GBP/CHF',
  prc: 1.2927
}, {
  symb: 'GBP/JPY',
  prc: 138.921
}, {
  symb: 'GBP/USD',
  prc: 1.3325
}, {
  symb: 'USD/BRL',
  prc: 3.85397
}, {
  symb: 'USD/CAD',
  prc: 1.31252
}, {
  symb: 'USD/CHF',
  prc: 0.98669
}, {
  symb: 'USD/CNY',
  prc: 6.6758
}, {
  symb: 'USD/CZK',
  prc: 24.6089
}, {
  symb: 'USD/HKD',
  prc: 7.7566
}, {
  symb: 'USD/INR',
  prc: 67.0958
}, {
  symb: 'USD/JPY',
  prc: 101.24
}, {
  symb: 'USD/MXN',
  prc: 18.5388
}, {
  symb: 'USD/NOK',
  prc: 8.54192
}, {
  symb: 'USD/PLN',
  prc: 3.9742
}, {
  symb: 'USD/RUB',
  prc: 64.745
}, {
  symb: 'USD/SEK',
  prc: 8.64657
}, {
  symb: 'USD/SGD',
  prc: 1.3579
}];

var percentChange = function percentChange(last, current) {
  if (current > last) {
    return ['#30b911', '+' + String((current - last) / last * 100).slice(0, 4) + '%'];
  } else {
    return ['#DC143C', '-' + String((last - current) / last * 100).slice(0, 4) + '%'];
  }
};
var spreadCTX = function spreadCTX() {
  var c = document.getElementById('activeSpreads');
  var ctx = (0, _Canvas2DContext2.default)(c);
  var Tickers = {
    activeSymbols: [],
    hasRendered: false
  };
  var inView = false;
  var ctxHeight = 400;
  var canRender = true;
  var typeSetting = 'spreads';
  var currentTicks = [];
  var twoDec = function twoDec(val) {
    return Math.round(val * 100) / 100;
  };

  var renderRow = function renderRow(atPos, symb, ask, bid, last, current) {
    var textPos = atPos + 15;
    var colorNpercent = percentChange(last, current);

    ctx.clearRect(0, atPos, 200, 20).font('13px Arial').fillStyle('black').fillRect(0, atPos, 200, 20).fillStyle('silver').fillRect(0, atPos + 19, 200, 1).textAlign('start').fillStyle('#00d8ff').fillText(symb, 2, textPos).textAlign('end').fillStyle(colorNpercent[0]).fillText(colorNpercent[1], 198, textPos).fillStyle('white').font('12px Arial').fillText(String(bid), 148, textPos - 1).textAlign('start').fillText(String(ask), 70, textPos - 1);
  };

  Tickers.renderLive = function () {
    Tickers.activeSymbols.forEach(function (symItm) {
      setTimeout(function () {
        Tickers[symItm.s].callRound();
      }, symItm.d);
    });
  };

  Tickers.renderSpread = function () {
    canRender = false;
    ctx.clearRect(0, 0, 200, 650);
    currentTicks.forEach(function (itm, index) {
      var atPos = 20 * index + 1;
      renderRow(atPos, itm.symb, itm.ask, itm.bid, itm.last, itm.close);
    });
    Tickers.hasRendered = true;
    setTimeout(function () {
      canRender = true;
      Tickers.renderLive();
    }, 100);
  };
  Tickers.renderUnit = function (topPos, utTick) {
    if (canRender) {
      window.requestAnimationFrame(function () {
        renderRow(topPos, utTick.symb, utTick.ask, utTick.bid, utTick.last, utTick.close);
      });
    }
  };
  var newTicker = function newTicker(symb, price, renderDelay) {
    currentTicks.push({ symbol: symb });
    var atDex = currentTicks.length - 1;
    var tickSymb = {
      data: [],
      currentPoint: null,
      lastPoint: null,
      change: 0.0,
      symbol: symb,
      atPos: 20 * atDex + 1,
      tickIndex: atDex,
      startPrice: price
    };

    tickSymb.logData = function (pr) {
      var symbol = symb;
      var thisIndex = tickSymb.tickIndex;
      tickSymb.generator = (0, _d3fcRandomData.randomFinancial)().startDate(new Date()).startPrice(pr);
      tickSymb.stream = tickSymb.generator.stream();
      var p1s = tickSymb.stream.next();
      var p2s = tickSymb.stream.next();
      var lastpoint = {
        symb: tickSymb.symbol,
        last: 0,
        close: twoDec(p2s.close),
        ask: twoDec(p2s.high),
        bid: twoDec(p2s.low),
        askVol: p2s.volume,
        bidVol: Math.ceil(p2s.volume * (Math.random() + 0.6))
      };
      var startpoint = {
        symb: tickSymb.symbol,
        last: twoDec(p2s.close),
        close: twoDec(p1s.close),
        ask: twoDec(p1s.high),
        bid: twoDec(p1s.low),
        askVol: p1s.volume,
        bidVol: Math.ceil(p1s.volume * (Math.random() + 0.6))
      };
      tickSymb.currentPoint = startpoint;
      tickSymb.lastPoint = lastpoint;
      currentTicks[tickSymb.tickIndex] = startpoint;

      tickSymb.callRound = function () {
        if (inView) {
          var p1 = tickSymb.stream.next();
          var bidVl = Math.ceil(p1.volume * (Math.random() + 0.6));
          var point = {
            symb: symbol,
            last: tickSymb.lastPoint.close,
            close: twoDec(p1.close),
            ask: twoDec(p1.high),
            bid: twoDec(p1.low),
            askVol: p1.volume,
            bidVol: bidVl
          };
          currentTicks[thisIndex] = point;
          tickSymb.lastPoint = tickSymb.currentPoint;
          tickSymb.currentPoint = point;
          Tickers.renderUnit(tickSymb.atPos, tickSymb.currentPoint);
          setTimeout(function () {
            tickSymb.callRound();
          }, 2000);
        }
      };
    };

    tickSymb.logData.bind(tickSymb);
    Tickers[symb] = tickSymb;
    Tickers.activeSymbols.push({ s: symb, d: renderDelay });

    tickSymb.logData(price);
  };

  function seedSpread() {
    seeds.forEach(function (itm, index) {
      newTicker(itm.symb, itm.prc, Math.floor(Math.random() * 2000 + 10));
    });
    ctxHeight = seeds.length * 20 + 10;
  }

  var spreadInterface = {
    renderRow: renderRow
  };
  spreadInterface.seedSpread = seedSpread.bind(spreadInterface);
  spreadInterface.inView = function () {
    inView = true;
    window.requestAnimationFrame(function () {
      Tickers.hasRendered ? Tickers.renderLive() : Tickers.renderSpread();
    });
  };
  spreadInterface.getView = function () {
    return inView;
  };
  spreadInterface.outView = function () {
    inView = false;
  };
  spreadInterface.setting = function (tp) {
    typeSetting = tp;
  };
  return spreadInterface;
};

exports.default = spreadCTX;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Canvas2DContext = __webpack_require__(5);

var _Canvas2DContext2 = _interopRequireDefault(_Canvas2DContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var trendLine2 = function trendLine2(ctxId) {
  var container = document.getElementById(ctxId);
  var c = container.querySelector('canvas');
  c.height = container.clientHeight;
  c.width = container.clientWidth;
  var theWid = c.width;
  var theHeight = c.width;
  var ctx = (0, _Canvas2DContext2.default)(c);
  var lineShift = function lineShift(shift) {
    var theY = shift.y + 0.5;
    ctx.clearRect(0, 0, theWid, theHeight).globalAlpha(1).beginPath().moveTo(0, theY).lineTo(theWid - 40, theY).lineWidth(1).strokeStyle('#f70').stroke();
  };

  return lineShift;
};
var trendLine = function trendLine(ctxId) {
  var container = document.getElementById(ctxId);
  var c = container.querySelector('canvas');
  var ctx2 = (0, _Canvas2DContext2.default)(c);
  var trendLineColor = false ? '#f70' : '#fff';
  var openPos = [];
  var LineShift = function LineShift(ctx, x, y, theWid, current) {
    var num = current.toFixed(2);
    var theY = y + 0.5;

    ctx.beginPath();
    ctx.moveTo(0, theY);
    ctx.lineTo(theWid, theY);
    ctx.lineWidth = 1;
    ctx.strokeStyle = trendLineColor;
    ctx.stroke();
    ctx.beginPath();
    //ctx.fillStyle = '#fff';
    //ctx.fill();
    window.requestAnimationFrame(function () {
      ctx2.beginPath().moveTo(8, theY - 8).lineTo(0, theY).lineTo(8, theY + 8).lineTo(8, theY + 8).strokeStyle('#fff').stroke().fillStyle('#fff').fill().closePath().fillStyle('#fff').fillRect(8, theY - 8, 38, 16).fillStyle('black').font('11px Arial').textAlign('start').fillText(num, 8, theY + 4);
    });
  };
  var CallPutLines = function CallPutLines(ctx, theWid, converter) {
    ctx2.clearRect(0, 0, 46, 800);
    //let stamp = new Date().getTime();
    if (openPos.length) {
      // ctx.save();
      openPos.forEach(function (itm) {
        var theY = converter(itm.unitPrice) + 0.5;
        var num = itm.unitPrice.toFixed(2);
        var theColor = itm.type === 'CALL' ? '#00FF00' : '#ff0000';
        ctx.beginPath();
        ctx.setLineDash([2, 2]);
        ctx.moveTo(0, theY);
        ctx.lineTo(theWid, theY);
        ctx.lineWidth = 1;
        ctx.strokeStyle = theColor;
        ctx.stroke();
        ctx.setLineDash([]);

        ctx2.beginPath().moveTo(8, theY - 8).lineTo(0, theY).lineTo(8, theY + 8).lineTo(8, theY + 8).strokeStyle(theColor).stroke().fillStyle(theColor).fill().closePath().fillStyle(theColor).fillRect(8, theY - 8, 38, 16).fillStyle('black').font('11px Arial').textAlign('start').fillText(num, 8, theY + 4);
        //ctx.beginPath();
        //ctx.fillStyle = '#fff';

        //ctx.fill();
      });
      //ctx.restore();
    }
  };

  return {
    lineShift: LineShift,
    callPutLines: CallPutLines,
    newPos: function newPos(pos) {
      openPos = openPos.concat(pos);
    },
    posExpired: function posExpired(stamp) {
      openPos = openPos.filter(function (itm) {
        return itm.timestamp !== stamp;
      });
    },
    newColor: function newColor(color) {
      trendLineColor = color;
    }
  };
};

module.exports = trendLine;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ChartContainer = function (_React$PureComponent) {
  _inherits(ChartContainer, _React$PureComponent);

  function ChartContainer() {
    _classCallCheck(this, ChartContainer);

    return _possibleConstructorReturn(this, (ChartContainer.__proto__ || Object.getPrototypeOf(ChartContainer)).apply(this, arguments));
  }

  _createClass(ChartContainer, [{
    key: 'containerClassName',
    value: function containerClassName(_ref) {
      var chartQnty = _ref.chartQnty,
          index = _ref.index;

      if (chartQnty === 1) {
        return 'chart-box-100 col-sm-12 fade-in-fast';
      }
      if (chartQnty === 2) {
        return 'chart-box-50 col-sm-12 fade-in-fast';
      }
      if (chartQnty === 3) {
        return index === 2 ? 'chart-box-50 col-sm-12 fade-in-fast' : 'chart-box-50 td-reduce col-sm-6 fade-in-fast';
      }
      return 'chart-box-50 td-reduce col-sm-6 fade-in-fast';
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: this.containerClassName(this.props) },
        this.props.children
      );
    }
  }]);

  return ChartContainer;
}(_react2.default.PureComponent);

exports.default = ChartContainer;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var percentChange2 = function percentChange2(last, current) {
   if (current > last) {
      return {
         pos: true, arrow: _react2.default.createElement(
            'i',
            { className: 'material-icons pos' },
            'arrow_drop_up'
         ),
         prnct: '+' + String((current - last) / last * 100).slice(0, 4) + '%'
      };
   } else {
      return {
         pos: false, arrow: _react2.default.createElement(
            'i',
            { className: 'material-icons neg' },
            'arrow_drop_down'
         ),
         prnct: '-' + String((last - current) / last * 100).slice(0, 4) + '%'
      };
   }
};
var returnLiClass = function returnLiClass(animate, active) {
   if (active) {
      return animate ? 'li-info-box pos-li-active li-slideup' : 'li-info-box pos-li-active';
   }
   return animate ? 'li-info-box li-slideup' : 'li-info-box';
};

var InfoLi = function (_React$Component) {
   _inherits(InfoLi, _React$Component);

   function InfoLi(props) {
      _classCallCheck(this, InfoLi);

      var _this = _possibleConstructorReturn(this, (InfoLi.__proto__ || Object.getPrototypeOf(InfoLi)).call(this, props));

      _this.whenClicked = _this.whenClicked.bind(_this);
      return _this;
   }

   _createClass(InfoLi, [{
      key: 'whenClicked',
      value: function whenClicked() {
         this.props.clicked(this.props.pos, this.props.index);
      }
   }, {
      key: 'componentWillMount',
      value: function componentWillMount() {}
   }, {
      key: 'render',
      value: function render() {
         var _props = this.props,
             pos = _props.pos,
             addStyle = _props.addStyle,
             animate = _props.animate,
             active = _props.active;

         var liClass = !addStyle ? returnLiClass(animate, active) : returnLiClass(false, active) + ' li-scale bounce-in-fast';
         var ani = this.props.animate && !addStyle ? 'slideUp ' + String(0.08 * this.props.index) + 's ease-out 0.6s 1 forwards' : '';
         var percentage = percentChange2(this.props.pos.pricestart, this.props.pos.priceend);
         var profit = '$' + String(Math.round(pos.priceend * pos.volume - pos.pricestart * pos.volume));
         var dta = this.props.pos.date.slice(0, -5);
         var unitPrice = '$' + pos.priceend.toFixed(2);
         return _react2.default.createElement(
            'li',
            { className: liClass, style: {
                  animation: ani
               }, onDragEnd: this.whenClicked.bind(this), onMouseUp: this.whenClicked.bind(this), draggable: 'true' },
            _react2.default.createElement(
               'div',
               { className: 'li-span-block dt-span' },
               dta
            ),
            _react2.default.createElement(
               'div',
               { className: 'li-span-block span-label-blue th-span' },
               this.props.pos.position
            ),
            _react2.default.createElement(
               'div',
               { className: 'li-span-block' },
               _react2.default.createElement(
                  'span',
                  { className: 'big-kahuna' },
                  unitPrice
               ),
               _react2.default.createElement(
                  'span',
                  { className: 'vol-span' },
                  this.props.pos.volume
               )
            ),
            _react2.default.createElement(
               'div',
               { className: 'li-span-block' },
               _react2.default.createElement(
                  'span',
                  null,
                  percentage.arrow
               ),
               _react2.default.createElement(
                  'span',
                  null,
                  percentage.prnct
               )
            ),
            _react2.default.createElement(
               'div',
               { className: 'li-span-block' },
               _react2.default.createElement(
                  'span',
                  { className: percentage.pos ? 'span-green' : 'span-red' },
                  profit
               )
            )
         );
      }
   }]);

   return InfoLi;
}(_react2.default.Component);

exports.default = InfoLi;
;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var postiveChange = function postiveChange(last, current) {
   return {
      pos: true,
      arrow: _react2.default.createElement(
         'i',
         { className: 'material-icons pos' },
         'arrow_drop_up'
      ),
      prnct: '+' + String((current - last) / last * 100).slice(0, 4) + '%'
   };
};

var negativeChange = function negativeChange(last, current) {
   return {
      pos: false,
      arrow: _react2.default.createElement(
         'i',
         { className: 'material-icons neg' },
         'arrow_drop_down'
      ),
      prnct: '-' + String((last - current) / last * 100).slice(0, 4) + '%'
   };
};

var PositionView = function (_React$PureComponent) {
   _inherits(PositionView, _React$PureComponent);

   function PositionView(props) {
      _classCallCheck(this, PositionView);

      var _this = _possibleConstructorReturn(this, (PositionView.__proto__ || Object.getPrototypeOf(PositionView)).call(this, props));

      _this.percentChange = function (_ref) {
         var pricestart = _ref.pricestart,
             priceend = _ref.priceend;
         return pricestart < priceend ? postiveChange(pricestart, priceend) : negativeChange(pricestart, priceend);
      };

      _this.currentProfit = function () {
         var _this$props$pos = _this.props.pos,
             priceend = _this$props$pos.priceend,
             volume = _this$props$pos.volume,
             pricestart = _this$props$pos.pricestart;

         return '$' + String(Math.round(priceend * volume - pricestart * volume));
      };

      props.GraphController.updatePosProps(props.pos);
      return _this;
   }

   _createClass(PositionView, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
         this.props.GraphController.createCharts(this.props.pos);
      }
   }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
         this.props.GraphController.updatePosProps(this.props.pos);
         this.props.GraphController.updateCharts();
      }
   }, {
      key: 'render',
      value: function render() {
         var pos = this.props.pos;

         var percentage = this.percentChange(pos);
         return _react2.default.createElement(
            'div',
            { className: 'view-trd fade-in' },
            _react2.default.createElement(
               'h3',
               { className: 'under-line span-label-blue margin-btm-sm' },
               pos.position
            ),
            pos.date,
            _react2.default.createElement(
               'div',
               { className: 'row pos-overview' },
               _react2.default.createElement(
                  'div',
                  { className: 'col-xs-2 pos-col pos-first' },
                  _react2.default.createElement(
                     'strong',
                     null,
                     'Positions'
                  ),
                  pos.volume
               ),
               _react2.default.createElement(
                  'div',
                  { className: 'col-xs-2 pos-col' },
                  _react2.default.createElement(
                     'strong',
                     null,
                     'Start Value'
                  ),
                  pos.pricestart
               ),
               _react2.default.createElement(
                  'div',
                  { className: 'col-xs-2 pos-col' },
                  _react2.default.createElement(
                     'strong',
                     null,
                     'End Value'
                  ),
                  pos.priceend
               ),
               _react2.default.createElement(
                  'div',
                  { className: 'col-xs-3 pos-col' },
                  _react2.default.createElement(
                     'strong',
                     null,
                     'Change'
                  ),
                  _react2.default.createElement(
                     'span',
                     null,
                     percentage.arrow
                  ),
                  _react2.default.createElement(
                     'span',
                     null,
                     percentage.prnct
                  )
               ),
               _react2.default.createElement(
                  'div',
                  { className: 'col-xs-2 pos-col' },
                  _react2.default.createElement(
                     'strong',
                     null,
                     'Profit'
                  ),
                  _react2.default.createElement(
                     'span',
                     { className: percentage.pos ? 'span-green' : 'span-red' },
                     this.currentProfit()
                  )
               )
            ),
            _react2.default.createElement(
               'div',
               { className: 'row' },
               _react2.default.createElement('div', { id: 'chart1view', className: 'ctx-charts-class' }),
               _react2.default.createElement('div', { id: 'chart2view', className: 'ctx-charts-class' })
            )
         );
      }
   }]);

   return PositionView;
}(_react2.default.PureComponent);

exports.default = PositionView;
;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _stat = __webpack_require__(83);

var _stat2 = _interopRequireDefault(_stat);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var svg1 = {
   plusValue: 0,
   buffer: 11,
   domElem: null,
   type: 'number',
   animate: true,
   fillChange: false,
   lastValue: 0,
   current: 0,
   name: 'svg1'
};
var svg2 = {
   plusValue: 0,
   type: 'float',
   buffer: 11,
   domElem: null,
   animate: true,
   fillChange: true,
   lastValue: 0.0,
   current: 0.0,
   name: 'svg2'
};
var svg3 = {
   plusValue: 0,
   buffer: 11,
   domElem: null,
   type: 'float',
   fillChange: true,
   animate: true,
   lastValue: 0.0,
   current: 0.0,
   name: 'svg3'
};
var svg4 = {
   plusValue: 0,
   buffer: 11,
   domElem: null,
   type: 'float',
   fillChange: true,
   animate: true,
   lastValue: 0,
   current: 0,
   name: 'svg4'
};
var svg5 = {
   plusValue: 0,
   buffer: 11,
   domElem: null,
   type: 'number',
   fillChange: false,
   animate: true,
   lastValue: 0,
   current: 0,
   name: 'svg5'
};

var StatTiles = function (_React$PureComponent) {
   _inherits(StatTiles, _React$PureComponent);

   function StatTiles() {
      _classCallCheck(this, StatTiles);

      return _possibleConstructorReturn(this, (StatTiles.__proto__ || Object.getPrototypeOf(StatTiles)).apply(this, arguments));
   }

   _createClass(StatTiles, [{
      key: 'render',
      value: function render() {
         var tradeProps = this.props.tradeProps;

         return _react2.default.createElement(
            'div',
            { id: 'statTiles' },
            _react2.default.createElement(
               'div',
               { className: 'col-xs-2 stat-tile border-none' },
               _react2.default.createElement(
                  'span',
                  { className: 'top_span span-label-white' },
                  'Weekly Transactions'
               ),
               _react2.default.createElement(_stat2.default, { svgId: 'svg1', SvgCB: this.props.SvgCB, config: svg1, fillColor: '#00d8ff', classType: 'svg-count' }),
               _react2.default.createElement(
                  'span',
                  { className: 'bottom_span' },
                  'Thing'
               )
            ),
            _react2.default.createElement(
               'div',
               { className: 'col-xs-2 stat-tile' },
               _react2.default.createElement(
                  'span',
                  { className: 'top_span span-label-white' },
                  'Current Total'
               ),
               _react2.default.createElement(_stat2.default, { svgId: 'svg2', SvgCB: this.props.SvgCB, config: svg2, fillColor: '#00d8ff', classType: 'svg-count' }),
               _react2.default.createElement(
                  'span',
                  { className: 'bottom_span' },
                  'Thing'
               )
            ),
            _react2.default.createElement(
               'div',
               { className: 'col-xs-2 stat-tile' },
               _react2.default.createElement(
                  'span',
                  { className: 'top_span span-label-white' },
                  'Wk-on-Wk Gains'
               ),
               _react2.default.createElement(_stat2.default, { svgId: 'svg3', SvgCB: this.props.SvgCB, config: svg3, fillColor: '#DC143C', classType: 'svg-count' }),
               _react2.default.createElement(
                  'span',
                  { className: 'bottom_span' },
                  'Thing'
               )
            ),
            _react2.default.createElement(
               'div',
               { className: 'col-xs-2 stat-tile' },
               _react2.default.createElement(
                  'span',
                  { className: 'top_span span-label-white' },
                  'Today\'s Profit'
               ),
               _react2.default.createElement(_stat2.default, { svgId: 'svg4', SvgCB: this.props.SvgCB, config: svg4, fillColor: '#30d94c', classType: 'svg-count' }),
               _react2.default.createElement(
                  'span',
                  { className: 'bottom_span' },
                  'Thing'
               )
            ),
            _react2.default.createElement(
               'div',
               { className: 'col-xs-2 stat-tile' },
               _react2.default.createElement(
                  'span',
                  { className: 'top_span span-label-white' },
                  'Volume Traded'
               ),
               _react2.default.createElement(_stat2.default, { svgId: 'svg5', SvgCB: this.props.SvgCB, config: svg5, fillColor: '#00d8ff', classType: 'svg-count' }),
               _react2.default.createElement(
                  'span',
                  { className: 'bottom_span' },
                  'Thing'
               )
            )
         );
      }
   }]);

   return StatTiles;
}(_react2.default.PureComponent);

exports.default = StatTiles;
;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AskBidOverview = function (_React$PureComponent) {
  _inherits(AskBidOverview, _React$PureComponent);

  function AskBidOverview() {
    _classCallCheck(this, AskBidOverview);

    return _possibleConstructorReturn(this, (AskBidOverview.__proto__ || Object.getPrototypeOf(AskBidOverview)).apply(this, arguments));
  }

  _createClass(AskBidOverview, [{
    key: 'posValue',
    value: function posValue(pos, valIndex) {
      if (pos.point === undefined) return '';
      return '$' + Math.round(pos.point.data[valIndex] * 100) / 100;
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          timeExpires = _props.timeExpires,
          valIndex = _props.valIndex;

      var pos = this.props.pos === null ? { isnull: true } : this.props.pos;
      return _react2.default.createElement(
        'div',
        { className: pos.isnull === true ? 'hide-elm' : 'trade-description' },
        _react2.default.createElement(
          'div',
          { className: 'trn-blk trn-symb' },
          _react2.default.createElement(
            'span',
            null,
            'Symbol'
          ),
          _react2.default.createElement(
            'span',
            null,
            pos.symb || 'NONE'
          )
        ),
        _react2.default.createElement(
          'div',
          { className: 'trn-blk' },
          _react2.default.createElement(
            'span',
            null,
            'Quantity'
          ),
          _react2.default.createElement(
            'span',
            null,
            pos.qty || 0
          )
        ),
        _react2.default.createElement(
          'div',
          { className: 'trn-blk' },
          _react2.default.createElement(
            'span',
            null,
            'PPU'
          ),
          _react2.default.createElement(
            'span',
            null,
            this.posValue(pos, valIndex)
          )
        ),
        _react2.default.createElement(
          'div',
          { className: 'trn-blk' },
          _react2.default.createElement(
            'span',
            null,
            'Expires'
          ),
          _react2.default.createElement(
            'span',
            null,
            timeExpires
          )
        )
      );
    }
  }]);

  return AskBidOverview;
}(_react2.default.PureComponent);

exports.default = AskBidOverview;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _timeintervals = __webpack_require__(82);

var _timeintervals2 = _interopRequireDefault(_timeintervals);

var _ask_bid_overview = __webpack_require__(60);

var _ask_bid_overview2 = _interopRequireDefault(_ask_bid_overview);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CallPut = function (_React$PureComponent) {
  _inherits(CallPut, _React$PureComponent);

  function CallPut(props) {
    _classCallCheck(this, CallPut);

    var _this = _possibleConstructorReturn(this, (CallPut.__proto__ || Object.getPrototypeOf(CallPut)).call(this, props));

    _this.toggleMenuBid = function () {
      var pos = _this.state.pos ? _this.state.pos : {
        qty: 1,
        time: _this.state.timeSet,
        point: {
          data: [2, 3, 2, 2]
        },
        symb: _this.props.mainSym
      };
      pos.qty = _this.state.qnty;
      pos.type = 'CALL';
      pos.point = _this.props.ctxChart.getLatestPoint();
      pos.unitPrice = pos.point.data[3];
      _this.setState({ bidOpen: true, askOpen: false, timeMenuOpen: false, pos: pos });
    };

    _this.toggleMenuAsk = function () {
      var pos = _this.state.pos ? _this.state.pos : {
        qty: 1,
        time: _this.state.timeSet,
        point: {
          data: [2, 3, 2, 2]
        },
        symb: _this.props.mainSym
      };
      pos.qty = _this.state.qnty;
      pos.type = 'PUT';
      pos.point = _this.props.ctxChart.getLatestPoint();
      pos.unitPrice = pos.point.data[3];
      _this.setState({ askOpen: true, bidOpen: false, timeMenuOpen: false, pos: pos });
    };

    _this.setPosTime = function (tm) {
      return function () {
        var pos = _this.state.pos ? Object.assign({}, _this.state.pos) : {
          qty: 1,
          time: _this.state.timeSet,
          point: {
            data: [2, 3, 2, 2]
          },
          symb: _this.props.mainSym
        };
        pos.time = tm;
        pos.qty = _this.state.qnty;
        pos.point = _this.props.ctxChart.getLatestPoint();
        pos.symb = _this.state.symb;
        _this.setState({
          timeSet: tm,
          pos: pos
        });
      };
    };

    _this.posSet = function (bidOrAsk) {
      return function () {
        var _Object$assign = Object.assign({}, _this.state),
            pos = _Object$assign.pos,
            posNum = _Object$assign.posNum;

        var d = new Date();
        pos.expires = d.getHours() + ':' + ('0' + (d.getMinutes() + pos.time)).slice(-2);
        pos.timestamp = new Date(new Date().getTime() + pos.time * 60000);
        posNum += 1;

        pos.type = bidOrAsk;
        pos.getLatestPoint = _this.props.ctxChart.getLatestPoint;
        pos.ctxid = pos.symb + '_' + Date.now().toString().slice(-4);
        _this.props.newPos(Object.assign({}, pos));
        _this.setState({ askOpen: false, bidOpen: false, posNum: posNum, pos: null });
      };
    };

    _this.closeModal = function () {
      _this.setState({ askOpen: false, bidOpen: false, bidBtnClass: '', putBtnClass: '' });
    };

    _this.menuSet = function () {
      _this.setState({ timeMenuOpen: false });
    };

    _this.timeMenuOpen = function () {
      _this.setState({
        timeMenuOpen: !_this.state.timeMenuOpen
      });
    };

    _this.plusMinus = function (num) {
      return function () {
        var qnty = _this.state.qnty + num > 0 ? _this.state.qnty + num : 1;
        var pos = _this.state.pos ? Object.assign({}, _this.state.pos, { qty: qnty }) : null;

        _this.setState({ qnty: qnty, pos: pos });
      };
    };

    _this.btnPtnpush = function (bool) {
      return function () {
        if (bool) {
          var btn = _this.state.bidBtnClass === 'button-click' ? 'button-in' : 'button-click';
          _this.setState({ bidBtnClass: btn, putBtnClass: '' });
        } else {
          var _btn = _this.state.putBtnClass === 'button-click' ? 'button-in' : 'button-click';
          _this.setState({ putBtnClass: _btn, bidBtnClass: '' });
        }
      };
    };

    _this.clock = null;
    _this.state = {
      timeMenuOpen: false,
      menutype: null,
      qnty: 1,
      bidOpen: false,
      askOpen: false,
      bidBtnClass: '',
      putBtnClass: '',
      timeSet: 1,
      posNum: 0,
      symb: props.mainSym,
      pos: null
    };
    return _this;
  }

  _createClass(CallPut, [{
    key: 'calcTimeExpires',
    value: function calcTimeExpires(pos, date) {
      if (pos === null) return '';
      return date.getHours() + ':' + ('0' + (date.getMinutes() + pos.time)).slice(-2);
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {

      this.clock = this.props.clockCtx.setClock(this.props.timerId);
      this.clock();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {

      this.clock = null;
    }
  }, {
    key: 'render',
    value: function render() {
      var _state = this.state,
          putBtnClass = _state.putBtnClass,
          bidBtnClass = _state.bidBtnClass,
          pos = _state.pos;

      var date = new Date();
      var timeExpires = this.calcTimeExpires(pos, date);
      return _react2.default.createElement(
        'div',
        { className: 'option-buy-sell reduct' },
        _react2.default.createElement(
          'div',
          { id: 'timeMenu', className: this.state.timeMenuOpen ? 'zing-in-fast' : 'hide-elm' },
          _react2.default.createElement(
            'strong',
            null,
            'Position Expiration'
          ),
          _react2.default.createElement(_timeintervals2.default, { ind: this.state.timeSet, date: date, timeSet: this.setPosTime }),
          _react2.default.createElement(
            'div',
            { className: 'cool-button  add-chart-bt set-pos', onClick: this.menuSet },
            'Set Time'
          )
        ),
        _react2.default.createElement(
          'div',
          { id: 'Bid', className: this.state.bidOpen ? 'bounce-in-fast' : 'hide-elm' },
          _react2.default.createElement(
            'p',
            { className: 'pos-type-header call-t' },
            'Call Position'
          ),
          _react2.default.createElement(
            'i',
            { className: 'material-icons  close-modal', onClick: this.closeModal },
            'clear'
          ),
          _react2.default.createElement(_ask_bid_overview2.default, { pos: pos, timeExpires: timeExpires, valIndex: 2 }),
          _react2.default.createElement(
            'div',
            { className: 'cool-button  add-chart-bt set-pos', onClick: this.posSet('CALL') },
            'Place Order'
          )
        ),
        _react2.default.createElement(
          'div',
          { id: 'Ask', className: this.state.askOpen ? 'bounce-in-fast' : 'hide-elm' },
          _react2.default.createElement(
            'p',
            { className: 'pos-type-header put-t' },
            'Put Position'
          ),
          _react2.default.createElement(
            'i',
            { className: 'material-icons close-modal', onClick: this.closeModal },
            'clear'
          ),
          _react2.default.createElement(_ask_bid_overview2.default, { pos: pos, timeExpires: timeExpires, valIndex: 1 }),
          _react2.default.createElement(
            'div',
            { className: 'cool-button  add-chart-bt set-pos', onClick: this.posSet('PUT') },
            'Place Order'
          )
        ),
        _react2.default.createElement(
          'p',
          { className: 'text-wrap-values time-ticker time-v', onClick: this.timeMenuOpen },
          _react2.default.createElement('canvas', { id: this.props.timerId, height: 18, width: 66 })
        ),
        _react2.default.createElement(
          'p',
          { className: 'text-wrap-values time-ticker' },
          _react2.default.createElement(
            'strong',
            null,
            this.state.qnty
          )
        ),
        _react2.default.createElement(
          'div',
          { className: 'text-wrap-values plus-minus sub-v', onClick: this.plusMinus(-1) },
          _react2.default.createElement(
            'i',
            { className: 'material-icons' },
            'remove'
          )
        ),
        _react2.default.createElement(
          'div',
          { className: 'text-wrap-values plus-minus add-v', onClick: this.plusMinus(1) },
          _react2.default.createElement(
            'i',
            { className: 'material-icons' },
            'add'
          )
        ),
        _react2.default.createElement(
          'p',
          { className: 'profit' },
          '71%'
        ),
        _react2.default.createElement(
          'div',
          { className: 'trade-butt put-butt ' + bidBtnClass, onMouseDown: this.btnPtnpush(true), onMouseUp: this.toggleMenuBid },
          _react2.default.createElement('img', { src: '/icons/gain.png' }),
          _react2.default.createElement(
            'strong',
            null,
            'Call'
          )
        ),
        _react2.default.createElement(
          'div',
          { className: 'trade-butt call-butt ' + putBtnClass, onMouseDown: this.btnPtnpush(false), onMouseUp: this.toggleMenuAsk },
          _react2.default.createElement('img', { src: '/icons/loss.png' }),
          _react2.default.createElement(
            'strong',
            null,
            'Put'
          )
        )
      );
    }
  }]);

  return CallPut;
}(_react2.default.PureComponent);

exports.default = CallPut;
;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _buysell = __webpack_require__(61);

var _buysell2 = _interopRequireDefault(_buysell);

var _dashboard = __webpack_require__(12);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var chartOpts = function chartOpts(type) {
  switch (type) {
    case 'candlestick':
      return _react2.default.createElement(
        'span',
        { 'data-tp': 'candlestick' },
        'Candlestick',
        _react2.default.createElement('img', { 'data-tp': 'candlestick', height: '18', src: '/icons/candlestick.png' })
      );
      break;
    case 'ohlc':
      return _react2.default.createElement(
        'span',
        { 'data-tp': 'ohlc' },
        'OHLC',
        _react2.default.createElement('img', { 'data-tp': 'ohlc', height: '18', src: '/icons/ohlc.png' })
      );
      break;
    case 'area':
      return _react2.default.createElement(
        'span',
        { 'data-tp': 'area' },
        'Area',
        _react2.default.createElement('img', { 'data-tp': 'area', height: '18', src: '/icons/area.png' })
      );
      break;
    case 'line':
      return _react2.default.createElement(
        'span',
        { 'data-tp': 'line' },
        'Line',
        _react2.default.createElement('img', { 'data-tp': 'line', height: '18', src: '/icons/line.png' })
      );
      break;
    default:
      return _react2.default.createElement(
        'span',
        { 'data-tp': 'area' },
        'Area',
        _react2.default.createElement('img', { 'data-tp': 'area', height: '18', src: '/icons/area.png' })
      );
  }
};

var CanvasChart = function (_React$PureComponent) {
  _inherits(CanvasChart, _React$PureComponent);

  function CanvasChart(props) {
    _classCallCheck(this, CanvasChart);

    var _this = _possibleConstructorReturn(this, (CanvasChart.__proto__ || Object.getPrototypeOf(CanvasChart)).call(this, props));

    _this.dispatchChange = function (payload) {
      return _this.props.dispatch({ type: _dashboard.CHART_STATE_UPDATE, chartSymbol: _this.props.mainSym, payload: payload });
    };

    _this.toggleModal = function (bool) {
      return function () {
        return _this.dispatchChange({ modalOpen: bool });
      };
    };

    _this.toggleSets = function (bool) {
      return function () {
        return _this.dispatchChange({ optsOpen: bool });
      };
    };

    _this.depositChanged = function (num) {
      return _this.props.depChg(num);
    };

    _this.newPos = function (pos) {
      return _this.props.newPos(pos);
    };

    _this.hideUL = function () {
      return _this.dispatchChange({ optsOpen: false });
    };

    _this.liveUpdate = function (data) {
      return _this.ctxChart.dataStream(data);
    };

    _this.chartTypeSel = function (e) {
      if (e.target.className === 'selected-chart' || e.target.parentElement.className === 'selected-chart') {
        return '';
      }

      var chartType = e.target.dataset.tp;
      if (chartType) {
        _this.dispatchChange({ chartType: chartType, optsOpen: false });

        _this.ctxChart.chartType(chartType);
      }
    };

    _this.closeChart = function () {
      var feedExit = 'exit_' + _this.props.mainSym;
      _this.dbSource.send(feedExit);
      _this.props.clCtx(_this.props.mainSym);
    };

    _this.dbSource = props.dataSource;
    _this.dataPoints = [];

    _this.feedWatch = props.mainSym;
    _this.ctxChart = null;
    _this.dbSource.dispatchEvent(_this.feedWatch, function (details) {
      return _this.liveUpdate(details);
    });

    return _this;
  }

  _createClass(CanvasChart, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.ctxChart = this.props.ctx(this.props.mainSym);
      var symbChart = {};
      symbChart[this.props.mainSym] = {
        ctxChart: this.ctxChart,
        open: {}
      };
      this.props.whenMounted(symbChart);
      this.dbSource.send(this.props.mainSym);
      this.dispatchChange({ callPut: this.props.mainSym });
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      //removeSeries
      var feedExit = 'exit_' + this.props.mainSym;
      this.dbSource.send(feedExit);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          state = _props.state,
          mainSym = _props.mainSym;

      var chartTypeLis = ['candlestick', 'area', 'ohlc', 'line'].map(function (itm, ii) {
        var clName = state.chartType === itm ? 'selected-chart' : '';
        return _react2.default.createElement(
          'li',
          { key: 'get-' + itm, 'data-tp': itm, className: clName },
          chartOpts(itm)
        );
      });
      return _react2.default.createElement(
        'div',
        { className: 'real-time-chart' },
        _react2.default.createElement('div', { id: this.props.mainSym, className: 'chartContainer reduct' }),
        _react2.default.createElement(
          'div',
          { id: mainSym + '_trend', className: 'chartContainer reduct trendline-ctx' },
          _react2.default.createElement('canvas', { height: '800', width: '46', className: 'floatRights' })
        ),
        _react2.default.createElement(
          'div',
          { className: 'chart-switch' },
          _react2.default.createElement(
            'div',
            { className: 'seclect-chart-butt' },
            _react2.default.createElement(
              'div',
              { onClick: this.toggleSets(true), className: state.optsOpen ? 'hide-elm' : 'current-type' },
              _react2.default.createElement(
                'span',
                null,
                state.chartType
              ),
              _react2.default.createElement(
                'span',
                null,
                _react2.default.createElement(
                  'i',
                  { className: 'material-icons small-i' },
                  'arrow_drop_down'
                )
              )
            ),
            _react2.default.createElement(
              'ul',
              { className: state.optsOpen ? 'chart-select-ul' : 'hide-elm', onMouseLeave: this.hideUL, onClick: this.chartTypeSel },
              chartTypeLis
            )
          ),
          _react2.default.createElement(
            'div',
            { onClick: this.toggleModal(true), className: 'chart-remove' },
            _react2.default.createElement(
              'span',
              null,
              'Close'
            ),
            _react2.default.createElement(
              'i',
              { className: 'material-icons' },
              'clear'
            )
          )
        ),
        state.callPut !== null && _react2.default.createElement(_buysell2.default, { mainSym: mainSym, newPos: this.newPos, depositChanged: this.depositChanged, ctxChart: this.ctxChart, timerId: mainSym + '_clock', clockCtx: this.props.clock }),
        _react2.default.createElement(
          'div',
          { className: state.modalOpen ? 'warn-modal fade-in-fast' : 'hide-elm' },
          _react2.default.createElement(
            'div',
            { className: 'heading-block' },
            _react2.default.createElement(
              'i',
              { className: 'material-icons' },
              'warning'
            ),
            _react2.default.createElement(
              'span',
              null,
              'FYI'
            ),
            _react2.default.createElement(
              'p',
              null,
              'Closing this modal will close your Feed listener for',
              _react2.default.createElement(
                'b',
                null,
                this.props.mainSym
              )
            ),
            _react2.default.createElement(
              'div',
              { onClick: this.closeChart, className: 'cool-button agree-ok' },
              'I know'
            ),
            _react2.default.createElement(
              'div',
              { onClick: this.toggleModal(false), className: 'cool-button disagree-ok' },
              'Nevermind'
            )
          )
        )
      );
    }
  }]);

  return CanvasChart;
}(_react2.default.PureComponent);

exports.default = CanvasChart;
;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _tickcard = __webpack_require__(80);

var _tickcard2 = _interopRequireDefault(_tickcard);

var _tickerview = __webpack_require__(81);

var _tickerview2 = _interopRequireDefault(_tickerview);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ll = [{
  symb: 'AUD/JPY',
  prc: 79.013
}, {
  symb: 'AUD/USD',
  prc: 0.7588
}, {
  symb: 'CAD/CHF',
  prc: 0.7514
}, {
  symb: 'EUR/AUD',
  prc: 1.4694
}, {
  symb: 'EUR/CAD',
  prc: 1.44065
}, {
  symb: 'EUR/GBP',
  prc: 0.8368
}, {
  symb: 'EUR/JPY',
  prc: 112.89
}, {
  symb: 'USD/BRL',
  prc: 3.85397
}, {
  symb: 'USD/CAD',
  prc: 1.31252
}, {
  symb: 'GBP/JPY',
  prc: 138.921
}, {
  symb: 'GBP/USD',
  prc: 1.3325
}];

var LiveTickers = function (_React$PureComponent) {
  _inherits(LiveTickers, _React$PureComponent);

  function LiveTickers(props) {
    _classCallCheck(this, LiveTickers);

    var _this = _possibleConstructorReturn(this, (LiveTickers.__proto__ || Object.getPrototypeOf(LiveTickers)).call(this, props));

    _this.cardPostionClick = function (ind) {
      var _this$state = _this.state,
          leftCard = _this$state.leftCard,
          hoveredCard = _this$state.hoveredCard,
          updateViewed = _this$state.updateViewed,
          cardlist = _this$state.cardlist;

      if (hoveredCard !== leftCard && hoveredCard !== null && updateViewed !== null) {
        _this.whenDrop(hoveredCard);
        return '';
      }

      var cardSymbol = updateViewed ? updateViewed : cardlist[ind];
      var price = cardSymbol.prc < 10 ? Math.round(cardSymbol.prc * 100) : Math.round(cardSymbol.prc);
      _this.props.cardCtx.chartView.newSet(cardSymbol.symb, price);
      _this.setState({
        active: ind,
        cardlist: cardlist,
        applyOutAni: null,
        updateViewed: null,
        draggedCard: null,
        leftCard: null,
        hoveredCard: null,
        viewedTicker: cardSymbol
      });
    };

    _this.cardDragStart = function (index) {
      _this.setState({ draggedCard: index, applyOutAni: null });
    };

    _this.dragOverCard = function (index) {
      _this.setState({ hoveredCard: index });
    };

    _this.sideEnter = function (e) {
      console.log('sideEntered');
      e.preventDefault();
      e.stopPropagation();
      var _this$state2 = _this.state,
          cardlist = _this$state2.cardlist,
          draggedCard = _this$state2.draggedCard;

      _this.setState({ updateViewed: cardlist[draggedCard] });
    };

    _this.sideLeave = function (e) {
      console.log('sideLeft');
      e.preventDefault();
      e.stopPropagation();
      _this.setState({ updateViewed: null });
    };

    _this.dragLeftCard = function (index) {
      _this.setState({ leftCard: index });
    };

    _this.onDragOver = function (e) {
      e.preventDefault();
    };

    _this.sideDrop = function () {
      var cardlist = _this.state.cardlist;
      var cardSymbol = _this.state.updateViewed;

      _this.setState({
        cardlist: cardlist,
        updateViewed: null,
        viewedTicker: cardSymbol,
        applyOutAni: null,
        leftCard: null,
        draggedCard: null
      });
    };

    _this.dropHandle = function () {
      var _this$state3 = _this.state,
          cardlist = _this$state3.cardlist,
          updateViewed = _this$state3.updateViewed;

      var draggedSymb = cardlist[_this.state.draggedCard];
      var cardlst = cardlist.reduce(function (obb, itm, i) {
        if (itm.symb !== draggedSymb.symb) {
          obb.push(itm);
        }

        return obb;
      }, []);

      cardlst.push(draggedSymb);
      var cardSymbol = updateViewed ? draggedSymb : _this.state.viewedTicker;
      _this.setState({
        cardlist: cardlist,
        hoveredCard: null,
        updateViewed: null,
        viewedTicker: cardSymbol,
        applyOutAni: cardlst.length - 1,
        leftCard: null,
        draggedCard: null
      });
    };

    _this.dragEnter = function (e) {
      e.preventDefault();
      e.stopPropagation();
    };

    _this.cardDropped = function (index) {
      var draggedSymb = _this.state.cardlist[_this.state.draggedCard];
      var cardlist = _this.state.cardlist.reduce(function (obb, itm, i) {
        if (index === i) {
          obb.push(draggedSymb);
        }
        if (itm.symb !== draggedSymb.symb) {
          obb.push(itm);
        }

        return obb;
      }, []);

      _this.setState({ cardlist: cardlist, hoveredCard: null, applyOutAni: index, leftCard: null, draggedCard: null });
    };

    _this.dragLeave = function (e) {
      e.preventDefault();
      e.stopPropagation();
    };

    _this.state = {
      active: 0,
      cardlist: ll,
      leftCard: null,
      updateViewed: null,
      viewedTicker: ll[0],
      applyOutAni: 88,
      hoveredCard: null,
      draggedCard: null

    };
    return _this;
  }

  _createClass(LiveTickers, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.props.cardCtx.chartView.symb = ll[0].symb;
      this.props.cardCtx.chartView.priceSeed = ll[0].prc;
      this.props.cardCtx.chartView.render();
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _state = this.state,
          draggedCard = _state.draggedCard,
          applyOutAni = _state.applyOutAni;

      var tickCards = this.state.cardlist.map(function (itm, i) {
        var animation = '';
        if (applyOutAni === i || draggedCard === i) {
          animation = i === draggedCard ? 'scaleSmall  ease-out 0.4s 1 forwards' : 'growBig  ease-out 0.3s 1 forwards';
        }

        return _react2.default.createElement(_tickcard2.default, {
          key: i + '_ww',
          active: _this2.state.active === i,
          applyOut: applyOutAni === i,
          cardCtx: _this2.props.cardCtx,
          animation: animation,
          cardId: 'card_' + itm.symb,
          cardPostionClick: _this2.cardPostionClick,
          dragLeftCard: _this2.dragLeftCard,
          dragOverCard: _this2.dragOverCard,
          cardDropped: _this2.cardDropped,
          cardDragStart: _this2.cardDragStart,
          index: i,
          symbol: itm });
      });
      return _react2.default.createElement(
        'div',
        { className: 'container-fluid wrapper' },
        _react2.default.createElement(
          'section',
          { id: 'cardContain' },
          tickCards,
          _react2.default.createElement(
            'div',
            { className: 'trade-card-holder normal-class' },
            _react2.default.createElement(
              'div',
              { id: 'AddTicker', onDragOver: this.dragEnter, onDrop: this.dropHandle },
              _react2.default.createElement('i', { className: 'fa fa-plus big-fa', 'aria-hidden': 'true' })
            )
          )
        ),
        _react2.default.createElement(
          'section',
          { className: 'side-look-at', onDragEnter: this.sideEnter, onDrop: this.dropHandle, onDragLeave: this.sideLeave },
          _react2.default.createElement(_tickerview2.default, { symbol: this.state.viewedTicker })
        ),
        _react2.default.createElement('section', { id: 'bottomLookUp' })
      );
    }
  }]);

  return LiveTickers;
}(_react2.default.PureComponent);

exports.default = LiveTickers;
;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ActiveSpreads = function (_React$PureComponent) {
  _inherits(ActiveSpreads, _React$PureComponent);

  function ActiveSpreads(props) {
    _classCallCheck(this, ActiveSpreads);

    var _this = _possibleConstructorReturn(this, (ActiveSpreads.__proto__ || Object.getPrototypeOf(ActiveSpreads)).call(this, props));

    _this.CTXspread = null;
    _this.dbSource = props.dataSource;
    _this.state = {
      trackedBids: [],
      onView: false
    };

    return _this;
  }

  _createClass(ActiveSpreads, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.CTXspread = this.props.callCT();
      this.CTXspread.seedSpread();
      this.props.setSpreadRef(this.CTXspread);
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'active-spreads' },
        _react2.default.createElement(
          'ul',
          { className: 'spread-labels' },
          _react2.default.createElement(
            'li',
            { className: 'index-li' },
            'Index'
          ),
          _react2.default.createElement(
            'li',
            null,
            'Ask'
          ),
          _react2.default.createElement(
            'li',
            null,
            'Bid'
          ),
          _react2.default.createElement(
            'li',
            null,
            '%'
          )
        ),
        _react2.default.createElement('canvas', { id: 'activeSpreads', width: '200', height: '650' })
      );
    }
  }]);

  return ActiveSpreads;
}(_react2.default.PureComponent);

exports.default = ActiveSpreads;
;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PositionTile = function (_React$PureComponent) {
  _inherits(PositionTile, _React$PureComponent);

  function PositionTile() {
    _classCallCheck(this, PositionTile);

    return _possibleConstructorReturn(this, (PositionTile.__proto__ || Object.getPrototypeOf(PositionTile)).apply(this, arguments));
  }

  _createClass(PositionTile, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.props.posTileCTX.setTile(this.props.pos, this.props.pos.ctxid);
    }
  }, {
    key: 'render',
    value: function render() {
      var pos = this.props.pos;

      return _react2.default.createElement(
        'li',
        { className: pos.type === 'CALL' ? 'pos-block pos-call' : 'pos-block pos-put' },
        _react2.default.createElement(
          'div',
          { className: 'span-label-blue th-span div-symb-hold' },
          pos.symb
        ),
        _react2.default.createElement(
          'div',
          null,
          pos.qty
        ),
        _react2.default.createElement('canvas', { id: pos.ctxid, width: '100', height: '30' })
      );
    }
  }]);

  return PositionTile;
}(_react2.default.PureComponent);

exports.default = PositionTile;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _positionTiles = __webpack_require__(65);

var _positionTiles2 = _interopRequireDefault(_positionTiles);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WatchedSpreads = function (_React$PureComponent) {
  _inherits(WatchedSpreads, _React$PureComponent);

  function WatchedSpreads(props) {
    _classCallCheck(this, WatchedSpreads);

    var _this = _possibleConstructorReturn(this, (WatchedSpreads.__proto__ || Object.getPrototypeOf(WatchedSpreads)).call(this, props));

    _this.currentBlocks = function (activePosList, posCTX) {
      return activePosList.map(function (itm) {
        return _react2.default.createElement(_positionTiles2.default, { key: itm.ctxid + '_' + itm.type, posTileCTX: posCTX, pos: itm });
      });
    };

    return _this;
  }

  _createClass(WatchedSpreads, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          activePosList = _props.activePosList,
          PositionTiles = _props.PositionTiles;

      return _react2.default.createElement(
        'div',
        { className: 'active-spreads watched-spreads' },
        activePosList.length === 0 && _react2.default.createElement(
          'div',
          { className: 'no-positions' },
          'No Active Positions'
        ),
        _react2.default.createElement(
          'ul',
          { className: 'pos-blocks' },
          this.currentBlocks(activePosList, PositionTiles)
        )
      );
    }
  }]);

  return WatchedSpreads;
}(_react2.default.PureComponent);

exports.default = WatchedSpreads;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SideOptions = function (_React$PureComponent) {
  _inherits(SideOptions, _React$PureComponent);

  function SideOptions(props) {
    _classCallCheck(this, SideOptions);

    var _this = _possibleConstructorReturn(this, (SideOptions.__proto__ || Object.getPrototypeOf(SideOptions)).call(this, props));

    _this.optionView = function (type) {
      return function () {
        return _this.props.itmView(type);
      };
    };

    return _this;
  }

  _createClass(SideOptions, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          platformView = _props.platformView,
          optsComponent = _props.optsComponent,
          tdClass = _props.tdClass,
          onStart = _props.onStart;

      return _react2.default.createElement(
        'div',
        { id: 'sideOptions', className: onStart ? 'hide-elm' : '' },
        _react2.default.createElement(
          'div',
          { onClick: this.optionView('overview'), className: platformView === 'trade history' ? 'opts-button opts-active-sec' : 'opts-button' },
          _react2.default.createElement(
            'i',
            { className: 'material-icons' },
            'update'
          ),
          _react2.default.createElement(
            'p',
            null,
            'TRADING HISTORY'
          )
        ),
        _react2.default.createElement(
          'div',
          { onClick: this.optionView('charts'), className: platformView === 'live graphs' ? 'opts-button opts-active-sec' : 'opts-button' },
          _react2.default.createElement('i', { className: 'fa fa-line-chart fix-fa', 'aria-hidden': 'true' }),
          _react2.default.createElement(
            'p',
            null,
            'CHARTS'
          )
        ),
        _react2.default.createElement(
          'div',
          { onClick: this.optionView('current-bids'), className: optsComponent === 'current-bids' && tdClass ? 'opts-button opts-active' : 'opts-button' },
          _react2.default.createElement(
            'i',
            { className: 'material-icons' },
            'event_available'
          ),
          _react2.default.createElement(
            'p',
            null,
            'POSITIONS'
          )
        ),
        _react2.default.createElement(
          'div',
          { onClick: this.optionView('spreads'), className: optsComponent === 'spreads' && tdClass ? 'opts-button opts-active' : 'opts-button' },
          _react2.default.createElement(
            'i',
            { className: 'material-icons' },
            'view_list'
          ),
          _react2.default.createElement(
            'p',
            null,
            'OPTIONS'
          )
        ),
        _react2.default.createElement(
          'div',
          { onClick: this.optionView('live options'), className: platformView === 'live options' ? 'opts-button opts-active-sec' : 'opts-button' },
          _react2.default.createElement(
            'i',
            { className: 'material-icons' },
            'view_compact'
          ),
          _react2.default.createElement(
            'p',
            null,
            'OPTIONS'
          )
        ),
        _react2.default.createElement(
          'div',
          { onClick: this.optionView('past-pos'), className: platformView === 'trade list' ? 'opts-button opts-active-sec' : 'opts-button' },
          _react2.default.createElement(
            'i',
            { className: 'material-icons' },
            'watch_later'
          ),
          _react2.default.createElement(
            'p',
            null,
            'HISTORY'
          )
        )
      );
    }
  }]);

  return SideOptions;
}(_react2.default.PureComponent);

exports.default = SideOptions;
;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _infoli = __webpack_require__(57);

var _infoli2 = _interopRequireDefault(_infoli);

var _statstiles = __webpack_require__(59);

var _statstiles2 = _interopRequireDefault(_statstiles);

var _positionview = __webpack_require__(58);

var _positionview2 = _interopRequireDefault(_positionview);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TransactionList = function (_React$PureComponent) {
  _inherits(TransactionList, _React$PureComponent);

  function TransactionList(props) {
    _classCallCheck(this, TransactionList);

    var _this = _possibleConstructorReturn(this, (TransactionList.__proto__ || Object.getPrototypeOf(TransactionList)).call(this, props));

    _this.postionClick = function (pos, ind) {
      return _this.setState({ active: ind });
    };

    _this.last = props.pastTrades.length;
    _this.state = {
      active: 0,
      animate: true

    };
    return _this;
  }

  _createClass(TransactionList, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          pastTrades = _props.pastTrades,
          inView = _props.inView,
          SvgCB = _props.SvgCB,
          GraphController = _props.GraphController;

      var firstClass = this.last < pastTrades.length && inView;
      var activeIndex = this.state.active ? this.state.active : 0;
      var pastTradeList = pastTrades.map(function (itm, i) {
        return _react2.default.createElement(_infoli2.default, {
          clicked: _this2.postionClick,
          key: i,
          addStyle: i === 0 ? firstClass : false,
          active: activeIndex === i,
          index: i,
          animate: _this2.state.animate,
          pos: itm });
      });
      return _react2.default.createElement(
        "div",
        { className: "container-fluid wrapper" },
        _react2.default.createElement(_statstiles2.default, { SvgCB: SvgCB, tradeProps: this.props }),
        _react2.default.createElement(
          "div",
          { className: "head-line-list" },
          _react2.default.createElement(
            "strong",
            null,
            "Past Transactions"
          )
        ),
        _react2.default.createElement(
          "div",
          { className: "row" },
          _react2.default.createElement(
            "div",
            { className: "col-lg-7 col-md-6" },
            _react2.default.createElement(_positionview2.default, { inView: inView, GraphController: GraphController, pos: pastTrades[activeIndex] })
          ),
          _react2.default.createElement(
            "div",
            { className: "trade-ul-list col-lg-5 col-md-6" },
            _react2.default.createElement(
              "ul",
              { id: "pastTrades" },
              pastTradeList
            )
          )
        )
      );
    }
  }]);

  return TransactionList;
}(_react2.default.PureComponent);

exports.default = TransactionList;
;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(8);

var _fullwidget = __webpack_require__(71);

var _fullwidget2 = _interopRequireDefault(_fullwidget);

var _datasource = __webpack_require__(13);

var _datasource2 = _interopRequireDefault(_datasource);

var _widgets = __webpack_require__(20);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function select(store) {
   // How Diffrent Redux stores get mapped to props
   return { widgets: store.widgets };
}

var WidgetBlock = function (_React$PureComponent) {
   _inherits(WidgetBlock, _React$PureComponent);

   function WidgetBlock(props) {
      _classCallCheck(this, WidgetBlock);

      var _this = _possibleConstructorReturn(this, (WidgetBlock.__proto__ || Object.getPrototypeOf(WidgetBlock)).call(this, props));

      _this.updateWidget = function (dta) {};

      _this.getMessage = function (mess, wid) {
         var newWait = {};
         newWait[mess] = wid;
         _this.props.dispatch({ type: _widgets.GOT_MESSAGE, payload: newWait });
         _this.dbSource.getMarketDataXHR(mess, _this.gotData);
      };

      _this.dropHandle = function (widgetNum) {
         return function () {
            var draggedWidget = _this.props.widgets.draggedWidget;

            var stateCopy = Object.assign({}, _this.props.widgets, {
               draggedWidget: null,
               WidgetList: Object.assign({}, _this.props.widgets.WidgetList)
            });
            stateCopy.WidgetList[draggedWidget] = _this.props.widgets[draggedWidget].data;
            stateCopy.WidgetList[widgetNum] = _this.props.widgets[widgetNum].data;

            stateCopy[draggedWidget] = _this.props.widgets[widgetNum];
            stateCopy[widgetNum] = _this.props.widgets[draggedWidget];

            _this.props.dispatch({ type: _widgets.WIDGET_DROP, payload: stateCopy });
         };
      };

      _this.handleDragEv = function (widget, data) {

         _this.props.dispatch({ type: _widgets.WIDGET_DRAGGED, payload: widget });
      };

      _this.gotData = function (details) {
         var _Object$assign = Object.assign({}, _this.props.widgets),
             WidgetList = _Object$assign.WidgetList,
             needsUpdate = _Object$assign.needsUpdate;

         console.log('needsUpdate', needsUpdate);
         var needsUpdateKey = details.results[0].symbol;
         var widgetNum = needsUpdate[needsUpdateKey];

         WidgetList[widgetNum].content.data = details.results;

         var stateUpdates = {
            WidgetList: WidgetList,
            needsUpdate: Object.keys(needsUpdate).reduce(function (obb, itm) {
               if (itm !== needsUpdateKey) {
                  obb[itm] = needsUpdate[itm];
               }
               return obb;
            }, {})
         };

         _this.props.dispatch({ type: _widgets.GOT_DATA, payload: stateUpdates });
      };

      _this.dbSource = _datasource2.default;
      return _this;
   }

   _createClass(WidgetBlock, [{
      key: 'onDragOver',
      value: function onDragOver(e) {
         e.preventDefault();
      }
   }, {
      key: 'dragEnter',
      value: function dragEnter(e) {
         e.preventDefault();
         e.stopPropagation();
      }
   }, {
      key: 'dragLeave',
      value: function dragLeave(e) {
         e.preventDefault();
         e.stopPropagation();
      }
   }, {
      key: 'render',
      value: function render() {
         var _props$widgets = this.props.widgets,
             rowTopStyle = _props$widgets.rowTopStyle,
             rowBtmStyle = _props$widgets.rowBtmStyle,
             widget1 = _props$widgets.widget1,
             widget2 = _props$widgets.widget2,
             widget3 = _props$widgets.widget3,
             widget4 = _props$widgets.widget4;

         return _react2.default.createElement(
            'div',
            { className: 'container-fluid wrapper' },
            _react2.default.createElement(
               'div',
               { className: 'row', style: rowTopStyle },
               _react2.default.createElement(
                  'div',
                  { className: widget1.shown ? widget1.clType : 'hide-elm', 'data-w': 'widget1', onDrop: this.dropHandle('widget1'), onDragOver: this.dragEnter },
                  _react2.default.createElement(_fullwidget2.default, { inView: this.props.inView, ms: this.getMessage, whenDrag: this.handleDragEv, data: widget1.data, wd: 'widget1', candrag: true })
               ),
               _react2.default.createElement(
                  'div',
                  { className: widget2.shown ? widget2.clType : 'hide-elm', 'data-w': 'widget2', onDrop: this.dropHandle('widget2'), onDragOver: this.dragEnter },
                  _react2.default.createElement(_fullwidget2.default, { inView: this.props.inView, ms: this.getMessage, whenDrag: this.handleDragEv, data: widget2.data, wd: 'widget2', candrag: true })
               )
            ),
            _react2.default.createElement(
               'div',
               { className: 'row', style: rowBtmStyle },
               _react2.default.createElement(
                  'div',
                  { className: widget3.shown ? widget3.clType : 'hide-elm', 'data-w': 'widget3', onDrop: this.dropHandle('widget3'), onDragOver: this.dragEnter },
                  _react2.default.createElement(_fullwidget2.default, { inView: this.props.inView, ms: this.getMessage, whenDrag: this.handleDragEv, data: widget3.data, wd: 'widget3', candrag: true })
               ),
               _react2.default.createElement(
                  'div',
                  { className: widget4.shown ? widget4.clType : 'hide-elm', 'data-w': 'widget4', onDrop: this.dropHandle('widget4'), onDragOver: this.dragEnter },
                  _react2.default.createElement(_fullwidget2.default, { inView: this.props.inView, ms: this.getMessage, whenDrag: this.handleDragEv, data: widget4.data, wd: 'widget4', candrag: true })
               )
            )
         );
      }
   }]);

   return WidgetBlock;
}(_react2.default.PureComponent);

;

exports.default = (0, _reactRedux.connect)(select)(WidgetBlock);

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _graphconfigs = __webpack_require__(97);

var _graphconfigs2 = _interopRequireDefault(_graphconfigs);

var _data_transform = __webpack_require__(96);

var _data_transform2 = _interopRequireDefault(_data_transform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ReactHighstock = __webpack_require__(151);

var ChartWidget = function (_React$PureComponent) {
  _inherits(ChartWidget, _React$PureComponent);

  function ChartWidget(props) {
    _classCallCheck(this, ChartWidget);

    var _this = _possibleConstructorReturn(this, (ChartWidget.__proto__ || Object.getPrototypeOf(ChartWidget)).call(this, props));

    _this.nullData = function () {
      return _react2.default.createElement(
        'div',
        { className: 'load-box' },
        _react2.default.createElement('div', { className: 'loading-pulse' })
      );
    };

    _this.dataGen = null;
    return _this;
  }

  _createClass(ChartWidget, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (this.props.data.content.data === null) {
        this.props.cb(this.props.data.symb);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      if (this.props.data.content.data === null) {
        return this.nullData();
      }
      var graphType = this.props.data.content.graphType;
      var dataTransform = _data_transform2.default[graphType]();
      var contentData = this.props.data.content.data.map(function (data) {
        return dataTransform(data);
      });
      var config = _graphconfigs2.default[graphType](this.props.data.content.data[0].symbol, contentData);

      return _react2.default.createElement(
        'div',
        { className: 'chart-blocked' },
        _react2.default.createElement(ReactHighstock, { config: config }),
        _react2.default.createElement('div', { className: 'widget-handle' })
      );
    }
  }]);

  return ChartWidget;
}(_react2.default.PureComponent);

exports.default = ChartWidget;
;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _table = __webpack_require__(74);

var _table2 = _interopRequireDefault(_table);

var _progressbars = __webpack_require__(73);

var _progressbars2 = _interopRequireDefault(_progressbars);

var _minigraph = __webpack_require__(72);

var _minigraph2 = _interopRequireDefault(_minigraph);

var _chartwidget = __webpack_require__(70);

var _chartwidget2 = _interopRequireDefault(_chartwidget);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FullWidget = function (_React$PureComponent) {
  _inherits(FullWidget, _React$PureComponent);

  function FullWidget(props) {
    _classCallCheck(this, FullWidget);

    var _this = _possibleConstructorReturn(this, (FullWidget.__proto__ || Object.getPrototypeOf(FullWidget)).call(this, props));

    _this.handleDrag = function () {
      _this.props.whenDrag(_this.props.wd, _this.props.data);
    };

    _this.passMessage = function (mess) {
      _this.props.ms(mess, _this.props.wd);
    };

    _this.graph = function (data) {
      return _react2.default.createElement(_minigraph2.default, { ctxId: data.content.chartid, data: data.content.data });
    };

    _this.table = function (data) {
      return _react2.default.createElement(_table2.default, { data: data });
    };

    _this.graphjs = function (data) {
      return _react2.default.createElement(_chartwidget2.default, { inView: _this.props.inView, cb: _this.passMessage, data: data });
    };

    _this.progress = function (data) {
      return _react2.default.createElement(_progressbars2.default, { data: data });
    };

    return _this;
  }

  _createClass(FullWidget, [{
    key: "render",
    value: function render() {
      var _props = this.props,
          data = _props.data,
          inView = _props.inView,
          candrag = _props.candrag;
      var title = data.title,
          kind = data.kind;

      var widgets = this[kind] !== undefined ? this[kind](data) : null;

      return _react2.default.createElement(
        "div",
        { className: "full-widget can-drag", onDragStart: this.handleDrag, draggable: "true" },
        _react2.default.createElement(
          "div",
          { className: kind !== "graphjs" ? "widget-title" : "hide-elm" },
          _react2.default.createElement(
            "h2",
            { className: kind !== "graphjs" ? "" : "hide-elm" },
            title
          )
        ),
        widgets
      );
    }
  }]);

  return FullWidget;
}(_react2.default.PureComponent);

exports.default = FullWidget;
;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _ctxgraphs = __webpack_require__(51);

var _ctxgraphs2 = _interopRequireDefault(_ctxgraphs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MiniGraph = function (_React$PureComponent) {
  _inherits(MiniGraph, _React$PureComponent);

  function MiniGraph() {
    _classCallCheck(this, MiniGraph);

    return _possibleConstructorReturn(this, (MiniGraph.__proto__ || Object.getPrototypeOf(MiniGraph)).apply(this, arguments));
  }

  _createClass(MiniGraph, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var chart = (0, _ctxgraphs2.default)(this.props.ctxId, this.props.data, this.props.data.title);
      chart.renderChart();
    }
  }, {
    key: "render",
    value: function render() {
      return _react2.default.createElement("div", { id: this.props.ctxId, className: "holds-graph donut-graph" });
    }
  }]);

  return MiniGraph;
}(_react2.default.PureComponent);

exports.default = MiniGraph;
;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ProgressBars = function (_React$PureComponent) {
  _inherits(ProgressBars, _React$PureComponent);

  function ProgressBars() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, ProgressBars);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ProgressBars.__proto__ || Object.getPrototypeOf(ProgressBars)).call.apply(_ref, [this].concat(args))), _this), _this.width66 = { width: '66%' }, _this.width45 = { width: '45%' }, _this.width25 = { width: '25%' }, _this.width3 = { width: '3%' }, _this.width1 = { width: '1%' }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(ProgressBars, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'x_content' },
        _react2.default.createElement(
          'div',
          { className: 'widget_summary' },
          _react2.default.createElement(
            'div',
            { className: 'w_left w_25' },
            _react2.default.createElement(
              'span',
              null,
              '0.1.5.2'
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'w_center w_55' },
            _react2.default.createElement(
              'div',
              { className: 'progress' },
              _react2.default.createElement('div', {
                className: 'progress-bar bg-green',
                role: 'progressbar',
                'aria-valuenow': '60',
                'aria-valuemin': '0',
                'aria-valuemax': '100',
                style: this.width66 })
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'w_right w_20' },
            _react2.default.createElement(
              'span',
              null,
              '123k'
            )
          ),
          _react2.default.createElement('div', { className: 'clearfix' })
        ),
        _react2.default.createElement(
          'div',
          { className: 'widget_summary' },
          _react2.default.createElement(
            'div',
            { className: 'w_left w_25' },
            _react2.default.createElement(
              'span',
              null,
              '0.1.5.3'
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'w_center w_55' },
            _react2.default.createElement(
              'div',
              { className: 'progress' },
              _react2.default.createElement('div', {
                className: 'progress-bar bg-green',
                role: 'progressbar',
                'aria-valuenow': '60',
                'aria-valuemin': '0',
                'aria-valuemax': '100',
                style: this.width45 })
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'w_right w_20' },
            _react2.default.createElement(
              'span',
              null,
              '53k'
            )
          ),
          _react2.default.createElement('div', { className: 'clearfix' })
        ),
        _react2.default.createElement(
          'div',
          { className: 'widget_summary' },
          _react2.default.createElement(
            'div',
            { className: 'w_left w_25' },
            _react2.default.createElement(
              'span',
              null,
              '0.1.5.4'
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'w_center w_55' },
            _react2.default.createElement(
              'div',
              { className: 'progress' },
              _react2.default.createElement(
                'div',
                {
                  className: 'progress-bar bg-green',
                  role: 'progressbar',
                  'aria-valuenow': '60',
                  'aria-valuemin': '0',
                  'aria-valuemax': '100',
                  style: this.width25 },
                _react2.default.createElement(
                  'span',
                  { className: 'sr-only' },
                  '60% Complete'
                )
              )
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'w_right w_20' },
            _react2.default.createElement(
              'span',
              null,
              '23k'
            )
          ),
          _react2.default.createElement('div', { className: 'clearfix' })
        ),
        _react2.default.createElement(
          'div',
          { className: 'widget_summary' },
          _react2.default.createElement(
            'div',
            { className: 'w_left w_25' },
            _react2.default.createElement(
              'span',
              null,
              '0.1.5.5'
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'w_center w_55' },
            _react2.default.createElement(
              'div',
              { className: 'progress' },
              _react2.default.createElement('div', {
                className: 'progress-bar bg-green',
                role: 'progressbar',
                'aria-valuenow': '60',
                'aria-valuemin': '0',
                'aria-valuemax': '100',
                style: this.width3 })
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'w_right w_20' },
            _react2.default.createElement(
              'span',
              null,
              '3k'
            )
          ),
          _react2.default.createElement('div', { className: 'clearfix' })
        ),
        _react2.default.createElement(
          'div',
          { className: 'widget_summary' },
          _react2.default.createElement(
            'div',
            { className: 'w_left w_25' },
            _react2.default.createElement(
              'span',
              null,
              '0.1.5.6'
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'w_center w_55' },
            _react2.default.createElement(
              'div',
              { className: 'progress' },
              _react2.default.createElement('div', { className: 'progress-bar bg-green',
                role: 'progressbar',
                'aria-valuenow': '60',
                'aria-valuemin': '0',
                'aria-valuemax': '100',
                style: this.width1 })
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'w_right w_20' },
            _react2.default.createElement(
              'span',
              null,
              '1k'
            )
          )
        )
      );
    }
  }]);

  return ProgressBars;
}(_react2.default.PureComponent);

exports.default = ProgressBars;
;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Table = function (_React$PureComponent) {
  _inherits(Table, _React$PureComponent);

  function Table() {
    _classCallCheck(this, Table);

    return _possibleConstructorReturn(this, (Table.__proto__ || Object.getPrototypeOf(Table)).apply(this, arguments));
  }

  _createClass(Table, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'table',
        { className: 'table table-striped  table-md table-inverse' },
        _react2.default.createElement(
          'thead',
          null,
          _react2.default.createElement(
            'tr',
            null,
            _react2.default.createElement(
              'th',
              null,
              _react2.default.createElement('i', { className: 'fa fa-codepen', 'aria-hidden': 'true' })
            ),
            _react2.default.createElement(
              'th',
              null,
              'Column heading'
            ),
            _react2.default.createElement(
              'th',
              null,
              'Column heading'
            )
          )
        ),
        _react2.default.createElement(
          'tbody',
          null,
          _react2.default.createElement(
            'tr',
            { className: 'active' },
            _react2.default.createElement(
              'th',
              { className: 'row-scope' },
              '1'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            )
          ),
          _react2.default.createElement(
            'tr',
            null,
            _react2.default.createElement(
              'th',
              { className: 'row-scope' },
              '2'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            )
          ),
          _react2.default.createElement(
            'tr',
            { className: 'success' },
            _react2.default.createElement(
              'th',
              { className: 'row-scope' },
              '3'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            )
          ),
          _react2.default.createElement(
            'tr',
            null,
            _react2.default.createElement(
              'th',
              { className: 'row-scope' },
              '4'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            )
          ),
          _react2.default.createElement(
            'tr',
            { className: 'warning' },
            _react2.default.createElement(
              'th',
              { className: 'row-scope' },
              '5'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            )
          ),
          _react2.default.createElement(
            'tr',
            null,
            _react2.default.createElement(
              'th',
              { className: 'row-scope' },
              '6'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            )
          ),
          _react2.default.createElement(
            'tr',
            { className: 'danger' },
            _react2.default.createElement(
              'th',
              { className: 'row-scope' },
              '7'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            ),
            _react2.default.createElement(
              'td',
              null,
              'Column content'
            )
          )
        )
      );
    }
  }]);

  return Table;
}(_react2.default.PureComponent);

exports.default = Table;
;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LoadBars = function (_React$PureComponent) {
  _inherits(LoadBars, _React$PureComponent);

  function LoadBars() {
    _classCallCheck(this, LoadBars);

    return _possibleConstructorReturn(this, (LoadBars.__proto__ || Object.getPrototypeOf(LoadBars)).apply(this, arguments));
  }

  _createClass(LoadBars, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'spinner' },
        _react2.default.createElement('div', { className: 'rect1' }),
        _react2.default.createElement('div', { className: 'rect2' }),
        _react2.default.createElement('div', { className: 'rect3' }),
        _react2.default.createElement('div', { className: 'rect4' }),
        _react2.default.createElement('div', { className: 'rect5' })
      );
    }
  }]);

  return LoadBars;
}(_react2.default.PureComponent);

exports.default = LoadBars;
;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LoadConnect = function (_React$PureComponent) {
  _inherits(LoadConnect, _React$PureComponent);

  function LoadConnect() {
    _classCallCheck(this, LoadConnect);

    return _possibleConstructorReturn(this, (LoadConnect.__proto__ || Object.getPrototypeOf(LoadConnect)).apply(this, arguments));
  }

  _createClass(LoadConnect, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'connecting' },
        _react2.default.createElement(
          'div',
          { className: 'spinner-bn' },
          _react2.default.createElement('div', { className: 'bounce1' }),
          _react2.default.createElement('div', { className: 'bounce2' }),
          _react2.default.createElement('div', { className: 'bounce3' })
        ),
        _react2.default.createElement(
          'h2',
          null,
          'Connecting to WebSocket. . .'
        )
      );
    }
  }]);

  return LoadConnect;
}(_react2.default.PureComponent);

exports.default = LoadConnect;
;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _forex_symbol_pairs = __webpack_require__(89);

var _forex_symbol_pairs2 = _interopRequireDefault(_forex_symbol_pairs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ForexList = function (_React$PureComponent) {
  _inherits(ForexList, _React$PureComponent);

  function ForexList(props) {
    _classCallCheck(this, ForexList);

    var _this = _possibleConstructorReturn(this, (ForexList.__proto__ || Object.getPrototypeOf(ForexList)).call(this, props));

    _this.exchangeChange = function (e) {
      return _this.setState({ exchange: e.target.value });
    };

    _this.handleStart = function () {
      _this.props.startChart(_this.feedSymbol.value, "forex");
    };

    _this.state = {
      exchange: 'NASDAQ'
    };
    return _this;
  }

  _createClass(ForexList, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var used = this.props.used.length === 0 ? ["NOPE", "WHAT"] : this.props.used;
      var inUse = new RegExp("(" + used.join("|") + ")");
      var list = _forex_symbol_pairs2.default.map(function (itm) {
        if (inUse.test(itm)) {
          return null;
        } else {
          return _react2.default.createElement(
            'option',
            { key: itm, value: itm },
            itm
          );
        }
      });
      return _react2.default.createElement(
        'div',
        { className: 'column-two text-center' },
        _react2.default.createElement(
          'div',
          { className: 'sel-ind' },
          _react2.default.createElement(
            'strong',
            null,
            'Currency Pairs'
          ),
          _react2.default.createElement(
            'select',
            { 'data-type': 'forex', ref: function ref(select) {
                return _this2.feedSymbol = select;
              }, className: 'symbol-pick live-sym' },
            list
          )
        ),
        _react2.default.createElement(
          'div',
          { className: 'add-chart-butt-div text-center' },
          _react2.default.createElement(
            'div',
            { onClick: this.handleStart, className: 'cool-button add-chart-bt' },
            'Track'
          )
        )
      );
    }
  }]);

  return ForexList;
}(_react2.default.PureComponent);

exports.default = ForexList;
;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _gosymbols = __webpack_require__(90);

var _gosymbols2 = _interopRequireDefault(_gosymbols);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var StockList = function (_React$PureComponent) {
  _inherits(StockList, _React$PureComponent);

  function StockList(props) {
    _classCallCheck(this, StockList);

    var _this = _possibleConstructorReturn(this, (StockList.__proto__ || Object.getPrototypeOf(StockList)).call(this, props));

    _this.exchangeChange = function (e) {
      return _this.setState({ exchange: e.target.value });
    };

    _this.handleStart = function () {
      _this.props.startChart(_this.feedSymbol.value, "stocks");
    };

    _this.state = {
      exchange: 'NASDAQ'
    };
    return _this;
  }

  _createClass(StockList, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var used = this.props.used.length === 0 ? ["NOPE", "WHAT"] : this.props.used;
      var inUse = new RegExp("(" + used.join("|") + ")");
      var exchangeOpts = (0, _gosymbols2.default)(inUse);
      return _react2.default.createElement(
        'div',
        { className: 'column-two' },
        _react2.default.createElement(
          'div',
          { className: 'sel-ind' },
          _react2.default.createElement(
            'strong',
            null,
            'Exchange'
          ),
          _react2.default.createElement(
            'select',
            { ref: function ref(select) {
                return _this2.changeExchange = select;
              }, className: 'symbol-pick live-sym', defaultValue: this.state.exchange, onChange: this.exchangeChange },
            _react2.default.createElement(
              'option',
              { key: 'NASDAQ-2', value: 'NASDAQ' },
              'NASDAQ'
            ),
            _react2.default.createElement(
              'option',
              { key: 'NYSE-2', value: 'NYSE' },
              'NYSE'
            )
          )
        ),
        _react2.default.createElement(
          'div',
          { className: 'sel-ind' },
          _react2.default.createElement(
            'strong',
            null,
            'Symbol'
          ),
          _react2.default.createElement(
            'select',
            { ref: function ref(select) {
                return _this2.feedSymbol = select;
              }, className: 'symbol-pick live-sym' },
            exchangeOpts[this.state.exchange]
          )
        ),
        _react2.default.createElement(
          'div',
          { className: 'add-chart-butt-div text-center' },
          _react2.default.createElement(
            'div',
            { onClick: this.handleStart, className: 'cool-button add-chart-bt' },
            'Something'
          )
        )
      );
    }
  }]);

  return StockList;
}(_react2.default.PureComponent);

exports.default = StockList;
;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _stocks = __webpack_require__(93);

var _stocks2 = _interopRequireDefault(_stocks);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LiveStart = function (_React$PureComponent) {
  _inherits(LiveStart, _React$PureComponent);

  function LiveStart(props) {
    _classCallCheck(this, LiveStart);

    var _this = _possibleConstructorReturn(this, (LiveStart.__proto__ || Object.getPrototypeOf(LiveStart)).call(this, props));

    _this.exchangeChange = function (e) {
      return _this.setState({ exchange: e.target.value });
    };

    _this.handleStart = function () {
      return _this.props.startChart(_this.feedSymbol.value);
    };

    _this.state = {
      exchange: 'NASDAQ'
    };
    return _this;
  }

  _createClass(LiveStart, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      return _react2.default.createElement(
        'div',
        { className: 'container' },
        _react2.default.createElement(
          'div',
          { className: 'chart-controller chart-live-cntrl live-set' },
          _react2.default.createElement(
            'div',
            { className: 'select-holders spread-m' },
            _react2.default.createElement(
              'strong',
              null,
              'Symbols:'
            ),
            _react2.default.createElement(
              'select',
              { ref: function ref(select) {
                  return _this2.feedSymbol = select;
                }, className: 'symbol-pick live-sym' },
              _stocks2.default[this.state.exchange]
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'select-holders spread-m' },
            _react2.default.createElement(
              'strong',
              null,
              'Exchange:'
            ),
            _react2.default.createElement(
              'select',
              { ref: function ref(select) {
                  return _this2.changeExchange = select;
                }, className: 'symbol-pick live-sym', value: this.state.exchange, onChange: this.exchangeChange },
              _react2.default.createElement(
                'option',
                { key: 'NASDAQ-2', value: 'NASDAQ' },
                'NASDAQ'
              ),
              _react2.default.createElement(
                'option',
                { key: 'NYSE-2', value: 'NYSE' },
                'NYSE'
              )
            )
          )
        ),
        _react2.default.createElement(
          'div',
          { className: 'row text-center' },
          _react2.default.createElement(
            'div',
            { onClick: this.handleStart, className: 'big-butt cool-button' },
            'Start LiveFeed!'
          )
        )
      );
    }
  }]);

  return LiveStart;
}(_react2.default.PureComponent);

exports.default = LiveStart;
;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TickCard = function (_React$PureComponent) {
	_inherits(TickCard, _React$PureComponent);

	function TickCard(props) {
		_classCallCheck(this, TickCard);

		var _this = _possibleConstructorReturn(this, (TickCard.__proto__ || Object.getPrototypeOf(TickCard)).call(this, props));

		_this.dragStart = function () {
			return _this.props.cardDragStart(_this.props.index);
		};

		_this.onDragOver = function (e) {
			return e.preventDefault();
		};

		_this.mouseUp = function () {
			return _this.props.cardPostionClick(_this.props.index);
		};

		_this.dragEnter = function (e) {
			e.preventDefault();
			e.stopPropagation();
			_this.props.dragOverCard(_this.props.index);
		};

		_this.dragLeave = function (e) {
			e.preventDefault();
			e.stopPropagation();
			_this.props.dragLeftCard(_this.props.index);
		};

		_this.dropHandle = function (e) {
			e.preventDefault();
			_this.props.cardDropped(_this.props.index);
		};

		_this.cardCTX = null;
		return _this;
	}

	_createClass(TickCard, [{
		key: "componentDidMount",
		value: function componentDidMount() {
			var price = this.props.symbol.prc < 10 ? Math.round(this.props.symbol.prc * 100) : Math.round(this.props.symbol.prc);
			this.cardCTX = this.props.cardCtx.setCard(this.props.cardId, price, this.props.symbol.symb);
			this.cardCTX.startLoop();
		}
	}, {
		key: "render",
		value: function render() {
			var _props = this.props,
			    applyOut = _props.applyOut,
			    active = _props.active;

			return _react2.default.createElement(
				"div",
				{
					className: applyOut ? "trade-card-holder  apply-out" : "trade-card-holder normal-class",
					onDragOver: this.dragEnter,
					onMouseUp: this.mouseUp,
					style: { animation: this.props.animation },
					onDrop: this.dropHandle },
				_react2.default.createElement(
					"div",
					{ className: active ? "trade-card card-active" : "trade-card",
						draggable: "true",
						onDragStart: this.dragStart },
					_react2.default.createElement(
						"p",
						{ className: "span-label-blue symb-label" },
						this.props.symbol.symb
					),
					_react2.default.createElement("canvas", { id: this.props.cardId, className: "canvasTick", width: 210, height: 60 })
				)
			);
		}
	}]);

	return TickCard;
}(_react2.default.PureComponent);

exports.default = TickCard;
;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TickerView = function (_React$PureComponent) {
  _inherits(TickerView, _React$PureComponent);

  function TickerView() {
    _classCallCheck(this, TickerView);

    return _possibleConstructorReturn(this, (TickerView.__proto__ || Object.getPrototypeOf(TickerView)).apply(this, arguments));
  }

  _createClass(TickerView, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'ticker-side-content' },
        _react2.default.createElement(
          'h2',
          { className: 't-side-h2' },
          this.props.symbol.symb
        ),
        _react2.default.createElement('div', { id: 'tickChart' }),
        _react2.default.createElement('canvas', { id: 'askBidRatio', width: 190, height: 50 })
      );
    }
  }]);

  return TickerView;
}(_react2.default.PureComponent);

exports.default = TickerView;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var timeUnit = function timeUnit(d, index, setIndex, timeSet) {
   var time = d.getHours() + ':' + ('0' + (d.getMinutes() + index)).slice(-2);
   var displayClass = index === setIndex ? 'active-t' : '';
   return _react2.default.createElement(
      'li',
      { key: 'tm_' + index, onClick: timeSet(index), className: displayClass },
      _react2.default.createElement(
         'span',
         null,
         time
      ),
      _react2.default.createElement(
         'span',
         { className: 'ft-rt' },
         index + ' min'
      )
   );
};

var TimeIntervals = function (_React$PureComponent) {
   _inherits(TimeIntervals, _React$PureComponent);

   function TimeIntervals() {
      _classCallCheck(this, TimeIntervals);

      return _possibleConstructorReturn(this, (TimeIntervals.__proto__ || Object.getPrototypeOf(TimeIntervals)).apply(this, arguments));
   }

   _createClass(TimeIntervals, [{
      key: 'render',
      value: function render() {
         var _props = this.props,
             timeSet = _props.timeSet,
             ind = _props.ind,
             date = _props.date;

         var timeList = [];
         for (var i = 1; i < 11; i++) {
            timeList.push(timeUnit(date, i, ind, timeSet));
         }
         return _react2.default.createElement(
            'ul',
            { className: 'time-pick' },
            timeList
         );
      }
   }]);

   return TimeIntervals;
}(_react2.default.PureComponent);

exports.default = TimeIntervals;
;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _mathfuncs = __webpack_require__(25);

var _mathfuncs2 = _interopRequireDefault(_mathfuncs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var calcX = function calcX(number) {
   return 11 + -11 * _mathfuncs2.default.getDigitLen(number);
};
var animateStat = function animateStat() {};

var Stat = function (_React$PureComponent) {
   _inherits(Stat, _React$PureComponent);

   function Stat(props) {
      _classCallCheck(this, Stat);

      var _this = _possibleConstructorReturn(this, (Stat.__proto__ || Object.getPrototypeOf(Stat)).call(this, props));

      _this.svg = null;

      return _this;
   }

   _createClass(Stat, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
         var _props = this.props,
             svgId = _props.svgId,
             SvgCB = _props.SvgCB,
             config = _props.config;

         var theSVG = document.getElementById(svgId).querySelector('text');
         this.svg = theSVG;
         SvgCB.setRef(svgId, Object.assign({}, config, { domElem: theSVG }));
      }
   }, {
      key: 'componentWillMount',
      value: function componentWillMount() {}
   }, {
      key: 'render',
      value: function render() {
         var _props2 = this.props,
             classType = _props2.classType,
             number = _props2.number,
             svgId = _props2.svgId,
             fillColor = _props2.fillColor;

         return _react2.default.createElement(
            'div',
            { className: 'count count-47' },
            _react2.default.createElement(
               'svg',
               { id: svgId, className: 'svg-container', height: '40', width: '22' },
               _react2.default.createElement('text', { className: classType, x: '11', y: '35', fill: fillColor })
            )
         );
      }
   }]);

   return Stat;
}(_react2.default.PureComponent);

exports.default = Stat;
;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _mathfuncs = __webpack_require__(25);

var _mathfuncs2 = _interopRequireDefault(_mathfuncs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var statSVGs = function statSVGs() {
   var calcX = function calcX(number) {
      var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 11;

      return buffer + -11 * _mathfuncs2.default.getDigitLen(number);
   };

   function SvgCallBacks() {};

   var SvgCB = new SvgCallBacks();
   SvgCB.inViewBool = false;
   SvgCB.shouldAnimate = true;
   SvgCB.svg1 = null;
   SvgCB.svg2 = null;
   SvgCB.svg3 = null;
   SvgCB.svg4 = null;
   SvgCB.svg5 = null;

   SvgCB.svgRepeat = function (svgElm, itm, ii, unit, fillChng) {
      var tO = ii * unit;
      setTimeout(function () {
         window.requestAnimationFrame(function () {
            svgElm.setAttribute('x', itm.xVal);
            if (fillChng) {
               svgElm.setAttribute('fill', itm.fill);
            }
            svgElm.textContent = itm.text;
         });
      }, tO);
   };
   SvgCB.setRef = function (svgId, config) {
      SvgCB[svgId] = config;
      if (config.current === config.lastValue) {
         var numString = config.type === "float" ? _mathfuncs2.default.niceFloats(config.current) : config.current;
         var xx = config.type === "float" ? -11 * (numString.length - 1) : config.current === 0 ? 0 : calcX(config.current);
         var fillColor = config.current === 0 ? "#73879C" : config.current > 0 ? "#30d94c" : "#DC143C";
         config.domElem.setAttribute('x', xx);
         config.domElem.setAttribute('fill', fillColor);
         config.domElem.textContent = numString;
      }
      //console.log('setRef', {config: config, svgId: svgId}, SvgCB);
   };

   SvgCB.svgAnimate = function (ogValue, newValue, svgOb) {

      //let SvG = svgOb.domElem;
      var buffer = svgOb.buffer;
      var plusValue = svgOb.plusValue;
      var values = [];
      var inc = svgOb.type === "float" ? 100 : 1;
      var ogCPY = Math.round(ogValue * inc);
      var newVl = Math.round(newValue * inc);
      var diff = Math.abs(ogCPY - newVl);
      var unit = diff > 1000 ? 16 : Math.ceil(1 / diff * 500);
      var sub = diff > 1000 ? Math.ceil(diff / 60) : diff / inc > 10 ? inc : 1;
      if (ogValue > newValue) {
         while (ogCPY > newVl) {
            ogCPY -= sub;
            var numString = svgOb.type === "float" ? _mathfuncs2.default.niceFloats(ogCPY / inc) : ogCPY;
            var xx = svgOb.type === "float" ? -11 * (numString.length - 1) : calcX(ogCPY, 11);
            // let measureNum = svgOb.type === "float" ?  Math.round(ogCPY * 100) : ogCpy;
            //let txtNum = svgOb.type === "float" ? (measureNum/100) : ogCpy;
            values.push({
               text: numString,
               fill: ogCPY === 0 ? "#73879C" : ogCPY > 0 ? "#30d94c" : "#DC143C",
               xVal: xx
            });
         }
      } else {
         while (ogCPY < newVl) {
            ogCPY += sub;
            var _numString = svgOb.type === "float" ? _mathfuncs2.default.niceFloats(ogCPY / inc) : ogCPY;
            var _xx = svgOb.type === "float" ? -11 * (_numString.length - 1) : calcX(ogCPY, -1);
            //let measureNum = svgOb.type === "float" ?  Math.round(ogCPY * 100) : ogCpy;
            //let txtNum = svgOb.type === "float" ? (measureNum/100) : ogCpy;
            values.push({
               text: _numString,
               fill: ogCPY === 0 ? "#73879C" : ogCPY > 0 ? "#30d94c" : "#DC143C",
               xVal: _xx
            });
         }
      }
      // console.log('values', values);
      values.forEach(function (itm, i) {
         SvgCB.svgRepeat(svgOb.domElem, itm, i, unit, svgOb.fillChange);
      });
   };
   SvgCB.inView = function () {
      console.log('SvgCB', SvgCB);
      SvgCB.inViewBool = true;

      setTimeout(function () {
         ['svg1', 'svg2', 'svg3', 'svg4', 'svg5'].forEach(function (itm) {
            if (!SvgCB[itm]) return false;

            var cuSVG = SvgCB[itm];
            if (cuSVG.animate) {
               SvgCB.svgAnimate(cuSVG.lastValue, cuSVG.current, cuSVG);
               cuSVG.animate = false;
            }
         });
      }, 150);
   };

   SvgCB.upDate = function (pastTrades, totalRev) {
      if (!SvgCB.svg1) return '';

      //let s1 = Object.assign({}, SvgCB.svg1);
      SvgCB.svg1.lastValue = SvgCB.svg1.current;
      SvgCB.svg1.animate = true;
      SvgCB.svg1.current += 1;
      //let s2 =  Object.assign({}, SvgCB.svg2);
      SvgCB.svg2.lastValue = SvgCB.svg2.current;
      SvgCB.svg2.animate = true;
      SvgCB.svg2.current = totalRev;
      //  let s3 = Object.assign({}, SvgCB.svg3);
      SvgCB.svg3.lastValue = SvgCB.svg3.current;
      SvgCB.svg3.animate = true;
      SvgCB.svg3.current = SvgCB.svg3.current + (SvgCB.svg2.current - SvgCB.svg2.lastValue);
      //  let s4 =  Object.assign({}, SvgCB.svg4);
      SvgCB.svg4.lastValue = SvgCB.svg4.current;
      SvgCB.svg4.animate = true;
      SvgCB.svg4.current += Math.round(pastTrades[0].profit * 100) / 100;
      //   let s5 =  Object.assign({}, SvgCB.svg5);
      SvgCB.svg5.lastValue = SvgCB.svg5.current;
      SvgCB.svg5.animate = true;
      SvgCB.svg5.current += pastTrades[0].volume;
      if (SvgCB.inViewBool) {
         ['svg1', 'svg2', 'svg3', 'svg4', 'svg5'].forEach(function (itm) {
            if (!SvgCB[itm]) return false;

            var cuSVG = SvgCB[itm];
            if (cuSVG.animate) {
               SvgCB.svgAnimate(cuSVG.lastValue, cuSVG.current, cuSVG);
               //cuSVG.animate = false;
            }
         });
      }
   };
   return SvgCB;
};
exports.default = statSVGs;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var NEW_PATH = 'NEW_PATH';

exports.NEW_PATH = NEW_PATH;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var FETCH_TRADES = 'FETCH_TRADES';
var FETCH_TRADES_REJECTED = 'FETCH_TRADES_REJECTED';
var FETCH_TRADES_FULFILLED = 'FETCH_TRADES_FULFILLED';
var DEPOSIT_CHANGE = 'DEPOSIT_CHANGE';
var ADD_TRADE = 'ADD_TRADE';
var TRADE_COMPLETE = 'TRADE_COMPLETE';
var ADD_MONEY = 'ADD_MONEY';

exports.FETCH_TRADES = FETCH_TRADES;
exports.FETCH_TRADES_REJECTED = FETCH_TRADES_REJECTED;
exports.FETCH_TRADES_FULFILLED = FETCH_TRADES_FULFILLED;
exports.DEPOSIT_CHANGE = DEPOSIT_CHANGE;
exports.ADD_TRADE = ADD_TRADE;
exports.TRADE_COMPLETE = TRADE_COMPLETE;
exports.ADD_MONEY = ADD_MONEY;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var DEPOSIT_CHANGE = 'DEPOSIT_CHANGE';

exports.DEPOSIT_CHANGE = DEPOSIT_CHANGE;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var Countries = { AMERICA: ["Antigua And Barbuda", "Argentina", "Aruba", "Bahamas", "Barbados", "Belize", "Bermuda", "Bolivia", "Brazil", "Canada", "Cayman Islands", "Chile", "Colombia", "Costa Rica", "Cuba", "Dominica", "Dominican Republic", "Ecuador", "El Salvador", "Grenada", "Guatemala", "Guyana", "Haiti", "Honduras", "Jamaica", "Mexico", "Nicaragua", "Panama", "Paraguay", "Peru", "Puerto Rico", "Suriname", "Trinidad And Tobago", "United States", "Uruguay", "Venezuela"],
  EUROPE: ["Albania", "Andorra", "Austria", "Belarus", "Belgium", "Bosnia And Herzegovina", "Bulgaria", "Croatia", "Cyprus", "Czech Republic", "Denmark", "Estonia", "Euro Area", "European Union", "Finland", "France", "Germany", "Greece", "Hungary", "Iceland", "Ireland", "Isle Of Man", "Italy", "Kosovo", "Latvia", "Liechtenstein", "Lithuania", "Luxembourg", "Macedonia", "Malta", "Moldova", "Monaco", "Montenegro", "Netherlands", "Norway", "Poland", "Portugal", "Romania", "Russia", "Serbia", "Slovakia", "Slovenia", "Spain", "Sweden", "Switzerland", "Turkey", "Ukraine", "United Kingdom"],
  AFRICA: ["Algeria", "Angola", "Benin", "Botswana", "Burkina Faso", "Burundi", "Cameroon", "Cape Verde", "Central African Republic", "Chad", "Comoros", "Congo", "Djibouti", "Egypt", "Equatorial Guinea", "Eritrea", "Ethiopia", "Gabon", "Gambia", "Ghana", "Guinea", "Guinea Bissau", "Ivory Coast", "Kenya", "Lesotho", "Liberia", "Libya", "Madagascar", "Malawi", "Mali", "Mauritania", "Mauritius", "Morocco", "Mozambique", "Namibia", "Niger", "Nigeria", "Republic Of The Congo", "Rwanda", "Sao Tome And Principe", "Senegal", "Seychelles", "Sierra Leone", "Somalia", "South Africa", "South Sudan", "Sudan", "Swaziland", "Tanzania", "Togo", "Tunisia", "Uganda", "Zambia", "Zimbabwe"],
  ASIA: ["Afghanistan", "Armenia", "Azerbaijan", "Bahrain", "Bangladesh", "Bhutan", "Brunei", "Cambodia", "China", "East Timor", "Georgia", "India", "Indonesia", "Iran", "Iraq", "Israel", "Japan", "Jordan", "Kazakhstan", "Kuwait", "Kyrgyzstan", "Laos", "Lebanon", "Malaysia", "Maldives", "Mongolia", "Myanmar", "Nepal", "North Korea", "Oman", "Palestine", "Pakistan", "Philippines", "Qatar", "Saudi Arabia", "Singapore", "South Korea", "Sri Lanka", "Syria", "Taiwan", "Tajikistan", "Thailand", "Turkmenistan", "United Arab Emirates", "Uzbekistan", "Vietnam", "Yemen"], "AUSTRALIA": ["Australia", "Fiji", "Kiribati", "New Caledonia", "New Zealand", "Papua New Guinea", "Samoa", "Solomon Islands", "Tonga", "Vanuatu"] };

exports.default = Countries;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
var forexSymbolPairs = ['AUD/JPY', 'AUD/USD', 'CAD/CHF', 'CAD/JPY', 'CHF/JPY', 'EUR/AUD', 'EUR/CAD', 'EUR/GBP', 'EUR/JPY', 'EUR/NOK', 'EUR/SEK', 'EUR/USD', 'GBP/CHF', 'GBP/JPY', 'GBP/USD', 'NZD/JPY', 'NZD/USD', 'USD/BRL', 'USD/CAD', 'USD/CHF', 'USD/CNY', 'USD/CZK', 'USD/HKD', 'USD/INR', 'USD/JPY', 'USD/KRW', 'USD/MXN', 'USD/NOK', 'USD/PLN', 'USD/RUB', 'USD/SEK', 'USD/SGD', 'USD/ZAR'];

exports.default = forexSymbolPairs;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var stockSymbs = ['AAPL', 'YHOO', 'MSFT', 'SNE', 'GOOG', 'AMZN', 'OILD', 'AEIS', 'AMD', 'ALGN', 'APEI', 'ASML', 'ASTE', 'ALOT', 'ATRI', 'ADRE', 'BMCH', 'BRKS', 'CA', 'CPLA', 'CARO', 'CASY', 'CBNK', 'CSCO', 'CVLT', 'CYBE', 'CYNO', 'CYRN', 'DLTR', 'DORM', 'EBAY', 'FNTCW', 'FFBC', 'THFF', 'SKYY', 'FEX', 'FTC', 'FTA', 'FAB', 'TDIV', 'QTEC', 'FYX', 'FIVE', 'FELE', 'GRMN', 'GENC', 'GNTX', 'SOCL', 'GDEN', 'GBDC', 'IESC', 'IPAR', 'SOXX', 'JKHY', 'JSMD', 'KEQU', 'KLAC', 'LKFN', 'LRCX', 'LXRX', 'LGIH', 'LSXMB', 'LSXMA', 'LLTC', 'LITE', 'MGIC', 'MBFI', 'MGPI', 'MCHP', 'MKSI', 'MPWR', 'NANO', 'NGHCZ', 'NATL', 'NTES', 'NVEE', 'NVDA', 'OCLR', 'ORLY', 'PDFS', 'PEBO', 'PEBK', 'PRFT', 'POWI', 'PSCI', 'PSCT', 'PSEC', 'PROV', 'QCRH', 'RAVN', 'ROST', 'SMTC', 'SIRI', 'JSM', 'OKSB', 'SPAR', 'TXN', 'SPNC', 'UBNT', 'UFPI', 'VTWV', 'VASC', 'CFO', 'CFA', 'CDL', 'FLAG'].sort();
var nyse = ['ACM', 'AKS', 'AMBR', 'ARMK', 'BANC', 'BSBR', 'BAX', 'BHL', 'BERY', 'LND', 'BR', 'CAT', 'IGR', 'CIM', 'MJN', 'MSCI', 'MUSA', 'NCI', 'NXRT', 'NTC', 'NEV', 'PCI', 'PHK', 'RCS', 'PPX', 'PLD', 'PRH', 'TLK', 'PSA', 'CTY', 'CTAA', 'RFT', 'SAP', 'AOS', 'SWK', 'EDF', 'SRI', 'BLD', 'TTC', 'TDG', 'UTX', 'WCN', 'WFC'].sort();

var exchangeSymbs = function exchangeSymbs(usedItms) {
   var nasdaqOptions = stockSymbs.map(function (symbs, ii) {
      if (usedItms.test(symbs)) {
         // return  <option key={symbs} disabled="true" value={symbs} >{symbs}</option>;
         return null;
      } else {
         return _react2.default.createElement(
            'option',
            { key: symbs, value: symbs },
            symbs
         );
      }
   });
   var nyseOptions = nyse.map(function (symbs, ii) {
      if (usedItms.test(symbs)) {
         //  return  <option key={symbs} disabled="true" value={symbs} >{symbs}</option>;
         return null;
      } else {
         return _react2.default.createElement(
            'option',
            { key: symbs, value: symbs },
            symbs
         );
      }
   });

   return {
      NASDAQ: nasdaqOptions,
      NYSE: nyseOptions
   };
};
exports.default = exchangeSymbs;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var urlBase = false ? '127.0.0.1:8000/ws' : 'damp-beyond-64138.herokuapp.com/ws';

var OpenWebsocket = function OpenWebsocket() {
  var theSocketUrl = window.location.protocol !== 'https:' ? 'ws://' + urlBase : 'wss://' + urlBase;

  var SOCKET = new WebSocket(theSocketUrl);
  SOCKET.on = {};
  SOCKET.watchedFeeds = {};
  SOCKET.dispatchEvent = function (name, callback) {
    SOCKET.on[name] = callback;
  };

  SOCKET.onmessage = function (event) {
    var theData = JSON.parse(event.data);
    if (!SOCKET.watchedFeeds[theData.symb]) {
      SOCKET.watchedFeeds[theData.symb] = true;
      SOCKET.on.liveFeedStarted(theData.symb);
    }
    SOCKET.on[theData.symb](theData);
  };
  return SOCKET;
};

exports.default = OpenWebsocket;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
var Indicators = ["gdp-per-capita", "gdp-growth-rate", "gdp-annual-growth-rate", "interest-rate", "inflation-rate", "unemployment-rate", "government-debt-to-gdp", "gdp", "gdp-per-capita", "population", "productivity", "balance-of-trade", "current-account-to-gdp", "crude-oil-production", "foreign-exchange-reserves", "rating", "corporate-tax-rate", "personal-income-tax-rate", "retirement-age-men", "retirement-age-women", "population", "gdp-per-capita"];

exports.default = Indicators;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var nasSymbs = ['AAPL', 'YHOO', 'MSFT', 'SNE', 'GOOG', 'AMZN', 'OILD', 'AEIS', 'AMD', 'ALGN', 'APEI', 'ASML', 'ASTE', 'ALOT', 'ATRI', 'ADRE', 'BMCH', 'BRKS', 'CA', 'CPLA', 'CARO', 'CASY', 'CBNK', 'CSCO', 'CVLT', 'CYBE', 'CYNO', 'CYRN', 'DLTR', 'DORM', 'EBAY', 'FNTCW', 'FFBC', 'THFF', 'SKYY', 'FEX', 'FTC', 'FTA', 'FAB', 'TDIV', 'QTEC', 'FYX', 'FIVE', 'FELE', 'GRMN', 'GENC', 'GNTX', 'SOCL', 'GDEN', 'GBDC', 'IESC', 'IPAR', 'SOXX', 'JKHY', 'JSMD', 'KEQU', 'KLAC', 'LKFN', 'LRCX', 'LXRX', 'LGIH', 'LSXMB', 'LSXMA', 'LLTC', 'LITE', 'MGIC', 'MBFI', 'MGPI', 'MCHP', 'MKSI', 'MPWR', 'NANO', 'NGHCZ', 'NATL', 'NTES', 'NVEE', 'NVDA', 'OCLR', 'ORLY', 'PDFS', 'PEBO', 'PEBK', 'PRFT', 'POWI', 'PSCI', 'PSCT', 'PSEC', 'PROV', 'QCRH', 'RAVN', 'ROST', 'SMTC', 'SIRI', 'JSM', 'OKSB', 'SPAR', 'TXN', 'SPNC', 'UBNT', 'UFPI', 'VTWV', 'VASC', 'CFO', 'CFA', 'CDL', 'FLAG'].sort();
var nyseSymbs = ['ACM', 'AKS', 'AMBR', 'ARMK', 'BANC', 'BSBR', 'BAX', 'BHL', 'BERY', 'LND', 'BR', 'CAT', 'IGR', 'CIM', 'MJN', 'MSCI', 'MUSA', 'NCI', 'NXRT', 'NTC', 'NEV', 'PCI', 'PHK', 'RCS', 'PPX', 'PLD', 'PRH', 'TLK', 'PSA', 'CTY', 'CTAA', 'RFT', 'SAP', 'AOS', 'SWK', 'EDF', 'SRI', 'BLD', 'TTC', 'TDG', 'UTX', 'WCN', 'WFC'].sort();

var nasdaqOpts = nasSymbs.map(function (symbs, ii) {

   return _react2.default.createElement(
      'option',
      { key: symbs, value: symbs },
      symbs
   );
});
var nyseOpts = nyseSymbs.map(function (symbs, ii) {

   return _react2.default.createElement(
      'option',
      { key: symbs, value: symbs },
      symbs
   );
});

var exchangeOptions = {
   NASDAQ: nasdaqOpts,
   NYSE: nyseOpts
};
exports.default = exchangeOptions;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _charts = __webpack_require__(95);

var _charts2 = _interopRequireDefault(_charts);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var askBidVolume = function askBidVolume(bool, v1, v2) {
   if (bool) {
      return [Math.max(v1, v2), Math.min(v1, v2)];
   }
   return [Math.min(v1, v2), Math.max(v1, v2)];
};

var GraphController = function GraphController() {
   var _this = this;

   _classCallCheck(this, GraphController);

   this.updatePosProps = function (_ref) {
      var pricestart = _ref.pricestart,
          priceend = _ref.priceend;

      _this.posProps = {
         pricestart: pricestart,
         priceend: priceend
      };
   };

   this.createCharts = function (_ref2) {
      var pricestart = _ref2.pricestart,
          priceend = _ref2.priceend;

      _this.posProps = {
         pricestart: pricestart,
         priceend: priceend
      };
      _this.donutChart = _charts2.default.makeChart('chart1view', _this.ratioData(), 'doughnut', {
         height: 150,
         animate: true,
         background: '#18252e',
         msAni: 900
      });
      _this.comboChart = _charts2.default.makeComboChart('chart2view', {
         price: pricestart,
         len: 30
      }, {
         msAni: 900,
         aYmin: pricestart * 0.8
      });
   };

   this.ratioData = function () {
      var askBid = askBidVolume(_this.posProps.pricestart < _this.posProps.priceend, Math.floor(Math.random() * 10000) + 1000, Math.floor(Math.random() * 10000) + 1000);

      return [{
         y: askBid[0],
         name: 'Bid',
         fillOpacity: .9,
         legendText: 'Bid',
         color: '#30d94c'
      }, {
         y: askBid[1],
         name: 'Ask',
         fillOpacity: .9,
         legendText: 'Ask',
         color: 'red'
      }];
   };

   this.updateCharts = function () {
      _this.donutChart.newSet(_this.ratioData());
      _this.comboChart.genData(_this.posProps.pricestart, 30);
   };

   this.renderCharts = function () {
      if (_this.donutChart === null || _this.comboChart === null) {
         return false;
      }
      setTimeout(_this.updateCharts, 70);
   };

   this.donutChart = null;
   this.comboChart = null;
   this.posProps = {
      pricestart: 0,
      priceend: 0
   };
};

var viewCntrl = new GraphController();

exports.default = viewCntrl;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _d3fcRandomData = __webpack_require__(14);

var getRandomData = function getRandomData(seedDate, price) {
  return (0, _d3fcRandomData.randomFinancial)().startDate(new Date()).startPrice(price);
};

var donutConfig = function donutConfig(data, _ref) {
  var height = _ref.height,
      animate = _ref.animate,
      background = _ref.background,
      msAni = _ref.msAni;
  return {
    height: height ? height : 150,
    animationEnabled: animate ? animate : true,
    backgroundColor: background ? background : "#18252e",
    animationDuration: msAni ? msAni : 1300,
    legend: {
      verticalAlign: "top",
      horizontalAlign: "center"
    },
    data: [{
      startAngle: 45,
      type: "doughnut",
      dataPoints: data
    }]
  };
};

var columnConfig = function columnConfig(data, _ref2) {
  var height = _ref2.height,
      animate = _ref2.animate,
      background = _ref2.background,
      msAni = _ref2.msAni;
  return {
    height: height ? height : 150,
    animationEnabled: animate ? animate : true,
    backgroundColor: background ? background : "#18252e",
    animationDuration: msAni ? msAni : 1300,
    data: [{
      type: "column",
      dataPoints: data
    }]
  };
};

var rangeAreaConfig = function rangeAreaConfig(data, _ref3) {
  var height = _ref3.height,
      animate = _ref3.animate,
      background = _ref3.background,
      msAni = _ref3.msAni;
  return {
    height: height ? height : 150,
    animationEnabled: animate ? animate : true,
    backgroundColor: background ? background : "#18252e",
    animationDuration: msAni ? msAni : 1300,
    data: [{
      type: "rangeArea",
      fillOpacity: .6,
      markerType: "none",
      dataPoints: data
    }]
  };
};

var plainMultiSeries = function plainMultiSeries(data) {
  var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return {
    interactivityEnabled: false,
    axisX: {
      valueFormatString: " ",

      tickLength: 1,
      //  labelFontColor:  settings.background ? settings.background : "#18252e",
      lineThickness: 1
    },
    axisY: {
      valueFormatString: "",
      gridThickness: 0.3,
      minimum: settings.min,
      maximum: settings.max,
      includeZero: false,
      tickLength: 1,
      margin: 5,
      //  labelFontColor:  settings.background ? settings.background : "#18252e",
      gridColor: "#224458",
      lineThickness: 1
    },
    backgroundColor: settings.background ? settings.background : "#18252e",
    animationEnabled: true,
    animationDuration: 1300,
    data: data
  };
};
var volumeAndRange = function volumeAndRange(data, price) {
  var theMin = price * 2;
  var theMax = 0;
  var points = data.reduce(function (ob, itm) {
    ob.range.push({
      x: itm.date,
      y: [itm.low, itm.high]
    });
    var colColor = itm.open < itm.close ? "#30d94c" : "red";
    theMin = Math.min(theMin, itm.low);
    theMax = Math.max(theMax, itm.high);
    ob.column.push({
      x: itm.date,
      y: Math.floor(itm.volume / 1000),
      color: colColor
    });
    return ob;
  }, {
    column: [],
    range: []
  });
  var columns = points.column.map(function (itm) {
    itm.y = Math.floor(Math.random() * (theMax - theMin) / 3 + theMin);
    return itm;
  });
  return {
    minMax: {
      min: theMin,
      max: theMax
    },
    d: [{
      type: "column",
      dataPoints: columns
    }, {
      type: "rangeArea",
      fillOpacity: .6,
      markerType: "none",
      dataPoints: points.range
    }]
  };
};
var kindConfig = function kindConfig(kind, data, settings) {
  switch (kind) {
    case "doughnut":
      return donutConfig(data, settings);
      break;
    case "bar":
      return false;
      break;
    case "pie":
      return false;
      break;
    case "multiseriesPlain":
      return plainMultiSeries(data, settings);
      break;
    case "rangeArea":
      return false;
      break;
    case "column":
      return false;
      break;
    case "scatter":
      return false;
  }
  return false;
};

var makeChart = function makeChart(chartId, data, kind, settings) {
  var theId = chartId;
  var theSettings = settings;
  var theConfig = kindConfig(kind, data, settings);
  console.log('theConfig', theConfig);
  var chart = new CanvasJS.Chart(chartId, theConfig);
  console.log('chart', chart);
  return {
    renderChart: function renderChart() {
      chart.render();
    },
    newSet: function newSet(newdata) {
      theConfig = kindConfig(kind, newdata, theSettings);
      chart = new CanvasJS.Chart(theId, theConfig);
      chart.render();
    }
  };
};
var makeComboChart = function makeComboChart(chartId, data, kind, settings) {

  var theId = chartId;
  var res = volumeAndRange(getRandomData(new Date(), data.price)(data.len), data.price);
  var dataSets = res.d;
  var theSettings = {
    min: res.minMax.min,
    max: res.minMax.max
  };
  var theConfig = kindConfig("multiseriesPlain", dataSets, theSettings);
  console.log('theConfig', theConfig);
  var chart = new CanvasJS.Chart(chartId, theConfig);
  console.log('chart', chart);
  chart.render();
  return {
    renderChart: function renderChart() {
      chart.render();
    },
    genData: function genData(pr, ln) {
      var res = volumeAndRange(getRandomData(new Date(), data.price)(data.len), data.price);
      dataSets = res.d;
      theConfig = kindConfig("multiseriesPlain", dataSets, {
        min: res.minMax.min,
        max: res.minMax.max
      });
      chart = new CanvasJS.Chart(theId, theConfig);
      chart.render();
    },
    newSet: function newSet(newdata) {
      theConfig = kindConfig(kind, newdata, theSettings);
      chart = new CanvasJS.Chart(theId, theConfig);
      chart.render();
    }
  };
};
var chartMaker = {
  makeComboChart: makeComboChart,
  makeChart: makeChart
};

exports.default = chartMaker;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var candleStick = function candleStick(dta) {
	return [new Date(dta.timestamp).getTime(), dta.open, dta.high, dta.low, dta.close];
};
var spline = function spline(dta) {
	return [new Date(dta.timestamp).getTime(), dta.close];
};
var column = function column(dta) {
	return [new Date(dta.timestamp).getTime(), dta.volume];
};
var columnrange = function columnrange(dta) {
	return [new Date(dta.timestamp).getTime(), dta.low, dta.hight];
};

var dataTransform = {
	candlestick: function candlestick() {
		return function (dta) {
			return [new Date(dta.timestamp).getTime(), dta.open, dta.high, dta.low, dta.close];
		};
	},
	ohlc: function ohlc() {
		return function (dta) {
			return [new Date(dta.timestamp).getTime(), dta.open, dta.high, dta.low, dta.close];
		};
	},
	spline: function spline() {
		return function (dta) {
			return [new Date(dta.timestamp).getTime(), dta.close];
		};
	},
	line: function line() {
		return function (dta) {
			return [new Date(dta.timestamp).getTime(), dta.close];
		};
	},
	area: function area() {
		return function (dta) {
			return [new Date(dta.timestamp).getTime(), dta.close];
		};
	},
	step: function step() {
		return function (dta) {
			return [new Date(dta.timestamp).getTime(), dta.close];
		};
	},
	column: function column() {
		return function (dta) {
			return [new Date(dta.timestamp).getTime(), dta.volume];
		};
	},
	columnrange: function columnrange() {
		return function (dta) {
			return [new Date(dta.timestamp).getTime(), dta.low, dta.high];
		};
	}
};

exports.default = dataTransform;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
var candlestickConfig = function candlestickConfig(symbol, data) {
   var name = symbol + ' Stock Price';
   return {
      rangeSelector: {
         selected: 1
      },

      title: {
         text: name
      },
      series: [{
         type: 'candlestick',
         name: name,
         data: data,
         dataGrouping: {
            units: [['week', [1]], ['month', [1, 2, 3, 4, 6]]]
         }
      }]
   };
};
var ohlcConfig = function ohlcConfig(symbol, data) {
   var name = symbol + ' Stock Price';
   return {
      rangeSelector: {
         selected: 1
      },

      title: {
         text: name
      },
      series: [{
         type: 'ohlc',
         name: name,
         data: data,
         dataGrouping: {
            units: [['week', [1]], ['month', [1, 2, 3, 4, 6]]]
         }
      }]
   };
};
var columnConfig = function columnConfig(symbol, data) {
   var name = symbol + ' Stock Volume';
   return {
      chart: {
         alignTicks: false
      },

      rangeSelector: {
         selected: 1
      },

      title: {
         text: name
      },

      series: [{
         type: 'column',
         name: name,
         data: data,
         dataGrouping: {
            units: [['week', // unit name
            [1] // allowed multiples
            ], ['month', [1, 2, 3, 4, 6]]]
         }
      }]
   };
};
var columnRangeConfig = function columnRangeConfig(symbol, data) {
   var name = symbol + ' Daily Low High';
   return {
      chart: {
         type: 'columnrange'
      },

      rangeSelector: {
         selected: 2
      },

      title: {
         text: name
      },

      series: [{
         type: 'columnrange',
         name: 'Low - High',
         data: data
      }]
   };
};
var lineConfig = function lineConfig(symbol, data) {
   var name = symbol + ' Stock Price';
   return {

      rangeSelector: {
         selected: 1
      },

      title: {
         text: name
      },

      series: [{
         name: name,
         data: data,
         type: 'line',
         tooltip: {
            valueDecimals: 2
         }
      }]
   };
};
var areaConfig = function areaConfig(symbol, data) {
   var name = symbol + ' Stock Price';
   return {

      rangeSelector: {
         selected: 1
      },

      title: {
         text: name
      },

      series: [{
         name: name,
         data: data,
         type: 'area',
         tooltip: {
            valueDecimals: 2
         }
      }]
   };
};
var stepConfig = function stepConfig(symbol, data) {
   var name = symbol + ' Stock Price';
   return {
      rangeSelector: {
         selected: 1
      },

      title: {
         text: name
      },

      series: [{
         name: name,
         data: data,
         step: true,
         tooltip: {
            valueDecimals: 2
         }
      }]
   };
};
var splineConfig = function splineConfig(symbol, data) {
   var name = symbol + ' Stock Price';
   return {

      rangeSelector: {
         selected: 1
      },

      title: {
         text: name
      },

      series: [{
         name: name,
         data: data,
         type: 'spline',
         tooltip: {
            valueDecimals: 2
         }
      }]
   };
};
var stackColumnConfig = function stackColumnConfig() {
   var symbol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "hey";
   var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

   var name = symbol + ' per quarter';
   return {

      title: {
         text: name
      },
      xAxis: {
         categories: ['Apples', 'Oranges', 'Pears', 'Grapes', 'Bananas']
      },
      yAxis: {
         min: 0,
         title: {
            text: 'Total fruit consumption'
         },
         stackLabels: {
            enabled: true,
            style: {
               fontWeight: 'bold'
            }
         }
      },
      tooltip: {
         headerFormat: '<b>{point.x}</b><br/>',
         pointFormat: '{series.name}: {point.y}<br/>Total: {point.stackTotal}'
      },
      legend: {
         align: 'right',
         x: -30,
         verticalAlign: 'top',
         y: 25,
         floating: true,
         backgroundColor: 'white',
         borderColor: '#CCC',
         borderWidth: 1,
         shadow: false
      },
      plotOptions: {
         column: {
            stacking: 'normal',
            dataLabels: {
               enabled: true,
               // color: 'white',
               style: {
                  textShadow: '0 0 3px black'
               }
            }
         }
      },

      series: [{
         name: 'Q1',
         data: [5, 3, 4, 7, 2]
      }, {
         name: 'Q2',
         data: [2, 2, 3, 2, 1]
      }, {
         name: 'Q3',
         data: [3, 4, 4, 2, 5]
      }]
   };
};
var multiConfig = function multiConfig(symbol, seriesOptions) {
   console.log('seriesOptions', seriesOptions);
   return {
      rangeSelector: {
         selected: 4
      },

      yAxis: {
         labels: {
            formatter: function formatter() {
               return (this.value > 0 ? ' + ' : '') + this.value + '%';
            }
         },
         plotLines: [{
            value: 0,
            width: 2,
            color: 'silver'
         }]
      },

      plotOptions: {
         series: {
            compare: 'percent'
         }
      },

      tooltip: {
         pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y}</b> ({point.change}%)<br/>',
         valueDecimals: 2
      },

      series: seriesOptions
   };
};

var graphConfigs = {
   candlestick: candlestickConfig,
   spline: splineConfig,
   column: columnConfig,
   line: lineConfig,
   step: stepConfig,
   area: areaConfig,
   ohlc: ohlcConfig,
   stackColumnConfig: stackColumnConfig,
   multiconfig: multiConfig,
   columnrange: columnRangeConfig
};

exports.default = graphConfigs;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(47);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _Layout = __webpack_require__(45);

var _Layout2 = _interopRequireDefault(_Layout);

var _reactRedux = __webpack_require__(8);

var _store = __webpack_require__(46);

var _store2 = _interopRequireDefault(_store);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var root = document.getElementById('container');

_reactDom2.default.render(_react2.default.createElement(
  _reactRedux.Provider,
  { store: _store2.default },
  _react2.default.createElement(_Layout2.default, null)
), root);

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = reducer;

var _dashboard = __webpack_require__(12);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var innitialState = {
  onStart: true,
  chartPositions: {},
  chartStates: {},
  chartAddOpen: false,
  selectUl: 'forex',
  totalCharts: 0,
  addButton: false,
  optsComponent: null,
  newSet: null,
  chartList: [],
  platformView: 'live graphs',
  tradViewClass: 'full-view',
  connected: false,
  seriesWatch: []
};

function reducer() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : innitialState;
  var action = arguments[1];

  switch (action.type) {
    case _dashboard.ADD_CHART:
      {
        return _extends({}, state, action.payload);
      }
    case _dashboard.CLOSE_CHART:
      {
        return _extends({}, state, action.payload);
      }
    case _dashboard.CHART_STATE_UPDATE:
      {
        return _extends({}, state, {
          chartStates: _extends({}, state.chartStates, _defineProperty({}, action.chartSymbol, _extends({}, state.chartStates[action.chartSymbol], action.payload)))
        });
      }
    case _dashboard.WATCHED_POSITIONS:
      {
        return action.payload;
      }
    case _dashboard.FEED_START:
      {
        return _extends({}, state, {
          seriesWatch: action.payload.seriesWatch,
          addButton: action.payload.addButton
        });
      }
    case _dashboard.OPTS_VIEW:
      {
        return _extends({}, state, {
          tradViewClass: action.payload.tradViewClass,
          optsComponent: action.payload.optsComponent,
          platformView: action.payload.platformView
        });
      }
    case _dashboard.SWITCH_INDICES:
      {
        return _extends({}, state, {
          selectUl: action.payload
        });
      }
    case _dashboard.TOGGLE_CHART_MENU:
      {
        return _extends({}, state, {
          chartAddOpen: action.payload
        });
      }
    case _dashboard.CONNECTION_LOST:
      {
        return _extends({}, state, {
          connected: false
        });
      }
    case _dashboard.CONNECTED:
      {
        return _extends({}, state, {
          connected: true
        });
      }
  }

  return state;
}

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _redux = __webpack_require__(19);

var _dashboardReducer = __webpack_require__(99);

var _dashboardReducer2 = _interopRequireDefault(_dashboardReducer);

var _tradeReducer = __webpack_require__(102);

var _tradeReducer2 = _interopRequireDefault(_tradeReducer);

var _widgetReducer = __webpack_require__(104);

var _widgetReducer2 = _interopRequireDefault(_widgetReducer);

var _routeReducer = __webpack_require__(101);

var _routeReducer2 = _interopRequireDefault(_routeReducer);

var _transactionReducer = __webpack_require__(103);

var _transactionReducer2 = _interopRequireDefault(_transactionReducer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _redux.combineReducers)({
  rt: _dashboardReducer2.default,
  trades: _tradeReducer2.default,
  widgets: _widgetReducer2.default,
  transactions: _transactionReducer2.default,
  routes: _routeReducer2.default
});

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = reducer;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _graph_temp = __webpack_require__(21);

var _graph_temp2 = _interopRequireDefault(_graph_temp);

var _realtime = __webpack_require__(23);

var _realtime2 = _interopRequireDefault(_realtime);

var _map = __webpack_require__(22);

var _map2 = _interopRequireDefault(_map);

var _topnav = __webpack_require__(24);

var _topnav2 = _interopRequireDefault(_topnav);

var _routes = __webpack_require__(85);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.checkPath = function () {

  var ChangeUrl = function ChangeUrl(title, url) {
    if (typeof history.pushState === 'undefined') return;

    var obj = {
      Title: title,
      Url: url
    };
    history.pushState(obj, obj.Title, obj.Url);
  };
  var allPaths = ['/', '/history', '/realtime', '/map'];
  var allTitles = {
    '/': 'Examples',
    '/history': 'History',
    '/realtime': 'Real Time',
    '/map': 'Map Stuff'
  };
  var pathReducer = function pathReducer(path) {};
  return function (path) {
    //  let routeArray = path.split('/').filter(Boolean);
    var pathIS = allPaths.reduce(function (q, i) {
      return i === path ? i : q;
    }, '/');
    ChangeUrl(allTitles[pathIS], pathIS);
    return pathIS;
  };
}();

var routeComponents = {
  '/': _react2.default.createElement(_graph_temp2.default, null),
  '/history': _react2.default.createElement(_graph_temp2.default, null),
  '/realtime': _react2.default.createElement(_realtime2.default, null),
  '/map': _react2.default.createElement(_map2.default, null)
};
var getTopNav = {
  '/': _react2.default.createElement(_topnav2.default, { theClass: 'normal', pathName: '/' }),
  '/history': _react2.default.createElement(_topnav2.default, { theClass: 'normal', pathName: '/history' }),
  '/realtime': _react2.default.createElement(_topnav2.default, { theClass: 'rt-alter', pathName: '/realtime' }),
  '/map': _react2.default.createElement(_topnav2.default, { theClass: 'normal', pathName: '/map' })
};
var initialPath = window.checkPath(window.location.pathname);
function reducer() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    pathName: window.location.pathname,
    blocked: routeComponents[initialPath],
    topNav: _react2.default.createElement(_topnav2.default, { theClass: initialPath === '/realtime' ? 'rt-alter' : '', pathName: initialPath }),
    routeComponents: routeComponents
  };
  var action = arguments[1];


  switch (action.type) {
    case _routes.NEW_PATH:
      {
        return _extends({}, state, {
          pathName: action.payload.pathname,
          blocked: action.payload.blocked,
          topNav: action.payload.topNav
        });
        break;
      }

  }

  return state;
}

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = reducer;

var _trades = __webpack_require__(86);

var pastTrades = [{
  position: 'GOOG',
  volume: 120,
  date: new Date().toDateString(),
  short: false,
  pricestart: 776.15,
  priceend: 776.95
}, {
  position: 'YHOO',
  volume: 45,
  date: new Date().toDateString(),
  short: false,
  pricestart: 38.19,
  priceend: 38.80
}, {
  position: 'APPL',
  volume: 10,
  date: new Date().toDateString(),
  short: false,
  pricestart: 121,
  priceend: 88
}, {
  position: 'MSFT',
  volume: 95,
  date: new Date().toDateString(),
  short: false,
  pricestart: 61.79,
  priceend: 61.52
}, {
  position: 'GBP/USD',
  volume: 80,
  date: new Date().toDateString(),
  short: false,
  pricestart: 1.327,
  priceend: 1.3272
}, {
  position: 'AUD/JPY',
  volume: 20,
  date: new Date().toDateString(),
  short: false,
  pricestart: 82.21,
  priceend: 81.94
}, {
  position: 'AMZN',
  volume: 200,
  date: new Date().toDateString(),
  short: false,
  pricestart: 751.77,
  priceend: 750.77
}];

function reducer() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    pastTrades: pastTrades,
    currentPos: [],
    todayTradeCount: 0,
    weeklyTradeCount: 0,
    netPosTrades: 0,
    totalVolume: 0,
    netNegTrades: 0,
    totalRev: 0,
    todayTotalNet: 0.0,
    moneyAvaliable: 0.0,
    fetching: false,
    fetched: false,
    deposit: 2500,
    error: null
  };
  var action = arguments[1];


  switch (action.type) {
    case _trades.FETCH_TRADES:
      {
        return _extends({}, state, {
          fetching: true
        });
      }
    case _trades.FETCH_TRADES_REJECTED:
      {
        return _extends({}, state, {
          fetching: false,
          error: action.payload
        });
      }
    case _trades.FETCH_TRADES_FULFILLED:
      {
        return _extends({}, state, {
          fetching: false,
          fetched: true,
          pastTrades: action.payload
        });
      }
    case _trades.DEPOSIT_CHANGE:
      {
        return _extends({}, state, {
          deposit: action.payload
        });
      }
    case _trades.ADD_TRADE:
      {
        return _extends({}, state, action.payload);
      }
    case _trades.TRADE_COMPLETE:
      {

        return _extends({}, state, action.payload);
      }
    case _trades.ADD_MONEY:
      {
        return _extends({}, state, {
          moneyAvaliable: action.payload
        });
      }
  }

  return state;
}

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = reducer;

var _transactions = __webpack_require__(87);

function reducer() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    deposit: 2500
  };
  var action = arguments[1];


  switch (action.type) {
    case _transactions.DEPOSIT_CHANGE:
      {
        return _extends({}, state, {
          deposit: action.payload
        });
        break;
      }
  }
  return state;
}

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = reducer;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _widgets = __webpack_require__(20);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var WidgetList = {
  widget1: {
    title: "stuff",
    kind: "graphjs",
    symb: "AMZN",
    content: {
      chartid: "AMZN_HIST",
      data: null,
      graphType: 'area',
      dynamic: true
    }
  },
  widget2: {
    title: "",
    kind: "table",
    content: {
      title: "",
      data: null
    }
  },
  widget3: {
    title: "stuff",
    kind: "graphjs",
    symb: "SNE",
    content: {
      chartid: "SNE_HIST",
      data: null,
      graphType: 'column',
      dynamic: true
    }
  },
  widget4: {
    title: "",
    kind: "progress",
    content: {
      title: "",
      data: null
    }
  }
};
var innitialState = {
  WidgetList: WidgetList,
  rowTopStyle: {
    height: "50%"
  },
  rowBtmStyle: {
    height: "50%"
  },
  rowTop: {
    comps: []
  },
  rowBtm: {
    comps: []
  },
  needsUpdate: {},
  draggedWidget: null,
  overWidget: null,
  widget1: {
    clType: "col-xs-6 widget-box",
    colType: 6,
    style: {},
    holdType: "FullWidget",
    shown: true,
    data: WidgetList.widget1
  },
  widget2: {
    clType: "col-xs-6 widget-box",
    colType: 6,
    style: {},
    shown: true,
    holdType: "FullWidget",
    data: WidgetList.widget2
  },
  widget3: {
    clType: "col-xs-6 widget-box",
    colType: 6,
    style: {},
    shown: true,
    holdType: "FullWidget",
    data: WidgetList.widget3
  },
  widget4: {
    clType: "col-xs-6 widget-box",
    colType: 6,
    style: {},
    shown: true,
    holdType: "FullWidget",
    data: WidgetList.widget4
  }

};

function reducer() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : innitialState;
  var action = arguments[1];

  switch (action.type) {
    case _widgets.WIDGET_DROP:
      {
        return action.payload;
      }
    case _widgets.WIDGET_DRAGGED:
      {
        return _extends({}, state, {
          draggedWidget: action.payload
        });
      }
    case _widgets.GOT_MESSAGE:
      {
        return _extends({}, state, {
          needsUpdate: _extends({}, state.needsUpdate, action.payload)
        });
        break;
      }
    case _widgets.GOT_DATA:
      {
        return _extends({}, state, action.payload);
      }

  }

  return state;
}

/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_uniform__ = __webpack_require__(109);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "randomUniform", function() { return __WEBPACK_IMPORTED_MODULE_0__src_uniform__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_normal__ = __webpack_require__(27);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "randomNormal", function() { return __WEBPACK_IMPORTED_MODULE_1__src_normal__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_logNormal__ = __webpack_require__(108);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "randomLogNormal", function() { return __WEBPACK_IMPORTED_MODULE_2__src_logNormal__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_bates__ = __webpack_require__(106);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "randomBates", function() { return __WEBPACK_IMPORTED_MODULE_3__src_bates__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_irwinHall__ = __webpack_require__(26);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "randomIrwinHall", function() { return __WEBPACK_IMPORTED_MODULE_4__src_irwinHall__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_exponential__ = __webpack_require__(107);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "randomExponential", function() { return __WEBPACK_IMPORTED_MODULE_5__src_exponential__["a"]; });








/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__irwinHall__ = __webpack_require__(26);


/* harmony default export */ __webpack_exports__["a"] = (function(n) {
  var randomIrwinHall = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__irwinHall__["a" /* default */])(n);
  return function() {
    return randomIrwinHall() / n;
  };
});


/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(lambda) {
  return function() {
    return -Math.log(1 - Math.random()) / lambda;
  };
});


/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__normal__ = __webpack_require__(27);


/* harmony default export */ __webpack_exports__["a"] = (function() {
  var randomNormal = __WEBPACK_IMPORTED_MODULE_0__normal__["a" /* default */].apply(this, arguments);
  return function() {
    return Math.exp(randomNormal());
  };
});


/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(min, max) {
  min = min == null ? 0 : +min;
  max = max == null ? 1 : +max;
  if (arguments.length === 1) max = min, min = 0;
  else max -= min;
  return function() {
    return Math.random() * max + min;
  };
});


/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_interval__ = __webpack_require__(2);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeInterval", function() { return __WEBPACK_IMPORTED_MODULE_0__src_interval__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_millisecond__ = __webpack_require__(113);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeMillisecond", function() { return __WEBPACK_IMPORTED_MODULE_1__src_millisecond__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeMilliseconds", function() { return __WEBPACK_IMPORTED_MODULE_1__src_millisecond__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcMillisecond", function() { return __WEBPACK_IMPORTED_MODULE_1__src_millisecond__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcMilliseconds", function() { return __WEBPACK_IMPORTED_MODULE_1__src_millisecond__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_second__ = __webpack_require__(116);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeSecond", function() { return __WEBPACK_IMPORTED_MODULE_2__src_second__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeSeconds", function() { return __WEBPACK_IMPORTED_MODULE_2__src_second__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcSecond", function() { return __WEBPACK_IMPORTED_MODULE_2__src_second__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcSeconds", function() { return __WEBPACK_IMPORTED_MODULE_2__src_second__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_minute__ = __webpack_require__(114);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeMinute", function() { return __WEBPACK_IMPORTED_MODULE_3__src_minute__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeMinutes", function() { return __WEBPACK_IMPORTED_MODULE_3__src_minute__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_hour__ = __webpack_require__(112);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeHour", function() { return __WEBPACK_IMPORTED_MODULE_4__src_hour__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeHours", function() { return __WEBPACK_IMPORTED_MODULE_4__src_hour__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_day__ = __webpack_require__(111);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeDay", function() { return __WEBPACK_IMPORTED_MODULE_5__src_day__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeDays", function() { return __WEBPACK_IMPORTED_MODULE_5__src_day__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_week__ = __webpack_require__(123);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeWeek", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeWeeks", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeSunday", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeSundays", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeMonday", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeMondays", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeTuesday", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["e"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeTuesdays", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["f"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeWednesday", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["g"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeWednesdays", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["h"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeThursday", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["i"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeThursdays", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["j"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeFriday", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["k"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeFridays", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["l"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeSaturday", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["m"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeSaturdays", function() { return __WEBPACK_IMPORTED_MODULE_6__src_week__["n"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_month__ = __webpack_require__(115);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeMonth", function() { return __WEBPACK_IMPORTED_MODULE_7__src_month__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeMonths", function() { return __WEBPACK_IMPORTED_MODULE_7__src_month__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_year__ = __webpack_require__(124);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeYear", function() { return __WEBPACK_IMPORTED_MODULE_8__src_year__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "timeYears", function() { return __WEBPACK_IMPORTED_MODULE_8__src_year__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_utcMinute__ = __webpack_require__(119);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcMinute", function() { return __WEBPACK_IMPORTED_MODULE_9__src_utcMinute__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcMinutes", function() { return __WEBPACK_IMPORTED_MODULE_9__src_utcMinute__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_utcHour__ = __webpack_require__(118);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcHour", function() { return __WEBPACK_IMPORTED_MODULE_10__src_utcHour__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcHours", function() { return __WEBPACK_IMPORTED_MODULE_10__src_utcHour__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_utcDay__ = __webpack_require__(117);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcDay", function() { return __WEBPACK_IMPORTED_MODULE_11__src_utcDay__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcDays", function() { return __WEBPACK_IMPORTED_MODULE_11__src_utcDay__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__ = __webpack_require__(121);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcWeek", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcWeeks", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcSunday", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcSundays", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcMonday", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcMondays", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcTuesday", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["e"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcTuesdays", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["f"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcWednesday", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["g"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcWednesdays", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["h"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcThursday", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["i"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcThursdays", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["j"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcFriday", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["k"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcFridays", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["l"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcSaturday", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["m"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcSaturdays", function() { return __WEBPACK_IMPORTED_MODULE_12__src_utcWeek__["n"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_utcMonth__ = __webpack_require__(120);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcMonth", function() { return __WEBPACK_IMPORTED_MODULE_13__src_utcMonth__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcMonths", function() { return __WEBPACK_IMPORTED_MODULE_13__src_utcMonth__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_utcYear__ = __webpack_require__(122);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcYear", function() { return __WEBPACK_IMPORTED_MODULE_14__src_utcYear__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "utcYears", function() { return __WEBPACK_IMPORTED_MODULE_14__src_utcYear__["b"]; });































/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(3);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return days; });



var day = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * __WEBPACK_IMPORTED_MODULE_1__duration__["d" /* durationMinute */]) / __WEBPACK_IMPORTED_MODULE_1__duration__["b" /* durationDay */];
}, function(date) {
  return date.getDate() - 1;
});

/* harmony default export */ __webpack_exports__["a"] = (day);
var days = day.range;


/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(3);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return hours; });



var hour = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  var offset = date.getTimezoneOffset() * __WEBPACK_IMPORTED_MODULE_1__duration__["d" /* durationMinute */] % __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationHour */];
  if (offset < 0) offset += __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationHour */];
  date.setTime(Math.floor((+date - offset) / __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationHour */]) * __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationHour */] + offset);
}, function(date, step) {
  date.setTime(+date + step * __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationHour */]);
}, function(start, end) {
  return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationHour */];
}, function(date) {
  return date.getHours();
});

/* harmony default export */ __webpack_exports__["a"] = (hour);
var hours = hour.range;


/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(2);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return milliseconds; });


var millisecond = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

/* harmony default export */ __webpack_exports__["a"] = (millisecond);
var milliseconds = millisecond.range;


/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(3);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return minutes; });



var minute = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setTime(Math.floor(date / __WEBPACK_IMPORTED_MODULE_1__duration__["d" /* durationMinute */]) * __WEBPACK_IMPORTED_MODULE_1__duration__["d" /* durationMinute */]);
}, function(date, step) {
  date.setTime(+date + step * __WEBPACK_IMPORTED_MODULE_1__duration__["d" /* durationMinute */]);
}, function(start, end) {
  return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["d" /* durationMinute */];
}, function(date) {
  return date.getMinutes();
});

/* harmony default export */ __webpack_exports__["a"] = (minute);
var minutes = minute.range;


/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(2);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return months; });


var month = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

/* harmony default export */ __webpack_exports__["a"] = (month);
var months = month.range;


/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(3);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return seconds; });



var second = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setTime(Math.floor(date / __WEBPACK_IMPORTED_MODULE_1__duration__["e" /* durationSecond */]) * __WEBPACK_IMPORTED_MODULE_1__duration__["e" /* durationSecond */]);
}, function(date, step) {
  date.setTime(+date + step * __WEBPACK_IMPORTED_MODULE_1__duration__["e" /* durationSecond */]);
}, function(start, end) {
  return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["e" /* durationSecond */];
}, function(date) {
  return date.getUTCSeconds();
});

/* harmony default export */ __webpack_exports__["a"] = (second);
var seconds = second.range;


/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(3);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return utcDays; });



var utcDay = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["b" /* durationDay */];
}, function(date) {
  return date.getUTCDate() - 1;
});

/* harmony default export */ __webpack_exports__["a"] = (utcDay);
var utcDays = utcDay.range;


/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(3);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return utcHours; });



var utcHour = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationHour */]);
}, function(start, end) {
  return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["c" /* durationHour */];
}, function(date) {
  return date.getUTCHours();
});

/* harmony default export */ __webpack_exports__["a"] = (utcHour);
var utcHours = utcHour.range;


/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(3);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return utcMinutes; });



var utcMinute = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * __WEBPACK_IMPORTED_MODULE_1__duration__["d" /* durationMinute */]);
}, function(start, end) {
  return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["d" /* durationMinute */];
}, function(date) {
  return date.getUTCMinutes();
});

/* harmony default export */ __webpack_exports__["a"] = (utcMinute);
var utcMinutes = utcMinute.range;


/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(2);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return utcMonths; });


var utcMonth = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

/* harmony default export */ __webpack_exports__["a"] = (utcMonth);
var utcMonths = utcMonth.range;


/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(3);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return utcSunday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return utcMonday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return utcTuesday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return utcWednesday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return utcThursday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return utcFriday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return utcSaturday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return utcSundays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return utcMondays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return utcTuesdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return utcWednesdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return utcThursdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return utcFridays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return utcSaturdays; });



function utcWeekday(i) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / __WEBPACK_IMPORTED_MODULE_1__duration__["a" /* durationWeek */];
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;


/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(2);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return utcYears; });


var utcYear = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

/* harmony default export */ __webpack_exports__["a"] = (utcYear);
var utcYears = utcYear.range;


/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__duration__ = __webpack_require__(3);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return sunday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return monday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return tuesday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return wednesday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return thursday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return friday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return saturday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return sundays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return mondays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return tuesdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return wednesdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return thursdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return fridays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return saturdays; });



function weekday(i) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * __WEBPACK_IMPORTED_MODULE_1__duration__["d" /* durationMinute */]) / __WEBPACK_IMPORTED_MODULE_1__duration__["a" /* durationWeek */];
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;


/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interval__ = __webpack_require__(2);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return years; });


var year = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__interval__["a" /* default */])(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

/* harmony default export */ __webpack_exports__["a"] = (year);
var years = year.range;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
   true ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.fc = global.fc || {})));
}(this, (function (exports) { 'use strict';

var createReboundMethod = (function (target, source, name) {
    var method = source[name];
    if (typeof method !== 'function') {
        throw new Error('Attempt to rebind ' + name + ' which isn\'t a function on the source object');
    }
    return function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var value = method.apply(source, args);
        return value === source ? target : value;
    };
});

var rebind = (function (target, source) {
    for (var _len = arguments.length, names = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        names[_key - 2] = arguments[_key];
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = names[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var name = _step.value;

            target[name] = createReboundMethod(target, source, name);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return target;
});

var createTransform = function createTransform(transforms) {
    return function (name) {
        return transforms.reduce(function (name, fn) {
            return name && fn(name);
        }, name);
    };
};

var rebindAll = (function (target, source) {
    for (var _len = arguments.length, transforms = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        transforms[_key - 2] = arguments[_key];
    }

    var transform = createTransform(transforms);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = Object.keys(source)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var name = _step.value;

            var result = transform(name);
            if (result) {
                target[result] = createReboundMethod(target, source, name);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return target;
});

var regexify = (function (strsOrRegexes) {
    return strsOrRegexes.map(function (strOrRegex) {
        return typeof strOrRegex === 'string' ? new RegExp('^' + strOrRegex + '$') : strOrRegex;
    });
});

var exclude = (function () {
    for (var _len = arguments.length, exclusions = Array(_len), _key = 0; _key < _len; _key++) {
        exclusions[_key] = arguments[_key];
    }

    exclusions = regexify(exclusions);
    return function (name) {
        return exclusions.every(function (exclusion) {
            return !exclusion.test(name);
        }) && name;
    };
});

var include = (function () {
    for (var _len = arguments.length, inclusions = Array(_len), _key = 0; _key < _len; _key++) {
        inclusions[_key] = arguments[_key];
    }

    inclusions = regexify(inclusions);
    return function (name) {
        return inclusions.some(function (inclusion) {
            return inclusion.test(name);
        }) && name;
    };
});

var includeMap = (function (mappings) {
  return function (name) {
    return mappings[name];
  };
});

var capitalizeFirstLetter = function capitalizeFirstLetter(str) {
  return str[0].toUpperCase() + str.slice(1);
};

var prefix = (function (prefix) {
  return function (name) {
    return prefix + capitalizeFirstLetter(name);
  };
});

exports.rebind = rebind;
exports.rebindAll = rebindAll;
exports.exclude = exclude;
exports.include = include;
exports.includeMap = includeMap;
exports.prefix = prefix;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * deep-diff.
 * Licensed under the MIT License.
 */
;(function(root, factory) {
  'use strict';
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
      return factory();
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.DeepDiff = factory();
  }
}(this, function(undefined) {
  'use strict';

  var $scope, conflict, conflictResolution = [];
  if (typeof global === 'object' && global) {
    $scope = global;
  } else if (typeof window !== 'undefined') {
    $scope = window;
  } else {
    $scope = {};
  }
  conflict = $scope.DeepDiff;
  if (conflict) {
    conflictResolution.push(
      function() {
        if ('undefined' !== typeof conflict && $scope.DeepDiff === accumulateDiff) {
          $scope.DeepDiff = conflict;
          conflict = undefined;
        }
      });
  }

  // nodejs compatible on server side and in the browser.
  function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  }

  function Diff(kind, path) {
    Object.defineProperty(this, 'kind', {
      value: kind,
      enumerable: true
    });
    if (path && path.length) {
      Object.defineProperty(this, 'path', {
        value: path,
        enumerable: true
      });
    }
  }

  function DiffEdit(path, origin, value) {
    DiffEdit.super_.call(this, 'E', path);
    Object.defineProperty(this, 'lhs', {
      value: origin,
      enumerable: true
    });
    Object.defineProperty(this, 'rhs', {
      value: value,
      enumerable: true
    });
  }
  inherits(DiffEdit, Diff);

  function DiffNew(path, value) {
    DiffNew.super_.call(this, 'N', path);
    Object.defineProperty(this, 'rhs', {
      value: value,
      enumerable: true
    });
  }
  inherits(DiffNew, Diff);

  function DiffDeleted(path, value) {
    DiffDeleted.super_.call(this, 'D', path);
    Object.defineProperty(this, 'lhs', {
      value: value,
      enumerable: true
    });
  }
  inherits(DiffDeleted, Diff);

  function DiffArray(path, index, item) {
    DiffArray.super_.call(this, 'A', path);
    Object.defineProperty(this, 'index', {
      value: index,
      enumerable: true
    });
    Object.defineProperty(this, 'item', {
      value: item,
      enumerable: true
    });
  }
  inherits(DiffArray, Diff);

  function arrayRemove(arr, from, to) {
    var rest = arr.slice((to || from) + 1 || arr.length);
    arr.length = from < 0 ? arr.length + from : from;
    arr.push.apply(arr, rest);
    return arr;
  }

  function realTypeOf(subject) {
    var type = typeof subject;
    if (type !== 'object') {
      return type;
    }

    if (subject === Math) {
      return 'math';
    } else if (subject === null) {
      return 'null';
    } else if (Array.isArray(subject)) {
      return 'array';
    } else if (Object.prototype.toString.call(subject) === '[object Date]') {
      return 'date';
    } else if (typeof subject.toString !== 'undefined' && /^\/.*\//.test(subject.toString())) {
      return 'regexp';
    }
    return 'object';
  }

  function deepDiff(lhs, rhs, changes, prefilter, path, key, stack) {
    path = path || [];
    var currentPath = path.slice(0);
    if (typeof key !== 'undefined') {
      if (prefilter) {
        if (typeof(prefilter) === 'function' && prefilter(currentPath, key)) { return; }
        else if (typeof(prefilter) === 'object') {
          if (prefilter.prefilter && prefilter.prefilter(currentPath, key)) { return; }
          if (prefilter.normalize) {
            var alt = prefilter.normalize(currentPath, key, lhs, rhs);
            if (alt) {
              lhs = alt[0];
              rhs = alt[1];
            }
          }
        }
      }
      currentPath.push(key);
    }

    // Use string comparison for regexes
    if (realTypeOf(lhs) === 'regexp' && realTypeOf(rhs) === 'regexp') {
      lhs = lhs.toString();
      rhs = rhs.toString();
    }

    var ltype = typeof lhs;
    var rtype = typeof rhs;
    if (ltype === 'undefined') {
      if (rtype !== 'undefined') {
        changes(new DiffNew(currentPath, rhs));
      }
    } else if (rtype === 'undefined') {
      changes(new DiffDeleted(currentPath, lhs));
    } else if (realTypeOf(lhs) !== realTypeOf(rhs)) {
      changes(new DiffEdit(currentPath, lhs, rhs));
    } else if (Object.prototype.toString.call(lhs) === '[object Date]' && Object.prototype.toString.call(rhs) === '[object Date]' && ((lhs - rhs) !== 0)) {
      changes(new DiffEdit(currentPath, lhs, rhs));
    } else if (ltype === 'object' && lhs !== null && rhs !== null) {
      stack = stack || [];
      if (stack.indexOf(lhs) < 0) {
        stack.push(lhs);
        if (Array.isArray(lhs)) {
          var i, len = lhs.length;
          for (i = 0; i < lhs.length; i++) {
            if (i >= rhs.length) {
              changes(new DiffArray(currentPath, i, new DiffDeleted(undefined, lhs[i])));
            } else {
              deepDiff(lhs[i], rhs[i], changes, prefilter, currentPath, i, stack);
            }
          }
          while (i < rhs.length) {
            changes(new DiffArray(currentPath, i, new DiffNew(undefined, rhs[i++])));
          }
        } else {
          var akeys = Object.keys(lhs);
          var pkeys = Object.keys(rhs);
          akeys.forEach(function(k, i) {
            var other = pkeys.indexOf(k);
            if (other >= 0) {
              deepDiff(lhs[k], rhs[k], changes, prefilter, currentPath, k, stack);
              pkeys = arrayRemove(pkeys, other);
            } else {
              deepDiff(lhs[k], undefined, changes, prefilter, currentPath, k, stack);
            }
          });
          pkeys.forEach(function(k) {
            deepDiff(undefined, rhs[k], changes, prefilter, currentPath, k, stack);
          });
        }
        stack.length = stack.length - 1;
      }
    } else if (lhs !== rhs) {
      if (!(ltype === 'number' && isNaN(lhs) && isNaN(rhs))) {
        changes(new DiffEdit(currentPath, lhs, rhs));
      }
    }
  }

  function accumulateDiff(lhs, rhs, prefilter, accum) {
    accum = accum || [];
    deepDiff(lhs, rhs,
      function(diff) {
        if (diff) {
          accum.push(diff);
        }
      },
      prefilter);
    return (accum.length) ? accum : undefined;
  }

  function applyArrayChange(arr, index, change) {
    if (change.path && change.path.length) {
      var it = arr[index],
          i, u = change.path.length - 1;
      for (i = 0; i < u; i++) {
        it = it[change.path[i]];
      }
      switch (change.kind) {
        case 'A':
          applyArrayChange(it[change.path[i]], change.index, change.item);
          break;
        case 'D':
          delete it[change.path[i]];
          break;
        case 'E':
        case 'N':
          it[change.path[i]] = change.rhs;
          break;
      }
    } else {
      switch (change.kind) {
        case 'A':
          applyArrayChange(arr[index], change.index, change.item);
          break;
        case 'D':
          arr = arrayRemove(arr, index);
          break;
        case 'E':
        case 'N':
          arr[index] = change.rhs;
          break;
      }
    }
    return arr;
  }

  function applyChange(target, source, change) {
    if (target && source && change && change.kind) {
      var it = target,
          i = -1,
          last = change.path ? change.path.length - 1 : 0;
      while (++i < last) {
        if (typeof it[change.path[i]] === 'undefined') {
          it[change.path[i]] = (typeof change.path[i] === 'number') ? [] : {};
        }
        it = it[change.path[i]];
      }
      switch (change.kind) {
        case 'A':
          applyArrayChange(change.path ? it[change.path[i]] : it, change.index, change.item);
          break;
        case 'D':
          delete it[change.path[i]];
          break;
        case 'E':
        case 'N':
          it[change.path[i]] = change.rhs;
          break;
      }
    }
  }

  function revertArrayChange(arr, index, change) {
    if (change.path && change.path.length) {
      // the structure of the object at the index has changed...
      var it = arr[index],
          i, u = change.path.length - 1;
      for (i = 0; i < u; i++) {
        it = it[change.path[i]];
      }
      switch (change.kind) {
        case 'A':
          revertArrayChange(it[change.path[i]], change.index, change.item);
          break;
        case 'D':
          it[change.path[i]] = change.lhs;
          break;
        case 'E':
          it[change.path[i]] = change.lhs;
          break;
        case 'N':
          delete it[change.path[i]];
          break;
      }
    } else {
      // the array item is different...
      switch (change.kind) {
        case 'A':
          revertArrayChange(arr[index], change.index, change.item);
          break;
        case 'D':
          arr[index] = change.lhs;
          break;
        case 'E':
          arr[index] = change.lhs;
          break;
        case 'N':
          arr = arrayRemove(arr, index);
          break;
      }
    }
    return arr;
  }

  function revertChange(target, source, change) {
    if (target && source && change && change.kind) {
      var it = target,
          i, u;
      u = change.path.length - 1;
      for (i = 0; i < u; i++) {
        if (typeof it[change.path[i]] === 'undefined') {
          it[change.path[i]] = {};
        }
        it = it[change.path[i]];
      }
      switch (change.kind) {
        case 'A':
          // Array was modified...
          // it will be an array...
          revertArrayChange(it[change.path[i]], change.index, change.item);
          break;
        case 'D':
          // Item was deleted...
          it[change.path[i]] = change.lhs;
          break;
        case 'E':
          // Item was edited...
          it[change.path[i]] = change.lhs;
          break;
        case 'N':
          // Item is new...
          delete it[change.path[i]];
          break;
      }
    }
  }

  function applyDiff(target, source, filter) {
    if (target && source) {
      var onChange = function(change) {
        if (!filter || filter(target, source, change)) {
          applyChange(target, source, change);
        }
      };
      deepDiff(target, source, onChange);
    }
  }

  Object.defineProperties(accumulateDiff, {

    diff: {
      value: accumulateDiff,
      enumerable: true
    },
    observableDiff: {
      value: deepDiff,
      enumerable: true
    },
    applyDiff: {
      value: applyDiff,
      enumerable: true
    },
    applyChange: {
      value: applyChange,
      enumerable: true
    },
    revertChange: {
      value: revertChange,
      enumerable: true
    },
    isConflict: {
      value: function() {
        return 'undefined' !== typeof conflict;
      },
      enumerable: true
    },
    noConflict: {
      value: function() {
        if (conflictResolution) {
          conflictResolution.forEach(function(it) {
            it();
          });
          conflictResolution = null;
        }
        return accumulateDiff;
      },
      enumerable: true
    }
  });

  return accumulateDiff;
}));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var camelize = __webpack_require__(127);

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var hyphenate = __webpack_require__(129);

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var isNode = __webpack_require__(131);

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(34)

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ }),
/* 135 */
/***/ (function(module, exports) {

/*
 Highstock JS v6.0.4 (2017-12-15)

 (c) 2009-2016 Torstein Honsi

 License: www.highcharts.com/license
*/
(function(Q,L){"object"===typeof module&&module.exports?module.exports=Q.document?L(Q):L:Q.Highcharts=L(Q)})("undefined"!==typeof window?window:this,function(Q){var L=function(){var a="undefined"===typeof Q?window:Q,G=a.document,E=a.navigator&&a.navigator.userAgent||"",H=G&&G.createElementNS&&!!G.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect,v=/(edge|msie|trident)/i.test(E)&&!a.opera,k=/Firefox/.test(E),q=k&&4>parseInt(E.split("Firefox/")[1],10);return a.Highcharts?a.Highcharts.error(16,
!0):{product:"Highstock",version:"6.0.4",deg2rad:2*Math.PI/360,doc:G,hasBidiBug:q,hasTouch:G&&void 0!==G.documentElement.ontouchstart,isMS:v,isWebKit:/AppleWebKit/.test(E),isFirefox:k,isTouchDevice:/(Mobile|Android|Windows Phone)/.test(E),SVG_NS:"http://www.w3.org/2000/svg",chartCount:0,seriesTypes:{},symbolSizes:{},svg:H,win:a,marginNames:["plotTop","marginRight","marginBottom","plotLeft"],noop:function(){},charts:[]}}();(function(a){a.timers=[];var G=a.charts,E=a.doc,H=a.win;a.error=function(v,
k){v=a.isNumber(v)?"Highcharts error #"+v+": www.highcharts.com/errors/"+v:v;if(k)throw Error(v);H.console&&console.log(v)};a.Fx=function(a,k,q){this.options=k;this.elem=a;this.prop=q};a.Fx.prototype={dSetter:function(){var a=this.paths[0],k=this.paths[1],q=[],w=this.now,t=a.length,u;if(1===w)q=this.toD;else if(t===k.length&&1>w)for(;t--;)u=parseFloat(a[t]),q[t]=isNaN(u)?k[t]:w*parseFloat(k[t]-u)+u;else q=k;this.elem.attr("d",q,null,!0)},update:function(){var a=this.elem,k=this.prop,q=this.now,w=
this.options.step;if(this[k+"Setter"])this[k+"Setter"]();else a.attr?a.element&&a.attr(k,q,null,!0):a.style[k]=q+this.unit;w&&w.call(a,q,this)},run:function(v,k,q){var w=this,t=w.options,u=function(a){return u.stopped?!1:w.step(a)},z=H.requestAnimationFrame||function(a){setTimeout(a,13)},m=function(){for(var g=0;g<a.timers.length;g++)a.timers[g]()||a.timers.splice(g--,1);a.timers.length&&z(m)};v===k?(delete t.curAnim[this.prop],t.complete&&0===a.keys(t.curAnim).length&&t.complete.call(this.elem)):
(this.startTime=+new Date,this.start=v,this.end=k,this.unit=q,this.now=this.start,this.pos=0,u.elem=this.elem,u.prop=this.prop,u()&&1===a.timers.push(u)&&z(m))},step:function(v){var k=+new Date,q,w=this.options,t=this.elem,u=w.complete,z=w.duration,m=w.curAnim;t.attr&&!t.element?v=!1:v||k>=z+this.startTime?(this.now=this.end,this.pos=1,this.update(),q=m[this.prop]=!0,a.objectEach(m,function(a){!0!==a&&(q=!1)}),q&&u&&u.call(t),v=!1):(this.pos=w.easing((k-this.startTime)/z),this.now=this.start+(this.end-
this.start)*this.pos,this.update(),v=!0);return v},initPath:function(v,k,q){function w(a){var b,c;for(r=a.length;r--;)b="M"===a[r]||"L"===a[r],c=/[a-zA-Z]/.test(a[r+3]),b&&c&&a.splice(r+1,0,a[r+1],a[r+2],a[r+1],a[r+2])}function t(a,b){for(;a.length<c;){a[0]=b[c-a.length];var n=a.slice(0,e);[].splice.apply(a,[0,0].concat(n));l&&(n=a.slice(a.length-e),[].splice.apply(a,[a.length,0].concat(n)),r--)}a[0]="M"}function u(a,r){for(var n=(c-a.length)/e;0<n&&n--;)b=a.slice().splice(a.length/C-e,e*C),b[0]=
r[c-e-n*e],f&&(b[e-6]=b[e-2],b[e-5]=b[e-1]),[].splice.apply(a,[a.length/C,0].concat(b)),l&&n--}k=k||"";var z,m=v.startX,g=v.endX,f=-1<k.indexOf("C"),e=f?7:3,c,b,r;k=k.split(" ");q=q.slice();var l=v.isArea,C=l?2:1,I;f&&(w(k),w(q));if(m&&g){for(r=0;r<m.length;r++)if(m[r]===g[0]){z=r;break}else if(m[0]===g[g.length-m.length+r]){z=r;I=!0;break}void 0===z&&(k=[])}k.length&&a.isNumber(z)&&(c=q.length+z*C*e,I?(t(k,q),u(q,k)):(t(q,k),u(k,q)));return[k,q]}};a.Fx.prototype.fillSetter=a.Fx.prototype.strokeSetter=
function(){this.elem.attr(this.prop,a.color(this.start).tweenTo(a.color(this.end),this.pos),null,!0)};a.extend=function(a,k){var q;a||(a={});for(q in k)a[q]=k[q];return a};a.merge=function(){var v,k=arguments,q,w={},t=function(u,q){"object"!==typeof u&&(u={});a.objectEach(q,function(m,g){!a.isObject(m,!0)||a.isClass(m)||a.isDOMElement(m)?u[g]=q[g]:u[g]=t(u[g]||{},m)});return u};!0===k[0]&&(w=k[1],k=Array.prototype.slice.call(k,2));q=k.length;for(v=0;v<q;v++)w=t(w,k[v]);return w};a.pInt=function(a,
k){return parseInt(a,k||10)};a.isString=function(a){return"string"===typeof a};a.isArray=function(a){a=Object.prototype.toString.call(a);return"[object Array]"===a||"[object Array Iterator]"===a};a.isObject=function(v,k){return!!v&&"object"===typeof v&&(!k||!a.isArray(v))};a.isDOMElement=function(v){return a.isObject(v)&&"number"===typeof v.nodeType};a.isClass=function(v){var k=v&&v.constructor;return!(!a.isObject(v,!0)||a.isDOMElement(v)||!k||!k.name||"Object"===k.name)};a.isNumber=function(a){return"number"===
typeof a&&!isNaN(a)&&Infinity>a&&-Infinity<a};a.erase=function(a,k){for(var q=a.length;q--;)if(a[q]===k){a.splice(q,1);break}};a.defined=function(a){return void 0!==a&&null!==a};a.attr=function(v,k,q){var w;a.isString(k)?a.defined(q)?v.setAttribute(k,q):v&&v.getAttribute&&(w=v.getAttribute(k)):a.defined(k)&&a.isObject(k)&&a.objectEach(k,function(a,u){v.setAttribute(u,a)});return w};a.splat=function(v){return a.isArray(v)?v:[v]};a.syncTimeout=function(a,k,q){if(k)return setTimeout(a,k,q);a.call(0,
q)};a.pick=function(){var a=arguments,k,q,w=a.length;for(k=0;k<w;k++)if(q=a[k],void 0!==q&&null!==q)return q};a.css=function(v,k){a.isMS&&!a.svg&&k&&void 0!==k.opacity&&(k.filter="alpha(opacity\x3d"+100*k.opacity+")");a.extend(v.style,k)};a.createElement=function(v,k,q,w,t){v=E.createElement(v);var u=a.css;k&&a.extend(v,k);t&&u(v,{padding:0,border:"none",margin:0});q&&u(v,q);w&&w.appendChild(v);return v};a.extendClass=function(v,k){var q=function(){};q.prototype=new v;a.extend(q.prototype,k);return q};
a.pad=function(a,k,q){return Array((k||2)+1-String(a).length).join(q||0)+a};a.relativeLength=function(a,k,q){return/%$/.test(a)?k*parseFloat(a)/100+(q||0):parseFloat(a)};a.wrap=function(a,k,q){var v=a[k];a[k]=function(){var a=Array.prototype.slice.call(arguments),u=arguments,z=this;z.proceed=function(){v.apply(z,arguments.length?arguments:u)};a.unshift(v);a=q.apply(this,a);z.proceed=null;return a}};a.getTZOffset=function(v){var k=a.Date;return 6E4*(k.hcGetTimezoneOffset&&k.hcGetTimezoneOffset(v)||
k.hcTimezoneOffset||0)};a.dateFormat=function(v,k,q){if(!a.defined(k)||isNaN(k))return a.defaultOptions.lang.invalidDate||"";v=a.pick(v,"%Y-%m-%d %H:%M:%S");var w=a.Date,t=new w(k-a.getTZOffset(k)),u=t[w.hcGetHours](),z=t[w.hcGetDay](),m=t[w.hcGetDate](),g=t[w.hcGetMonth](),f=t[w.hcGetFullYear](),e=a.defaultOptions.lang,c=e.weekdays,b=e.shortWeekdays,r=a.pad,w=a.extend({a:b?b[z]:c[z].substr(0,3),A:c[z],d:r(m),e:r(m,2," "),w:z,b:e.shortMonths[g],B:e.months[g],m:r(g+1),y:f.toString().substr(2,2),Y:f,
H:r(u),k:u,I:r(u%12||12),l:u%12||12,M:r(t[w.hcGetMinutes]()),p:12>u?"AM":"PM",P:12>u?"am":"pm",S:r(t.getSeconds()),L:r(Math.round(k%1E3),3)},a.dateFormats);a.objectEach(w,function(a,b){for(;-1!==v.indexOf("%"+b);)v=v.replace("%"+b,"function"===typeof a?a(k):a)});return q?v.substr(0,1).toUpperCase()+v.substr(1):v};a.formatSingle=function(v,k){var q=/\.([0-9])/,w=a.defaultOptions.lang;/f$/.test(v)?(q=(q=v.match(q))?q[1]:-1,null!==k&&(k=a.numberFormat(k,q,w.decimalPoint,-1<v.indexOf(",")?w.thousandsSep:
""))):k=a.dateFormat(v,k);return k};a.format=function(v,k){for(var q="{",w=!1,t,u,z,m,g=[],f;v;){q=v.indexOf(q);if(-1===q)break;t=v.slice(0,q);if(w){t=t.split(":");u=t.shift().split(".");m=u.length;f=k;for(z=0;z<m;z++)f&&(f=f[u[z]]);t.length&&(f=a.formatSingle(t.join(":"),f));g.push(f)}else g.push(t);v=v.slice(q+1);q=(w=!w)?"}":"{"}g.push(v);return g.join("")};a.getMagnitude=function(a){return Math.pow(10,Math.floor(Math.log(a)/Math.LN10))};a.normalizeTickInterval=function(v,k,q,w,t){var u,z=v;q=
a.pick(q,1);u=v/q;k||(k=t?[1,1.2,1.5,2,2.5,3,4,5,6,8,10]:[1,2,2.5,5,10],!1===w&&(1===q?k=a.grep(k,function(a){return 0===a%1}):.1>=q&&(k=[1/q])));for(w=0;w<k.length&&!(z=k[w],t&&z*q>=v||!t&&u<=(k[w]+(k[w+1]||k[w]))/2);w++);return z=a.correctFloat(z*q,-Math.round(Math.log(.001)/Math.LN10))};a.stableSort=function(a,k){var q=a.length,v,t;for(t=0;t<q;t++)a[t].safeI=t;a.sort(function(a,t){v=k(a,t);return 0===v?a.safeI-t.safeI:v});for(t=0;t<q;t++)delete a[t].safeI};a.arrayMin=function(a){for(var k=a.length,
q=a[0];k--;)a[k]<q&&(q=a[k]);return q};a.arrayMax=function(a){for(var k=a.length,q=a[0];k--;)a[k]>q&&(q=a[k]);return q};a.destroyObjectProperties=function(v,k){a.objectEach(v,function(a,w){a&&a!==k&&a.destroy&&a.destroy();delete v[w]})};a.discardElement=function(v){var k=a.garbageBin;k||(k=a.createElement("div"));v&&k.appendChild(v);k.innerHTML=""};a.correctFloat=function(a,k){return parseFloat(a.toPrecision(k||14))};a.setAnimation=function(v,k){k.renderer.globalAnimation=a.pick(v,k.options.chart.animation,
!0)};a.animObject=function(v){return a.isObject(v)?a.merge(v):{duration:v?500:0}};a.timeUnits={millisecond:1,second:1E3,minute:6E4,hour:36E5,day:864E5,week:6048E5,month:24192E5,year:314496E5};a.numberFormat=function(v,k,q,w){v=+v||0;k=+k;var t=a.defaultOptions.lang,u=(v.toString().split(".")[1]||"").split("e")[0].length,z,m,g=v.toString().split("e");-1===k?k=Math.min(u,20):a.isNumber(k)?k&&g[1]&&0>g[1]&&(z=k+ +g[1],0<=z?(g[0]=(+g[0]).toExponential(z).split("e")[0],k=z):(g[0]=g[0].split(".")[0]||0,
v=20>k?(g[0]*Math.pow(10,g[1])).toFixed(k):0,g[1]=0)):k=2;m=(Math.abs(g[1]?g[0]:v)+Math.pow(10,-Math.max(k,u)-1)).toFixed(k);u=String(a.pInt(m));z=3<u.length?u.length%3:0;q=a.pick(q,t.decimalPoint);w=a.pick(w,t.thousandsSep);v=(0>v?"-":"")+(z?u.substr(0,z)+w:"");v+=u.substr(z).replace(/(\d{3})(?=\d)/g,"$1"+w);k&&(v+=q+m.slice(-k));g[1]&&0!==+v&&(v+="e"+g[1]);return v};Math.easeInOutSine=function(a){return-.5*(Math.cos(Math.PI*a)-1)};a.getStyle=function(v,k,q){if("width"===k)return Math.min(v.offsetWidth,
v.scrollWidth)-a.getStyle(v,"padding-left")-a.getStyle(v,"padding-right");if("height"===k)return Math.min(v.offsetHeight,v.scrollHeight)-a.getStyle(v,"padding-top")-a.getStyle(v,"padding-bottom");H.getComputedStyle||a.error(27,!0);if(v=H.getComputedStyle(v,void 0))v=v.getPropertyValue(k),a.pick(q,"opacity"!==k)&&(v=a.pInt(v));return v};a.inArray=function(v,k){return(a.indexOfPolyfill||Array.prototype.indexOf).call(k,v)};a.grep=function(v,k){return(a.filterPolyfill||Array.prototype.filter).call(v,
k)};a.find=Array.prototype.find?function(a,k){return a.find(k)}:function(a,k){var q,w=a.length;for(q=0;q<w;q++)if(k(a[q],q))return a[q]};a.map=function(a,k){for(var q=[],w=0,t=a.length;w<t;w++)q[w]=k.call(a[w],a[w],w,a);return q};a.keys=function(v){return(a.keysPolyfill||Object.keys).call(void 0,v)};a.reduce=function(v,k,q){return(a.reducePolyfill||Array.prototype.reduce).call(v,k,q)};a.offset=function(a){var k=E.documentElement;a=a.parentElement?a.getBoundingClientRect():{top:0,left:0};return{top:a.top+
(H.pageYOffset||k.scrollTop)-(k.clientTop||0),left:a.left+(H.pageXOffset||k.scrollLeft)-(k.clientLeft||0)}};a.stop=function(v,k){for(var q=a.timers.length;q--;)a.timers[q].elem!==v||k&&k!==a.timers[q].prop||(a.timers[q].stopped=!0)};a.each=function(v,k,q){return(a.forEachPolyfill||Array.prototype.forEach).call(v,k,q)};a.objectEach=function(a,k,q){for(var w in a)a.hasOwnProperty(w)&&k.call(q,a[w],w,a)};a.addEvent=function(v,k,q){var w,t,u=v.addEventListener||a.addEventListenerPolyfill;v.hcEvents&&
!Object.prototype.hasOwnProperty.call(v,"hcEvents")&&(t={},a.objectEach(v.hcEvents,function(a,m){t[m]=a.slice(0)}),v.hcEvents=t);w=v.hcEvents=v.hcEvents||{};u&&u.call(v,k,q,!1);w[k]||(w[k]=[]);w[k].push(q);return function(){a.removeEvent(v,k,q)}};a.removeEvent=function(v,k,q){function w(g,f){var e=v.removeEventListener||a.removeEventListenerPolyfill;e&&e.call(v,g,f,!1)}function t(){var g,f;v.nodeName&&(k?(g={},g[k]=!0):g=z,a.objectEach(g,function(a,c){if(z[c])for(f=z[c].length;f--;)w(c,z[c][f])}))}
var u,z=v.hcEvents,m;z&&(k?(u=z[k]||[],q?(m=a.inArray(q,u),-1<m&&(u.splice(m,1),z[k]=u),w(k,q)):(t(),z[k]=[])):(t(),v.hcEvents={}))};a.fireEvent=function(v,k,q,w){var t;t=v.hcEvents;var u,z;q=q||{};if(E.createEvent&&(v.dispatchEvent||v.fireEvent))t=E.createEvent("Events"),t.initEvent(k,!0,!0),a.extend(t,q),v.dispatchEvent?v.dispatchEvent(t):v.fireEvent(k,t);else if(t)for(t=t[k]||[],u=t.length,q.target||a.extend(q,{preventDefault:function(){q.defaultPrevented=!0},target:v,type:k}),k=0;k<u;k++)(z=t[k])&&
!1===z.call(v,q)&&q.preventDefault();w&&!q.defaultPrevented&&w(q)};a.animate=function(v,k,q){var w,t="",u,z,m;a.isObject(q)||(m=arguments,q={duration:m[2],easing:m[3],complete:m[4]});a.isNumber(q.duration)||(q.duration=400);q.easing="function"===typeof q.easing?q.easing:Math[q.easing]||Math.easeInOutSine;q.curAnim=a.merge(k);a.objectEach(k,function(g,f){a.stop(v,f);z=new a.Fx(v,q,f);u=null;"d"===f?(z.paths=z.initPath(v,v.d,k.d),z.toD=k.d,w=0,u=1):v.attr?w=v.attr(f):(w=parseFloat(a.getStyle(v,f))||
0,"opacity"!==f&&(t="px"));u||(u=g);u&&u.match&&u.match("px")&&(u=u.replace(/px/g,""));z.run(w,u,t)})};a.seriesType=function(v,k,q,w,t){var u=a.getOptions(),z=a.seriesTypes;u.plotOptions[v]=a.merge(u.plotOptions[k],q);z[v]=a.extendClass(z[k]||function(){},w);z[v].prototype.type=v;t&&(z[v].prototype.pointClass=a.extendClass(a.Point,t));return z[v]};a.uniqueKey=function(){var a=Math.random().toString(36).substring(2,9),k=0;return function(){return"highcharts-"+a+"-"+k++}}();H.jQuery&&(H.jQuery.fn.highcharts=
function(){var v=[].slice.call(arguments);if(this[0])return v[0]?(new (a[a.isString(v[0])?v.shift():"Chart"])(this[0],v[0],v[1]),this):G[a.attr(this[0],"data-highcharts-chart")]})})(L);(function(a){var G=a.each,E=a.isNumber,H=a.map,v=a.merge,k=a.pInt;a.Color=function(q){if(!(this instanceof a.Color))return new a.Color(q);this.init(q)};a.Color.prototype={parsers:[{regex:/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,parse:function(a){return[k(a[1]),k(a[2]),
k(a[3]),parseFloat(a[4],10)]}},{regex:/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,parse:function(a){return[k(a[1]),k(a[2]),k(a[3]),1]}}],names:{none:"rgba(255,255,255,0)",white:"#ffffff",black:"#000000"},init:function(q){var k,t,u,z;if((this.input=q=this.names[q&&q.toLowerCase?q.toLowerCase():""]||q)&&q.stops)this.stops=H(q.stops,function(m){return new a.Color(m[1])});else if(q&&q.charAt&&"#"===q.charAt()&&(k=q.length,q=parseInt(q.substr(1),16),7===k?t=[(q&16711680)>>16,(q&65280)>>
8,q&255,1]:4===k&&(t=[(q&3840)>>4|(q&3840)>>8,(q&240)>>4|q&240,(q&15)<<4|q&15,1])),!t)for(u=this.parsers.length;u--&&!t;)z=this.parsers[u],(k=z.regex.exec(q))&&(t=z.parse(k));this.rgba=t||[]},get:function(a){var q=this.input,t=this.rgba,u;this.stops?(u=v(q),u.stops=[].concat(u.stops),G(this.stops,function(t,m){u.stops[m]=[u.stops[m][0],t.get(a)]})):u=t&&E(t[0])?"rgb"===a||!a&&1===t[3]?"rgb("+t[0]+","+t[1]+","+t[2]+")":"a"===a?t[3]:"rgba("+t.join(",")+")":q;return u},brighten:function(a){var q,t=this.rgba;
if(this.stops)G(this.stops,function(t){t.brighten(a)});else if(E(a)&&0!==a)for(q=0;3>q;q++)t[q]+=k(255*a),0>t[q]&&(t[q]=0),255<t[q]&&(t[q]=255);return this},setOpacity:function(a){this.rgba[3]=a;return this},tweenTo:function(a,k){var t=this.rgba,u=a.rgba;u.length&&t&&t.length?(a=1!==u[3]||1!==t[3],k=(a?"rgba(":"rgb(")+Math.round(u[0]+(t[0]-u[0])*(1-k))+","+Math.round(u[1]+(t[1]-u[1])*(1-k))+","+Math.round(u[2]+(t[2]-u[2])*(1-k))+(a?","+(u[3]+(t[3]-u[3])*(1-k)):"")+")"):k=a.input||"none";return k}};
a.color=function(k){return new a.Color(k)}})(L);(function(a){var G,E,H=a.addEvent,v=a.animate,k=a.attr,q=a.charts,w=a.color,t=a.css,u=a.createElement,z=a.defined,m=a.deg2rad,g=a.destroyObjectProperties,f=a.doc,e=a.each,c=a.extend,b=a.erase,r=a.grep,l=a.hasTouch,C=a.inArray,I=a.isArray,x=a.isFirefox,F=a.isMS,n=a.isObject,B=a.isString,J=a.isWebKit,A=a.merge,d=a.noop,p=a.objectEach,D=a.pick,h=a.pInt,y=a.removeEvent,P=a.stop,M=a.svg,O=a.SVG_NS,N=a.symbolSizes,R=a.win;G=a.SVGElement=function(){return this};
c(G.prototype,{opacity:1,SVG_NS:O,textProps:"direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline".split(" "),init:function(a,h){this.element="span"===h?u(h):f.createElementNS(this.SVG_NS,h);this.renderer=a},animate:function(K,h,d){h=a.animObject(D(h,this.renderer.globalAnimation,!0));0!==h.duration?(d&&(h.complete=d),v(this,K,h)):(this.attr(K,null,d),h.step&&h.step.call(this));return this},colorGradient:function(h,d,y){var K=
this.renderer,b,c,l,n,r,f,S,M,C,D,g=[],B;h.radialGradient?c="radialGradient":h.linearGradient&&(c="linearGradient");c&&(l=h[c],r=K.gradients,S=h.stops,D=y.radialReference,I(l)&&(h[c]=l={x1:l[0],y1:l[1],x2:l[2],y2:l[3],gradientUnits:"userSpaceOnUse"}),"radialGradient"===c&&D&&!z(l.gradientUnits)&&(n=l,l=A(l,K.getRadialAttr(D,n),{gradientUnits:"userSpaceOnUse"})),p(l,function(a,h){"id"!==h&&g.push(h,a)}),p(S,function(a){g.push(a)}),g=g.join(","),r[g]?D=r[g].attr("id"):(l.id=D=a.uniqueKey(),r[g]=f=K.createElement(c).attr(l).add(K.defs),
f.radAttr=n,f.stops=[],e(S,function(h){0===h[1].indexOf("rgba")?(b=a.color(h[1]),M=b.get("rgb"),C=b.get("a")):(M=h[1],C=1);h=K.createElement("stop").attr({offset:h[0],"stop-color":M,"stop-opacity":C}).add(f);f.stops.push(h)})),B="url("+K.url+"#"+D+")",y.setAttribute(d,B),y.gradient=g,h.toString=function(){return B})},applyTextOutline:function(h){var K=this.element,d,y,c,p,l;-1!==h.indexOf("contrast")&&(h=h.replace(/contrast/g,this.renderer.getContrast(K.style.fill)));h=h.split(" ");y=h[h.length-1];
if((c=h[0])&&"none"!==c&&a.svg){this.fakeTS=!0;h=[].slice.call(K.getElementsByTagName("tspan"));this.ySetter=this.xSetter;c=c.replace(/(^[\d\.]+)(.*?)$/g,function(a,h,K){return 2*h+K});for(l=h.length;l--;)d=h[l],"highcharts-text-outline"===d.getAttribute("class")&&b(h,K.removeChild(d));p=K.firstChild;e(h,function(a,h){0===h&&(a.setAttribute("x",K.getAttribute("x")),h=K.getAttribute("y"),a.setAttribute("y",h||0),null===h&&K.setAttribute("y",0));a=a.cloneNode(1);k(a,{"class":"highcharts-text-outline",
fill:y,stroke:y,"stroke-width":c,"stroke-linejoin":"round"});K.insertBefore(a,p)})}},attr:function(a,h,d,y){var K,b=this.element,c,l=this,e,n;"string"===typeof a&&void 0!==h&&(K=a,a={},a[K]=h);"string"===typeof a?l=(this[a+"Getter"]||this._defaultGetter).call(this,a,b):(p(a,function(h,K){e=!1;y||P(this,K);this.symbolName&&/^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/.test(K)&&(c||(this.symbolAttr(a),c=!0),e=!0);!this.rotation||"x"!==K&&"y"!==K||(this.doTransform=!0);e||(n=this[K+"Setter"]||
this._defaultSetter,n.call(this,h,K,b),this.shadows&&/^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(K)&&this.updateShadows(K,h,n))},this),this.afterSetters());d&&d();return l},afterSetters:function(){this.doTransform&&(this.updateTransform(),this.doTransform=!1)},updateShadows:function(a,h,d){for(var K=this.shadows,y=K.length;y--;)d.call(K[y],"height"===a?Math.max(h-(K[y].cutHeight||0),0):"d"===a?this.d:h,a,K[y])},addClass:function(a,h){var K=this.attr("class")||"";-1===K.indexOf(a)&&
(h||(a=(K+(K?" ":"")+a).replace("  "," ")),this.attr("class",a));return this},hasClass:function(a){return-1!==C(a,(this.attr("class")||"").split(" "))},removeClass:function(a){return this.attr("class",(this.attr("class")||"").replace(a,""))},symbolAttr:function(a){var h=this;e("x y r start end width height innerR anchorX anchorY".split(" "),function(K){h[K]=D(a[K],h[K])});h.attr({d:h.renderer.symbols[h.symbolName](h.x,h.y,h.width,h.height,h)})},clip:function(a){return this.attr("clip-path",a?"url("+
this.renderer.url+"#"+a.id+")":"none")},crisp:function(a,h){var d;h=h||a.strokeWidth||0;d=Math.round(h)%2/2;a.x=Math.floor(a.x||this.x||0)+d;a.y=Math.floor(a.y||this.y||0)+d;a.width=Math.floor((a.width||this.width||0)-2*d);a.height=Math.floor((a.height||this.height||0)-2*d);z(a.strokeWidth)&&(a.strokeWidth=h);return a},css:function(a){var d=this.styles,y={},K=this.element,b,e="",l,n=!d,A=["textOutline","textOverflow","width"];a&&a.color&&(a.fill=a.color);d&&p(a,function(a,h){a!==d[h]&&(y[h]=a,n=!0)});
n&&(d&&(a=c(d,y)),b=this.textWidth=a&&a.width&&"auto"!==a.width&&"text"===K.nodeName.toLowerCase()&&h(a.width),this.styles=a,b&&!M&&this.renderer.forExport&&delete a.width,F&&!M?t(this.element,a):(l=function(a,h){return"-"+h.toLowerCase()},p(a,function(a,h){-1===C(h,A)&&(e+=h.replace(/([A-Z])/g,l)+":"+a+";")}),e&&k(K,"style",e)),this.added&&("text"===this.element.nodeName&&this.renderer.buildText(this),a&&a.textOutline&&this.applyTextOutline(a.textOutline)));return this},strokeWidth:function(){return this["stroke-width"]||
0},on:function(a,h){var d=this,y=d.element;l&&"click"===a?(y.ontouchstart=function(a){d.touchEventFired=Date.now();a.preventDefault();h.call(y,a)},y.onclick=function(a){(-1===R.navigator.userAgent.indexOf("Android")||1100<Date.now()-(d.touchEventFired||0))&&h.call(y,a)}):y["on"+a]=h;return this},setRadialReference:function(a){var h=this.renderer.gradients[this.element.gradient];this.element.radialReference=a;h&&h.radAttr&&h.animate(this.renderer.getRadialAttr(a,h.radAttr));return this},translate:function(a,
h){return this.attr({translateX:a,translateY:h})},invert:function(a){this.inverted=a;this.updateTransform();return this},updateTransform:function(){var a=this.translateX||0,h=this.translateY||0,d=this.scaleX,y=this.scaleY,b=this.inverted,c=this.rotation,p=this.matrix,e=this.element;b&&(a+=this.width,h+=this.height);a=["translate("+a+","+h+")"];z(p)&&a.push("matrix("+p.join(",")+")");b?a.push("rotate(90) scale(-1,1)"):c&&a.push("rotate("+c+" "+D(this.rotationOriginX,e.getAttribute("x"),0)+" "+D(this.rotationOriginY,
e.getAttribute("y")||0)+")");(z(d)||z(y))&&a.push("scale("+D(d,1)+" "+D(y,1)+")");a.length&&e.setAttribute("transform",a.join(" "))},toFront:function(){var a=this.element;a.parentNode.appendChild(a);return this},align:function(a,h,d){var y,c,K,p,e={};c=this.renderer;K=c.alignedObjects;var l,n;if(a){if(this.alignOptions=a,this.alignByTranslate=h,!d||B(d))this.alignTo=y=d||"renderer",b(K,this),K.push(this),d=null}else a=this.alignOptions,h=this.alignByTranslate,y=this.alignTo;d=D(d,c[y],c);y=a.align;
c=a.verticalAlign;K=(d.x||0)+(a.x||0);p=(d.y||0)+(a.y||0);"right"===y?l=1:"center"===y&&(l=2);l&&(K+=(d.width-(a.width||0))/l);e[h?"translateX":"x"]=Math.round(K);"bottom"===c?n=1:"middle"===c&&(n=2);n&&(p+=(d.height-(a.height||0))/n);e[h?"translateY":"y"]=Math.round(p);this[this.placed?"animate":"attr"](e);this.placed=!0;this.alignAttr=e;return this},getBBox:function(a,h){var d,y=this.renderer,b,p=this.element,K=this.styles,l,n=this.textStr,A,r=y.cache,f=y.cacheKeys,M;h=D(h,this.rotation);b=h*m;
l=K&&K.fontSize;z(n)&&(M=n.toString(),-1===M.indexOf("\x3c")&&(M=M.replace(/[0-9]/g,"0")),M+=["",h||0,l,K&&K.width,K&&K.textOverflow].join());M&&!a&&(d=r[M]);if(!d){if(p.namespaceURI===this.SVG_NS||y.forExport){try{(A=this.fakeTS&&function(a){e(p.querySelectorAll(".highcharts-text-outline"),function(h){h.style.display=a})})&&A("none"),d=p.getBBox?c({},p.getBBox()):{width:p.offsetWidth,height:p.offsetHeight},A&&A("")}catch(T){}if(!d||0>d.width)d={width:0,height:0}}else d=this.htmlGetBBox();y.isSVG&&
(a=d.width,y=d.height,K&&"11px"===K.fontSize&&17===Math.round(y)&&(d.height=y=14),h&&(d.width=Math.abs(y*Math.sin(b))+Math.abs(a*Math.cos(b)),d.height=Math.abs(y*Math.cos(b))+Math.abs(a*Math.sin(b))));if(M&&0<d.height){for(;250<f.length;)delete r[f.shift()];r[M]||f.push(M);r[M]=d}}return d},show:function(a){return this.attr({visibility:a?"inherit":"visible"})},hide:function(){return this.attr({visibility:"hidden"})},fadeOut:function(a){var h=this;h.animate({opacity:0},{duration:a||150,complete:function(){h.attr({y:-9999})}})},
add:function(a){var h=this.renderer,d=this.element,y;a&&(this.parentGroup=a);this.parentInverted=a&&a.inverted;void 0!==this.textStr&&h.buildText(this);this.added=!0;if(!a||a.handleZ||this.zIndex)y=this.zIndexSetter();y||(a?a.element:h.box).appendChild(d);if(this.onAdd)this.onAdd();return this},safeRemoveChild:function(a){var h=a.parentNode;h&&h.removeChild(a)},destroy:function(){var a=this,h=a.element||{},d=a.renderer.isSVG&&"SPAN"===h.nodeName&&a.parentGroup,y=h.ownerSVGElement;h.onclick=h.onmouseout=
h.onmouseover=h.onmousemove=h.point=null;P(a);a.clipPath&&y&&(e(y.querySelectorAll("[clip-path],[CLIP-PATH]"),function(h){h.getAttribute("clip-path").match(RegExp('[("]#'+a.clipPath.element.id+'[)"]'))&&h.removeAttribute("clip-path")}),a.clipPath=a.clipPath.destroy());if(a.stops){for(y=0;y<a.stops.length;y++)a.stops[y]=a.stops[y].destroy();a.stops=null}a.safeRemoveChild(h);for(a.destroyShadows();d&&d.div&&0===d.div.childNodes.length;)h=d.parentGroup,a.safeRemoveChild(d.div),delete d.div,d=h;a.alignTo&&
b(a.renderer.alignedObjects,a);p(a,function(h,d){delete a[d]});return null},shadow:function(a,h,d){var y=[],b,c,p=this.element,e,l,K,n;if(!a)this.destroyShadows();else if(!this.shadows){l=D(a.width,3);K=(a.opacity||.15)/l;n=this.parentInverted?"(-1,-1)":"("+D(a.offsetX,1)+", "+D(a.offsetY,1)+")";for(b=1;b<=l;b++)c=p.cloneNode(0),e=2*l+1-2*b,k(c,{isShadow:"true",stroke:a.color||"#000000","stroke-opacity":K*b,"stroke-width":e,transform:"translate"+n,fill:"none"}),d&&(k(c,"height",Math.max(k(c,"height")-
e,0)),c.cutHeight=e),h?h.element.appendChild(c):p.parentNode&&p.parentNode.insertBefore(c,p),y.push(c);this.shadows=y}return this},destroyShadows:function(){e(this.shadows||[],function(a){this.safeRemoveChild(a)},this);this.shadows=void 0},xGetter:function(a){"circle"===this.element.nodeName&&("x"===a?a="cx":"y"===a&&(a="cy"));return this._defaultGetter(a)},_defaultGetter:function(a){a=D(this[a+"Value"],this[a],this.element?this.element.getAttribute(a):null,0);/^[\-0-9\.]+$/.test(a)&&(a=parseFloat(a));
return a},dSetter:function(a,h,d){a&&a.join&&(a=a.join(" "));/(NaN| {2}|^$)/.test(a)&&(a="M 0 0");this[h]!==a&&(d.setAttribute(h,a),this[h]=a)},dashstyleSetter:function(a){var d,y=this["stroke-width"];"inherit"===y&&(y=1);if(a=a&&a.toLowerCase()){a=a.replace("shortdashdotdot","3,1,1,1,1,1,").replace("shortdashdot","3,1,1,1").replace("shortdot","1,1,").replace("shortdash","3,1,").replace("longdash","8,3,").replace(/dot/g,"1,3,").replace("dash","4,3,").replace(/,$/,"").split(",");for(d=a.length;d--;)a[d]=
h(a[d])*y;a=a.join(",").replace(/NaN/g,"none");this.element.setAttribute("stroke-dasharray",a)}},alignSetter:function(a){this.alignValue=a;this.element.setAttribute("text-anchor",{left:"start",center:"middle",right:"end"}[a])},opacitySetter:function(a,h,d){this[h]=a;d.setAttribute(h,a)},titleSetter:function(a){var h=this.element.getElementsByTagName("title")[0];h||(h=f.createElementNS(this.SVG_NS,"title"),this.element.appendChild(h));h.firstChild&&h.removeChild(h.firstChild);h.appendChild(f.createTextNode(String(D(a),
"").replace(/<[^>]*>/g,"")))},textSetter:function(a){a!==this.textStr&&(delete this.bBox,this.textStr=a,this.added&&this.renderer.buildText(this))},fillSetter:function(a,h,d){"string"===typeof a?d.setAttribute(h,a):a&&this.colorGradient(a,h,d)},visibilitySetter:function(a,h,d){"inherit"===a?d.removeAttribute(h):this[h]!==a&&d.setAttribute(h,a);this[h]=a},zIndexSetter:function(a,d){var y=this.renderer,b=this.parentGroup,c=(b||y).element||y.box,p,e=this.element,l,n,y=c===y.box;p=this.added;var A;z(a)&&
(e.zIndex=a,a=+a,this[d]===a&&(p=!1),this[d]=a);if(p){(a=this.zIndex)&&b&&(b.handleZ=!0);d=c.childNodes;for(A=d.length-1;0<=A&&!l;A--)if(b=d[A],p=b.zIndex,n=!z(p),b!==e)if(0>a&&n&&!y&&!A)c.insertBefore(e,d[A]),l=!0;else if(h(p)<=a||n&&(!z(a)||0<=a))c.insertBefore(e,d[A+1]||null),l=!0;l||(c.insertBefore(e,d[y?3:0]||null),l=!0)}return l},_defaultSetter:function(a,h,d){d.setAttribute(h,a)}});G.prototype.yGetter=G.prototype.xGetter;G.prototype.translateXSetter=G.prototype.translateYSetter=G.prototype.rotationSetter=
G.prototype.verticalAlignSetter=G.prototype.rotationOriginXSetter=G.prototype.rotationOriginYSetter=G.prototype.scaleXSetter=G.prototype.scaleYSetter=G.prototype.matrixSetter=function(a,h){this[h]=a;this.doTransform=!0};G.prototype["stroke-widthSetter"]=G.prototype.strokeSetter=function(a,h,d){this[h]=a;this.stroke&&this["stroke-width"]?(G.prototype.fillSetter.call(this,this.stroke,"stroke",d),d.setAttribute("stroke-width",this["stroke-width"]),this.hasStroke=!0):"stroke-width"===h&&0===a&&this.hasStroke&&
(d.removeAttribute("stroke"),this.hasStroke=!1)};E=a.SVGRenderer=function(){this.init.apply(this,arguments)};c(E.prototype,{Element:G,SVG_NS:O,init:function(a,h,d,y,b,c){var p;y=this.createElement("svg").attr({version:"1.1","class":"highcharts-root"}).css(this.getStyle(y));p=y.element;a.appendChild(p);k(a,"dir","ltr");-1===a.innerHTML.indexOf("xmlns")&&k(p,"xmlns",this.SVG_NS);this.isSVG=!0;this.box=p;this.boxWrapper=y;this.alignedObjects=[];this.url=(x||J)&&f.getElementsByTagName("base").length?
R.location.href.replace(/#.*?$/,"").replace(/<[^>]*>/g,"").replace(/([\('\)])/g,"\\$1").replace(/ /g,"%20"):"";this.createElement("desc").add().element.appendChild(f.createTextNode("Created with Highstock 6.0.4"));this.defs=this.createElement("defs").add();this.allowHTML=c;this.forExport=b;this.gradients={};this.cache={};this.cacheKeys=[];this.imgCount=0;this.setSize(h,d,!1);var e;x&&a.getBoundingClientRect&&(h=function(){t(a,{left:0,top:0});e=a.getBoundingClientRect();t(a,{left:Math.ceil(e.left)-
e.left+"px",top:Math.ceil(e.top)-e.top+"px"})},h(),this.unSubPixelFix=H(R,"resize",h))},getStyle:function(a){return this.style=c({fontFamily:'"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',fontSize:"12px"},a)},setStyle:function(a){this.boxWrapper.css(this.getStyle(a))},isHidden:function(){return!this.boxWrapper.getBBox().width},destroy:function(){var a=this.defs;this.box=null;this.boxWrapper=this.boxWrapper.destroy();g(this.gradients||{});this.gradients=null;a&&(this.defs=a.destroy());
this.unSubPixelFix&&this.unSubPixelFix();return this.alignedObjects=null},createElement:function(a){var h=new this.Element;h.init(this,a);return h},draw:d,getRadialAttr:function(a,h){return{cx:a[0]-a[2]/2+h.cx*a[2],cy:a[1]-a[2]/2+h.cy*a[2],r:h.r*a[2]}},getSpanWidth:function(a,h){var d=a.getBBox(!0).width;!M&&this.forExport&&(d=this.measureSpanWidth(h.firstChild.data,a.styles));return d},applyEllipsis:function(a,h,d,y){var b=a.rotation,c=d,p,e=0,l=d.length,n=function(a){h.removeChild(h.firstChild);
a&&h.appendChild(f.createTextNode(a))},A;a.rotation=0;c=this.getSpanWidth(a,h);if(A=c>y){for(;e<=l;)p=Math.ceil((e+l)/2),c=d.substring(0,p)+"\u2026",n(c),c=this.getSpanWidth(a,h),e===l?e=l+1:c>y?l=p-1:e=p;0===l&&n("")}a.rotation=b;return A},escapes:{"\x26":"\x26amp;","\x3c":"\x26lt;","\x3e":"\x26gt;","'":"\x26#39;",'"':"\x26quot;"},buildText:function(a){var d=a.element,y=this,b=y.forExport,c=D(a.textStr,"").toString(),l=-1!==c.indexOf("\x3c"),n=d.childNodes,A,K,C,g,B=k(d,"x"),x=a.styles,m=a.textWidth,
N=x&&x.lineHeight,P=x&&x.textOutline,F=x&&"ellipsis"===x.textOverflow,I=x&&"nowrap"===x.whiteSpace,u=x&&x.fontSize,R,q,J=n.length,x=m&&!a.added&&this.box,z=function(a){var b;b=/(px|em)$/.test(a&&a.style.fontSize)?a.style.fontSize:u||y.style.fontSize||12;return N?h(N):y.fontMetrics(b,a.getAttribute("style")?a:d).h},w=function(a){p(y.escapes,function(h,d){a=a.replace(new RegExp(h,"g"),d)});return a};R=[c,F,I,N,P,u,m].join();if(R!==a.textCache){for(a.textCache=R;J--;)d.removeChild(n[J]);l||P||F||m||
-1!==c.indexOf(" ")?(A=/<.*class="([^"]+)".*>/,K=/<.*style="([^"]+)".*>/,C=/<.*href="([^"]+)".*>/,x&&x.appendChild(d),c=l?c.replace(/<(b|strong)>/g,'\x3cspan style\x3d"font-weight:bold"\x3e').replace(/<(i|em)>/g,'\x3cspan style\x3d"font-style:italic"\x3e').replace(/<a/g,"\x3cspan").replace(/<\/(b|strong|i|em|a)>/g,"\x3c/span\x3e").split(/<br.*?>/g):[c],c=r(c,function(a){return""!==a}),e(c,function(h,c){var p,l=0;h=h.replace(/^\s+|\s+$/g,"").replace(/<span/g,"|||\x3cspan").replace(/<\/span>/g,"\x3c/span\x3e|||");
p=h.split("|||");e(p,function(h){if(""!==h||1===p.length){var e={},n=f.createElementNS(y.SVG_NS,"tspan"),r,D;A.test(h)&&(r=h.match(A)[1],k(n,"class",r));K.test(h)&&(D=h.match(K)[1].replace(/(;| |^)color([ :])/,"$1fill$2"),k(n,"style",D));C.test(h)&&!b&&(k(n,"onclick",'location.href\x3d"'+h.match(C)[1]+'"'),k(n,"class","highcharts-anchor"),t(n,{cursor:"pointer"}));h=w(h.replace(/<[a-zA-Z\/](.|\n)*?>/g,"")||" ");if(" "!==h){n.appendChild(f.createTextNode(h));l?e.dx=0:c&&null!==B&&(e.x=B);k(n,e);d.appendChild(n);
!l&&q&&(!M&&b&&t(n,{display:"block"}),k(n,"dy",z(n)));if(m){e=h.replace(/([^\^])-/g,"$1- ").split(" ");r=1<p.length||c||1<e.length&&!I;var x=[],N,P=z(n),S=a.rotation;for(F&&(g=y.applyEllipsis(a,n,h,m));!F&&r&&(e.length||x.length);)a.rotation=0,N=y.getSpanWidth(a,n),h=N>m,void 0===g&&(g=h),h&&1!==e.length?(n.removeChild(n.firstChild),x.unshift(e.pop())):(e=x,x=[],e.length&&!I&&(n=f.createElementNS(O,"tspan"),k(n,{dy:P,x:B}),D&&k(n,"style",D),d.appendChild(n)),N>m&&(m=N)),e.length&&n.appendChild(f.createTextNode(e.join(" ").replace(/- /g,
"-")));a.rotation=S}l++}}});q=q||d.childNodes.length}),g&&a.attr("title",a.textStr),x&&x.removeChild(d),P&&a.applyTextOutline&&a.applyTextOutline(P)):d.appendChild(f.createTextNode(w(c)))}},getContrast:function(a){a=w(a).rgba;return 510<a[0]+a[1]+a[2]?"#000000":"#FFFFFF"},button:function(a,h,d,y,b,p,e,l,n){var r=this.label(a,h,d,n,null,null,null,null,"button"),f=0;r.attr(A({padding:8,r:2},b));var M,C,D,K;b=A({fill:"#f7f7f7",stroke:"#cccccc","stroke-width":1,style:{color:"#333333",cursor:"pointer",
fontWeight:"normal"}},b);M=b.style;delete b.style;p=A(b,{fill:"#e6e6e6"},p);C=p.style;delete p.style;e=A(b,{fill:"#e6ebf5",style:{color:"#000000",fontWeight:"bold"}},e);D=e.style;delete e.style;l=A(b,{style:{color:"#cccccc"}},l);K=l.style;delete l.style;H(r.element,F?"mouseover":"mouseenter",function(){3!==f&&r.setState(1)});H(r.element,F?"mouseout":"mouseleave",function(){3!==f&&r.setState(f)});r.setState=function(a){1!==a&&(r.state=f=a);r.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-"+
["normal","hover","pressed","disabled"][a||0]);r.attr([b,p,e,l][a||0]).css([M,C,D,K][a||0])};r.attr(b).css(c({cursor:"default"},M));return r.on("click",function(a){3!==f&&y.call(r,a)})},crispLine:function(a,h){a[1]===a[4]&&(a[1]=a[4]=Math.round(a[1])-h%2/2);a[2]===a[5]&&(a[2]=a[5]=Math.round(a[2])+h%2/2);return a},path:function(a){var h={fill:"none"};I(a)?h.d=a:n(a)&&c(h,a);return this.createElement("path").attr(h)},circle:function(a,h,d){a=n(a)?a:{x:a,y:h,r:d};h=this.createElement("circle");h.xSetter=
h.ySetter=function(a,h,d){d.setAttribute("c"+h,a)};return h.attr(a)},arc:function(a,h,d,y,b,c){n(a)?(y=a,h=y.y,d=y.r,a=y.x):y={innerR:y,start:b,end:c};a=this.symbol("arc",a,h,d,d,y);a.r=d;return a},rect:function(a,h,d,y,b,c){b=n(a)?a.r:b;var p=this.createElement("rect");a=n(a)?a:void 0===a?{}:{x:a,y:h,width:Math.max(d,0),height:Math.max(y,0)};void 0!==c&&(a.strokeWidth=c,a=p.crisp(a));a.fill="none";b&&(a.r=b);p.rSetter=function(a,h,d){k(d,{rx:a,ry:a})};return p.attr(a)},setSize:function(a,h,d){var y=
this.alignedObjects,b=y.length;this.width=a;this.height=h;for(this.boxWrapper.animate({width:a,height:h},{step:function(){this.attr({viewBox:"0 0 "+this.attr("width")+" "+this.attr("height")})},duration:D(d,!0)?void 0:0});b--;)y[b].align()},g:function(a){var h=this.createElement("g");return a?h.attr({"class":"highcharts-"+a}):h},image:function(a,h,d,y,b){var p={preserveAspectRatio:"none"};1<arguments.length&&c(p,{x:h,y:d,width:y,height:b});p=this.createElement("image").attr(p);p.element.setAttributeNS?
p.element.setAttributeNS("http://www.w3.org/1999/xlink","href",a):p.element.setAttribute("hc-svg-href",a);return p},symbol:function(a,h,d,y,b,p){var l=this,n,A=/^url\((.*?)\)$/,r=A.test(a),M=!r&&(this.symbols[a]?a:"circle"),C=M&&this.symbols[M],g=z(h)&&C&&C.call(this.symbols,Math.round(h),Math.round(d),y,b,p),x,B;C?(n=this.path(g),n.attr("fill","none"),c(n,{symbolName:M,x:h,y:d,width:y,height:b}),p&&c(n,p)):r&&(x=a.match(A)[1],n=this.image(x),n.imgwidth=D(N[x]&&N[x].width,p&&p.width),n.imgheight=
D(N[x]&&N[x].height,p&&p.height),B=function(){n.attr({width:n.width,height:n.height})},e(["width","height"],function(a){n[a+"Setter"]=function(a,h){var d={},y=this["img"+h],b="width"===h?"translateX":"translateY";this[h]=a;z(y)&&(this.element&&this.element.setAttribute(h,y),this.alignByTranslate||(d[b]=((this[h]||0)-y)/2,this.attr(d)))}}),z(h)&&n.attr({x:h,y:d}),n.isImg=!0,z(n.imgwidth)&&z(n.imgheight)?B():(n.attr({width:0,height:0}),u("img",{onload:function(){var a=q[l.chartIndex];0===this.width&&
(t(this,{position:"absolute",top:"-999em"}),f.body.appendChild(this));N[x]={width:this.width,height:this.height};n.imgwidth=this.width;n.imgheight=this.height;n.element&&B();this.parentNode&&this.parentNode.removeChild(this);l.imgCount--;if(!l.imgCount&&a&&a.onload)a.onload()},src:x}),this.imgCount++));return n},symbols:{circle:function(a,h,d,y){return this.arc(a+d/2,h+y/2,d/2,y/2,{start:0,end:2*Math.PI,open:!1})},square:function(a,h,d,y){return["M",a,h,"L",a+d,h,a+d,h+y,a,h+y,"Z"]},triangle:function(a,
h,d,y){return["M",a+d/2,h,"L",a+d,h+y,a,h+y,"Z"]},"triangle-down":function(a,h,d,y){return["M",a,h,"L",a+d,h,a+d/2,h+y,"Z"]},diamond:function(a,h,d,y){return["M",a+d/2,h,"L",a+d,h+y/2,a+d/2,h+y,a,h+y/2,"Z"]},arc:function(a,h,d,y,b){var p=b.start,c=b.r||d,e=b.r||y||d,n=b.end-.001;d=b.innerR;y=D(b.open,.001>Math.abs(b.end-b.start-2*Math.PI));var l=Math.cos(p),A=Math.sin(p),r=Math.cos(n),n=Math.sin(n);b=.001>b.end-p-Math.PI?0:1;c=["M",a+c*l,h+e*A,"A",c,e,0,b,1,a+c*r,h+e*n];z(d)&&c.push(y?"M":"L",a+d*
r,h+d*n,"A",d,d,0,b,0,a+d*l,h+d*A);c.push(y?"":"Z");return c},callout:function(a,h,d,y,b){var p=Math.min(b&&b.r||0,d,y),c=p+6,e=b&&b.anchorX;b=b&&b.anchorY;var n;n=["M",a+p,h,"L",a+d-p,h,"C",a+d,h,a+d,h,a+d,h+p,"L",a+d,h+y-p,"C",a+d,h+y,a+d,h+y,a+d-p,h+y,"L",a+p,h+y,"C",a,h+y,a,h+y,a,h+y-p,"L",a,h+p,"C",a,h,a,h,a+p,h];e&&e>d?b>h+c&&b<h+y-c?n.splice(13,3,"L",a+d,b-6,a+d+6,b,a+d,b+6,a+d,h+y-p):n.splice(13,3,"L",a+d,y/2,e,b,a+d,y/2,a+d,h+y-p):e&&0>e?b>h+c&&b<h+y-c?n.splice(33,3,"L",a,b+6,a-6,b,a,b-6,
a,h+p):n.splice(33,3,"L",a,y/2,e,b,a,y/2,a,h+p):b&&b>y&&e>a+c&&e<a+d-c?n.splice(23,3,"L",e+6,h+y,e,h+y+6,e-6,h+y,a+p,h+y):b&&0>b&&e>a+c&&e<a+d-c&&n.splice(3,3,"L",e-6,h,e,h-6,e+6,h,d-p,h);return n}},clipRect:function(h,d,y,b){var p=a.uniqueKey(),c=this.createElement("clipPath").attr({id:p}).add(this.defs);h=this.rect(h,d,y,b,0).add(c);h.id=p;h.clipPath=c;h.count=0;return h},text:function(a,h,d,y){var b={};if(y&&(this.allowHTML||!this.forExport))return this.html(a,h,d);b.x=Math.round(h||0);d&&(b.y=
Math.round(d));if(a||0===a)b.text=a;a=this.createElement("text").attr(b);y||(a.xSetter=function(a,h,d){var y=d.getElementsByTagName("tspan"),b,p=d.getAttribute(h),c;for(c=0;c<y.length;c++)b=y[c],b.getAttribute(h)===p&&b.setAttribute(h,a);d.setAttribute(h,a)});return a},fontMetrics:function(a,d){a=a||d&&d.style&&d.style.fontSize||this.style&&this.style.fontSize;a=/px/.test(a)?h(a):/em/.test(a)?parseFloat(a)*(d?this.fontMetrics(null,d.parentNode).f:16):12;d=24>a?a+3:Math.round(1.2*a);return{h:d,b:Math.round(.8*
d),f:a}},rotCorr:function(a,h,d){var y=a;h&&d&&(y=Math.max(y*Math.cos(h*m),4));return{x:-a/3*Math.sin(h*m),y:y}},label:function(h,d,b,p,n,l,r,f,M){var C=this,D=C.g("button"!==M&&"label"),g=D.text=C.text("",0,0,r).attr({zIndex:1}),x,B,m=0,N=3,P=0,F,t,I,u,K,O={},R,k,q=/^url\((.*?)\)$/.test(p),J=q,w,S,v,W;M&&D.addClass("highcharts-"+M);J=q;w=function(){return(R||0)%2/2};S=function(){var a=g.element.style,h={};B=(void 0===F||void 0===t||K)&&z(g.textStr)&&g.getBBox();D.width=(F||B.width||0)+2*N+P;D.height=
(t||B.height||0)+2*N;k=N+C.fontMetrics(a&&a.fontSize,g).b;J&&(x||(D.box=x=C.symbols[p]||q?C.symbol(p):C.rect(),x.addClass(("button"===M?"":"highcharts-label-box")+(M?" highcharts-"+M+"-box":"")),x.add(D),a=w(),h.x=a,h.y=(f?-k:0)+a),h.width=Math.round(D.width),h.height=Math.round(D.height),x.attr(c(h,O)),O={})};v=function(){var a=P+N,h;h=f?0:k;z(F)&&B&&("center"===K||"right"===K)&&(a+={center:.5,right:1}[K]*(F-B.width));if(a!==g.x||h!==g.y)g.attr("x",a),void 0!==h&&g.attr("y",h);g.x=a;g.y=h};W=function(a,
h){x?x.attr(a,h):O[a]=h};D.onAdd=function(){g.add(D);D.attr({text:h||0===h?h:"",x:d,y:b});x&&z(n)&&D.attr({anchorX:n,anchorY:l})};D.widthSetter=function(h){F=a.isNumber(h)?h:null};D.heightSetter=function(a){t=a};D["text-alignSetter"]=function(a){K=a};D.paddingSetter=function(a){z(a)&&a!==N&&(N=D.padding=a,v())};D.paddingLeftSetter=function(a){z(a)&&a!==P&&(P=a,v())};D.alignSetter=function(a){a={left:0,center:.5,right:1}[a];a!==m&&(m=a,B&&D.attr({x:I}))};D.textSetter=function(a){void 0!==a&&g.textSetter(a);
S();v()};D["stroke-widthSetter"]=function(a,h){a&&(J=!0);R=this["stroke-width"]=a;W(h,a)};D.strokeSetter=D.fillSetter=D.rSetter=function(a,h){"r"!==h&&("fill"===h&&a&&(J=!0),D[h]=a);W(h,a)};D.anchorXSetter=function(a,h){n=D.anchorX=a;W(h,Math.round(a)-w()-I)};D.anchorYSetter=function(a,h){l=D.anchorY=a;W(h,a-u)};D.xSetter=function(a){D.x=a;m&&(a-=m*((F||B.width)+2*N));I=Math.round(a);D.attr("translateX",I)};D.ySetter=function(a){u=D.y=Math.round(a);D.attr("translateY",u)};var aa=D.css;return c(D,
{css:function(a){if(a){var h={};a=A(a);e(D.textProps,function(d){void 0!==a[d]&&(h[d]=a[d],delete a[d])});g.css(h)}return aa.call(D,a)},getBBox:function(){return{width:B.width+2*N,height:B.height+2*N,x:B.x-N,y:B.y-N}},shadow:function(a){a&&(S(),x&&x.shadow(a));return D},destroy:function(){y(D.element,"mouseenter");y(D.element,"mouseleave");g&&(g=g.destroy());x&&(x=x.destroy());G.prototype.destroy.call(D);D=C=S=v=W=null}})}});a.Renderer=E})(L);(function(a){var G=a.attr,E=a.createElement,H=a.css,v=
a.defined,k=a.each,q=a.extend,w=a.isFirefox,t=a.isMS,u=a.isWebKit,z=a.pick,m=a.pInt,g=a.SVGRenderer,f=a.win,e=a.wrap;q(a.SVGElement.prototype,{htmlCss:function(a){var b=this.element;if(b=a&&"SPAN"===b.tagName&&a.width)delete a.width,this.textWidth=b,this.updateTransform();a&&"ellipsis"===a.textOverflow&&(a.whiteSpace="nowrap",a.overflow="hidden");this.styles=q(this.styles,a);H(this.element,a);return this},htmlGetBBox:function(){var a=this.element;return{x:a.offsetLeft,y:a.offsetTop,width:a.offsetWidth,
height:a.offsetHeight}},htmlUpdateTransform:function(){if(this.added){var a=this.renderer,b=this.element,e=this.translateX||0,l=this.translateY||0,f=this.x||0,g=this.y||0,x=this.textAlign||"left",F={left:0,center:.5,right:1}[x],n=this.styles;H(b,{marginLeft:e,marginTop:l});this.shadows&&k(this.shadows,function(a){H(a,{marginLeft:e+1,marginTop:l+1})});this.inverted&&k(b.childNodes,function(d){a.invertChild(d,b)});if("SPAN"===b.tagName){var B=this.rotation,t=m(this.textWidth),A=n&&n.whiteSpace,d=[B,
x,b.innerHTML,this.textWidth,this.textAlign].join();d!==this.cTT&&(n=a.fontMetrics(b.style.fontSize).b,v(B)&&this.setSpanRotation(B,F,n),H(b,{width:"",whiteSpace:A||"nowrap"}),b.offsetWidth>t&&/[ \-]/.test(b.textContent||b.innerText)&&H(b,{width:t+"px",display:"block",whiteSpace:A||"normal"}),this.getSpanCorrection(b.offsetWidth,n,F,B,x));H(b,{left:f+(this.xCorr||0)+"px",top:g+(this.yCorr||0)+"px"});u&&(n=b.offsetHeight);this.cTT=d}}else this.alignOnAdd=!0},setSpanRotation:function(a,b,e){var c={},
r=this.renderer.getTransformKey();c[r]=c.transform="rotate("+a+"deg)";c[r+(w?"Origin":"-origin")]=c.transformOrigin=100*b+"% "+e+"px";H(this.element,c)},getSpanCorrection:function(a,b,e){this.xCorr=-a*e;this.yCorr=-b}});q(g.prototype,{getTransformKey:function(){return t&&!/Edge/.test(f.navigator.userAgent)?"-ms-transform":u?"-webkit-transform":w?"MozTransform":f.opera?"-o-transform":""},html:function(a,b,r){var c=this.createElement("span"),f=c.element,g=c.renderer,x=g.isSVG,m=function(a,b){k(["opacity",
"visibility"],function(c){e(a,c+"Setter",function(a,d,c,e){a.call(this,d,c,e);b[c]=d})})};c.textSetter=function(a){a!==f.innerHTML&&delete this.bBox;this.textStr=a;f.innerHTML=z(a,"");c.htmlUpdateTransform()};x&&m(c,c.element.style);c.xSetter=c.ySetter=c.alignSetter=c.rotationSetter=function(a,b){"align"===b&&(b="textAlign");c[b]=a;c.htmlUpdateTransform()};c.attr({text:a,x:Math.round(b),y:Math.round(r)}).css({fontFamily:this.style.fontFamily,fontSize:this.style.fontSize,position:"absolute"});f.style.whiteSpace=
"nowrap";c.css=c.htmlCss;x&&(c.add=function(a){var b,e=g.box.parentNode,n=[];if(this.parentGroup=a){if(b=a.div,!b){for(;a;)n.push(a),a=a.parentGroup;k(n.reverse(),function(a){function d(h,d){a[d]=h;t?l[g.getTransformKey()]="translate("+(a.x||a.translateX)+"px,"+(a.y||a.translateY)+"px)":"translateX"===d?l.left=h+"px":l.top=h+"px";a.doTransform=!0}var l,h=G(a.element,"class");h&&(h={className:h});b=a.div=a.div||E("div",h,{position:"absolute",left:(a.translateX||0)+"px",top:(a.translateY||0)+"px",display:a.display,
opacity:a.opacity,pointerEvents:a.styles&&a.styles.pointerEvents},b||e);l=b.style;q(a,{classSetter:function(a){return function(h){this.element.setAttribute("class",h);a.className=h}}(b),on:function(){n[0].div&&c.on.apply({element:n[0].div},arguments);return a},translateXSetter:d,translateYSetter:d});m(a,l)})}}else b=e;b.appendChild(f);c.added=!0;c.alignOnAdd&&c.htmlUpdateTransform();return c});return c}})})(L);(function(a){function G(){var t=a.defaultOptions.global,u=w.moment;if(t.timezone){if(u)return function(a){return-u.tz(a,
t.timezone).utcOffset()};a.error(25)}return t.useUTC&&t.getTimezoneOffset}function E(){var t=a.defaultOptions.global,u,k=t.useUTC,m=k?"getUTC":"get",g=k?"setUTC":"set",f="Minutes Hours Day Date Month FullYear".split(" "),e=f.concat(["Milliseconds","Seconds"]);a.Date=u=t.Date||w.Date;u.hcTimezoneOffset=k&&t.timezoneOffset;u.hcGetTimezoneOffset=G();u.hcHasTimeZone=!(!u.hcTimezoneOffset&&!u.hcGetTimezoneOffset);u.hcMakeTime=function(a,b,e,l,f,g){var c;k?(c=u.UTC.apply(0,arguments),c+=v(c)):c=(new u(a,
b,q(e,1),q(l,0),q(f,0),q(g,0))).getTime();return c};for(t=0;t<f.length;t++)u["hcGet"+f[t]]=m+f[t];for(t=0;t<e.length;t++)u["hcSet"+e[t]]=g+e[t]}var H=a.color,v=a.getTZOffset,k=a.merge,q=a.pick,w=a.win;a.defaultOptions={colors:"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),symbols:["circle","diamond","square","triangle","triangle-down"],lang:{loading:"Loading...",months:"January February March April May June July August September October November December".split(" "),
shortMonths:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),weekdays:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),decimalPoint:".",numericSymbols:"kMGTPE".split(""),resetZoom:"Reset zoom",resetZoomTitle:"Reset zoom level 1:1",thousandsSep:" "},global:{useUTC:!0},chart:{borderRadius:0,defaultSeriesType:"line",ignoreHiddenSeries:!0,spacing:[10,10,15,10],resetZoomButton:{theme:{zIndex:6},position:{align:"right",x:-10,y:10}},width:null,height:null,borderColor:"#335cad",
backgroundColor:"#ffffff",plotBorderColor:"#cccccc"},title:{text:"Chart title",align:"center",margin:15,widthAdjust:-44},subtitle:{text:"",align:"center",widthAdjust:-44},plotOptions:{},labels:{style:{position:"absolute",color:"#333333"}},legend:{enabled:!0,align:"center",layout:"horizontal",labelFormatter:function(){return this.name},borderColor:"#999999",borderRadius:0,navigation:{activeColor:"#003399",inactiveColor:"#cccccc"},itemStyle:{color:"#333333",fontSize:"12px",fontWeight:"bold",textOverflow:"ellipsis"},
itemHoverStyle:{color:"#000000"},itemHiddenStyle:{color:"#cccccc"},shadow:!1,itemCheckboxStyle:{position:"absolute",width:"13px",height:"13px"},squareSymbol:!0,symbolPadding:5,verticalAlign:"bottom",x:0,y:0,title:{style:{fontWeight:"bold"}}},loading:{labelStyle:{fontWeight:"bold",position:"relative",top:"45%"},style:{position:"absolute",backgroundColor:"#ffffff",opacity:.5,textAlign:"center"}},tooltip:{enabled:!0,animation:a.svg,borderRadius:3,dateTimeLabelFormats:{millisecond:"%A, %b %e, %H:%M:%S.%L",
second:"%A, %b %e, %H:%M:%S",minute:"%A, %b %e, %H:%M",hour:"%A, %b %e, %H:%M",day:"%A, %b %e, %Y",week:"Week from %A, %b %e, %Y",month:"%B %Y",year:"%Y"},footerFormat:"",padding:8,snap:a.isTouchDevice?25:10,backgroundColor:H("#f7f7f7").setOpacity(.85).get(),borderWidth:1,headerFormat:'\x3cspan style\x3d"font-size: 10px"\x3e{point.key}\x3c/span\x3e\x3cbr/\x3e',pointFormat:'\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e {series.name}: \x3cb\x3e{point.y}\x3c/b\x3e\x3cbr/\x3e',shadow:!0,
style:{color:"#333333",cursor:"default",fontSize:"12px",pointerEvents:"none",whiteSpace:"nowrap"}},credits:{enabled:!0,href:"http://www.highcharts.com",position:{align:"right",x:-10,verticalAlign:"bottom",y:-5},style:{cursor:"pointer",color:"#999999",fontSize:"9px"},text:"Highcharts.com"}};a.setOptions=function(t){a.defaultOptions=k(!0,a.defaultOptions,t);E();return a.defaultOptions};a.getOptions=function(){return a.defaultOptions};a.defaultPlotOptions=a.defaultOptions.plotOptions;E()})(L);(function(a){var G=
a.correctFloat,E=a.defined,H=a.destroyObjectProperties,v=a.isNumber,k=a.merge,q=a.pick,w=a.deg2rad;a.Tick=function(a,u,k,m){this.axis=a;this.pos=u;this.type=k||"";this.isNewLabel=this.isNew=!0;k||m||this.addLabel()};a.Tick.prototype={addLabel:function(){var a=this.axis,u=a.options,z=a.chart,m=a.categories,g=a.names,f=this.pos,e=u.labels,c=a.tickPositions,b=f===c[0],r=f===c[c.length-1],g=m?q(m[f],g[f],f):f,m=this.label,c=c.info,l;a.isDatetimeAxis&&c&&(l=u.dateTimeLabelFormats[c.higherRanks[f]||c.unitName]);
this.isFirst=b;this.isLast=r;u=a.labelFormatter.call({axis:a,chart:z,isFirst:b,isLast:r,dateTimeLabelFormat:l,value:a.isLog?G(a.lin2log(g)):g,pos:f});E(m)?m&&m.attr({text:u}):(this.labelLength=(this.label=m=E(u)&&e.enabled?z.renderer.text(u,0,0,e.useHTML).css(k(e.style)).add(a.labelGroup):null)&&m.getBBox().width,this.rotation=0)},getLabelSize:function(){return this.label?this.label.getBBox()[this.axis.horiz?"height":"width"]:0},handleOverflow:function(a){var t=this.axis,k=t.options.labels,m=a.x,
g=t.chart.chartWidth,f=t.chart.spacing,e=q(t.labelLeft,Math.min(t.pos,f[3])),f=q(t.labelRight,Math.max(t.isRadial?0:t.pos+t.len,g-f[1])),c=this.label,b=this.rotation,r={left:0,center:.5,right:1}[t.labelAlign||c.attr("align")],l=c.getBBox().width,C=t.getSlotWidth(),I=C,x=1,F,n={};if(b||!1===k.overflow)0>b&&m-r*l<e?F=Math.round(m/Math.cos(b*w)-e):0<b&&m+r*l>f&&(F=Math.round((g-m)/Math.cos(b*w)));else if(g=m+(1-r)*l,m-r*l<e?I=a.x+I*(1-r)-e:g>f&&(I=f-a.x+I*r,x=-1),I=Math.min(C,I),I<C&&"center"===t.labelAlign&&
(a.x+=x*(C-I-r*(C-Math.min(l,I)))),l>I||t.autoRotation&&(c.styles||{}).width)F=I;F&&(n.width=F,(k.style||{}).textOverflow||(n.textOverflow="ellipsis"),c.css(n))},getPosition:function(a,k,q,m){var g=this.axis,f=g.chart,e=m&&f.oldChartHeight||f.chartHeight;return{x:a?g.translate(k+q,null,null,m)+g.transB:g.left+g.offset+(g.opposite?(m&&f.oldChartWidth||f.chartWidth)-g.right-g.left:0),y:a?e-g.bottom+g.offset-(g.opposite?g.height:0):e-g.translate(k+q,null,null,m)-g.transB}},getLabelPosition:function(a,
k,q,m,g,f,e,c){var b=this.axis,r=b.transA,l=b.reversed,C=b.staggerLines,t=b.tickRotCorr||{x:0,y:0},x=g.y,F=m||b.reserveSpaceDefault?0:-b.labelOffset*("center"===b.labelAlign?.5:1);E(x)||(x=0===b.side?q.rotation?-8:-q.getBBox().height:2===b.side?t.y+8:Math.cos(q.rotation*w)*(t.y-q.getBBox(!1,0).height/2));a=a+g.x+F+t.x-(f&&m?f*r*(l?-1:1):0);k=k+x-(f&&!m?f*r*(l?1:-1):0);C&&(q=e/(c||1)%C,b.opposite&&(q=C-q-1),k+=b.labelOffset/C*q);return{x:a,y:Math.round(k)}},getMarkPath:function(a,k,q,m,g,f){return f.crispLine(["M",
a,k,"L",a+(g?0:-q),k+(g?q:0)],m)},renderGridLine:function(a,k,q){var m=this.axis,g=m.options,f=this.gridLine,e={},c=this.pos,b=this.type,r=m.tickmarkOffset,l=m.chart.renderer,C=b?b+"Grid":"grid",t=g[C+"LineWidth"],x=g[C+"LineColor"],g=g[C+"LineDashStyle"];f||(e.stroke=x,e["stroke-width"]=t,g&&(e.dashstyle=g),b||(e.zIndex=1),a&&(e.opacity=0),this.gridLine=f=l.path().attr(e).addClass("highcharts-"+(b?b+"-":"")+"grid-line").add(m.gridGroup));if(!a&&f&&(a=m.getPlotLinePath(c+r,f.strokeWidth()*q,a,!0)))f[this.isNew?
"attr":"animate"]({d:a,opacity:k})},renderMark:function(a,k,z){var m=this.axis,g=m.options,f=m.chart.renderer,e=this.type,c=e?e+"Tick":"tick",b=m.tickSize(c),r=this.mark,l=!r,C=a.x;a=a.y;var t=q(g[c+"Width"],!e&&m.isXAxis?1:0),g=g[c+"Color"];b&&(m.opposite&&(b[0]=-b[0]),l&&(this.mark=r=f.path().addClass("highcharts-"+(e?e+"-":"")+"tick").add(m.axisGroup),r.attr({stroke:g,"stroke-width":t})),r[l?"attr":"animate"]({d:this.getMarkPath(C,a,b[0],r.strokeWidth()*z,m.horiz,f),opacity:k}))},renderLabel:function(a,
k,z,m){var g=this.axis,f=g.horiz,e=g.options,c=this.label,b=e.labels,r=b.step,g=g.tickmarkOffset,l=!0,C=a.x;a=a.y;c&&v(C)&&(c.xy=a=this.getLabelPosition(C,a,c,f,b,g,m,r),this.isFirst&&!this.isLast&&!q(e.showFirstLabel,1)||this.isLast&&!this.isFirst&&!q(e.showLastLabel,1)?l=!1:!f||b.step||b.rotation||k||0===z||this.handleOverflow(a),r&&m%r&&(l=!1),l&&v(a.y)?(a.opacity=z,c[this.isNewLabel?"attr":"animate"](a),this.isNewLabel=!1):(c.attr("y",-9999),this.isNewLabel=!0))},render:function(a,k,z){var m=
this.axis,g=m.horiz,f=this.getPosition(g,this.pos,m.tickmarkOffset,k),e=f.x,c=f.y,m=g&&e===m.pos+m.len||!g&&c===m.pos?-1:1;z=q(z,1);this.isActive=!0;this.renderGridLine(k,z,m);this.renderMark(f,z,m);this.renderLabel(f,k,z,a);this.isNew=!1},destroy:function(){H(this,this.axis)}}})(L);var Z=function(a){var G=a.addEvent,E=a.animObject,H=a.arrayMax,v=a.arrayMin,k=a.color,q=a.correctFloat,w=a.defaultOptions,t=a.defined,u=a.deg2rad,z=a.destroyObjectProperties,m=a.each,g=a.extend,f=a.fireEvent,e=a.format,
c=a.getMagnitude,b=a.grep,r=a.inArray,l=a.isArray,C=a.isNumber,I=a.isString,x=a.merge,F=a.normalizeTickInterval,n=a.objectEach,B=a.pick,J=a.removeEvent,A=a.splat,d=a.syncTimeout,p=a.Tick,D=function(){this.init.apply(this,arguments)};a.extend(D.prototype,{defaultOptions:{dateTimeLabelFormats:{millisecond:"%H:%M:%S.%L",second:"%H:%M:%S",minute:"%H:%M",hour:"%H:%M",day:"%e. %b",week:"%e. %b",month:"%b '%y",year:"%Y"},endOnTick:!1,labels:{enabled:!0,style:{color:"#666666",cursor:"default",fontSize:"11px"},
x:0},maxPadding:.01,minorTickLength:2,minorTickPosition:"outside",minPadding:.01,startOfWeek:1,startOnTick:!1,tickLength:10,tickmarkPlacement:"between",tickPixelInterval:100,tickPosition:"outside",title:{align:"middle",style:{color:"#666666"}},type:"linear",minorGridLineColor:"#f2f2f2",minorGridLineWidth:1,minorTickColor:"#999999",lineColor:"#ccd6eb",lineWidth:1,gridLineColor:"#e6e6e6",tickColor:"#ccd6eb"},defaultYAxisOptions:{endOnTick:!0,tickPixelInterval:72,showLastLabel:!0,labels:{x:-8},maxPadding:.05,
minPadding:.05,startOnTick:!0,title:{rotation:270,text:"Values"},stackLabels:{allowOverlap:!1,enabled:!1,formatter:function(){return a.numberFormat(this.total,-1)},style:{fontSize:"11px",fontWeight:"bold",color:"#000000",textOutline:"1px contrast"}},gridLineWidth:1,lineWidth:0},defaultLeftAxisOptions:{labels:{x:-15},title:{rotation:270}},defaultRightAxisOptions:{labels:{x:15},title:{rotation:90}},defaultBottomAxisOptions:{labels:{autoRotation:[-45],x:0},title:{rotation:0}},defaultTopAxisOptions:{labels:{autoRotation:[-45],
x:0},title:{rotation:0}},init:function(a,d){var h=d.isX,y=this;y.chart=a;y.horiz=a.inverted&&!y.isZAxis?!h:h;y.isXAxis=h;y.coll=y.coll||(h?"xAxis":"yAxis");y.opposite=d.opposite;y.side=d.side||(y.horiz?y.opposite?0:2:y.opposite?1:3);y.setOptions(d);var b=this.options,c=b.type;y.labelFormatter=b.labels.formatter||y.defaultLabelFormatter;y.userOptions=d;y.minPixelPadding=0;y.reversed=b.reversed;y.visible=!1!==b.visible;y.zoomEnabled=!1!==b.zoomEnabled;y.hasNames="category"===c||!0===b.categories;y.categories=
b.categories||y.hasNames;y.names=y.names||[];y.plotLinesAndBandsGroups={};y.isLog="logarithmic"===c;y.isDatetimeAxis="datetime"===c;y.positiveValuesOnly=y.isLog&&!y.allowNegativeLog;y.isLinked=t(b.linkedTo);y.ticks={};y.labelEdge=[];y.minorTicks={};y.plotLinesAndBands=[];y.alternateBands={};y.len=0;y.minRange=y.userMinRange=b.minRange||b.maxZoom;y.range=b.range;y.offset=b.offset||0;y.stacks={};y.oldStacks={};y.stacksTouched=0;y.max=null;y.min=null;y.crosshair=B(b.crosshair,A(a.options.tooltip.crosshairs)[h?
0:1],!1);d=y.options.events;-1===r(y,a.axes)&&(h?a.axes.splice(a.xAxis.length,0,y):a.axes.push(y),a[y.coll].push(y));y.series=y.series||[];a.inverted&&!y.isZAxis&&h&&void 0===y.reversed&&(y.reversed=!0);n(d,function(a,h){G(y,h,a)});y.lin2log=b.linearToLogConverter||y.lin2log;y.isLog&&(y.val2lin=y.log2lin,y.lin2val=y.lin2log)},setOptions:function(a){this.options=x(this.defaultOptions,"yAxis"===this.coll&&this.defaultYAxisOptions,[this.defaultTopAxisOptions,this.defaultRightAxisOptions,this.defaultBottomAxisOptions,
this.defaultLeftAxisOptions][this.side],x(w[this.coll],a))},defaultLabelFormatter:function(){var h=this.axis,d=this.value,b=h.categories,c=this.dateTimeLabelFormat,p=w.lang,n=p.numericSymbols,p=p.numericSymbolMagnitude||1E3,l=n&&n.length,A,r=h.options.labels.format,h=h.isLog?Math.abs(d):h.tickInterval;if(r)A=e(r,this);else if(b)A=d;else if(c)A=a.dateFormat(c,d);else if(l&&1E3<=h)for(;l--&&void 0===A;)b=Math.pow(p,l+1),h>=b&&0===10*d%b&&null!==n[l]&&0!==d&&(A=a.numberFormat(d/b,-1)+n[l]);void 0===
A&&(A=1E4<=Math.abs(d)?a.numberFormat(d,-1):a.numberFormat(d,-1,void 0,""));return A},getSeriesExtremes:function(){var a=this,d=a.chart;a.hasVisibleSeries=!1;a.dataMin=a.dataMax=a.threshold=null;a.softThreshold=!a.isXAxis;a.buildStacks&&a.buildStacks();m(a.series,function(h){if(h.visible||!d.options.chart.ignoreHiddenSeries){var y=h.options,c=y.threshold,p;a.hasVisibleSeries=!0;a.positiveValuesOnly&&0>=c&&(c=null);if(a.isXAxis)y=h.xData,y.length&&(h=v(y),p=H(y),C(h)||h instanceof Date||(y=b(y,C),
h=v(y)),a.dataMin=Math.min(B(a.dataMin,y[0],h),h),a.dataMax=Math.max(B(a.dataMax,y[0],p),p));else if(h.getExtremes(),p=h.dataMax,h=h.dataMin,t(h)&&t(p)&&(a.dataMin=Math.min(B(a.dataMin,h),h),a.dataMax=Math.max(B(a.dataMax,p),p)),t(c)&&(a.threshold=c),!y.softThreshold||a.positiveValuesOnly)a.softThreshold=!1}})},translate:function(a,d,b,c,p,e){var h=this.linkedParent||this,y=1,n=0,l=c?h.oldTransA:h.transA;c=c?h.oldMin:h.min;var A=h.minPixelPadding;p=(h.isOrdinal||h.isBroken||h.isLog&&p)&&h.lin2val;
l||(l=h.transA);b&&(y*=-1,n=h.len);h.reversed&&(y*=-1,n-=y*(h.sector||h.len));d?(a=(a*y+n-A)/l+c,p&&(a=h.lin2val(a))):(p&&(a=h.val2lin(a)),a=C(c)?y*(a-c)*l+n+y*A+(C(e)?l*e:0):void 0);return a},toPixels:function(a,d){return this.translate(a,!1,!this.horiz,null,!0)+(d?0:this.pos)},toValue:function(a,d){return this.translate(a-(d?0:this.pos),!0,!this.horiz,null,!0)},getPlotLinePath:function(a,d,b,c,p){var h=this.chart,y=this.left,e=this.top,n,l,A=b&&h.oldChartHeight||h.chartHeight,r=b&&h.oldChartWidth||
h.chartWidth,f;n=this.transB;var D=function(a,h,d){if(a<h||a>d)c?a=Math.min(Math.max(h,a),d):f=!0;return a};p=B(p,this.translate(a,null,null,b));a=b=Math.round(p+n);n=l=Math.round(A-p-n);C(p)?this.horiz?(n=e,l=A-this.bottom,a=b=D(a,y,y+this.width)):(a=y,b=r-this.right,n=l=D(n,e,e+this.height)):(f=!0,c=!1);return f&&!c?null:h.renderer.crispLine(["M",a,n,"L",b,l],d||1)},getLinearTickPositions:function(a,d,b){var h,y=q(Math.floor(d/a)*a);b=q(Math.ceil(b/a)*a);var c=[],p;q(y+a)===y&&(p=20);if(this.single)return[d];
for(d=y;d<=b;){c.push(d);d=q(d+a,p);if(d===h)break;h=d}return c},getMinorTickInterval:function(){var a=this.options;return!0===a.minorTicks?B(a.minorTickInterval,"auto"):!1===a.minorTicks?null:a.minorTickInterval},getMinorTickPositions:function(){var a=this,d=a.options,b=a.tickPositions,c=a.minorTickInterval,p=[],e=a.pointRangePadding||0,n=a.min-e,e=a.max+e,l=e-n;if(l&&l/c<a.len/3)if(a.isLog)m(this.paddedTicks,function(h,d,y){d&&p.push.apply(p,a.getLogTickPositions(c,y[d-1],y[d],!0))});else if(a.isDatetimeAxis&&
"auto"===this.getMinorTickInterval())p=p.concat(a.getTimeTicks(a.normalizeTimeTickInterval(c),n,e,d.startOfWeek));else for(d=n+(b[0]-n)%c;d<=e&&d!==p[0];d+=c)p.push(d);0!==p.length&&a.trimTicks(p);return p},adjustForMinRange:function(){var a=this.options,d=this.min,b=this.max,c,p,e,n,l,A,r,f;this.isXAxis&&void 0===this.minRange&&!this.isLog&&(t(a.min)||t(a.max)?this.minRange=null:(m(this.series,function(a){A=a.xData;for(n=r=a.xIncrement?1:A.length-1;0<n;n--)if(l=A[n]-A[n-1],void 0===e||l<e)e=l}),
this.minRange=Math.min(5*e,this.dataMax-this.dataMin)));b-d<this.minRange&&(p=this.dataMax-this.dataMin>=this.minRange,f=this.minRange,c=(f-b+d)/2,c=[d-c,B(a.min,d-c)],p&&(c[2]=this.isLog?this.log2lin(this.dataMin):this.dataMin),d=H(c),b=[d+f,B(a.max,d+f)],p&&(b[2]=this.isLog?this.log2lin(this.dataMax):this.dataMax),b=v(b),b-d<f&&(c[0]=b-f,c[1]=B(a.min,b-f),d=H(c)));this.min=d;this.max=b},getClosest:function(){var a;this.categories?a=1:m(this.series,function(h){var d=h.closestPointRange,y=h.visible||
!h.chart.options.chart.ignoreHiddenSeries;!h.noSharedTooltip&&t(d)&&y&&(a=t(a)?Math.min(a,d):d)});return a},nameToX:function(a){var h=l(this.categories),d=h?this.categories:this.names,b=a.options.x,c;a.series.requireSorting=!1;t(b)||(b=!1===this.options.uniqueNames?a.series.autoIncrement():r(a.name,d));-1===b?h||(c=d.length):c=b;void 0!==c&&(this.names[c]=a.name);return c},updateNames:function(){var a=this;0<this.names.length&&(this.names.length=0,this.minRange=this.userMinRange,m(this.series||[],
function(h){h.xIncrement=null;if(!h.points||h.isDirtyData)h.processData(),h.generatePoints();m(h.points,function(d,b){var y;d.options&&(y=a.nameToX(d),void 0!==y&&y!==d.x&&(d.x=y,h.xData[b]=y))})}))},setAxisTranslation:function(a){var h=this,d=h.max-h.min,b=h.axisPointRange||0,c,p=0,e=0,n=h.linkedParent,l=!!h.categories,A=h.transA,r=h.isXAxis;if(r||l||b)c=h.getClosest(),n?(p=n.minPointOffset,e=n.pointRangePadding):m(h.series,function(a){var d=l?1:r?B(a.options.pointRange,c,0):h.axisPointRange||0;
a=a.options.pointPlacement;b=Math.max(b,d);h.single||(p=Math.max(p,I(a)?0:d/2),e=Math.max(e,"on"===a?0:d))}),n=h.ordinalSlope&&c?h.ordinalSlope/c:1,h.minPointOffset=p*=n,h.pointRangePadding=e*=n,h.pointRange=Math.min(b,d),r&&(h.closestPointRange=c);a&&(h.oldTransA=A);h.translationSlope=h.transA=A=h.options.staticScale||h.len/(d+e||1);h.transB=h.horiz?h.left:h.bottom;h.minPixelPadding=A*p},minFromRange:function(){return this.max-this.range},setTickInterval:function(h){var d=this,b=d.chart,p=d.options,
e=d.isLog,n=d.log2lin,l=d.isDatetimeAxis,A=d.isXAxis,r=d.isLinked,D=p.maxPadding,g=p.minPadding,x=p.tickInterval,k=p.tickPixelInterval,I=d.categories,J=d.threshold,u=d.softThreshold,z,w,v,E;l||I||r||this.getTickAmount();v=B(d.userMin,p.min);E=B(d.userMax,p.max);r?(d.linkedParent=b[d.coll][p.linkedTo],b=d.linkedParent.getExtremes(),d.min=B(b.min,b.dataMin),d.max=B(b.max,b.dataMax),p.type!==d.linkedParent.options.type&&a.error(11,1)):(!u&&t(J)&&(d.dataMin>=J?(z=J,g=0):d.dataMax<=J&&(w=J,D=0)),d.min=
B(v,z,d.dataMin),d.max=B(E,w,d.dataMax));e&&(d.positiveValuesOnly&&!h&&0>=Math.min(d.min,B(d.dataMin,d.min))&&a.error(10,1),d.min=q(n(d.min),15),d.max=q(n(d.max),15));d.range&&t(d.max)&&(d.userMin=d.min=v=Math.max(d.dataMin,d.minFromRange()),d.userMax=E=d.max,d.range=null);f(d,"foundExtremes");d.beforePadding&&d.beforePadding();d.adjustForMinRange();!(I||d.axisPointRange||d.usePercentage||r)&&t(d.min)&&t(d.max)&&(n=d.max-d.min)&&(!t(v)&&g&&(d.min-=n*g),!t(E)&&D&&(d.max+=n*D));C(p.softMin)&&!C(d.userMin)&&
(d.min=Math.min(d.min,p.softMin));C(p.softMax)&&!C(d.userMax)&&(d.max=Math.max(d.max,p.softMax));C(p.floor)&&(d.min=Math.max(d.min,p.floor));C(p.ceiling)&&(d.max=Math.min(d.max,p.ceiling));u&&t(d.dataMin)&&(J=J||0,!t(v)&&d.min<J&&d.dataMin>=J?d.min=J:!t(E)&&d.max>J&&d.dataMax<=J&&(d.max=J));d.tickInterval=d.min===d.max||void 0===d.min||void 0===d.max?1:r&&!x&&k===d.linkedParent.options.tickPixelInterval?x=d.linkedParent.tickInterval:B(x,this.tickAmount?(d.max-d.min)/Math.max(this.tickAmount-1,1):
void 0,I?1:(d.max-d.min)*k/Math.max(d.len,k));A&&!h&&m(d.series,function(a){a.processData(d.min!==d.oldMin||d.max!==d.oldMax)});d.setAxisTranslation(!0);d.beforeSetTickPositions&&d.beforeSetTickPositions();d.postProcessTickInterval&&(d.tickInterval=d.postProcessTickInterval(d.tickInterval));d.pointRange&&!x&&(d.tickInterval=Math.max(d.pointRange,d.tickInterval));h=B(p.minTickInterval,d.isDatetimeAxis&&d.closestPointRange);!x&&d.tickInterval<h&&(d.tickInterval=h);l||e||x||(d.tickInterval=F(d.tickInterval,
null,c(d.tickInterval),B(p.allowDecimals,!(.5<d.tickInterval&&5>d.tickInterval&&1E3<d.max&&9999>d.max)),!!this.tickAmount));this.tickAmount||(d.tickInterval=d.unsquish());this.setTickPositions()},setTickPositions:function(){var a=this.options,d,b=a.tickPositions;d=this.getMinorTickInterval();var c=a.tickPositioner,p=a.startOnTick,e=a.endOnTick;this.tickmarkOffset=this.categories&&"between"===a.tickmarkPlacement&&1===this.tickInterval?.5:0;this.minorTickInterval="auto"===d&&this.tickInterval?this.tickInterval/
5:d;this.single=this.min===this.max&&t(this.min)&&!this.tickAmount&&(parseInt(this.min,10)===this.min||!1!==a.allowDecimals);this.tickPositions=d=b&&b.slice();!d&&(d=this.isDatetimeAxis?this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval,a.units),this.min,this.max,a.startOfWeek,this.ordinalPositions,this.closestPointRange,!0):this.isLog?this.getLogTickPositions(this.tickInterval,this.min,this.max):this.getLinearTickPositions(this.tickInterval,this.min,this.max),d.length>this.len&&(d=
[d[0],d.pop()],d[0]===d[1]&&(d.length=1)),this.tickPositions=d,c&&(c=c.apply(this,[this.min,this.max])))&&(this.tickPositions=d=c);this.paddedTicks=d.slice(0);this.trimTicks(d,p,e);this.isLinked||(this.single&&2>d.length&&(this.min-=.5,this.max+=.5),b||c||this.adjustTickAmount())},trimTicks:function(a,d,b){var h=a[0],c=a[a.length-1],p=this.minPointOffset||0;if(!this.isLinked){if(d&&-Infinity!==h)this.min=h;else for(;this.min-p>a[0];)a.shift();if(b)this.max=c;else for(;this.max+p<a[a.length-1];)a.pop();
0===a.length&&t(h)&&!this.options.tickPositions&&a.push((c+h)/2)}},alignToOthers:function(){var a={},d,b=this.options;!1===this.chart.options.chart.alignTicks||!1===b.alignTicks||this.isLog||m(this.chart[this.coll],function(h){var b=h.options,b=[h.horiz?b.left:b.top,b.width,b.height,b.pane].join();h.series.length&&(a[b]?d=!0:a[b]=1)});return d},getTickAmount:function(){var a=this.options,d=a.tickAmount,b=a.tickPixelInterval;!t(a.tickInterval)&&this.len<b&&!this.isRadial&&!this.isLog&&a.startOnTick&&
a.endOnTick&&(d=2);!d&&this.alignToOthers()&&(d=Math.ceil(this.len/b)+1);4>d&&(this.finalTickAmt=d,d=5);this.tickAmount=d},adjustTickAmount:function(){var a=this.tickInterval,d=this.tickPositions,b=this.tickAmount,c=this.finalTickAmt,p=d&&d.length,e=B(this.threshold,this.softThreshold?0:null);if(this.hasData()){if(p<b){for(;d.length<b;)d.length%2||this.min===e?d.push(q(d[d.length-1]+a)):d.unshift(q(d[0]-a));this.transA*=(p-1)/(b-1);this.min=d[0];this.max=d[d.length-1]}else p>b&&(this.tickInterval*=
2,this.setTickPositions());if(t(c)){for(a=b=d.length;a--;)(3===c&&1===a%2||2>=c&&0<a&&a<b-1)&&d.splice(a,1);this.finalTickAmt=void 0}}},setScale:function(){var a,d;this.oldMin=this.min;this.oldMax=this.max;this.oldAxisLength=this.len;this.setAxisSize();d=this.len!==this.oldAxisLength;m(this.series,function(d){if(d.isDirtyData||d.isDirty||d.xAxis.isDirty)a=!0});d||a||this.isLinked||this.forceRedraw||this.userMin!==this.oldUserMin||this.userMax!==this.oldUserMax||this.alignToOthers()?(this.resetStacks&&
this.resetStacks(),this.forceRedraw=!1,this.getSeriesExtremes(),this.setTickInterval(),this.oldUserMin=this.userMin,this.oldUserMax=this.userMax,this.isDirty||(this.isDirty=d||this.min!==this.oldMin||this.max!==this.oldMax)):this.cleanStacks&&this.cleanStacks()},setExtremes:function(a,d,b,c,p){var h=this,e=h.chart;b=B(b,!0);m(h.series,function(a){delete a.kdTree});p=g(p,{min:a,max:d});f(h,"setExtremes",p,function(){h.userMin=a;h.userMax=d;h.eventArgs=p;b&&e.redraw(c)})},zoom:function(a,d){var h=this.dataMin,
b=this.dataMax,c=this.options,p=Math.min(h,B(c.min,h)),c=Math.max(b,B(c.max,b));if(a!==this.min||d!==this.max)this.allowZoomOutside||(t(h)&&(a<p&&(a=p),a>c&&(a=c)),t(b)&&(d<p&&(d=p),d>c&&(d=c))),this.displayBtn=void 0!==a||void 0!==d,this.setExtremes(a,d,!1,void 0,{trigger:"zoom"});return!0},setAxisSize:function(){var d=this.chart,b=this.options,c=b.offsets||[0,0,0,0],p=this.horiz,e=this.width=Math.round(a.relativeLength(B(b.width,d.plotWidth-c[3]+c[1]),d.plotWidth)),n=this.height=Math.round(a.relativeLength(B(b.height,
d.plotHeight-c[0]+c[2]),d.plotHeight)),l=this.top=Math.round(a.relativeLength(B(b.top,d.plotTop+c[0]),d.plotHeight,d.plotTop)),b=this.left=Math.round(a.relativeLength(B(b.left,d.plotLeft+c[3]),d.plotWidth,d.plotLeft));this.bottom=d.chartHeight-n-l;this.right=d.chartWidth-e-b;this.len=Math.max(p?e:n,0);this.pos=p?b:l},getExtremes:function(){var a=this.isLog,d=this.lin2log;return{min:a?q(d(this.min)):this.min,max:a?q(d(this.max)):this.max,dataMin:this.dataMin,dataMax:this.dataMax,userMin:this.userMin,
userMax:this.userMax}},getThreshold:function(a){var d=this.isLog,h=this.lin2log,b=d?h(this.min):this.min,d=d?h(this.max):this.max;null===a?a=b:b>a?a=b:d<a&&(a=d);return this.translate(a,0,1,0,1)},autoLabelAlign:function(a){a=(B(a,0)-90*this.side+720)%360;return 15<a&&165>a?"right":195<a&&345>a?"left":"center"},tickSize:function(a){var d=this.options,h=d[a+"Length"],b=B(d[a+"Width"],"tick"===a&&this.isXAxis?1:0);if(b&&h)return"inside"===d[a+"Position"]&&(h=-h),[h,b]},labelMetrics:function(){var a=
this.tickPositions&&this.tickPositions[0]||0;return this.chart.renderer.fontMetrics(this.options.labels.style&&this.options.labels.style.fontSize,this.ticks[a]&&this.ticks[a].label)},unsquish:function(){var a=this.options.labels,d=this.horiz,b=this.tickInterval,c=b,p=this.len/(((this.categories?1:0)+this.max-this.min)/b),e,n=a.rotation,l=this.labelMetrics(),A,r=Number.MAX_VALUE,f,D=function(a){a/=p||1;a=1<a?Math.ceil(a):1;return a*b};d?(f=!a.staggerLines&&!a.step&&(t(n)?[n]:p<B(a.autoRotationLimit,
80)&&a.autoRotation))&&m(f,function(a){var d;if(a===n||a&&-90<=a&&90>=a)A=D(Math.abs(l.h/Math.sin(u*a))),d=A+Math.abs(a/360),d<r&&(r=d,e=a,c=A)}):a.step||(c=D(l.h));this.autoRotation=f;this.labelRotation=B(e,n);return c},getSlotWidth:function(){var a=this.chart,d=this.horiz,b=this.options.labels,c=Math.max(this.tickPositions.length-(this.categories?0:1),1),p=a.margin[3];return d&&2>(b.step||0)&&!b.rotation&&(this.staggerLines||1)*this.len/c||!d&&(b.style&&parseInt(b.style.width,10)||p&&p-a.spacing[3]||
.33*a.chartWidth)},renderUnsquish:function(){var a=this.chart,d=a.renderer,b=this.tickPositions,c=this.ticks,p=this.options.labels,e=this.horiz,n=this.getSlotWidth(),l=Math.max(1,Math.round(n-2*(p.padding||5))),A={},r=this.labelMetrics(),f=p.style&&p.style.textOverflow,D,g=0,C,B;I(p.rotation)||(A.rotation=p.rotation||0);m(b,function(a){(a=c[a])&&a.labelLength>g&&(g=a.labelLength)});this.maxLabelLength=g;if(this.autoRotation)g>l&&g>r.h?A.rotation=this.labelRotation:this.labelRotation=0;else if(n&&
(D={width:l+"px"},!f))for(D.textOverflow="clip",C=b.length;!e&&C--;)if(B=b[C],l=c[B].label)l.styles&&"ellipsis"===l.styles.textOverflow?l.css({textOverflow:"clip"}):c[B].labelLength>n&&l.css({width:n+"px"}),l.getBBox().height>this.len/b.length-(r.h-r.f)&&(l.specCss={textOverflow:"ellipsis"});A.rotation&&(D={width:(g>.5*a.chartHeight?.33*a.chartHeight:a.chartHeight)+"px"},f||(D.textOverflow="ellipsis"));if(this.labelAlign=p.align||this.autoLabelAlign(this.labelRotation))A.align=this.labelAlign;m(b,
function(a){var d=(a=c[a])&&a.label;d&&(d.attr(A),D&&d.css(x(D,d.specCss)),delete d.specCss,a.rotation=A.rotation)});this.tickRotCorr=d.rotCorr(r.b,this.labelRotation||0,0!==this.side)},hasData:function(){return this.hasVisibleSeries||t(this.min)&&t(this.max)&&this.tickPositions&&0<this.tickPositions.length},addTitle:function(a){var d=this.chart.renderer,h=this.horiz,b=this.opposite,c=this.options.title,p;this.axisTitle||((p=c.textAlign)||(p=(h?{low:"left",middle:"center",high:"right"}:{low:b?"right":
"left",middle:"center",high:b?"left":"right"})[c.align]),this.axisTitle=d.text(c.text,0,0,c.useHTML).attr({zIndex:7,rotation:c.rotation||0,align:p}).addClass("highcharts-axis-title").css(c.style).add(this.axisGroup),this.axisTitle.isNew=!0);c.style.width||this.isRadial||this.axisTitle.css({width:this.len});this.axisTitle[a?"show":"hide"](!0)},generateTick:function(a){var d=this.ticks;d[a]?d[a].addLabel():d[a]=new p(this,a)},getOffset:function(){var a=this,d=a.chart,b=d.renderer,c=a.options,p=a.tickPositions,
e=a.ticks,l=a.horiz,A=a.side,r=d.inverted&&!a.isZAxis?[1,0,3,2][A]:A,f,D,g=0,x,C=0,F=c.title,k=c.labels,q=0,I=d.axisOffset,d=d.clipOffset,J=[-1,1,1,-1][A],u=c.className,z=a.axisParent,v=this.tickSize("tick");f=a.hasData();a.showAxis=D=f||B(c.showEmpty,!0);a.staggerLines=a.horiz&&k.staggerLines;a.axisGroup||(a.gridGroup=b.g("grid").attr({zIndex:c.gridZIndex||1}).addClass("highcharts-"+this.coll.toLowerCase()+"-grid "+(u||"")).add(z),a.axisGroup=b.g("axis").attr({zIndex:c.zIndex||2}).addClass("highcharts-"+
this.coll.toLowerCase()+" "+(u||"")).add(z),a.labelGroup=b.g("axis-labels").attr({zIndex:k.zIndex||7}).addClass("highcharts-"+a.coll.toLowerCase()+"-labels "+(u||"")).add(z));f||a.isLinked?(m(p,function(d,h){a.generateTick(d,h)}),a.renderUnsquish(),a.reserveSpaceDefault=0===A||2===A||{1:"left",3:"right"}[A]===a.labelAlign,B(k.reserveSpace,"center"===a.labelAlign?!0:null,a.reserveSpaceDefault)&&m(p,function(a){q=Math.max(e[a].getLabelSize(),q)}),a.staggerLines&&(q*=a.staggerLines),a.labelOffset=q*
(a.opposite?-1:1)):n(e,function(a,d){a.destroy();delete e[d]});F&&F.text&&!1!==F.enabled&&(a.addTitle(D),D&&!1!==F.reserveSpace&&(a.titleOffset=g=a.axisTitle.getBBox()[l?"height":"width"],x=F.offset,C=t(x)?0:B(F.margin,l?5:10)));a.renderLine();a.offset=J*B(c.offset,I[A]);a.tickRotCorr=a.tickRotCorr||{x:0,y:0};b=0===A?-a.labelMetrics().h:2===A?a.tickRotCorr.y:0;C=Math.abs(q)+C;q&&(C=C-b+J*(l?B(k.y,a.tickRotCorr.y+8*J):k.x));a.axisTitleMargin=B(x,C);I[A]=Math.max(I[A],a.axisTitleMargin+g+J*a.offset,
C,f&&p.length&&v?v[0]+J*a.offset:0);c=c.offset?0:2*Math.floor(a.axisLine.strokeWidth()/2);d[r]=Math.max(d[r],c)},getLinePath:function(a){var d=this.chart,h=this.opposite,b=this.offset,c=this.horiz,p=this.left+(h?this.width:0)+b,b=d.chartHeight-this.bottom-(h?this.height:0)+b;h&&(a*=-1);return d.renderer.crispLine(["M",c?this.left:p,c?b:this.top,"L",c?d.chartWidth-this.right:p,c?b:d.chartHeight-this.bottom],a)},renderLine:function(){this.axisLine||(this.axisLine=this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup),
this.axisLine.attr({stroke:this.options.lineColor,"stroke-width":this.options.lineWidth,zIndex:7}))},getTitlePosition:function(){var a=this.horiz,d=this.left,b=this.top,c=this.len,p=this.options.title,e=a?d:b,n=this.opposite,l=this.offset,A=p.x||0,r=p.y||0,f=this.axisTitle,D=this.chart.renderer.fontMetrics(p.style&&p.style.fontSize,f),f=Math.max(f.getBBox(null,0).height-D.h-1,0),c={low:e+(a?0:c),middle:e+c/2,high:e+(a?c:0)}[p.align],d=(a?b+this.height:d)+(a?1:-1)*(n?-1:1)*this.axisTitleMargin+[-f,
f,D.f,-f][this.side];return{x:a?c+A:d+(n?this.width:0)+l+A,y:a?d+r-(n?this.height:0)+l:c+r}},renderMinorTick:function(a){var d=this.chart.hasRendered&&C(this.oldMin),b=this.minorTicks;b[a]||(b[a]=new p(this,a,"minor"));d&&b[a].isNew&&b[a].render(null,!0);b[a].render(null,!1,1)},renderTick:function(a,d){var b=this.isLinked,h=this.ticks,c=this.chart.hasRendered&&C(this.oldMin);if(!b||a>=this.min&&a<=this.max)h[a]||(h[a]=new p(this,a)),c&&h[a].isNew&&h[a].render(d,!0,.1),h[a].render(d)},render:function(){var b=
this,c=b.chart,e=b.options,l=b.isLog,A=b.lin2log,r=b.isLinked,f=b.tickPositions,D=b.axisTitle,g=b.ticks,x=b.minorTicks,B=b.alternateBands,F=e.stackLabels,k=e.alternateGridColor,q=b.tickmarkOffset,t=b.axisLine,I=b.showAxis,J=E(c.renderer.globalAnimation),u,z;b.labelEdge.length=0;b.overlap=!1;m([g,x,B],function(a){n(a,function(a){a.isActive=!1})});if(b.hasData()||r)b.minorTickInterval&&!b.categories&&m(b.getMinorTickPositions(),function(a){b.renderMinorTick(a)}),f.length&&(m(f,function(a,d){b.renderTick(a,
d)}),q&&(0===b.min||b.single)&&(g[-1]||(g[-1]=new p(b,-1,null,!0)),g[-1].render(-1))),k&&m(f,function(d,h){z=void 0!==f[h+1]?f[h+1]+q:b.max-q;0===h%2&&d<b.max&&z<=b.max+(c.polar?-q:q)&&(B[d]||(B[d]=new a.PlotLineOrBand(b)),u=d+q,B[d].options={from:l?A(u):u,to:l?A(z):z,color:k},B[d].render(),B[d].isActive=!0)}),b._addedPlotLB||(m((e.plotLines||[]).concat(e.plotBands||[]),function(a){b.addPlotBandOrLine(a)}),b._addedPlotLB=!0);m([g,x,B],function(a){var b,h=[],p=J.duration;n(a,function(a,d){a.isActive||
(a.render(d,!1,0),a.isActive=!1,h.push(d))});d(function(){for(b=h.length;b--;)a[h[b]]&&!a[h[b]].isActive&&(a[h[b]].destroy(),delete a[h[b]])},a!==B&&c.hasRendered&&p?p:0)});t&&(t[t.isPlaced?"animate":"attr"]({d:this.getLinePath(t.strokeWidth())}),t.isPlaced=!0,t[I?"show":"hide"](!0));D&&I&&(e=b.getTitlePosition(),C(e.y)?(D[D.isNew?"attr":"animate"](e),D.isNew=!1):(D.attr("y",-9999),D.isNew=!0));F&&F.enabled&&b.renderStackTotals();b.isDirty=!1},redraw:function(){this.visible&&(this.render(),m(this.plotLinesAndBands,
function(a){a.render()}));m(this.series,function(a){a.isDirty=!0})},keepProps:"extKey hcEvents names series userMax userMin".split(" "),destroy:function(a){var d=this,b=d.stacks,h=d.plotLinesAndBands,c;a||J(d);n(b,function(a,d){z(a);b[d]=null});m([d.ticks,d.minorTicks,d.alternateBands],function(a){z(a)});if(h)for(a=h.length;a--;)h[a].destroy();m("stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross".split(" "),function(a){d[a]&&(d[a]=d[a].destroy())});for(c in d.plotLinesAndBandsGroups)d.plotLinesAndBandsGroups[c]=
d.plotLinesAndBandsGroups[c].destroy();n(d,function(a,b){-1===r(b,d.keepProps)&&delete d[b]})},drawCrosshair:function(a,d){var b,h=this.crosshair,c=B(h.snap,!0),p,e=this.cross;a||(a=this.cross&&this.cross.e);this.crosshair&&!1!==(t(d)||!c)?(c?t(d)&&(p=this.isXAxis?d.plotX:this.len-d.plotY):p=a&&(this.horiz?a.chartX-this.pos:this.len-a.chartY+this.pos),t(p)&&(b=this.getPlotLinePath(d&&(this.isXAxis?d.x:B(d.stackY,d.y)),null,null,null,p)||null),t(b)?(d=this.categories&&!this.isRadial,e||(this.cross=
e=this.chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-"+(d?"category ":"thin ")+h.className).attr({zIndex:B(h.zIndex,2)}).add(),e.attr({stroke:h.color||(d?k("#ccd6eb").setOpacity(.25).get():"#cccccc"),"stroke-width":B(h.width,1)}).css({"pointer-events":"none"}),h.dashStyle&&e.attr({dashstyle:h.dashStyle})),e.show().attr({d:b}),d&&!h.width&&e.attr({"stroke-width":this.transA}),this.cross.e=a):this.hideCrosshair()):this.hideCrosshair()},hideCrosshair:function(){this.cross&&
this.cross.hide()}});return a.Axis=D}(L);(function(a){var G=a.Axis,E=a.Date,H=a.dateFormat,v=a.defaultOptions,k=a.defined,q=a.each,w=a.extend,t=a.getMagnitude,u=a.getTZOffset,z=a.normalizeTickInterval,m=a.pick,g=a.timeUnits;G.prototype.getTimeTicks=function(a,e,c,b){var r=[],l={},f=v.global.useUTC,t,x=new E(e-Math.max(u(e),u(c))),F=E.hcMakeTime,n=a.unitRange,B=a.count,J,A;if(k(e)){x[E.hcSetMilliseconds](n>=g.second?0:B*Math.floor(x.getMilliseconds()/B));if(n>=g.second)x[E.hcSetSeconds](n>=g.minute?
0:B*Math.floor(x.getSeconds()/B));if(n>=g.minute)x[E.hcSetMinutes](n>=g.hour?0:B*Math.floor(x[E.hcGetMinutes]()/B));if(n>=g.hour)x[E.hcSetHours](n>=g.day?0:B*Math.floor(x[E.hcGetHours]()/B));if(n>=g.day)x[E.hcSetDate](n>=g.month?1:B*Math.floor(x[E.hcGetDate]()/B));n>=g.month&&(x[E.hcSetMonth](n>=g.year?0:B*Math.floor(x[E.hcGetMonth]()/B)),t=x[E.hcGetFullYear]());if(n>=g.year)x[E.hcSetFullYear](t-t%B);if(n===g.week)x[E.hcSetDate](x[E.hcGetDate]()-x[E.hcGetDay]()+m(b,1));t=x[E.hcGetFullYear]();b=x[E.hcGetMonth]();
var d=x[E.hcGetDate](),p=x[E.hcGetHours]();e=x.getTime();E.hcHasTimeZone&&(A=(!f||!!E.hcGetTimezoneOffset)&&(c-e>4*g.month||u(e)!==u(c)),J=u(x),x=new E(e+J));f=x.getTime();for(e=1;f<c;)r.push(f),f=n===g.year?F(t+e*B,0):n===g.month?F(t,b+e*B):!A||n!==g.day&&n!==g.week?A&&n===g.hour?F(t,b,d,p+e*B,0,0,J)-J:f+n*B:F(t,b,d+e*B*(n===g.day?1:7)),e++;r.push(f);n<=g.hour&&1E4>r.length&&q(r,function(a){0===a%18E5&&"000000000"===H("%H%M%S%L",a)&&(l[a]="day")})}r.info=w(a,{higherRanks:l,totalRange:n*B});return r};
G.prototype.normalizeTimeTickInterval=function(a,e){var c=e||[["millisecond",[1,2,5,10,20,25,50,100,200,500]],["second",[1,2,5,10,15,30]],["minute",[1,2,5,10,15,30]],["hour",[1,2,3,4,6,8,12]],["day",[1,2]],["week",[1,2]],["month",[1,2,3,4,6]],["year",null]];e=c[c.length-1];var b=g[e[0]],r=e[1],l;for(l=0;l<c.length&&!(e=c[l],b=g[e[0]],r=e[1],c[l+1]&&a<=(b*r[r.length-1]+g[c[l+1][0]])/2);l++);b===g.year&&a<5*b&&(r=[1,2,5]);a=z(a/b,r,"year"===e[0]?Math.max(t(a/b),1):1);return{unitRange:b,count:a,unitName:e[0]}}})(L);
(function(a){var G=a.Axis,E=a.getMagnitude,H=a.map,v=a.normalizeTickInterval,k=a.pick;G.prototype.getLogTickPositions=function(a,w,t,u){var q=this.options,m=this.len,g=this.lin2log,f=this.log2lin,e=[];u||(this._minorAutoInterval=null);if(.5<=a)a=Math.round(a),e=this.getLinearTickPositions(a,w,t);else if(.08<=a)for(var m=Math.floor(w),c,b,r,l,C,q=.3<a?[1,2,4]:.15<a?[1,2,4,6,8]:[1,2,3,4,5,6,7,8,9];m<t+1&&!C;m++)for(b=q.length,c=0;c<b&&!C;c++)r=f(g(m)*q[c]),r>w&&(!u||l<=t)&&void 0!==l&&e.push(l),l>t&&
(C=!0),l=r;else w=g(w),t=g(t),a=u?this.getMinorTickInterval():q.tickInterval,a=k("auto"===a?null:a,this._minorAutoInterval,q.tickPixelInterval/(u?5:1)*(t-w)/((u?m/this.tickPositions.length:m)||1)),a=v(a,null,E(a)),e=H(this.getLinearTickPositions(a,w,t),f),u||(this._minorAutoInterval=a/5);u||(this.tickInterval=a);return e};G.prototype.log2lin=function(a){return Math.log(a)/Math.LN10};G.prototype.lin2log=function(a){return Math.pow(10,a)}})(L);(function(a,G){var E=a.arrayMax,H=a.arrayMin,v=a.defined,
k=a.destroyObjectProperties,q=a.each,w=a.erase,t=a.merge,u=a.pick;a.PlotLineOrBand=function(a,m){this.axis=a;m&&(this.options=m,this.id=m.id)};a.PlotLineOrBand.prototype={render:function(){var k=this,m=k.axis,g=m.horiz,f=k.options,e=f.label,c=k.label,b=f.to,r=f.from,l=f.value,C=v(r)&&v(b),q=v(l),x=k.svgElem,F=!x,n=[],B=f.color,J=u(f.zIndex,0),A=f.events,n={"class":"highcharts-plot-"+(C?"band ":"line ")+(f.className||"")},d={},p=m.chart.renderer,D=C?"bands":"lines",h=m.log2lin;m.isLog&&(r=h(r),b=h(b),
l=h(l));q?(n={stroke:B,"stroke-width":f.width},f.dashStyle&&(n.dashstyle=f.dashStyle)):C&&(B&&(n.fill=B),f.borderWidth&&(n.stroke=f.borderColor,n["stroke-width"]=f.borderWidth));d.zIndex=J;D+="-"+J;(B=m.plotLinesAndBandsGroups[D])||(m.plotLinesAndBandsGroups[D]=B=p.g("plot-"+D).attr(d).add());F&&(k.svgElem=x=p.path().attr(n).add(B));if(q)n=m.getPlotLinePath(l,x.strokeWidth());else if(C)n=m.getPlotBandPath(r,b,f);else return;F&&n&&n.length?(x.attr({d:n}),A&&a.objectEach(A,function(a,d){x.on(d,function(a){A[d].apply(k,
[a])})})):x&&(n?(x.show(),x.animate({d:n})):(x.hide(),c&&(k.label=c=c.destroy())));e&&v(e.text)&&n&&n.length&&0<m.width&&0<m.height&&!n.flat?(e=t({align:g&&C&&"center",x:g?!C&&4:10,verticalAlign:!g&&C&&"middle",y:g?C?16:10:C?6:-4,rotation:g&&!C&&90},e),this.renderLabel(e,n,C,J)):c&&c.hide();return k},renderLabel:function(a,m,g,f){var e=this.label,c=this.axis.chart.renderer;e||(e={align:a.textAlign||a.align,rotation:a.rotation,"class":"highcharts-plot-"+(g?"band":"line")+"-label "+(a.className||"")},
e.zIndex=f,this.label=e=c.text(a.text,0,0,a.useHTML).attr(e).add(),e.css(a.style));f=m.xBounds||[m[1],m[4],g?m[6]:m[1]];m=m.yBounds||[m[2],m[5],g?m[7]:m[2]];g=H(f);c=H(m);e.align(a,!1,{x:g,y:c,width:E(f)-g,height:E(m)-c});e.show()},destroy:function(){w(this.axis.plotLinesAndBands,this);delete this.axis;k(this)}};a.extend(G.prototype,{getPlotBandPath:function(a,m){var g=this.getPlotLinePath(m,null,null,!0),f=this.getPlotLinePath(a,null,null,!0),e=[],c=this.horiz,b=1,r;a=a<this.min&&m<this.min||a>this.max&&
m>this.max;if(f&&g)for(a&&(r=f.toString()===g.toString(),b=0),a=0;a<f.length;a+=6)c&&g[a+1]===f[a+1]?(g[a+1]+=b,g[a+4]+=b):c||g[a+2]!==f[a+2]||(g[a+2]+=b,g[a+5]+=b),e.push("M",f[a+1],f[a+2],"L",f[a+4],f[a+5],g[a+4],g[a+5],g[a+1],g[a+2],"z"),e.flat=r;return e},addPlotBand:function(a){return this.addPlotBandOrLine(a,"plotBands")},addPlotLine:function(a){return this.addPlotBandOrLine(a,"plotLines")},addPlotBandOrLine:function(k,m){var g=(new a.PlotLineOrBand(this,k)).render(),f=this.userOptions;g&&(m&&
(f[m]=f[m]||[],f[m].push(k)),this.plotLinesAndBands.push(g));return g},removePlotBandOrLine:function(a){for(var m=this.plotLinesAndBands,g=this.options,f=this.userOptions,e=m.length;e--;)m[e].id===a&&m[e].destroy();q([g.plotLines||[],f.plotLines||[],g.plotBands||[],f.plotBands||[]],function(c){for(e=c.length;e--;)c[e].id===a&&w(c,c[e])})},removePlotBand:function(a){this.removePlotBandOrLine(a)},removePlotLine:function(a){this.removePlotBandOrLine(a)}})})(L,Z);(function(a){var G=a.dateFormat,E=a.each,
H=a.extend,v=a.format,k=a.isNumber,q=a.map,w=a.merge,t=a.pick,u=a.splat,z=a.syncTimeout,m=a.timeUnits;a.Tooltip=function(){this.init.apply(this,arguments)};a.Tooltip.prototype={init:function(a,f){this.chart=a;this.options=f;this.crosshairs=[];this.now={x:0,y:0};this.isHidden=!0;this.split=f.split&&!a.inverted;this.shared=f.shared||this.split},cleanSplit:function(a){E(this.chart.series,function(f){var e=f&&f.tt;e&&(!e.isActive||a?f.tt=e.destroy():e.isActive=!1)})},getLabel:function(){var a=this.chart.renderer,
f=this.options;this.label||(this.split?this.label=a.g("tooltip"):(this.label=a.label("",0,0,f.shape||"callout",null,null,f.useHTML,null,"tooltip").attr({padding:f.padding,r:f.borderRadius}),this.label.attr({fill:f.backgroundColor,"stroke-width":f.borderWidth}).css(f.style).shadow(f.shadow)),this.label.attr({zIndex:8}).add());return this.label},update:function(a){this.destroy();w(!0,this.chart.options.tooltip.userOptions,a);this.init(this.chart,w(!0,this.options,a))},destroy:function(){this.label&&
(this.label=this.label.destroy());this.split&&this.tt&&(this.cleanSplit(this.chart,!0),this.tt=this.tt.destroy());clearTimeout(this.hideTimer);clearTimeout(this.tooltipTimeout)},move:function(a,f,e,c){var b=this,r=b.now,l=!1!==b.options.animation&&!b.isHidden&&(1<Math.abs(a-r.x)||1<Math.abs(f-r.y)),g=b.followPointer||1<b.len;H(r,{x:l?(2*r.x+a)/3:a,y:l?(r.y+f)/2:f,anchorX:g?void 0:l?(2*r.anchorX+e)/3:e,anchorY:g?void 0:l?(r.anchorY+c)/2:c});b.getLabel().attr(r);l&&(clearTimeout(this.tooltipTimeout),
this.tooltipTimeout=setTimeout(function(){b&&b.move(a,f,e,c)},32))},hide:function(a){var f=this;clearTimeout(this.hideTimer);a=t(a,this.options.hideDelay,500);this.isHidden||(this.hideTimer=z(function(){f.getLabel()[a?"fadeOut":"hide"]();f.isHidden=!0},a))},getAnchor:function(a,f){var e,c=this.chart,b=c.inverted,r=c.plotTop,l=c.plotLeft,g=0,m=0,x,F;a=u(a);e=a[0].tooltipPos;this.followPointer&&f&&(void 0===f.chartX&&(f=c.pointer.normalize(f)),e=[f.chartX-c.plotLeft,f.chartY-r]);e||(E(a,function(a){x=
a.series.yAxis;F=a.series.xAxis;g+=a.plotX+(!b&&F?F.left-l:0);m+=(a.plotLow?(a.plotLow+a.plotHigh)/2:a.plotY)+(!b&&x?x.top-r:0)}),g/=a.length,m/=a.length,e=[b?c.plotWidth-m:g,this.shared&&!b&&1<a.length&&f?f.chartY-r:b?c.plotHeight-g:m]);return q(e,Math.round)},getPosition:function(a,f,e){var c=this.chart,b=this.distance,r={},l=c.inverted&&e.h||0,g,m=["y",c.chartHeight,f,e.plotY+c.plotTop,c.plotTop,c.plotTop+c.plotHeight],x=["x",c.chartWidth,a,e.plotX+c.plotLeft,c.plotLeft,c.plotLeft+c.plotWidth],
F=!this.followPointer&&t(e.ttBelow,!c.inverted===!!e.negative),n=function(a,c,e,h,n,A){var d=e<h-b,p=h+b+e<c,f=h-b-e;h+=b;if(F&&p)r[a]=h;else if(!F&&d)r[a]=f;else if(d)r[a]=Math.min(A-e,0>f-l?f:f-l);else if(p)r[a]=Math.max(n,h+l+e>c?h:h+l);else return!1},B=function(a,c,e,h){var d;h<b||h>c-b?d=!1:r[a]=h<e/2?1:h>c-e/2?c-e-2:h-e/2;return d},k=function(a){var d=m;m=x;x=d;g=a},A=function(){!1!==n.apply(0,m)?!1!==B.apply(0,x)||g||(k(!0),A()):g?r.x=r.y=0:(k(!0),A())};(c.inverted||1<this.len)&&k();A();return r},
defaultFormatter:function(a){var f=this.points||u(this),e;e=[a.tooltipFooterHeaderFormatter(f[0])];e=e.concat(a.bodyFormatter(f));e.push(a.tooltipFooterHeaderFormatter(f[0],!0));return e},refresh:function(a,f){var e,c=this.options,b,r=a,l,g={},m=[];e=c.formatter||this.defaultFormatter;var g=this.shared,x;c.enabled&&(clearTimeout(this.hideTimer),this.followPointer=u(r)[0].series.tooltipOptions.followPointer,l=this.getAnchor(r,f),f=l[0],b=l[1],!g||r.series&&r.series.noSharedTooltip?g=r.getLabelConfig():
(E(r,function(a){a.setState("hover");m.push(a.getLabelConfig())}),g={x:r[0].category,y:r[0].y},g.points=m,r=r[0]),this.len=m.length,g=e.call(g,this),x=r.series,this.distance=t(x.tooltipOptions.distance,16),!1===g?this.hide():(e=this.getLabel(),this.isHidden&&e.attr({opacity:1}).show(),this.split?this.renderSplit(g,u(a)):(c.style.width||e.css({width:this.chart.spacingBox.width}),e.attr({text:g&&g.join?g.join(""):g}),e.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-"+t(r.colorIndex,
x.colorIndex)),e.attr({stroke:c.borderColor||r.color||x.color||"#666666"}),this.updatePosition({plotX:f,plotY:b,negative:r.negative,ttBelow:r.ttBelow,h:l[2]||0})),this.isHidden=!1))},renderSplit:function(g,f){var e=this,c=[],b=this.chart,r=b.renderer,l=!0,m=this.options,k=0,x=this.getLabel();a.isString(g)&&(g=[!1,g]);E(g.slice(0,f.length+1),function(a,n){if(!1!==a){n=f[n-1]||{isHeader:!0,plotX:f[0].plotX};var g=n.series||e,C=g.tt,A=n.series||{},d="highcharts-color-"+t(n.colorIndex,A.colorIndex,"none");
C||(g.tt=C=r.label(null,null,null,"callout",null,null,m.useHTML).addClass("highcharts-tooltip-box "+d).attr({padding:m.padding,r:m.borderRadius,fill:m.backgroundColor,stroke:m.borderColor||n.color||A.color||"#333333","stroke-width":m.borderWidth}).add(x));C.isActive=!0;C.attr({text:a});C.css(m.style).shadow(m.shadow);a=C.getBBox();A=a.width+C.strokeWidth();n.isHeader?(k=a.height,A=Math.max(0,Math.min(n.plotX+b.plotLeft-A/2,b.chartWidth-A))):A=n.plotX+b.plotLeft-t(m.distance,16)-A;0>A&&(l=!1);a=(n.series&&
n.series.yAxis&&n.series.yAxis.pos)+(n.plotY||0);a-=b.plotTop;c.push({target:n.isHeader?b.plotHeight+k:a,rank:n.isHeader?1:0,size:g.tt.getBBox().height+1,point:n,x:A,tt:C})}});this.cleanSplit();a.distribute(c,b.plotHeight+k);E(c,function(a){var c=a.point,e=c.series;a.tt.attr({visibility:void 0===a.pos?"hidden":"inherit",x:l||c.isHeader?a.x:c.plotX+b.plotLeft+t(m.distance,16),y:a.pos+b.plotTop,anchorX:c.isHeader?c.plotX+b.plotLeft:c.plotX+e.xAxis.pos,anchorY:c.isHeader?a.pos+b.plotTop-15:c.plotY+e.yAxis.pos})})},
updatePosition:function(a){var f=this.chart,e=this.getLabel(),e=(this.options.positioner||this.getPosition).call(this,e.width,e.height,a);this.move(Math.round(e.x),Math.round(e.y||0),a.plotX+f.plotLeft,a.plotY+f.plotTop)},getDateFormat:function(a,f,e,c){var b=G("%m-%d %H:%M:%S.%L",f),r,l,g={millisecond:15,second:12,minute:9,hour:6,day:3},k="millisecond";for(l in m){if(a===m.week&&+G("%w",f)===e&&"00:00:00.000"===b.substr(6)){l="week";break}if(m[l]>a){l=k;break}if(g[l]&&b.substr(g[l])!=="01-01 00:00:00.000".substr(g[l]))break;
"week"!==l&&(k=l)}l&&(r=c[l]);return r},getXDateFormat:function(a,f,e){f=f.dateTimeLabelFormats;var c=e&&e.closestPointRange;return(c?this.getDateFormat(c,a.x,e.options.startOfWeek,f):f.day)||f.year},tooltipFooterHeaderFormatter:function(a,f){f=f?"footer":"header";var e=a.series,c=e.tooltipOptions,b=c.xDateFormat,r=e.xAxis,l=r&&"datetime"===r.options.type&&k(a.key),g=c[f+"Format"];l&&!b&&(b=this.getXDateFormat(a,c,r));l&&b&&E(a.point&&a.point.tooltipDateKeys||["key"],function(a){g=g.replace("{point."+
a+"}","{point."+a+":"+b+"}")});return v(g,{point:a,series:e})},bodyFormatter:function(a){return q(a,function(a){var e=a.series.tooltipOptions;return(e[(a.point.formatPrefix||"point")+"Formatter"]||a.point.tooltipFormatter).call(a.point,e[(a.point.formatPrefix||"point")+"Format"])})}}})(L);(function(a){var G=a.addEvent,E=a.attr,H=a.charts,v=a.color,k=a.css,q=a.defined,w=a.each,t=a.extend,u=a.find,z=a.fireEvent,m=a.isObject,g=a.offset,f=a.pick,e=a.splat,c=a.Tooltip;a.Pointer=function(a,c){this.init(a,
c)};a.Pointer.prototype={init:function(a,e){this.options=e;this.chart=a;this.runChartClick=e.chart.events&&!!e.chart.events.click;this.pinchDown=[];this.lastValidTouch={};c&&(a.tooltip=new c(a,e.tooltip),this.followTouchMove=f(e.tooltip.followTouchMove,!0));this.setDOMEvents()},zoomOption:function(a){var b=this.chart,c=b.options.chart,e=c.zoomType||"",b=b.inverted;/touch/.test(a.type)&&(e=f(c.pinchType,e));this.zoomX=a=/x/.test(e);this.zoomY=e=/y/.test(e);this.zoomHor=a&&!b||e&&b;this.zoomVert=e&&
!b||a&&b;this.hasZoom=a||e},normalize:function(a,c){var b;b=a.touches?a.touches.length?a.touches.item(0):a.changedTouches[0]:a;c||(this.chartPosition=c=g(this.chart.container));return t(a,{chartX:Math.round(b.pageX-c.left),chartY:Math.round(b.pageY-c.top)})},getCoordinates:function(a){var b={xAxis:[],yAxis:[]};w(this.chart.axes,function(c){b[c.isXAxis?"xAxis":"yAxis"].push({axis:c,value:c.toValue(a[c.horiz?"chartX":"chartY"])})});return b},findNearestKDPoint:function(a,c,e){var b;w(a,function(a){var l=
!(a.noSharedTooltip&&c)&&0>a.options.findNearestPointBy.indexOf("y");a=a.searchPoint(e,l);if((l=m(a,!0))&&!(l=!m(b,!0)))var l=b.distX-a.distX,r=b.dist-a.dist,n=(a.series.group&&a.series.group.zIndex)-(b.series.group&&b.series.group.zIndex),l=0<(0!==l&&c?l:0!==r?r:0!==n?n:b.series.index>a.series.index?-1:1);l&&(b=a)});return b},getPointFromEvent:function(a){a=a.target;for(var b;a&&!b;)b=a.point,a=a.parentNode;return b},getChartCoordinatesFromPoint:function(a,c){var b=a.series,e=b.xAxis,b=b.yAxis,r=
f(a.clientX,a.plotX);if(e&&b)return c?{chartX:e.len+e.pos-r,chartY:b.len+b.pos-a.plotY}:{chartX:r+e.pos,chartY:a.plotY+b.pos}},getHoverData:function(b,c,e,g,k,x,F){var n,l=[],r=F&&F.isBoosting;g=!(!g||!b);F=c&&!c.stickyTracking?[c]:a.grep(e,function(a){return a.visible&&!(!k&&a.directTouch)&&f(a.options.enableMouseTracking,!0)&&a.stickyTracking});c=(n=g?b:this.findNearestKDPoint(F,k,x))&&n.series;n&&(k&&!c.noSharedTooltip?(F=a.grep(e,function(a){return a.visible&&!(!k&&a.directTouch)&&f(a.options.enableMouseTracking,
!0)&&!a.noSharedTooltip}),w(F,function(a){var d=u(a.points,function(a){return a.x===n.x&&!a.isNull});m(d)&&(r&&(d=a.getPoint(d)),l.push(d))})):l.push(n));return{hoverPoint:n,hoverSeries:c,hoverPoints:l}},runPointActions:function(b,c){var e=this.chart,r=e.tooltip&&e.tooltip.options.enabled?e.tooltip:void 0,g=r?r.shared:!1,x=c||e.hoverPoint,m=x&&x.series||e.hoverSeries,m=this.getHoverData(x,m,e.series,!!c||m&&m.directTouch&&this.isDirectTouch,g,b,{isBoosting:e.isBoosting}),n,x=m.hoverPoint;n=m.hoverPoints;
c=(m=m.hoverSeries)&&m.tooltipOptions.followPointer;g=g&&m&&!m.noSharedTooltip;if(x&&(x!==e.hoverPoint||r&&r.isHidden)){w(e.hoverPoints||[],function(b){-1===a.inArray(b,n)&&b.setState()});w(n||[],function(a){a.setState("hover")});if(e.hoverSeries!==m)m.onMouseOver();e.hoverPoint&&e.hoverPoint.firePointEvent("mouseOut");if(!x.series)return;x.firePointEvent("mouseOver");e.hoverPoints=n;e.hoverPoint=x;r&&r.refresh(g?n:x,b)}else c&&r&&!r.isHidden&&(x=r.getAnchor([{}],b),r.updatePosition({plotX:x[0],plotY:x[1]}));
this.unDocMouseMove||(this.unDocMouseMove=G(e.container.ownerDocument,"mousemove",function(b){var c=H[a.hoverChartIndex];if(c)c.pointer.onDocumentMouseMove(b)}));w(e.axes,function(c){var e=f(c.crosshair.snap,!0),l=e?a.find(n,function(a){return a.series[c.coll]===c}):void 0;l||!e?c.drawCrosshair(b,l):c.hideCrosshair()})},reset:function(a,c){var b=this.chart,r=b.hoverSeries,f=b.hoverPoint,g=b.hoverPoints,m=b.tooltip,n=m&&m.shared?g:f;a&&n&&w(e(n),function(b){b.series.isCartesian&&void 0===b.plotX&&
(a=!1)});if(a)m&&n&&(m.refresh(n),f&&(f.setState(f.state,!0),w(b.axes,function(a){a.crosshair&&a.drawCrosshair(null,f)})));else{if(f)f.onMouseOut();g&&w(g,function(a){a.setState()});if(r)r.onMouseOut();m&&m.hide(c);this.unDocMouseMove&&(this.unDocMouseMove=this.unDocMouseMove());w(b.axes,function(a){a.hideCrosshair()});this.hoverX=b.hoverPoints=b.hoverPoint=null}},scaleGroups:function(a,c){var b=this.chart,e;w(b.series,function(l){e=a||l.getPlotBox();l.xAxis&&l.xAxis.zoomEnabled&&l.group&&(l.group.attr(e),
l.markerGroup&&(l.markerGroup.attr(e),l.markerGroup.clip(c?b.clipRect:null)),l.dataLabelsGroup&&l.dataLabelsGroup.attr(e))});b.clipRect.attr(c||b.clipBox)},dragStart:function(a){var b=this.chart;b.mouseIsDown=a.type;b.cancelClick=!1;b.mouseDownX=this.mouseDownX=a.chartX;b.mouseDownY=this.mouseDownY=a.chartY},drag:function(a){var b=this.chart,c=b.options.chart,e=a.chartX,f=a.chartY,g=this.zoomHor,m=this.zoomVert,n=b.plotLeft,B=b.plotTop,k=b.plotWidth,A=b.plotHeight,d,p=this.selectionMarker,D=this.mouseDownX,
h=this.mouseDownY,y=c.panKey&&a[c.panKey+"Key"];p&&p.touch||(e<n?e=n:e>n+k&&(e=n+k),f<B?f=B:f>B+A&&(f=B+A),this.hasDragged=Math.sqrt(Math.pow(D-e,2)+Math.pow(h-f,2)),10<this.hasDragged&&(d=b.isInsidePlot(D-n,h-B),b.hasCartesianSeries&&(this.zoomX||this.zoomY)&&d&&!y&&!p&&(this.selectionMarker=p=b.renderer.rect(n,B,g?1:k,m?1:A,0).attr({fill:c.selectionMarkerFill||v("#335cad").setOpacity(.25).get(),"class":"highcharts-selection-marker",zIndex:7}).add()),p&&g&&(e-=D,p.attr({width:Math.abs(e),x:(0<e?
0:e)+D})),p&&m&&(e=f-h,p.attr({height:Math.abs(e),y:(0<e?0:e)+h})),d&&!p&&c.panning&&b.pan(a,c.panning)))},drop:function(a){var b=this,c=this.chart,e=this.hasPinched;if(this.selectionMarker){var f={originalEvent:a,xAxis:[],yAxis:[]},g=this.selectionMarker,m=g.attr?g.attr("x"):g.x,n=g.attr?g.attr("y"):g.y,B=g.attr?g.attr("width"):g.width,u=g.attr?g.attr("height"):g.height,A;if(this.hasDragged||e)w(c.axes,function(d){if(d.zoomEnabled&&q(d.min)&&(e||b[{xAxis:"zoomX",yAxis:"zoomY"}[d.coll]])){var c=d.horiz,
l="touchend"===a.type?d.minPixelPadding:0,h=d.toValue((c?m:n)+l),c=d.toValue((c?m+B:n+u)-l);f[d.coll].push({axis:d,min:Math.min(h,c),max:Math.max(h,c)});A=!0}}),A&&z(c,"selection",f,function(a){c.zoom(t(a,e?{animation:!1}:null))});this.selectionMarker=this.selectionMarker.destroy();e&&this.scaleGroups()}c&&(k(c.container,{cursor:c._cursor}),c.cancelClick=10<this.hasDragged,c.mouseIsDown=this.hasDragged=this.hasPinched=!1,this.pinchDown=[])},onContainerMouseDown:function(a){2!==a.button&&(a=this.normalize(a),
this.zoomOption(a),a.preventDefault&&a.preventDefault(),this.dragStart(a))},onDocumentMouseUp:function(b){H[a.hoverChartIndex]&&H[a.hoverChartIndex].pointer.drop(b)},onDocumentMouseMove:function(a){var b=this.chart,c=this.chartPosition;a=this.normalize(a,c);!c||this.inClass(a.target,"highcharts-tracker")||b.isInsidePlot(a.chartX-b.plotLeft,a.chartY-b.plotTop)||this.reset()},onContainerMouseLeave:function(b){var c=H[a.hoverChartIndex];c&&(b.relatedTarget||b.toElement)&&(c.pointer.reset(),c.pointer.chartPosition=
null)},onContainerMouseMove:function(b){var c=this.chart;q(a.hoverChartIndex)&&H[a.hoverChartIndex]&&H[a.hoverChartIndex].mouseIsDown||(a.hoverChartIndex=c.index);b=this.normalize(b);b.returnValue=!1;"mousedown"===c.mouseIsDown&&this.drag(b);!this.inClass(b.target,"highcharts-tracker")&&!c.isInsidePlot(b.chartX-c.plotLeft,b.chartY-c.plotTop)||c.openMenu||this.runPointActions(b)},inClass:function(a,c){for(var b;a;){if(b=E(a,"class")){if(-1!==b.indexOf(c))return!0;if(-1!==b.indexOf("highcharts-container"))return!1}a=
a.parentNode}},onTrackerMouseOut:function(a){var b=this.chart.hoverSeries;a=a.relatedTarget||a.toElement;this.isDirectTouch=!1;if(!(!b||!a||b.stickyTracking||this.inClass(a,"highcharts-tooltip")||this.inClass(a,"highcharts-series-"+b.index)&&this.inClass(a,"highcharts-tracker")))b.onMouseOut()},onContainerClick:function(a){var b=this.chart,c=b.hoverPoint,e=b.plotLeft,f=b.plotTop;a=this.normalize(a);b.cancelClick||(c&&this.inClass(a.target,"highcharts-tracker")?(z(c.series,"click",t(a,{point:c})),
b.hoverPoint&&c.firePointEvent("click",a)):(t(a,this.getCoordinates(a)),b.isInsidePlot(a.chartX-e,a.chartY-f)&&z(b,"click",a)))},setDOMEvents:function(){var b=this,c=b.chart.container,e=c.ownerDocument;c.onmousedown=function(a){b.onContainerMouseDown(a)};c.onmousemove=function(a){b.onContainerMouseMove(a)};c.onclick=function(a){b.onContainerClick(a)};this.unbindContainerMouseLeave=G(c,"mouseleave",b.onContainerMouseLeave);a.unbindDocumentMouseUp||(a.unbindDocumentMouseUp=G(e,"mouseup",b.onDocumentMouseUp));
a.hasTouch&&(c.ontouchstart=function(a){b.onContainerTouchStart(a)},c.ontouchmove=function(a){b.onContainerTouchMove(a)},a.unbindDocumentTouchEnd||(a.unbindDocumentTouchEnd=G(e,"touchend",b.onDocumentTouchEnd)))},destroy:function(){var b=this;b.unDocMouseMove&&b.unDocMouseMove();this.unbindContainerMouseLeave();a.chartCount||(a.unbindDocumentMouseUp&&(a.unbindDocumentMouseUp=a.unbindDocumentMouseUp()),a.unbindDocumentTouchEnd&&(a.unbindDocumentTouchEnd=a.unbindDocumentTouchEnd()));clearInterval(b.tooltipTimeout);
a.objectEach(b,function(a,c){b[c]=null})}}})(L);(function(a){var G=a.charts,E=a.each,H=a.extend,v=a.map,k=a.noop,q=a.pick;H(a.Pointer.prototype,{pinchTranslate:function(a,k,q,v,m,g){this.zoomHor&&this.pinchTranslateDirection(!0,a,k,q,v,m,g);this.zoomVert&&this.pinchTranslateDirection(!1,a,k,q,v,m,g)},pinchTranslateDirection:function(a,k,q,v,m,g,f,e){var c=this.chart,b=a?"x":"y",r=a?"X":"Y",l="chart"+r,C=a?"width":"height",t=c["plot"+(a?"Left":"Top")],x,F,n=e||1,B=c.inverted,u=c.bounds[a?"h":"v"],
A=1===k.length,d=k[0][l],p=q[0][l],D=!A&&k[1][l],h=!A&&q[1][l],y;q=function(){!A&&20<Math.abs(d-D)&&(n=e||Math.abs(p-h)/Math.abs(d-D));F=(t-p)/n+d;x=c["plot"+(a?"Width":"Height")]/n};q();k=F;k<u.min?(k=u.min,y=!0):k+x>u.max&&(k=u.max-x,y=!0);y?(p-=.8*(p-f[b][0]),A||(h-=.8*(h-f[b][1])),q()):f[b]=[p,h];B||(g[b]=F-t,g[C]=x);g=B?1/n:n;m[C]=x;m[b]=k;v[B?a?"scaleY":"scaleX":"scale"+r]=n;v["translate"+r]=g*t+(p-g*d)},pinch:function(a){var t=this,u=t.chart,w=t.pinchDown,m=a.touches,g=m.length,f=t.lastValidTouch,
e=t.hasZoom,c=t.selectionMarker,b={},r=1===g&&(t.inClass(a.target,"highcharts-tracker")&&u.runTrackerClick||t.runChartClick),l={};1<g&&(t.initiated=!0);e&&t.initiated&&!r&&a.preventDefault();v(m,function(a){return t.normalize(a)});"touchstart"===a.type?(E(m,function(a,b){w[b]={chartX:a.chartX,chartY:a.chartY}}),f.x=[w[0].chartX,w[1]&&w[1].chartX],f.y=[w[0].chartY,w[1]&&w[1].chartY],E(u.axes,function(a){if(a.zoomEnabled){var b=u.bounds[a.horiz?"h":"v"],c=a.minPixelPadding,e=a.toPixels(q(a.options.min,
a.dataMin)),n=a.toPixels(q(a.options.max,a.dataMax)),l=Math.max(e,n);b.min=Math.min(a.pos,Math.min(e,n)-c);b.max=Math.max(a.pos+a.len,l+c)}}),t.res=!0):t.followTouchMove&&1===g?this.runPointActions(t.normalize(a)):w.length&&(c||(t.selectionMarker=c=H({destroy:k,touch:!0},u.plotBox)),t.pinchTranslate(w,m,b,c,l,f),t.hasPinched=e,t.scaleGroups(b,l),t.res&&(t.res=!1,this.reset(!1,0)))},touch:function(k,t){var u=this.chart,v,m;if(u.index!==a.hoverChartIndex)this.onContainerMouseLeave({relatedTarget:!0});
a.hoverChartIndex=u.index;1===k.touches.length?(k=this.normalize(k),(m=u.isInsidePlot(k.chartX-u.plotLeft,k.chartY-u.plotTop))&&!u.openMenu?(t&&this.runPointActions(k),"touchmove"===k.type&&(t=this.pinchDown,v=t[0]?4<=Math.sqrt(Math.pow(t[0].chartX-k.chartX,2)+Math.pow(t[0].chartY-k.chartY,2)):!1),q(v,!0)&&this.pinch(k)):t&&this.reset()):2===k.touches.length&&this.pinch(k)},onContainerTouchStart:function(a){this.zoomOption(a);this.touch(a,!0)},onContainerTouchMove:function(a){this.touch(a)},onDocumentTouchEnd:function(k){G[a.hoverChartIndex]&&
G[a.hoverChartIndex].pointer.drop(k)}})})(L);(function(a){var G=a.addEvent,E=a.charts,H=a.css,v=a.doc,k=a.extend,q=a.noop,w=a.Pointer,t=a.removeEvent,u=a.win,z=a.wrap;if(!a.hasTouch&&(u.PointerEvent||u.MSPointerEvent)){var m={},g=!!u.PointerEvent,f=function(){var c=[];c.item=function(a){return this[a]};a.objectEach(m,function(a){c.push({pageX:a.pageX,pageY:a.pageY,target:a.target})});return c},e=function(c,b,e,l){"touch"!==c.pointerType&&c.pointerType!==c.MSPOINTER_TYPE_TOUCH||!E[a.hoverChartIndex]||
(l(c),l=E[a.hoverChartIndex].pointer,l[b]({type:e,target:c.currentTarget,preventDefault:q,touches:f()}))};k(w.prototype,{onContainerPointerDown:function(a){e(a,"onContainerTouchStart","touchstart",function(a){m[a.pointerId]={pageX:a.pageX,pageY:a.pageY,target:a.currentTarget}})},onContainerPointerMove:function(a){e(a,"onContainerTouchMove","touchmove",function(a){m[a.pointerId]={pageX:a.pageX,pageY:a.pageY};m[a.pointerId].target||(m[a.pointerId].target=a.currentTarget)})},onDocumentPointerUp:function(a){e(a,
"onDocumentTouchEnd","touchend",function(a){delete m[a.pointerId]})},batchMSEvents:function(a){a(this.chart.container,g?"pointerdown":"MSPointerDown",this.onContainerPointerDown);a(this.chart.container,g?"pointermove":"MSPointerMove",this.onContainerPointerMove);a(v,g?"pointerup":"MSPointerUp",this.onDocumentPointerUp)}});z(w.prototype,"init",function(a,b,e){a.call(this,b,e);this.hasZoom&&H(b.container,{"-ms-touch-action":"none","touch-action":"none"})});z(w.prototype,"setDOMEvents",function(a){a.apply(this);
(this.hasZoom||this.followTouchMove)&&this.batchMSEvents(G)});z(w.prototype,"destroy",function(a){this.batchMSEvents(t);a.call(this)})}})(L);(function(a){var G=a.addEvent,E=a.css,H=a.discardElement,v=a.defined,k=a.each,q=a.isFirefox,w=a.marginNames,t=a.merge,u=a.pick,z=a.setAnimation,m=a.stableSort,g=a.win,f=a.wrap;a.Legend=function(a,c){this.init(a,c)};a.Legend.prototype={init:function(a,c){this.chart=a;this.setOptions(c);c.enabled&&(this.render(),G(this.chart,"endResize",function(){this.legend.positionCheckboxes()}))},
setOptions:function(a){var c=u(a.padding,8);this.options=a;this.itemStyle=a.itemStyle;this.itemHiddenStyle=t(this.itemStyle,a.itemHiddenStyle);this.itemMarginTop=a.itemMarginTop||0;this.padding=c;this.initialItemY=c-5;this.itemHeight=this.maxItemWidth=0;this.symbolWidth=u(a.symbolWidth,16);this.pages=[]},update:function(a,c){var b=this.chart;this.setOptions(t(!0,this.options,a));this.destroy();b.isDirtyLegend=b.isDirtyBox=!0;u(c,!0)&&b.redraw()},colorizeItem:function(a,c){a.legendGroup[c?"removeClass":
"addClass"]("highcharts-legend-item-hidden");var b=this.options,e=a.legendItem,l=a.legendLine,f=a.legendSymbol,g=this.itemHiddenStyle.color,b=c?b.itemStyle.color:g,m=c?a.color||g:g,k=a.options&&a.options.marker,n={fill:m};e&&e.css({fill:b,color:b});l&&l.attr({stroke:m});f&&(k&&f.isMarker&&(n=a.pointAttribs(),c||(n.stroke=n.fill=g)),f.attr(n))},positionItem:function(a){var c=this.options,b=c.symbolPadding,c=!c.rtl,e=a._legendItemPos,l=e[0],e=e[1],f=a.checkbox;(a=a.legendGroup)&&a.element&&a.translate(c?
l:this.legendWidth-l-2*b-4,e);f&&(f.x=l,f.y=e)},destroyItem:function(a){var c=a.checkbox;k(["legendItem","legendLine","legendSymbol","legendGroup"],function(b){a[b]&&(a[b]=a[b].destroy())});c&&H(a.checkbox)},destroy:function(){function a(a){this[a]&&(this[a]=this[a].destroy())}k(this.getAllItems(),function(c){k(["legendItem","legendGroup"],a,c)});k("clipRect up down pager nav box title group".split(" "),a,this);this.display=null},positionCheckboxes:function(){var a=this.group&&this.group.alignAttr,
c,b=this.clipHeight||this.legendHeight,f=this.titleHeight;a&&(c=a.translateY,k(this.allItems,function(e){var l=e.checkbox,g;l&&(g=c+f+l.y+(this.scrollOffset||0)+3,E(l,{left:a.translateX+e.checkboxOffset+l.x-20+"px",top:g+"px",display:g>c-6&&g<c+b-6?"":"none"}))},this))},renderTitle:function(){var a=this.options,c=this.padding,b=a.title,f=0;b.text&&(this.title||(this.title=this.chart.renderer.label(b.text,c-3,c-4,null,null,null,a.useHTML,null,"legend-title").attr({zIndex:1}).css(b.style).add(this.group)),
a=this.title.getBBox(),f=a.height,this.offsetWidth=a.width,this.contentGroup.attr({translateY:f}));this.titleHeight=f},setText:function(e){var c=this.options;e.legendItem.attr({text:c.labelFormat?a.format(c.labelFormat,e):c.labelFormatter.call(e)})},renderItem:function(a){var c=this.chart,b=c.renderer,e=this.options,l="horizontal"===e.layout,f=this.symbolWidth,g=e.symbolPadding,m=this.itemStyle,k=this.itemHiddenStyle,n=this.padding,B=l?u(e.itemDistance,20):0,q=!e.rtl,A=e.width,d=e.itemMarginBottom||
0,p=this.itemMarginTop,D=a.legendItem,h=!a.series,y=!h&&a.series.drawLegendSymbol?a.series:a,v=y.options,M=this.createCheckboxForItem&&v&&v.showCheckbox,v=f+g+B+(M?20:0),w=e.useHTML,N=a.options.className;D||(a.legendGroup=b.g("legend-item").addClass("highcharts-"+y.type+"-series highcharts-color-"+a.colorIndex+(N?" "+N:"")+(h?" highcharts-series-"+a.index:"")).attr({zIndex:1}).add(this.scrollGroup),a.legendItem=D=b.text("",q?f+g:-g,this.baseline||0,w).css(t(a.visible?m:k)).attr({align:q?"left":"right",
zIndex:2}).add(a.legendGroup),this.baseline||(f=m.fontSize,this.fontMetrics=b.fontMetrics(f,D),this.baseline=this.fontMetrics.f+3+p,D.attr("y",this.baseline)),this.symbolHeight=e.symbolHeight||this.fontMetrics.f,y.drawLegendSymbol(this,a),this.setItemEvents&&this.setItemEvents(a,D,w),M&&this.createCheckboxForItem(a));this.colorizeItem(a,a.visible);m.width||D.css({width:(e.itemWidth||e.width||c.spacingBox.width)-v});this.setText(a);b=D.getBBox();m=a.checkboxOffset=e.itemWidth||a.legendItemWidth||b.width+
v;this.itemHeight=b=Math.round(a.legendItemHeight||b.height||this.symbolHeight);l&&this.itemX-n+m>(A||c.spacingBox.width-2*n-e.x)&&(this.itemX=n,this.itemY+=p+this.lastLineHeight+d,this.lastLineHeight=0);this.maxItemWidth=Math.max(this.maxItemWidth,m);this.lastItemY=p+this.itemY+d;this.lastLineHeight=Math.max(b,this.lastLineHeight);a._legendItemPos=[this.itemX,this.itemY];l?this.itemX+=m:(this.itemY+=p+b+d,this.lastLineHeight=b);this.offsetWidth=A||Math.max((l?this.itemX-n-(a.checkbox?0:B):m)+n,this.offsetWidth)},
getAllItems:function(){var a=[];k(this.chart.series,function(c){var b=c&&c.options;c&&u(b.showInLegend,v(b.linkedTo)?!1:void 0,!0)&&(a=a.concat(c.legendItems||("point"===b.legendType?c.data:c)))});return a},getAlignment:function(){var a=this.options;return a.floating?"":a.align.charAt(0)+a.verticalAlign.charAt(0)+a.layout.charAt(0)},adjustMargins:function(a,c){var b=this.chart,e=this.options,l=this.getAlignment();l&&k([/(lth|ct|rth)/,/(rtv|rm|rbv)/,/(rbh|cb|lbh)/,/(lbv|lm|ltv)/],function(f,g){f.test(l)&&
!v(a[g])&&(b[w[g]]=Math.max(b[w[g]],b.legend[(g+1)%2?"legendHeight":"legendWidth"]+[1,-1,-1,1][g]*e[g%2?"x":"y"]+u(e.margin,12)+c[g]+(0===g?b.titleOffset+b.options.title.margin:0)))})},render:function(){var a=this,c=a.chart,b=c.renderer,f=a.group,l,g,q,x,F=a.box,n=a.options,B=a.padding;a.itemX=B;a.itemY=a.initialItemY;a.offsetWidth=0;a.lastItemY=0;f||(a.group=f=b.g("legend").attr({zIndex:7}).add(),a.contentGroup=b.g().attr({zIndex:1}).add(f),a.scrollGroup=b.g().add(a.contentGroup));a.renderTitle();
l=a.getAllItems();m(l,function(a,b){return(a.options&&a.options.legendIndex||0)-(b.options&&b.options.legendIndex||0)});n.reversed&&l.reverse();a.allItems=l;a.display=g=!!l.length;a.lastLineHeight=0;k(l,function(b){a.renderItem(b)});q=(n.width||a.offsetWidth)+B;x=a.lastItemY+a.lastLineHeight+a.titleHeight;x=a.handleOverflow(x);x+=B;F||(a.box=F=b.rect().addClass("highcharts-legend-box").attr({r:n.borderRadius}).add(f),F.isNew=!0);F.attr({stroke:n.borderColor,"stroke-width":n.borderWidth||0,fill:n.backgroundColor||
"none"}).shadow(n.shadow);0<q&&0<x&&(F[F.isNew?"attr":"animate"](F.crisp.call({},{x:0,y:0,width:q,height:x},F.strokeWidth())),F.isNew=!1);F[g?"show":"hide"]();a.legendWidth=q;a.legendHeight=x;k(l,function(b){a.positionItem(b)});g&&(b=c.spacingBox,/(lth|ct|rth)/.test(a.getAlignment())&&(b=t(b,{y:b.y+c.titleOffset+c.options.title.margin})),f.align(t(n,{width:q,height:x}),!0,b));c.isResizing||this.positionCheckboxes()},handleOverflow:function(a){var c=this,b=this.chart,e=b.renderer,l=this.options,f=
l.y,g=this.padding,b=b.spacingBox.height+("top"===l.verticalAlign?-f:f)-g,f=l.maxHeight,m,F=this.clipRect,n=l.navigation,B=u(n.animation,!0),q=n.arrowSize||12,A=this.nav,d=this.pages,p,D=this.allItems,h=function(a){"number"===typeof a?F.attr({height:a}):F&&(c.clipRect=F.destroy(),c.contentGroup.clip());c.contentGroup.div&&(c.contentGroup.div.style.clip=a?"rect("+g+"px,9999px,"+(g+a)+"px,0)":"auto")};"horizontal"!==l.layout||"middle"===l.verticalAlign||l.floating||(b/=2);f&&(b=Math.min(b,f));d.length=
0;a>b&&!1!==n.enabled?(this.clipHeight=m=Math.max(b-20-this.titleHeight-g,0),this.currentPage=u(this.currentPage,1),this.fullHeight=a,k(D,function(a,b){var c=a._legendItemPos[1],h=Math.round(a.legendItem.getBBox().height),e=d.length;if(!e||c-d[e-1]>m&&(p||c)!==d[e-1])d.push(p||c),e++;a.pageIx=e-1;p&&(D[b-1].pageIx=e-1);b===D.length-1&&c+h-d[e-1]>m&&(d.push(c),a.pageIx=e);c!==p&&(p=c)}),F||(F=c.clipRect=e.clipRect(0,g,9999,0),c.contentGroup.clip(F)),h(m),A||(this.nav=A=e.g().attr({zIndex:1}).add(this.group),
this.up=e.symbol("triangle",0,0,q,q).on("click",function(){c.scroll(-1,B)}).add(A),this.pager=e.text("",15,10).addClass("highcharts-legend-navigation").css(n.style).add(A),this.down=e.symbol("triangle-down",0,0,q,q).on("click",function(){c.scroll(1,B)}).add(A)),c.scroll(0),a=b):A&&(h(),this.nav=A.destroy(),this.scrollGroup.attr({translateY:1}),this.clipHeight=0);return a},scroll:function(a,c){var b=this.pages,e=b.length;a=this.currentPage+a;var l=this.clipHeight,f=this.options.navigation,g=this.pager,
m=this.padding;a>e&&(a=e);0<a&&(void 0!==c&&z(c,this.chart),this.nav.attr({translateX:m,translateY:l+this.padding+7+this.titleHeight,visibility:"visible"}),this.up.attr({"class":1===a?"highcharts-legend-nav-inactive":"highcharts-legend-nav-active"}),g.attr({text:a+"/"+e}),this.down.attr({x:18+this.pager.getBBox().width,"class":a===e?"highcharts-legend-nav-inactive":"highcharts-legend-nav-active"}),this.up.attr({fill:1===a?f.inactiveColor:f.activeColor}).css({cursor:1===a?"default":"pointer"}),this.down.attr({fill:a===
e?f.inactiveColor:f.activeColor}).css({cursor:a===e?"default":"pointer"}),this.scrollOffset=-b[a-1]+this.initialItemY,this.scrollGroup.animate({translateY:this.scrollOffset}),this.currentPage=a,this.positionCheckboxes())}};a.LegendSymbolMixin={drawRectangle:function(a,c){var b=a.symbolHeight,e=a.options.squareSymbol;c.legendSymbol=this.chart.renderer.rect(e?(a.symbolWidth-b)/2:0,a.baseline-b+1,e?b:a.symbolWidth,b,u(a.options.symbolRadius,b/2)).addClass("highcharts-point").attr({zIndex:3}).add(c.legendGroup)},
drawLineMarker:function(a){var c=this.options,b=c.marker,e=a.symbolWidth,l=a.symbolHeight,f=l/2,g=this.chart.renderer,m=this.legendGroup;a=a.baseline-Math.round(.3*a.fontMetrics.b);var k;k={"stroke-width":c.lineWidth||0};c.dashStyle&&(k.dashstyle=c.dashStyle);this.legendLine=g.path(["M",0,a,"L",e,a]).addClass("highcharts-graph").attr(k).add(m);b&&!1!==b.enabled&&(c=Math.min(u(b.radius,f),f),0===this.symbol.indexOf("url")&&(b=t(b,{width:l,height:l}),c=0),this.legendSymbol=b=g.symbol(this.symbol,e/
2-c,a-c,2*c,2*c,b).addClass("highcharts-point").add(m),b.isMarker=!0)}};(/Trident\/7\.0/.test(g.navigator.userAgent)||q)&&f(a.Legend.prototype,"positionItem",function(a,c){var b=this,e=function(){c._legendItemPos&&a.call(b,c)};e();setTimeout(e)})})(L);(function(a){var G=a.addEvent,E=a.animate,H=a.animObject,v=a.attr,k=a.doc,q=a.Axis,w=a.createElement,t=a.defaultOptions,u=a.discardElement,z=a.charts,m=a.css,g=a.defined,f=a.each,e=a.extend,c=a.find,b=a.fireEvent,r=a.grep,l=a.isNumber,C=a.isObject,I=
a.isString,x=a.Legend,F=a.marginNames,n=a.merge,B=a.objectEach,J=a.Pointer,A=a.pick,d=a.pInt,p=a.removeEvent,D=a.seriesTypes,h=a.splat,y=a.svg,P=a.syncTimeout,M=a.win,O=a.Chart=function(){this.getArgs.apply(this,arguments)};a.chart=function(a,d,b){return new O(a,d,b)};e(O.prototype,{callbacks:[],getArgs:function(){var a=[].slice.call(arguments);if(I(a[0])||a[0].nodeName)this.renderTo=a.shift();this.init(a[0],a[1])},init:function(d,b){var c,h,p=d.series,e=d.plotOptions||{};d.series=null;c=n(t,d);for(h in c.plotOptions)c.plotOptions[h].tooltip=
e[h]&&n(e[h].tooltip)||void 0;c.tooltip.userOptions=d.chart&&d.chart.forExport&&d.tooltip.userOptions||d.tooltip;c.series=d.series=p;this.userOptions=d;d=c.chart;h=d.events;this.margin=[];this.spacing=[];this.bounds={h:{},v:{}};this.labelCollectors=[];this.callback=b;this.isResizing=0;this.options=c;this.axes=[];this.series=[];this.hasCartesianSeries=d.showAxes;var l=this;l.index=z.length;z.push(l);a.chartCount++;h&&B(h,function(a,d){G(l,d,a)});l.xAxis=[];l.yAxis=[];l.pointCount=l.colorCounter=l.symbolCounter=
0;l.firstRender()},initSeries:function(d){var b=this.options.chart;(b=D[d.type||b.type||b.defaultSeriesType])||a.error(17,!0);b=new b;b.init(this,d);return b},orderSeries:function(a){var d=this.series;for(a=a||0;a<d.length;a++)d[a]&&(d[a].index=a,d[a].name=d[a].name||"Series "+(d[a].index+1))},isInsidePlot:function(a,d,b){var c=b?d:a;a=b?a:d;return 0<=c&&c<=this.plotWidth&&0<=a&&a<=this.plotHeight},redraw:function(d){var c=this.axes,h=this.series,p=this.pointer,n=this.legend,l=this.isDirtyLegend,
A,g,y=this.hasCartesianSeries,D=this.isDirtyBox,m,r=this.renderer,x=r.isHidden(),B=[];this.setResponsive&&this.setResponsive(!1);a.setAnimation(d,this);x&&this.temporaryDisplay();this.layOutTitles();for(d=h.length;d--;)if(m=h[d],m.options.stacking&&(A=!0,m.isDirty)){g=!0;break}if(g)for(d=h.length;d--;)m=h[d],m.options.stacking&&(m.isDirty=!0);f(h,function(a){a.isDirty&&"point"===a.options.legendType&&(a.updateTotals&&a.updateTotals(),l=!0);a.isDirtyData&&b(a,"updatedData")});l&&n.options.enabled&&
(n.render(),this.isDirtyLegend=!1);A&&this.getStacks();y&&f(c,function(a){a.updateNames();a.setScale()});this.getMargins();y&&(f(c,function(a){a.isDirty&&(D=!0)}),f(c,function(a){var d=a.min+","+a.max;a.extKey!==d&&(a.extKey=d,B.push(function(){b(a,"afterSetExtremes",e(a.eventArgs,a.getExtremes()));delete a.eventArgs}));(D||A)&&a.redraw()}));D&&this.drawChartBox();b(this,"predraw");f(h,function(a){(D||a.isDirty)&&a.visible&&a.redraw();a.isDirtyData=!1});p&&p.reset(!0);r.draw();b(this,"redraw");b(this,
"render");x&&this.temporaryDisplay(!0);f(B,function(a){a.call()})},get:function(a){function d(d){return d.id===a||d.options&&d.options.id===a}var b,h=this.series,p;b=c(this.axes,d)||c(this.series,d);for(p=0;!b&&p<h.length;p++)b=c(h[p].points||[],d);return b},getAxes:function(){var a=this,d=this.options,b=d.xAxis=h(d.xAxis||{}),d=d.yAxis=h(d.yAxis||{});f(b,function(a,d){a.index=d;a.isX=!0});f(d,function(a,d){a.index=d});b=b.concat(d);f(b,function(d){new q(a,d)})},getSelectedPoints:function(){var a=
[];f(this.series,function(d){a=a.concat(r(d.data||[],function(a){return a.selected}))});return a},getSelectedSeries:function(){return r(this.series,function(a){return a.selected})},setTitle:function(a,d,b){var c=this,h=c.options,p;p=h.title=n({style:{color:"#333333",fontSize:h.isStock?"16px":"18px"}},h.title,a);h=h.subtitle=n({style:{color:"#666666"}},h.subtitle,d);f([["title",a,p],["subtitle",d,h]],function(a,d){var b=a[0],h=c[b],p=a[1];a=a[2];h&&p&&(c[b]=h=h.destroy());a&&!h&&(c[b]=c.renderer.text(a.text,
0,0,a.useHTML).attr({align:a.align,"class":"highcharts-"+b,zIndex:a.zIndex||4}).add(),c[b].update=function(a){c.setTitle(!d&&a,d&&a)},c[b].css(a.style))});c.layOutTitles(b)},layOutTitles:function(a){var d=0,b,c=this.renderer,h=this.spacingBox;f(["title","subtitle"],function(a){var b=this[a],p=this.options[a];a="title"===a?-3:p.verticalAlign?0:d+2;var n;b&&(n=p.style.fontSize,n=c.fontMetrics(n,b).b,b.css({width:(p.width||h.width+p.widthAdjust)+"px"}).align(e({y:a+n},p),!1,"spacingBox"),p.floating||
p.verticalAlign||(d=Math.ceil(d+b.getBBox(p.useHTML).height)))},this);b=this.titleOffset!==d;this.titleOffset=d;!this.isDirtyBox&&b&&(this.isDirtyBox=b,this.hasRendered&&A(a,!0)&&this.isDirtyBox&&this.redraw())},getChartSize:function(){var d=this.options.chart,b=d.width,d=d.height,c=this.renderTo;g(b)||(this.containerWidth=a.getStyle(c,"width"));g(d)||(this.containerHeight=a.getStyle(c,"height"));this.chartWidth=Math.max(0,b||this.containerWidth||600);this.chartHeight=Math.max(0,a.relativeLength(d,
this.chartWidth)||(1<this.containerHeight?this.containerHeight:400))},temporaryDisplay:function(d){var b=this.renderTo;if(d)for(;b&&b.style;)b.hcOrigStyle&&(a.css(b,b.hcOrigStyle),delete b.hcOrigStyle),b.hcOrigDetached&&(k.body.removeChild(b),b.hcOrigDetached=!1),b=b.parentNode;else for(;b&&b.style;){k.body.contains(b)||b.parentNode||(b.hcOrigDetached=!0,k.body.appendChild(b));if("none"===a.getStyle(b,"display",!1)||b.hcOricDetached)b.hcOrigStyle={display:b.style.display,height:b.style.height,overflow:b.style.overflow},
d={display:"block",overflow:"hidden"},b!==this.renderTo&&(d.height=0),a.css(b,d),b.offsetWidth||b.style.setProperty("display","block","important");b=b.parentNode;if(b===k.body)break}},setClassName:function(a){this.container.className="highcharts-container "+(a||"")},getContainer:function(){var b,c=this.options,h=c.chart,p,n;b=this.renderTo;var f=a.uniqueKey(),A;b||(this.renderTo=b=h.renderTo);I(b)&&(this.renderTo=b=k.getElementById(b));b||a.error(13,!0);p=d(v(b,"data-highcharts-chart"));l(p)&&z[p]&&
z[p].hasRendered&&z[p].destroy();v(b,"data-highcharts-chart",this.index);b.innerHTML="";h.skipClone||b.offsetWidth||this.temporaryDisplay();this.getChartSize();p=this.chartWidth;n=this.chartHeight;A=e({position:"relative",overflow:"hidden",width:p+"px",height:n+"px",textAlign:"left",lineHeight:"normal",zIndex:0,"-webkit-tap-highlight-color":"rgba(0,0,0,0)"},h.style);this.container=b=w("div",{id:f},A,b);this._cursor=b.style.cursor;this.renderer=new (a[h.renderer]||a.Renderer)(b,p,n,null,h.forExport,
c.exporting&&c.exporting.allowHTML);this.setClassName(h.className);this.renderer.setStyle(h.style);this.renderer.chartIndex=this.index},getMargins:function(a){var d=this.spacing,b=this.margin,c=this.titleOffset;this.resetMargins();c&&!g(b[0])&&(this.plotTop=Math.max(this.plotTop,c+this.options.title.margin+d[0]));this.legend&&this.legend.display&&this.legend.adjustMargins(b,d);this.extraMargin&&(this[this.extraMargin.type]=(this[this.extraMargin.type]||0)+this.extraMargin.value);this.adjustPlotArea&&
this.adjustPlotArea();a||this.getAxisMargins()},getAxisMargins:function(){var a=this,d=a.axisOffset=[0,0,0,0],b=a.margin;a.hasCartesianSeries&&f(a.axes,function(a){a.visible&&a.getOffset()});f(F,function(c,h){g(b[h])||(a[c]+=d[h])});a.setChartSize()},reflow:function(d){var b=this,c=b.options.chart,h=b.renderTo,p=g(c.width)&&g(c.height),e=c.width||a.getStyle(h,"width"),c=c.height||a.getStyle(h,"height"),h=d?d.target:M;if(!p&&!b.isPrinting&&e&&c&&(h===M||h===k)){if(e!==b.containerWidth||c!==b.containerHeight)clearTimeout(b.reflowTimeout),
b.reflowTimeout=P(function(){b.container&&b.setSize(void 0,void 0,!1)},d?100:0);b.containerWidth=e;b.containerHeight=c}},initReflow:function(){var a=this,d;d=G(M,"resize",function(d){a.reflow(d)});G(a,"destroy",d)},setSize:function(d,c,h){var p=this,e=p.renderer;p.isResizing+=1;a.setAnimation(h,p);p.oldChartHeight=p.chartHeight;p.oldChartWidth=p.chartWidth;void 0!==d&&(p.options.chart.width=d);void 0!==c&&(p.options.chart.height=c);p.getChartSize();d=e.globalAnimation;(d?E:m)(p.container,{width:p.chartWidth+
"px",height:p.chartHeight+"px"},d);p.setChartSize(!0);e.setSize(p.chartWidth,p.chartHeight,h);f(p.axes,function(a){a.isDirty=!0;a.setScale()});p.isDirtyLegend=!0;p.isDirtyBox=!0;p.layOutTitles();p.getMargins();p.redraw(h);p.oldChartHeight=null;b(p,"resize");P(function(){p&&b(p,"endResize",null,function(){--p.isResizing})},H(d).duration)},setChartSize:function(a){var d=this.inverted,b=this.renderer,c=this.chartWidth,h=this.chartHeight,p=this.options.chart,e=this.spacing,n=this.clipOffset,l,A,g,y;this.plotLeft=
l=Math.round(this.plotLeft);this.plotTop=A=Math.round(this.plotTop);this.plotWidth=g=Math.max(0,Math.round(c-l-this.marginRight));this.plotHeight=y=Math.max(0,Math.round(h-A-this.marginBottom));this.plotSizeX=d?y:g;this.plotSizeY=d?g:y;this.plotBorderWidth=p.plotBorderWidth||0;this.spacingBox=b.spacingBox={x:e[3],y:e[0],width:c-e[3]-e[1],height:h-e[0]-e[2]};this.plotBox=b.plotBox={x:l,y:A,width:g,height:y};c=2*Math.floor(this.plotBorderWidth/2);d=Math.ceil(Math.max(c,n[3])/2);b=Math.ceil(Math.max(c,
n[0])/2);this.clipBox={x:d,y:b,width:Math.floor(this.plotSizeX-Math.max(c,n[1])/2-d),height:Math.max(0,Math.floor(this.plotSizeY-Math.max(c,n[2])/2-b))};a||f(this.axes,function(a){a.setAxisSize();a.setAxisTranslation()})},resetMargins:function(){var a=this,d=a.options.chart;f(["margin","spacing"],function(b){var c=d[b],h=C(c)?c:[c,c,c,c];f(["Top","Right","Bottom","Left"],function(c,p){a[b][p]=A(d[b+c],h[p])})});f(F,function(d,b){a[d]=A(a.margin[b],a.spacing[b])});a.axisOffset=[0,0,0,0];a.clipOffset=
[0,0,0,0]},drawChartBox:function(){var a=this.options.chart,d=this.renderer,b=this.chartWidth,c=this.chartHeight,h=this.chartBackground,p=this.plotBackground,e=this.plotBorder,n,l=this.plotBGImage,A=a.backgroundColor,f=a.plotBackgroundColor,g=a.plotBackgroundImage,y,D=this.plotLeft,m=this.plotTop,r=this.plotWidth,x=this.plotHeight,B=this.plotBox,k=this.clipRect,F=this.clipBox,q="animate";h||(this.chartBackground=h=d.rect().addClass("highcharts-background").add(),q="attr");n=a.borderWidth||0;y=n+(a.shadow?
8:0);A={fill:A||"none"};if(n||h["stroke-width"])A.stroke=a.borderColor,A["stroke-width"]=n;h.attr(A).shadow(a.shadow);h[q]({x:y/2,y:y/2,width:b-y-n%2,height:c-y-n%2,r:a.borderRadius});q="animate";p||(q="attr",this.plotBackground=p=d.rect().addClass("highcharts-plot-background").add());p[q](B);p.attr({fill:f||"none"}).shadow(a.plotShadow);g&&(l?l.animate(B):this.plotBGImage=d.image(g,D,m,r,x).add());k?k.animate({width:F.width,height:F.height}):this.clipRect=d.clipRect(F);q="animate";e||(q="attr",this.plotBorder=
e=d.rect().addClass("highcharts-plot-border").attr({zIndex:1}).add());e.attr({stroke:a.plotBorderColor,"stroke-width":a.plotBorderWidth||0,fill:"none"});e[q](e.crisp({x:D,y:m,width:r,height:x},-e.strokeWidth()));this.isDirtyBox=!1},propFromSeries:function(){var a=this,d=a.options.chart,b,c=a.options.series,h,p;f(["inverted","angular","polar"],function(e){b=D[d.type||d.defaultSeriesType];p=d[e]||b&&b.prototype[e];for(h=c&&c.length;!p&&h--;)(b=D[c[h].type])&&b.prototype[e]&&(p=!0);a[e]=p})},linkSeries:function(){var a=
this,d=a.series;f(d,function(a){a.linkedSeries.length=0});f(d,function(d){var b=d.options.linkedTo;I(b)&&(b=":previous"===b?a.series[d.index-1]:a.get(b))&&b.linkedParent!==d&&(b.linkedSeries.push(d),d.linkedParent=b,d.visible=A(d.options.visible,b.options.visible,d.visible))})},renderSeries:function(){f(this.series,function(a){a.translate();a.render()})},renderLabels:function(){var a=this,b=a.options.labels;b.items&&f(b.items,function(c){var h=e(b.style,c.style),p=d(h.left)+a.plotLeft,n=d(h.top)+
a.plotTop+12;delete h.left;delete h.top;a.renderer.text(c.html,p,n).attr({zIndex:2}).css(h).add()})},render:function(){var a=this.axes,d=this.renderer,b=this.options,c,h,p;this.setTitle();this.legend=new x(this,b.legend);this.getStacks&&this.getStacks();this.getMargins(!0);this.setChartSize();b=this.plotWidth;c=this.plotHeight=Math.max(this.plotHeight-21,0);f(a,function(a){a.setScale()});this.getAxisMargins();h=1.1<b/this.plotWidth;p=1.05<c/this.plotHeight;if(h||p)f(a,function(a){(a.horiz&&h||!a.horiz&&
p)&&a.setTickInterval(!0)}),this.getMargins();this.drawChartBox();this.hasCartesianSeries&&f(a,function(a){a.visible&&a.render()});this.seriesGroup||(this.seriesGroup=d.g("series-group").attr({zIndex:3}).add());this.renderSeries();this.renderLabels();this.addCredits();this.setResponsive&&this.setResponsive();this.hasRendered=!0},addCredits:function(a){var d=this;a=n(!0,this.options.credits,a);a.enabled&&!this.credits&&(this.credits=this.renderer.text(a.text+(this.mapCredits||""),0,0).addClass("highcharts-credits").on("click",
function(){a.href&&(M.location.href=a.href)}).attr({align:a.position.align,zIndex:8}).css(a.style).add().align(a.position),this.credits.update=function(a){d.credits=d.credits.destroy();d.addCredits(a)})},destroy:function(){var d=this,c=d.axes,h=d.series,e=d.container,n,l=e&&e.parentNode;b(d,"destroy");d.renderer.forExport?a.erase(z,d):z[d.index]=void 0;a.chartCount--;d.renderTo.removeAttribute("data-highcharts-chart");p(d);for(n=c.length;n--;)c[n]=c[n].destroy();this.scroller&&this.scroller.destroy&&
this.scroller.destroy();for(n=h.length;n--;)h[n]=h[n].destroy();f("title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" "),function(a){var b=d[a];b&&b.destroy&&(d[a]=b.destroy())});e&&(e.innerHTML="",p(e),l&&u(e));B(d,function(a,b){delete d[b]})},isReadyToRender:function(){var a=this;return y||M!=M.top||"complete"===k.readyState?!0:(k.attachEvent("onreadystatechange",function(){k.detachEvent("onreadystatechange",
a.firstRender);"complete"===k.readyState&&a.firstRender()}),!1)},firstRender:function(){var a=this,d=a.options;if(a.isReadyToRender()){a.getContainer();b(a,"init");a.resetMargins();a.setChartSize();a.propFromSeries();a.getAxes();f(d.series||[],function(d){a.initSeries(d)});a.linkSeries();b(a,"beforeRender");J&&(a.pointer=new J(a,d));a.render();if(!a.renderer.imgCount&&a.onload)a.onload();a.temporaryDisplay(!0)}},onload:function(){f([this.callback].concat(this.callbacks),function(a){a&&void 0!==this.index&&
a.apply(this,[this])},this);b(this,"load");b(this,"render");g(this.index)&&!1!==this.options.chart.reflow&&this.initReflow();this.onload=null}})})(L);(function(a){var G,E=a.each,H=a.extend,v=a.erase,k=a.fireEvent,q=a.format,w=a.isArray,t=a.isNumber,u=a.pick,z=a.removeEvent;a.Point=G=function(){};a.Point.prototype={init:function(a,g,f){this.series=a;this.color=a.color;this.applyOptions(g,f);a.options.colorByPoint?(g=a.options.colors||a.chart.options.colors,this.color=this.color||g[a.colorCounter],
g=g.length,f=a.colorCounter,a.colorCounter++,a.colorCounter===g&&(a.colorCounter=0)):f=a.colorIndex;this.colorIndex=u(this.colorIndex,f);a.chart.pointCount++;return this},applyOptions:function(a,g){var f=this.series,e=f.options.pointValKey||f.pointValKey;a=G.prototype.optionsToObject.call(this,a);H(this,a);this.options=this.options?H(this.options,a):a;a.group&&delete this.group;e&&(this.y=this[e]);this.isNull=u(this.isValid&&!this.isValid(),null===this.x||!t(this.y,!0));this.selected&&(this.state=
"select");"name"in this&&void 0===g&&f.xAxis&&f.xAxis.hasNames&&(this.x=f.xAxis.nameToX(this));void 0===this.x&&f&&(this.x=void 0===g?f.autoIncrement(this):g);return this},optionsToObject:function(a){var g={},f=this.series,e=f.options.keys,c=e||f.pointArrayMap||["y"],b=c.length,m=0,l=0;if(t(a)||null===a)g[c[0]]=a;else if(w(a))for(!e&&a.length>b&&(f=typeof a[0],"string"===f?g.name=a[0]:"number"===f&&(g.x=a[0]),m++);l<b;)e&&void 0===a[m]||(g[c[l]]=a[m]),m++,l++;else"object"===typeof a&&(g=a,a.dataLabels&&
(f._hasPointLabels=!0),a.marker&&(f._hasPointMarkers=!0));return g},getClassName:function(){return"highcharts-point"+(this.selected?" highcharts-point-select":"")+(this.negative?" highcharts-negative":"")+(this.isNull?" highcharts-null-point":"")+(void 0!==this.colorIndex?" highcharts-color-"+this.colorIndex:"")+(this.options.className?" "+this.options.className:"")+(this.zone&&this.zone.className?" "+this.zone.className.replace("highcharts-negative",""):"")},getZone:function(){var a=this.series,
g=a.zones,a=a.zoneAxis||"y",f=0,e;for(e=g[f];this[a]>=e.value;)e=g[++f];e&&e.color&&!this.options.color&&(this.color=e.color);return e},destroy:function(){var a=this.series.chart,g=a.hoverPoints,f;a.pointCount--;g&&(this.setState(),v(g,this),g.length||(a.hoverPoints=null));if(this===a.hoverPoint)this.onMouseOut();if(this.graphic||this.dataLabel)z(this),this.destroyElements();this.legendItem&&a.legend.destroyItem(this);for(f in this)this[f]=null},destroyElements:function(){for(var a=["graphic","dataLabel",
"dataLabelUpper","connector","shadowGroup"],g,f=6;f--;)g=a[f],this[g]&&(this[g]=this[g].destroy())},getLabelConfig:function(){return{x:this.category,y:this.y,color:this.color,colorIndex:this.colorIndex,key:this.name||this.category,series:this.series,point:this,percentage:this.percentage,total:this.total||this.stackTotal}},tooltipFormatter:function(a){var g=this.series,f=g.tooltipOptions,e=u(f.valueDecimals,""),c=f.valuePrefix||"",b=f.valueSuffix||"";E(g.pointArrayMap||["y"],function(f){f="{point."+
f;if(c||b)a=a.replace(f+"}",c+f+"}"+b);a=a.replace(f+"}",f+":,."+e+"f}")});return q(a,{point:this,series:this.series})},firePointEvent:function(a,g,f){var e=this,c=this.series.options;(c.point.events[a]||e.options&&e.options.events&&e.options.events[a])&&this.importEvents();"click"===a&&c.allowPointSelect&&(f=function(a){e.select&&e.select(null,a.ctrlKey||a.metaKey||a.shiftKey)});k(this,a,g,f)},visible:!0}})(L);(function(a){var G=a.addEvent,E=a.animObject,H=a.arrayMax,v=a.arrayMin,k=a.correctFloat,
q=a.Date,w=a.defaultOptions,t=a.defaultPlotOptions,u=a.defined,z=a.each,m=a.erase,g=a.extend,f=a.fireEvent,e=a.grep,c=a.isArray,b=a.isNumber,r=a.isString,l=a.merge,C=a.objectEach,I=a.pick,x=a.removeEvent,F=a.splat,n=a.SVGElement,B=a.syncTimeout,J=a.win;a.Series=a.seriesType("line",null,{lineWidth:2,allowPointSelect:!1,showCheckbox:!1,animation:{duration:1E3},events:{},marker:{lineWidth:0,lineColor:"#ffffff",radius:4,states:{hover:{animation:{duration:50},enabled:!0,radiusPlus:2,lineWidthPlus:1},select:{fillColor:"#cccccc",
lineColor:"#000000",lineWidth:2}}},point:{events:{}},dataLabels:{align:"center",formatter:function(){return null===this.y?"":a.numberFormat(this.y,-1)},style:{fontSize:"11px",fontWeight:"bold",color:"contrast",textOutline:"1px contrast"},verticalAlign:"bottom",x:0,y:0,padding:5},cropThreshold:300,pointRange:0,softThreshold:!0,states:{hover:{animation:{duration:50},lineWidthPlus:1,marker:{},halo:{size:10,opacity:.25}},select:{marker:{}}},stickyTracking:!0,turboThreshold:1E3,findNearestPointBy:"x"},
{isCartesian:!0,pointClass:a.Point,sorted:!0,requireSorting:!0,directTouch:!1,axisTypes:["xAxis","yAxis"],colorCounter:0,parallelArrays:["x","y"],coll:"series",init:function(a,d){var b=this,c,h=a.series,e;b.chart=a;b.options=d=b.setOptions(d);b.linkedSeries=[];b.bindAxes();g(b,{name:d.name,state:"",visible:!1!==d.visible,selected:!0===d.selected});c=d.events;C(c,function(a,d){G(b,d,a)});if(c&&c.click||d.point&&d.point.events&&d.point.events.click||d.allowPointSelect)a.runTrackerClick=!0;b.getColor();
b.getSymbol();z(b.parallelArrays,function(a){b[a+"Data"]=[]});b.setData(d.data,!1);b.isCartesian&&(a.hasCartesianSeries=!0);h.length&&(e=h[h.length-1]);b._i=I(e&&e._i,-1)+1;a.orderSeries(this.insert(h))},insert:function(a){var d=this.options.index,c;if(b(d)){for(c=a.length;c--;)if(d>=I(a[c].options.index,a[c]._i)){a.splice(c+1,0,this);break}-1===c&&a.unshift(this);c+=1}else a.push(this);return I(c,a.length-1)},bindAxes:function(){var b=this,d=b.options,c=b.chart,e;z(b.axisTypes||[],function(h){z(c[h],
function(a){e=a.options;if(d[h]===e.index||void 0!==d[h]&&d[h]===e.id||void 0===d[h]&&0===e.index)b.insert(a.series),b[h]=a,a.isDirty=!0});b[h]||b.optionalAxis===h||a.error(18,!0)})},updateParallelArrays:function(a,d){var c=a.series,e=arguments,h=b(d)?function(b){var h="y"===b&&c.toYData?c.toYData(a):a[b];c[b+"Data"][d]=h}:function(a){Array.prototype[d].apply(c[a+"Data"],Array.prototype.slice.call(e,2))};z(c.parallelArrays,h)},autoIncrement:function(){var b=this.options,d=this.xIncrement,c,e=b.pointIntervalUnit,
h=0,d=I(d,b.pointStart,0);this.pointInterval=c=I(this.pointInterval,b.pointInterval,1);e&&(b=new q(d),"day"===e?b=+b[q.hcSetDate](b[q.hcGetDate]()+c):"month"===e?b=+b[q.hcSetMonth](b[q.hcGetMonth]()+c):"year"===e&&(b=+b[q.hcSetFullYear](b[q.hcGetFullYear]()+c)),q.hcHasTimeZone&&(h=a.getTZOffset(b)-a.getTZOffset(d)),c=b-d+h);this.xIncrement=d+c;return d},setOptions:function(a){var d=this.chart,b=d.options,c=b.plotOptions,h=(d.userOptions||{}).plotOptions||{},e=c[this.type];this.userOptions=a;d=l(e,
c.series,a);this.tooltipOptions=l(w.tooltip,w.plotOptions.series&&w.plotOptions.series.tooltip,w.plotOptions[this.type].tooltip,b.tooltip.userOptions,c.series&&c.series.tooltip,c[this.type].tooltip,a.tooltip);this.stickyTracking=I(a.stickyTracking,h[this.type]&&h[this.type].stickyTracking,h.series&&h.series.stickyTracking,this.tooltipOptions.shared&&!this.noSharedTooltip?!0:d.stickyTracking);null===e.marker&&delete d.marker;this.zoneAxis=d.zoneAxis;a=this.zones=(d.zones||[]).slice();!d.negativeColor&&
!d.negativeFillColor||d.zones||a.push({value:d[this.zoneAxis+"Threshold"]||d.threshold||0,className:"highcharts-negative",color:d.negativeColor,fillColor:d.negativeFillColor});a.length&&u(a[a.length-1].value)&&a.push({color:this.color,fillColor:this.fillColor});return d},getCyclic:function(a,d,b){var c,h=this.chart,p=this.userOptions,e=a+"Index",n=a+"Counter",l=b?b.length:I(h.options.chart[a+"Count"],h[a+"Count"]);d||(c=I(p[e],p["_"+e]),u(c)||(h.series.length||(h[n]=0),p["_"+e]=c=h[n]%l,h[n]+=1),
b&&(d=b[c]));void 0!==c&&(this[e]=c);this[a]=d},getColor:function(){this.options.colorByPoint?this.options.color=null:this.getCyclic("color",this.options.color||t[this.type].color,this.chart.options.colors)},getSymbol:function(){this.getCyclic("symbol",this.options.marker.symbol,this.chart.options.symbols)},drawLegendSymbol:a.LegendSymbolMixin.drawLineMarker,setData:function(e,d,p,n){var h=this,l=h.points,f=l&&l.length||0,g,A=h.options,D=h.chart,m=null,x=h.xAxis,B=A.turboThreshold,k=this.xData,q=
this.yData,F=(g=h.pointArrayMap)&&g.length;e=e||[];g=e.length;d=I(d,!0);if(!1!==n&&g&&f===g&&!h.cropped&&!h.hasGroupedData&&h.visible)z(e,function(a,d){l[d].update&&a!==A.data[d]&&l[d].update(a,!1,null,!1)});else{h.xIncrement=null;h.colorCounter=0;z(this.parallelArrays,function(a){h[a+"Data"].length=0});if(B&&g>B){for(p=0;null===m&&p<g;)m=e[p],p++;if(b(m))for(p=0;p<g;p++)k[p]=this.autoIncrement(),q[p]=e[p];else if(c(m))if(F)for(p=0;p<g;p++)m=e[p],k[p]=m[0],q[p]=m.slice(1,F+1);else for(p=0;p<g;p++)m=
e[p],k[p]=m[0],q[p]=m[1];else a.error(12)}else for(p=0;p<g;p++)void 0!==e[p]&&(m={series:h},h.pointClass.prototype.applyOptions.apply(m,[e[p]]),h.updateParallelArrays(m,p));q&&r(q[0])&&a.error(14,!0);h.data=[];h.options.data=h.userOptions.data=e;for(p=f;p--;)l[p]&&l[p].destroy&&l[p].destroy();x&&(x.minRange=x.userMinRange);h.isDirty=D.isDirtyBox=!0;h.isDirtyData=!!l;p=!1}"point"===A.legendType&&(this.processData(),this.generatePoints());d&&D.redraw(p)},processData:function(b){var d=this.xData,c=this.yData,
e=d.length,h;h=0;var n,l,f=this.xAxis,g,A=this.options;g=A.cropThreshold;var m=this.getExtremesFromAll||A.getExtremesFromAll,x=this.isCartesian,A=f&&f.val2lin,B=f&&f.isLog,r=this.requireSorting,k,q;if(x&&!this.isDirty&&!f.isDirty&&!this.yAxis.isDirty&&!b)return!1;f&&(b=f.getExtremes(),k=b.min,q=b.max);if(x&&this.sorted&&!m&&(!g||e>g||this.forceCrop))if(d[e-1]<k||d[0]>q)d=[],c=[];else if(d[0]<k||d[e-1]>q)h=this.cropData(this.xData,this.yData,k,q),d=h.xData,c=h.yData,h=h.start,n=!0;for(g=d.length||
1;--g;)e=B?A(d[g])-A(d[g-1]):d[g]-d[g-1],0<e&&(void 0===l||e<l)?l=e:0>e&&r&&(a.error(15),r=!1);this.cropped=n;this.cropStart=h;this.processedXData=d;this.processedYData=c;this.closestPointRange=l},cropData:function(a,d,b,c){var h=a.length,p=0,e=h,n=I(this.cropShoulder,1),l;for(l=0;l<h;l++)if(a[l]>=b){p=Math.max(0,l-n);break}for(b=l;b<h;b++)if(a[b]>c){e=b+n;break}return{xData:a.slice(p,e),yData:d.slice(p,e),start:p,end:e}},generatePoints:function(){var a=this.options,d=a.data,b=this.data,c,h=this.processedXData,
e=this.processedYData,n=this.pointClass,l=h.length,f=this.cropStart||0,g,m=this.hasGroupedData,a=a.keys,x,B=[],r;b||m||(b=[],b.length=d.length,b=this.data=b);a&&m&&(this.options.keys=!1);for(r=0;r<l;r++)g=f+r,m?(x=(new n).init(this,[h[r]].concat(F(e[r]))),x.dataGroup=this.groupMap[r]):(x=b[g])||void 0===d[g]||(b[g]=x=(new n).init(this,d[g],h[r])),x&&(x.index=g,B[r]=x);this.options.keys=a;if(b&&(l!==(c=b.length)||m))for(r=0;r<c;r++)r!==f||m||(r+=l),b[r]&&(b[r].destroyElements(),b[r].plotX=void 0);
this.data=b;this.points=B},getExtremes:function(a){var d=this.yAxis,p=this.processedXData,e,h=[],n=0;e=this.xAxis.getExtremes();var l=e.min,f=e.max,g,A,m,r;a=a||this.stackedYData||this.processedYData||[];e=a.length;for(r=0;r<e;r++)if(A=p[r],m=a[r],g=(b(m,!0)||c(m))&&(!d.positiveValuesOnly||m.length||0<m),A=this.getExtremesFromAll||this.options.getExtremesFromAll||this.cropped||(p[r+1]||A)>=l&&(p[r-1]||A)<=f,g&&A)if(g=m.length)for(;g--;)"number"===typeof m[g]&&(h[n++]=m[g]);else h[n++]=m;this.dataMin=
v(h);this.dataMax=H(h)},translate:function(){this.processedXData||this.processData();this.generatePoints();var a=this.options,d=a.stacking,c=this.xAxis,e=c.categories,h=this.yAxis,n=this.points,l=n.length,f=!!this.modifyValue,g=a.pointPlacement,m="between"===g||b(g),r=a.threshold,x=a.startFromThreshold?r:0,B,q,F,t,C=Number.MAX_VALUE;"between"===g&&(g=.5);b(g)&&(g*=I(a.pointRange||c.pointRange));for(a=0;a<l;a++){var J=n[a],v=J.x,w=J.y;q=J.low;var z=d&&h.stacks[(this.negStacks&&w<(x?0:r)?"-":"")+this.stackKey],
E;h.positiveValuesOnly&&null!==w&&0>=w&&(J.isNull=!0);J.plotX=B=k(Math.min(Math.max(-1E5,c.translate(v,0,0,0,1,g,"flags"===this.type)),1E5));d&&this.visible&&!J.isNull&&z&&z[v]&&(t=this.getStackIndicator(t,v,this.index),E=z[v],w=E.points[t.key],q=w[0],w=w[1],q===x&&t.key===z[v].base&&(q=I(r,h.min)),h.positiveValuesOnly&&0>=q&&(q=null),J.total=J.stackTotal=E.total,J.percentage=E.total&&J.y/E.total*100,J.stackY=w,E.setOffset(this.pointXOffset||0,this.barW||0));J.yBottom=u(q)?h.translate(q,0,1,0,1):
null;f&&(w=this.modifyValue(w,J));J.plotY=q="number"===typeof w&&Infinity!==w?Math.min(Math.max(-1E5,h.translate(w,0,1,0,1)),1E5):void 0;J.isInside=void 0!==q&&0<=q&&q<=h.len&&0<=B&&B<=c.len;J.clientX=m?k(c.translate(v,0,0,0,1,g)):B;J.negative=J.y<(r||0);J.category=e&&void 0!==e[J.x]?e[J.x]:J.x;J.isNull||(void 0!==F&&(C=Math.min(C,Math.abs(B-F))),F=B);J.zone=this.zones.length&&J.getZone()}this.closestPointRangePx=C},getValidPoints:function(a,d){var b=this.chart;return e(a||this.points||[],function(a){return d&&
!b.isInsidePlot(a.plotX,a.plotY,b.inverted)?!1:!a.isNull})},setClip:function(a){var d=this.chart,b=this.options,c=d.renderer,h=d.inverted,e=this.clipBox,n=e||d.clipBox,l=this.sharedClipKey||["_sharedClip",a&&a.duration,a&&a.easing,n.height,b.xAxis,b.yAxis].join(),f=d[l],g=d[l+"m"];f||(a&&(n.width=0,h&&(n.x=d.plotSizeX),d[l+"m"]=g=c.clipRect(h?d.plotSizeX+99:-99,h?-d.plotLeft:-d.plotTop,99,h?d.chartWidth:d.chartHeight)),d[l]=f=c.clipRect(n),f.count={length:0});a&&!f.count[this.index]&&(f.count[this.index]=
!0,f.count.length+=1);!1!==b.clip&&(this.group.clip(a||e?f:d.clipRect),this.markerGroup.clip(g),this.sharedClipKey=l);a||(f.count[this.index]&&(delete f.count[this.index],--f.count.length),0===f.count.length&&l&&d[l]&&(e||(d[l]=d[l].destroy()),d[l+"m"]&&(d[l+"m"]=d[l+"m"].destroy())))},animate:function(a){var d=this.chart,b=E(this.options.animation),c;a?this.setClip(b):(c=this.sharedClipKey,(a=d[c])&&a.animate({width:d.plotSizeX,x:0},b),d[c+"m"]&&d[c+"m"].animate({width:d.plotSizeX+99,x:0},b),this.animate=
null)},afterAnimate:function(){this.setClip();f(this,"afterAnimate");this.finishedAnimating=!0},drawPoints:function(){var a=this.points,d=this.chart,b,c,h,e,n=this.options.marker,l,f,g,m=this[this.specialGroup]||this.markerGroup,r,x=I(n.enabled,this.xAxis.isRadial?!0:null,this.closestPointRangePx>=2*n.radius);if(!1!==n.enabled||this._hasPointMarkers)for(b=0;b<a.length;b++)c=a[b],e=c.graphic,l=c.marker||{},f=!!c.marker,h=x&&void 0===l.enabled||l.enabled,g=c.isInside,h&&!c.isNull?(h=I(l.symbol,this.symbol),
c.hasImage=0===h.indexOf("url"),r=this.markerAttribs(c,c.selected&&"select"),e?e[g?"show":"hide"](!0).animate(r):g&&(0<r.width||c.hasImage)&&(c.graphic=e=d.renderer.symbol(h,r.x,r.y,r.width,r.height,f?l:n).add(m)),e&&e.attr(this.pointAttribs(c,c.selected&&"select")),e&&e.addClass(c.getClassName(),!0)):e&&(c.graphic=e.destroy())},markerAttribs:function(a,d){var b=this.options.marker,c=a.marker||{},h=I(c.radius,b.radius);d&&(b=b.states[d],d=c.states&&c.states[d],h=I(d&&d.radius,b&&b.radius,h+(b&&b.radiusPlus||
0)));a.hasImage&&(h=0);a={x:Math.floor(a.plotX)-h,y:a.plotY-h};h&&(a.width=a.height=2*h);return a},pointAttribs:function(a,d){var b=this.options.marker,c=a&&a.options,h=c&&c.marker||{},e=this.color,n=c&&c.color,l=a&&a.color,c=I(h.lineWidth,b.lineWidth);a=a&&a.zone&&a.zone.color;e=n||a||l||e;a=h.fillColor||b.fillColor||e;e=h.lineColor||b.lineColor||e;d&&(b=b.states[d],d=h.states&&h.states[d]||{},c=I(d.lineWidth,b.lineWidth,c+I(d.lineWidthPlus,b.lineWidthPlus,0)),a=d.fillColor||b.fillColor||a,e=d.lineColor||
b.lineColor||e);return{stroke:e,"stroke-width":c,fill:a}},destroy:function(){var a=this,d=a.chart,b=/AppleWebKit\/533/.test(J.navigator.userAgent),c,h,e=a.data||[],l,g;f(a,"destroy");x(a);z(a.axisTypes||[],function(d){(g=a[d])&&g.series&&(m(g.series,a),g.isDirty=g.forceRedraw=!0)});a.legendItem&&a.chart.legend.destroyItem(a);for(h=e.length;h--;)(l=e[h])&&l.destroy&&l.destroy();a.points=null;clearTimeout(a.animationTimeout);C(a,function(a,d){a instanceof n&&!a.survive&&(c=b&&"group"===d?"hide":"destroy",
a[c]())});d.hoverSeries===a&&(d.hoverSeries=null);m(d.series,a);d.orderSeries();C(a,function(d,b){delete a[b]})},getGraphPath:function(a,d,b){var c=this,h=c.options,e=h.step,p,n=[],l=[],f;a=a||c.points;(p=a.reversed)&&a.reverse();(e={right:1,center:2}[e]||e&&3)&&p&&(e=4-e);!h.connectNulls||d||b||(a=this.getValidPoints(a));z(a,function(p,g){var m=p.plotX,r=p.plotY,A=a[g-1];(p.leftCliff||A&&A.rightCliff)&&!b&&(f=!0);p.isNull&&!u(d)&&0<g?f=!h.connectNulls:p.isNull&&!d?f=!0:(0===g||f?g=["M",p.plotX,p.plotY]:
c.getPointSpline?g=c.getPointSpline(a,p,g):e?(g=1===e?["L",A.plotX,r]:2===e?["L",(A.plotX+m)/2,A.plotY,"L",(A.plotX+m)/2,r]:["L",m,A.plotY],g.push("L",m,r)):g=["L",m,r],l.push(p.x),e&&l.push(p.x),n.push.apply(n,g),f=!1)});n.xMap=l;return c.graphPath=n},drawGraph:function(){var a=this,d=this.options,b=(this.gappedPath||this.getGraphPath).call(this),c=[["graph","highcharts-graph",d.lineColor||this.color,d.dashStyle]];z(this.zones,function(b,e){c.push(["zone-graph-"+e,"highcharts-graph highcharts-zone-graph-"+
e+" "+(b.className||""),b.color||a.color,b.dashStyle||d.dashStyle])});z(c,function(c,e){var h=c[0],p=a[h];p?(p.endX=a.preventGraphAnimation?null:b.xMap,p.animate({d:b})):b.length&&(a[h]=a.chart.renderer.path(b).addClass(c[1]).attr({zIndex:1}).add(a.group),p={stroke:c[2],"stroke-width":d.lineWidth,fill:a.fillGraph&&a.color||"none"},c[3]?p.dashstyle=c[3]:"square"!==d.linecap&&(p["stroke-linecap"]=p["stroke-linejoin"]="round"),p=a[h].attr(p).shadow(2>e&&d.shadow));p&&(p.startX=b.xMap,p.isArea=b.isArea)})},
applyZones:function(){var a=this,d=this.chart,b=d.renderer,c=this.zones,h,e,n=this.clips||[],l,f=this.graph,g=this.area,m=Math.max(d.chartWidth,d.chartHeight),r=this[(this.zoneAxis||"y")+"Axis"],x,B,k=d.inverted,q,F,t,C,u=!1;c.length&&(f||g)&&r&&void 0!==r.min&&(B=r.reversed,q=r.horiz,f&&f.hide(),g&&g.hide(),x=r.getExtremes(),z(c,function(c,p){h=B?q?d.plotWidth:0:q?0:r.toPixels(x.min);h=Math.min(Math.max(I(e,h),0),m);e=Math.min(Math.max(Math.round(r.toPixels(I(c.value,x.max),!0)),0),m);u&&(h=e=r.toPixels(x.max));
F=Math.abs(h-e);t=Math.min(h,e);C=Math.max(h,e);r.isXAxis?(l={x:k?C:t,y:0,width:F,height:m},q||(l.x=d.plotHeight-l.x)):(l={x:0,y:k?C:t,width:m,height:F},q&&(l.y=d.plotWidth-l.y));k&&b.isVML&&(l=r.isXAxis?{x:0,y:B?t:C,height:l.width,width:d.chartWidth}:{x:l.y-d.plotLeft-d.spacingBox.x,y:0,width:l.height,height:d.chartHeight});n[p]?n[p].animate(l):(n[p]=b.clipRect(l),f&&a["zone-graph-"+p].clip(n[p]),g&&a["zone-area-"+p].clip(n[p]));u=c.value>x.max}),this.clips=n)},invertGroups:function(a){function d(){z(["group",
"markerGroup"],function(d){b[d]&&(c.renderer.isVML&&b[d].attr({width:b.yAxis.len,height:b.xAxis.len}),b[d].width=b.yAxis.len,b[d].height=b.xAxis.len,b[d].invert(a))})}var b=this,c=b.chart,h;b.xAxis&&(h=G(c,"resize",d),G(b,"destroy",h),d(a),b.invertGroups=d)},plotGroup:function(a,d,b,c,h){var e=this[a],p=!e;p&&(this[a]=e=this.chart.renderer.g().attr({zIndex:c||.1}).add(h));e.addClass("highcharts-"+d+" highcharts-series-"+this.index+" highcharts-"+this.type+"-series "+(u(this.colorIndex)?"highcharts-color-"+
this.colorIndex+" ":"")+(this.options.className||"")+(e.hasClass("highcharts-tracker")?" highcharts-tracker":""),!0);e.attr({visibility:b})[p?"attr":"animate"](this.getPlotBox());return e},getPlotBox:function(){var a=this.chart,d=this.xAxis,b=this.yAxis;a.inverted&&(d=b,b=this.xAxis);return{translateX:d?d.left:a.plotLeft,translateY:b?b.top:a.plotTop,scaleX:1,scaleY:1}},render:function(){var a=this,d=a.chart,b,c=a.options,h=!!a.animate&&d.renderer.isSVG&&E(c.animation).duration,e=a.visible?"inherit":
"hidden",n=c.zIndex,l=a.hasRendered,f=d.seriesGroup,g=d.inverted;b=a.plotGroup("group","series",e,n,f);a.markerGroup=a.plotGroup("markerGroup","markers",e,n,f);h&&a.animate(!0);b.inverted=a.isCartesian?g:!1;a.drawGraph&&(a.drawGraph(),a.applyZones());a.drawDataLabels&&a.drawDataLabels();a.visible&&a.drawPoints();a.drawTracker&&!1!==a.options.enableMouseTracking&&a.drawTracker();a.invertGroups(g);!1===c.clip||a.sharedClipKey||l||b.clip(d.clipRect);h&&a.animate();l||(a.animationTimeout=B(function(){a.afterAnimate()},
h));a.isDirty=!1;a.hasRendered=!0},redraw:function(){var a=this.chart,d=this.isDirty||this.isDirtyData,b=this.group,c=this.xAxis,h=this.yAxis;b&&(a.inverted&&b.attr({width:a.plotWidth,height:a.plotHeight}),b.animate({translateX:I(c&&c.left,a.plotLeft),translateY:I(h&&h.top,a.plotTop)}));this.translate();this.render();d&&delete this.kdTree},kdAxisArray:["clientX","plotY"],searchPoint:function(a,d){var b=this.xAxis,c=this.yAxis,h=this.chart.inverted;return this.searchKDTree({clientX:h?b.len-a.chartY+
b.pos:a.chartX-b.pos,plotY:h?c.len-a.chartX+c.pos:a.chartY-c.pos},d)},buildKDTree:function(){function a(b,c,e){var h,p;if(p=b&&b.length)return h=d.kdAxisArray[c%e],b.sort(function(a,d){return a[h]-d[h]}),p=Math.floor(p/2),{point:b[p],left:a(b.slice(0,p),c+1,e),right:a(b.slice(p+1),c+1,e)}}this.buildingKdTree=!0;var d=this,b=-1<d.options.findNearestPointBy.indexOf("y")?2:1;delete d.kdTree;B(function(){d.kdTree=a(d.getValidPoints(null,!d.directTouch),b,b);d.buildingKdTree=!1},d.options.kdNow?0:1)},
searchKDTree:function(a,d){function b(a,d,p,l){var f=d.point,g=c.kdAxisArray[p%l],m,r,x=f;r=u(a[h])&&u(f[h])?Math.pow(a[h]-f[h],2):null;m=u(a[e])&&u(f[e])?Math.pow(a[e]-f[e],2):null;m=(r||0)+(m||0);f.dist=u(m)?Math.sqrt(m):Number.MAX_VALUE;f.distX=u(r)?Math.sqrt(r):Number.MAX_VALUE;g=a[g]-f[g];m=0>g?"left":"right";r=0>g?"right":"left";d[m]&&(m=b(a,d[m],p+1,l),x=m[n]<x[n]?m:f);d[r]&&Math.sqrt(g*g)<x[n]&&(a=b(a,d[r],p+1,l),x=a[n]<x[n]?a:x);return x}var c=this,h=this.kdAxisArray[0],e=this.kdAxisArray[1],
n=d?"distX":"dist";d=-1<c.options.findNearestPointBy.indexOf("y")?2:1;this.kdTree||this.buildingKdTree||this.buildKDTree();if(this.kdTree)return b(a,this.kdTree,d,d)}})})(L);(function(a){var G=a.Axis,E=a.Chart,H=a.correctFloat,v=a.defined,k=a.destroyObjectProperties,q=a.each,w=a.format,t=a.objectEach,u=a.pick,z=a.Series;a.StackItem=function(a,g,f,e,c){var b=a.chart.inverted;this.axis=a;this.isNegative=f;this.options=g;this.x=e;this.total=null;this.points={};this.stack=c;this.rightCliff=this.leftCliff=
0;this.alignOptions={align:g.align||(b?f?"left":"right":"center"),verticalAlign:g.verticalAlign||(b?"middle":f?"bottom":"top"),y:u(g.y,b?4:f?14:-6),x:u(g.x,b?f?-6:6:0)};this.textAlign=g.textAlign||(b?f?"right":"left":"center")};a.StackItem.prototype={destroy:function(){k(this,this.axis)},render:function(a){var g=this.options,f=g.format,f=f?w(f,this):g.formatter.call(this);this.label?this.label.attr({text:f,visibility:"hidden"}):this.label=this.axis.chart.renderer.text(f,null,null,g.useHTML).css(g.style).attr({align:this.textAlign,
rotation:g.rotation,visibility:"hidden"}).add(a)},setOffset:function(a,g){var f=this.axis,e=f.chart,c=f.translate(f.usePercentage?100:this.total,0,0,0,1),f=f.translate(0),f=Math.abs(c-f);a=e.xAxis[0].translate(this.x)+a;c=this.getStackBox(e,this,a,c,g,f);if(g=this.label)g.align(this.alignOptions,null,c),c=g.alignAttr,g[!1===this.options.crop||e.isInsidePlot(c.x,c.y)?"show":"hide"](!0)},getStackBox:function(a,g,f,e,c,b){var m=g.axis.reversed,l=a.inverted;a=a.plotHeight;g=g.isNegative&&!m||!g.isNegative&&
m;return{x:l?g?e:e-b:f,y:l?a-f-c:g?a-e-b:a-e,width:l?b:c,height:l?c:b}}};E.prototype.getStacks=function(){var a=this;q(a.yAxis,function(a){a.stacks&&a.hasVisibleSeries&&(a.oldStacks=a.stacks)});q(a.series,function(g){!g.options.stacking||!0!==g.visible&&!1!==a.options.chart.ignoreHiddenSeries||(g.stackKey=g.type+u(g.options.stack,""))})};G.prototype.buildStacks=function(){var a=this.series,g=u(this.options.reversedStacks,!0),f=a.length,e;if(!this.isXAxis){this.usePercentage=!1;for(e=f;e--;)a[g?e:
f-e-1].setStackedPoints();for(e=0;e<f;e++)a[e].modifyStacks()}};G.prototype.renderStackTotals=function(){var a=this.chart,g=a.renderer,f=this.stacks,e=this.stackTotalGroup;e||(this.stackTotalGroup=e=g.g("stack-labels").attr({visibility:"visible",zIndex:6}).add());e.translate(a.plotLeft,a.plotTop);t(f,function(a){t(a,function(a){a.render(e)})})};G.prototype.resetStacks=function(){var a=this,g=a.stacks;a.isXAxis||t(g,function(f){t(f,function(e,c){e.touched<a.stacksTouched?(e.destroy(),delete f[c]):
(e.total=null,e.cumulative=null)})})};G.prototype.cleanStacks=function(){var a;this.isXAxis||(this.oldStacks&&(a=this.stacks=this.oldStacks),t(a,function(a){t(a,function(a){a.cumulative=a.total})}))};z.prototype.setStackedPoints=function(){if(this.options.stacking&&(!0===this.visible||!1===this.chart.options.chart.ignoreHiddenSeries)){var m=this.processedXData,g=this.processedYData,f=[],e=g.length,c=this.options,b=c.threshold,r=u(c.startFromThreshold&&b,0),l=c.stack,c=c.stacking,k=this.stackKey,q=
"-"+k,x=this.negStacks,F=this.yAxis,n=F.stacks,B=F.oldStacks,t,A,d,p,D,h,y;F.stacksTouched+=1;for(D=0;D<e;D++)h=m[D],y=g[D],t=this.getStackIndicator(t,h,this.index),p=t.key,d=(A=x&&y<(r?0:b))?q:k,n[d]||(n[d]={}),n[d][h]||(B[d]&&B[d][h]?(n[d][h]=B[d][h],n[d][h].total=null):n[d][h]=new a.StackItem(F,F.options.stackLabels,A,h,l)),d=n[d][h],null!==y?(d.points[p]=d.points[this.index]=[u(d.cumulative,r)],v(d.cumulative)||(d.base=p),d.touched=F.stacksTouched,0<t.index&&!1===this.singleStacks&&(d.points[p][0]=
d.points[this.index+","+h+",0"][0])):d.points[p]=d.points[this.index]=null,"percent"===c?(A=A?k:q,x&&n[A]&&n[A][h]?(A=n[A][h],d.total=A.total=Math.max(A.total,d.total)+Math.abs(y)||0):d.total=H(d.total+(Math.abs(y)||0))):d.total=H(d.total+(y||0)),d.cumulative=u(d.cumulative,r)+(y||0),null!==y&&(d.points[p].push(d.cumulative),f[D]=d.cumulative);"percent"===c&&(F.usePercentage=!0);this.stackedYData=f;F.oldStacks={}}};z.prototype.modifyStacks=function(){var a=this,g=a.stackKey,f=a.yAxis.stacks,e=a.processedXData,
c,b=a.options.stacking;a[b+"Stacker"]&&q([g,"-"+g],function(g){for(var l=e.length,r,m;l--;)if(r=e[l],c=a.getStackIndicator(c,r,a.index,g),m=(r=f[g]&&f[g][r])&&r.points[c.key])a[b+"Stacker"](m,r,l)})};z.prototype.percentStacker=function(a,g,f){g=g.total?100/g.total:0;a[0]=H(a[0]*g);a[1]=H(a[1]*g);this.stackedYData[f]=a[1]};z.prototype.getStackIndicator=function(a,g,f,e){!v(a)||a.x!==g||e&&a.key!==e?a={x:g,index:0,key:e}:a.index++;a.key=[f,g,a.index].join();return a}})(L);(function(a){var G=a.addEvent,
E=a.animate,H=a.Axis,v=a.createElement,k=a.css,q=a.defined,w=a.each,t=a.erase,u=a.extend,z=a.fireEvent,m=a.inArray,g=a.isNumber,f=a.isObject,e=a.isArray,c=a.merge,b=a.objectEach,r=a.pick,l=a.Point,C=a.Series,I=a.seriesTypes,x=a.setAnimation,F=a.splat;u(a.Chart.prototype,{addSeries:function(a,b,c){var e,d=this;a&&(b=r(b,!0),z(d,"addSeries",{options:a},function(){e=d.initSeries(a);d.isDirtyLegend=!0;d.linkSeries();b&&d.redraw(c)}));return e},addAxis:function(a,b,e,l){var d=b?"xAxis":"yAxis",p=this.options;
a=c(a,{index:this[d].length,isX:b});b=new H(this,a);p[d]=F(p[d]||{});p[d].push(a);r(e,!0)&&this.redraw(l);return b},showLoading:function(a){var b=this,c=b.options,e=b.loadingDiv,d=c.loading,p=function(){e&&k(e,{left:b.plotLeft+"px",top:b.plotTop+"px",width:b.plotWidth+"px",height:b.plotHeight+"px"})};e||(b.loadingDiv=e=v("div",{className:"highcharts-loading highcharts-loading-hidden"},null,b.container),b.loadingSpan=v("span",{className:"highcharts-loading-inner"},null,e),G(b,"redraw",p));e.className=
"highcharts-loading";b.loadingSpan.innerHTML=a||c.lang.loading;k(e,u(d.style,{zIndex:10}));k(b.loadingSpan,d.labelStyle);b.loadingShown||(k(e,{opacity:0,display:""}),E(e,{opacity:d.style.opacity||.5},{duration:d.showDuration||0}));b.loadingShown=!0;p()},hideLoading:function(){var a=this.options,b=this.loadingDiv;b&&(b.className="highcharts-loading highcharts-loading-hidden",E(b,{opacity:0},{duration:a.loading.hideDuration||100,complete:function(){k(b,{display:"none"})}}));this.loadingShown=!1},propsRequireDirtyBox:"backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
propsRequireUpdateSeries:"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions tooltip".split(" "),update:function(a,e,l){var n=this,d={credits:"addCredits",title:"setTitle",subtitle:"setSubtitle"},p=a.chart,f,h,x=[];if(p){c(!0,n.options.chart,p);"className"in p&&n.setClassName(p.className);if("inverted"in p||"polar"in p)n.propFromSeries(),f=!0;"alignTicks"in p&&(f=!0);b(p,function(a,d){-1!==m("chart."+d,n.propsRequireUpdateSeries)&&(h=!0);-1!==m(d,n.propsRequireDirtyBox)&&
(n.isDirtyBox=!0)});"style"in p&&n.renderer.setStyle(p.style)}a.colors&&(this.options.colors=a.colors);a.plotOptions&&c(!0,this.options.plotOptions,a.plotOptions);b(a,function(a,b){if(n[b]&&"function"===typeof n[b].update)n[b].update(a,!1);else if("function"===typeof n[d[b]])n[d[b]](a);"chart"!==b&&-1!==m(b,n.propsRequireUpdateSeries)&&(h=!0)});w("xAxis yAxis zAxis series colorAxis pane".split(" "),function(d){a[d]&&(w(F(a[d]),function(a,b){(b=q(a.id)&&n.get(a.id)||n[d][b])&&b.coll===d&&(b.update(a,
!1),l&&(b.touched=!0));if(!b&&l)if("series"===d)n.addSeries(a,!1).touched=!0;else if("xAxis"===d||"yAxis"===d)n.addAxis(a,"xAxis"===d,!1).touched=!0}),l&&w(n[d],function(a){a.touched?delete a.touched:x.push(a)}))});w(x,function(a){a.remove(!1)});f&&w(n.axes,function(a){a.update({},!1)});h&&w(n.series,function(a){a.update({},!1)});a.loading&&c(!0,n.options.loading,a.loading);f=p&&p.width;p=p&&p.height;g(f)&&f!==n.chartWidth||g(p)&&p!==n.chartHeight?n.setSize(f,p):r(e,!0)&&n.redraw()},setSubtitle:function(a){this.setTitle(void 0,
a)}});u(l.prototype,{update:function(a,b,c,e){function d(){p.applyOptions(a);null===p.y&&h&&(p.graphic=h.destroy());f(a,!0)&&(h&&h.element&&a&&a.marker&&void 0!==a.marker.symbol&&(p.graphic=h.destroy()),a&&a.dataLabels&&p.dataLabel&&(p.dataLabel=p.dataLabel.destroy()),p.connector&&(p.connector=p.connector.destroy()));l=p.index;n.updateParallelArrays(p,l);m.data[l]=f(m.data[l],!0)||f(a,!0)?p.options:a;n.isDirty=n.isDirtyData=!0;!n.fixedBox&&n.hasCartesianSeries&&(g.isDirtyBox=!0);"point"===m.legendType&&
(g.isDirtyLegend=!0);b&&g.redraw(c)}var p=this,n=p.series,h=p.graphic,l,g=n.chart,m=n.options;b=r(b,!0);!1===e?d():p.firePointEvent("update",{options:a},d)},remove:function(a,b){this.series.removePoint(m(this,this.series.data),a,b)}});u(C.prototype,{addPoint:function(a,b,c,e){var d=this.options,p=this.data,n=this.chart,h=this.xAxis,h=h&&h.hasNames&&h.names,l=d.data,f,g,m=this.xData,x,k;b=r(b,!0);f={series:this};this.pointClass.prototype.applyOptions.apply(f,[a]);k=f.x;x=m.length;if(this.requireSorting&&
k<m[x-1])for(g=!0;x&&m[x-1]>k;)x--;this.updateParallelArrays(f,"splice",x,0,0);this.updateParallelArrays(f,x);h&&f.name&&(h[k]=f.name);l.splice(x,0,a);g&&(this.data.splice(x,0,null),this.processData());"point"===d.legendType&&this.generatePoints();c&&(p[0]&&p[0].remove?p[0].remove(!1):(p.shift(),this.updateParallelArrays(f,"shift"),l.shift()));this.isDirtyData=this.isDirty=!0;b&&n.redraw(e)},removePoint:function(a,b,c){var e=this,d=e.data,p=d[a],n=e.points,h=e.chart,l=function(){n&&n.length===d.length&&
n.splice(a,1);d.splice(a,1);e.options.data.splice(a,1);e.updateParallelArrays(p||{series:e},"splice",a,1);p&&p.destroy();e.isDirty=!0;e.isDirtyData=!0;b&&h.redraw()};x(c,h);b=r(b,!0);p?p.firePointEvent("remove",null,l):l()},remove:function(a,b,c){function e(){d.destroy();p.isDirtyLegend=p.isDirtyBox=!0;p.linkSeries();r(a,!0)&&p.redraw(b)}var d=this,p=d.chart;!1!==c?z(d,"remove",null,e):e()},update:function(a,b){var e=this,n=e.chart,d=e.userOptions,p=e.oldType||e.type,l=a.type||d.type||n.options.chart.type,
h=I[p].prototype,f,g=["group","markerGroup","dataLabelsGroup"],m=["navigatorSeries","baseSeries"],x=e.finishedAnimating&&{animation:!1};if(Object.keys&&"data"===Object.keys(a).toString())return this.setData(a.data,b);m=g.concat(m);w(m,function(a){m[a]=e[a];delete e[a]});a=c(d,x,{index:e.index,pointStart:e.xData[0]},{data:e.options.data},a);e.remove(!1,null,!1);for(f in h)e[f]=void 0;u(e,I[l||p].prototype);w(m,function(a){e[a]=m[a]});e.init(n,a);a.zIndex!==d.zIndex&&w(g,function(d){e[d]&&e[d].attr({zIndex:a.zIndex})});
e.oldType=p;n.linkSeries();r(b,!0)&&n.redraw(!1)}});u(H.prototype,{update:function(a,b){var e=this.chart;a=e.options[this.coll][this.options.index]=c(this.userOptions,a);this.destroy(!0);this.init(e,u(a,{events:void 0}));e.isDirtyBox=!0;r(b,!0)&&e.redraw()},remove:function(a){for(var b=this.chart,c=this.coll,n=this.series,d=n.length;d--;)n[d]&&n[d].remove(!1);t(b.axes,this);t(b[c],this);e(b.options[c])?b.options[c].splice(this.options.index,1):delete b.options[c];w(b[c],function(a,d){a.options.index=
d});this.destroy();b.isDirtyBox=!0;r(a,!0)&&b.redraw()},setTitle:function(a,b){this.update({title:a},b)},setCategories:function(a,b){this.update({categories:a},b)}})})(L);(function(a){var G=a.color,E=a.each,H=a.map,v=a.pick,k=a.Series,q=a.seriesType;q("area","line",{softThreshold:!1,threshold:0},{singleStacks:!1,getStackPoints:function(k){var q=[],u=[],w=this.xAxis,m=this.yAxis,g=m.stacks[this.stackKey],f={},e=this.index,c=m.series,b=c.length,r,l=v(m.options.reversedStacks,!0)?1:-1,C;k=k||this.points;
if(this.options.stacking){for(C=0;C<k.length;C++)k[C].leftNull=k[C].rightNull=null,f[k[C].x]=k[C];a.objectEach(g,function(a,b){null!==a.total&&u.push(b)});u.sort(function(a,b){return a-b});r=H(c,function(){return this.visible});E(u,function(a,c){var x=0,n,k;if(f[a]&&!f[a].isNull)q.push(f[a]),E([-1,1],function(m){var x=1===m?"rightNull":"leftNull",d=0,p=g[u[c+m]];if(p)for(C=e;0<=C&&C<b;)n=p.points[C],n||(C===e?f[a][x]=!0:r[C]&&(k=g[a].points[C])&&(d-=k[1]-k[0])),C+=l;f[a][1===m?"rightCliff":"leftCliff"]=
d});else{for(C=e;0<=C&&C<b;){if(n=g[a].points[C]){x=n[1];break}C+=l}x=m.translate(x,0,1,0,1);q.push({isNull:!0,plotX:w.translate(a,0,0,0,1),x:a,plotY:x,yBottom:x})}})}return q},getGraphPath:function(a){var q=k.prototype.getGraphPath,u=this.options,w=u.stacking,m=this.yAxis,g,f,e=[],c=[],b=this.index,r,l=m.stacks[this.stackKey],C=u.threshold,I=m.getThreshold(u.threshold),x,u=u.connectNulls||"percent"===w,F=function(n,f,g){var x=a[n];n=w&&l[x.x].points[b];var d=x[g+"Null"]||0;g=x[g+"Cliff"]||0;var p,
k,x=!0;g||d?(p=(d?n[0]:n[1])+g,k=n[0]+g,x=!!d):!w&&a[f]&&a[f].isNull&&(p=k=C);void 0!==p&&(c.push({plotX:r,plotY:null===p?I:m.getThreshold(p),isNull:x,isCliff:!0}),e.push({plotX:r,plotY:null===k?I:m.getThreshold(k),doCurve:!1}))};a=a||this.points;w&&(a=this.getStackPoints(a));for(g=0;g<a.length;g++)if(f=a[g].isNull,r=v(a[g].rectPlotX,a[g].plotX),x=v(a[g].yBottom,I),!f||u)u||F(g,g-1,"left"),f&&!w&&u||(c.push(a[g]),e.push({x:g,plotX:r,plotY:x})),u||F(g,g+1,"right");g=q.call(this,c,!0,!0);e.reversed=
!0;f=q.call(this,e,!0,!0);f.length&&(f[0]="L");f=g.concat(f);q=q.call(this,c,!1,u);f.xMap=g.xMap;this.areaPath=f;return q},drawGraph:function(){this.areaPath=[];k.prototype.drawGraph.apply(this);var a=this,q=this.areaPath,u=this.options,z=[["area","highcharts-area",this.color,u.fillColor]];E(this.zones,function(m,g){z.push(["zone-area-"+g,"highcharts-area highcharts-zone-area-"+g+" "+m.className,m.color||a.color,m.fillColor||u.fillColor])});E(z,function(m){var g=m[0],f=a[g];f?(f.endX=a.preventGraphAnimation?
null:q.xMap,f.animate({d:q})):(f=a[g]=a.chart.renderer.path(q).addClass(m[1]).attr({fill:v(m[3],G(m[2]).setOpacity(v(u.fillOpacity,.75)).get()),zIndex:0}).add(a.group),f.isArea=!0);f.startX=q.xMap;f.shiftUnit=u.step?2:1})},drawLegendSymbol:a.LegendSymbolMixin.drawRectangle})})(L);(function(a){var G=a.pick;a=a.seriesType;a("spline","line",{},{getPointSpline:function(a,H,v){var k=H.plotX,q=H.plotY,w=a[v-1];v=a[v+1];var t,u,z,m;if(w&&!w.isNull&&!1!==w.doCurve&&!H.isCliff&&v&&!v.isNull&&!1!==v.doCurve&&
!H.isCliff){a=w.plotY;z=v.plotX;v=v.plotY;var g=0;t=(1.5*k+w.plotX)/2.5;u=(1.5*q+a)/2.5;z=(1.5*k+z)/2.5;m=(1.5*q+v)/2.5;z!==t&&(g=(m-u)*(z-k)/(z-t)+q-m);u+=g;m+=g;u>a&&u>q?(u=Math.max(a,q),m=2*q-u):u<a&&u<q&&(u=Math.min(a,q),m=2*q-u);m>v&&m>q?(m=Math.max(v,q),u=2*q-m):m<v&&m<q&&(m=Math.min(v,q),u=2*q-m);H.rightContX=z;H.rightContY=m}H=["C",G(w.rightContX,w.plotX),G(w.rightContY,w.plotY),G(t,k),G(u,q),k,q];w.rightContX=w.rightContY=null;return H}})})(L);(function(a){var G=a.seriesTypes.area.prototype,
E=a.seriesType;E("areaspline","spline",a.defaultPlotOptions.area,{getStackPoints:G.getStackPoints,getGraphPath:G.getGraphPath,drawGraph:G.drawGraph,drawLegendSymbol:a.LegendSymbolMixin.drawRectangle})})(L);(function(a){var G=a.animObject,E=a.color,H=a.each,v=a.extend,k=a.isNumber,q=a.merge,w=a.pick,t=a.Series,u=a.seriesType,z=a.svg;u("column","line",{borderRadius:0,crisp:!0,groupPadding:.2,marker:null,pointPadding:.1,minPointLength:0,cropThreshold:50,pointRange:null,states:{hover:{halo:!1,brightness:.1},
select:{color:"#cccccc",borderColor:"#000000"}},dataLabels:{align:null,verticalAlign:null,y:null},softThreshold:!1,startFromThreshold:!0,stickyTracking:!1,tooltip:{distance:6},threshold:0,borderColor:"#ffffff"},{cropShoulder:0,directTouch:!0,trackerGroups:["group","dataLabelsGroup"],negStacks:!0,init:function(){t.prototype.init.apply(this,arguments);var a=this,g=a.chart;g.hasRendered&&H(g.series,function(f){f.type===a.type&&(f.isDirty=!0)})},getColumnMetrics:function(){var a=this,g=a.options,f=a.xAxis,
e=a.yAxis,c=f.reversed,b,r={},l=0;!1===g.grouping?l=1:H(a.chart.series,function(c){var n=c.options,f=c.yAxis,g;c.type!==a.type||!c.visible&&a.chart.options.chart.ignoreHiddenSeries||e.len!==f.len||e.pos!==f.pos||(n.stacking?(b=c.stackKey,void 0===r[b]&&(r[b]=l++),g=r[b]):!1!==n.grouping&&(g=l++),c.columnIndex=g)});var k=Math.min(Math.abs(f.transA)*(f.ordinalSlope||g.pointRange||f.closestPointRange||f.tickInterval||1),f.len),q=k*g.groupPadding,x=(k-2*q)/(l||1),g=Math.min(g.maxPointWidth||f.len,w(g.pointWidth,
x*(1-2*g.pointPadding)));a.columnMetrics={width:g,offset:(x-g)/2+(q+((a.columnIndex||0)+(c?1:0))*x-k/2)*(c?-1:1)};return a.columnMetrics},crispCol:function(a,g,f,e){var c=this.chart,b=this.borderWidth,r=-(b%2?.5:0),b=b%2?.5:1;c.inverted&&c.renderer.isVML&&(b+=1);this.options.crisp&&(f=Math.round(a+f)+r,a=Math.round(a)+r,f-=a);e=Math.round(g+e)+b;r=.5>=Math.abs(g)&&.5<e;g=Math.round(g)+b;e-=g;r&&e&&(--g,e+=1);return{x:a,y:g,width:f,height:e}},translate:function(){var a=this,g=a.chart,f=a.options,e=
a.dense=2>a.closestPointRange*a.xAxis.transA,e=a.borderWidth=w(f.borderWidth,e?0:1),c=a.yAxis,b=f.threshold,r=a.translatedThreshold=c.getThreshold(b),l=w(f.minPointLength,5),k=a.getColumnMetrics(),q=k.width,x=a.barW=Math.max(q,1+2*e),F=a.pointXOffset=k.offset;g.inverted&&(r-=.5);f.pointPadding&&(x=Math.ceil(x));t.prototype.translate.apply(a);H(a.points,function(e){var n=w(e.yBottom,r),f=999+Math.abs(n),f=Math.min(Math.max(-f,e.plotY),c.len+f),k=e.plotX+F,d=x,p=Math.min(f,n),m,h=Math.max(f,n)-p;l&&
Math.abs(h)<l&&(h=l,m=!c.reversed&&!e.negative||c.reversed&&e.negative,e.y===b&&a.dataMax<=b&&c.min<b&&(m=!m),p=Math.abs(p-r)>l?n-l:r-(m?l:0));e.barX=k;e.pointWidth=q;e.tooltipPos=g.inverted?[c.len+c.pos-g.plotLeft-f,a.xAxis.len-k-d/2,h]:[k+d/2,f+c.pos-g.plotTop,h];e.shapeType="rect";e.shapeArgs=a.crispCol.apply(a,e.isNull?[k,r,d,0]:[k,p,d,h])})},getSymbol:a.noop,drawLegendSymbol:a.LegendSymbolMixin.drawRectangle,drawGraph:function(){this.group[this.dense?"addClass":"removeClass"]("highcharts-dense-data")},
pointAttribs:function(a,g){var f=this.options,e,c=this.pointAttrToOptions||{};e=c.stroke||"borderColor";var b=c["stroke-width"]||"borderWidth",r=a&&a.color||this.color,l=a&&a[e]||f[e]||this.color||r,k=a&&a[b]||f[b]||this[b]||0,c=f.dashStyle;a&&this.zones.length&&(r=a.getZone(),r=a.options.color||r&&r.color||this.color);g&&(a=q(f.states[g],a.options.states&&a.options.states[g]||{}),g=a.brightness,r=a.color||void 0!==g&&E(r).brighten(a.brightness).get()||r,l=a[e]||l,k=a[b]||k,c=a.dashStyle||c);e={fill:r,
stroke:l,"stroke-width":k};c&&(e.dashstyle=c);return e},drawPoints:function(){var a=this,g=this.chart,f=a.options,e=g.renderer,c=f.animationLimit||250,b;H(a.points,function(r){var l=r.graphic;if(k(r.plotY)&&null!==r.y){b=r.shapeArgs;if(l)l[g.pointCount<c?"animate":"attr"](q(b));else r.graphic=l=e[r.shapeType](b).add(r.group||a.group);f.borderRadius&&l.attr({r:f.borderRadius});l.attr(a.pointAttribs(r,r.selected&&"select")).shadow(f.shadow,null,f.stacking&&!f.borderRadius);l.addClass(r.getClassName(),
!0)}else l&&(r.graphic=l.destroy())})},animate:function(a){var g=this,f=this.yAxis,e=g.options,c=this.chart.inverted,b={},r=c?"translateX":"translateY",l;z&&(a?(b.scaleY=.001,a=Math.min(f.pos+f.len,Math.max(f.pos,f.toPixels(e.threshold))),c?b.translateX=a-f.len:b.translateY=a,g.group.attr(b)):(l=g.group.attr(r),g.group.animate({scaleY:1},v(G(g.options.animation),{step:function(a,c){b[r]=l+c.pos*(f.pos-l);g.group.attr(b)}})),g.animate=null))},remove:function(){var a=this,g=a.chart;g.hasRendered&&H(g.series,
function(f){f.type===a.type&&(f.isDirty=!0)});t.prototype.remove.apply(a,arguments)}})})(L);(function(a){a=a.seriesType;a("bar","column",null,{inverted:!0})})(L);(function(a){var G=a.Series;a=a.seriesType;a("scatter","line",{lineWidth:0,findNearestPointBy:"xy",marker:{enabled:!0},tooltip:{headerFormat:'\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e \x3cspan style\x3d"font-size: 0.85em"\x3e {series.name}\x3c/span\x3e\x3cbr/\x3e',pointFormat:"x: \x3cb\x3e{point.x}\x3c/b\x3e\x3cbr/\x3ey: \x3cb\x3e{point.y}\x3c/b\x3e\x3cbr/\x3e"}},
{sorted:!1,requireSorting:!1,noSharedTooltip:!0,trackerGroups:["group","markerGroup","dataLabelsGroup"],takeOrdinalPosition:!1,drawGraph:function(){this.options.lineWidth&&G.prototype.drawGraph.call(this)}})})(L);(function(a){var G=a.deg2rad,E=a.isNumber,H=a.pick,v=a.relativeLength;a.CenteredSeriesMixin={getCenter:function(){var a=this.options,q=this.chart,w=2*(a.slicedOffset||0),t=q.plotWidth-2*w,q=q.plotHeight-2*w,u=a.center,u=[H(u[0],"50%"),H(u[1],"50%"),a.size||"100%",a.innerSize||0],z=Math.min(t,
q),m,g;for(m=0;4>m;++m)g=u[m],a=2>m||2===m&&/%$/.test(g),u[m]=v(g,[t,q,z,u[2]][m])+(a?w:0);u[3]>u[2]&&(u[3]=u[2]);return u},getStartAndEndRadians:function(a,q){a=E(a)?a:0;q=E(q)&&q>a&&360>q-a?q:a+360;return{start:G*(a+-90),end:G*(q+-90)}}}})(L);(function(a){var G=a.addEvent,E=a.CenteredSeriesMixin,H=a.defined,v=a.each,k=a.extend,q=E.getStartAndEndRadians,w=a.inArray,t=a.noop,u=a.pick,z=a.Point,m=a.Series,g=a.seriesType,f=a.setAnimation;g("pie","line",{center:[null,null],clip:!1,colorByPoint:!0,dataLabels:{distance:30,
enabled:!0,formatter:function(){return this.point.isNull?void 0:this.point.name},x:0},ignoreHiddenPoint:!0,legendType:"point",marker:null,size:null,showInLegend:!1,slicedOffset:10,stickyTracking:!1,tooltip:{followPointer:!0},borderColor:"#ffffff",borderWidth:1,states:{hover:{brightness:.1,shadow:!1}}},{isCartesian:!1,requireSorting:!1,directTouch:!0,noSharedTooltip:!0,trackerGroups:["group","dataLabelsGroup"],axisTypes:[],pointAttribs:a.seriesTypes.column.prototype.pointAttribs,animate:function(a){var c=
this,b=c.points,e=c.startAngleRad;a||(v(b,function(a){var b=a.graphic,l=a.shapeArgs;b&&(b.attr({r:a.startR||c.center[3]/2,start:e,end:e}),b.animate({r:l.r,start:l.start,end:l.end},c.options.animation))}),c.animate=null)},updateTotals:function(){var a,c=0,b=this.points,f=b.length,l,g=this.options.ignoreHiddenPoint;for(a=0;a<f;a++)l=b[a],c+=g&&!l.visible?0:l.isNull?0:l.y;this.total=c;for(a=0;a<f;a++)l=b[a],l.percentage=0<c&&(l.visible||!g)?l.y/c*100:0,l.total=c},generatePoints:function(){m.prototype.generatePoints.call(this);
this.updateTotals()},translate:function(a){this.generatePoints();var c=0,b=this.options,e=b.slicedOffset,l=e+(b.borderWidth||0),f,g,x,k=q(b.startAngle,b.endAngle),n=this.startAngleRad=k.start,k=(this.endAngleRad=k.end)-n,m=this.points,t,A=b.dataLabels.distance,b=b.ignoreHiddenPoint,d,p=m.length,D;a||(this.center=a=this.getCenter());this.getX=function(d,b,c){x=Math.asin(Math.min((d-a[1])/(a[2]/2+c.labelDistance),1));return a[0]+(b?-1:1)*Math.cos(x)*(a[2]/2+c.labelDistance)};for(d=0;d<p;d++){D=m[d];
D.labelDistance=u(D.options.dataLabels&&D.options.dataLabels.distance,A);this.maxLabelDistance=Math.max(this.maxLabelDistance||0,D.labelDistance);f=n+c*k;if(!b||D.visible)c+=D.percentage/100;g=n+c*k;D.shapeType="arc";D.shapeArgs={x:a[0],y:a[1],r:a[2]/2,innerR:a[3]/2,start:Math.round(1E3*f)/1E3,end:Math.round(1E3*g)/1E3};x=(g+f)/2;x>1.5*Math.PI?x-=2*Math.PI:x<-Math.PI/2&&(x+=2*Math.PI);D.slicedTranslation={translateX:Math.round(Math.cos(x)*e),translateY:Math.round(Math.sin(x)*e)};g=Math.cos(x)*a[2]/
2;t=Math.sin(x)*a[2]/2;D.tooltipPos=[a[0]+.7*g,a[1]+.7*t];D.half=x<-Math.PI/2||x>Math.PI/2?1:0;D.angle=x;f=Math.min(l,D.labelDistance/5);D.labelPos=[a[0]+g+Math.cos(x)*D.labelDistance,a[1]+t+Math.sin(x)*D.labelDistance,a[0]+g+Math.cos(x)*f,a[1]+t+Math.sin(x)*f,a[0]+g,a[1]+t,0>D.labelDistance?"center":D.half?"right":"left",x]}},drawGraph:null,drawPoints:function(){var a=this,c=a.chart.renderer,b,f,l,g,m=a.options.shadow;m&&!a.shadowGroup&&(a.shadowGroup=c.g("shadow").add(a.group));v(a.points,function(e){f=
e.graphic;if(e.isNull)f&&(e.graphic=f.destroy());else{g=e.shapeArgs;b=e.getTranslate();var r=e.shadowGroup;m&&!r&&(r=e.shadowGroup=c.g("shadow").add(a.shadowGroup));r&&r.attr(b);l=a.pointAttribs(e,e.selected&&"select");f?f.setRadialReference(a.center).attr(l).animate(k(g,b)):(e.graphic=f=c[e.shapeType](g).setRadialReference(a.center).attr(b).add(a.group),e.visible||f.attr({visibility:"hidden"}),f.attr(l).attr({"stroke-linejoin":"round"}).shadow(m,r));f.addClass(e.getClassName())}})},searchPoint:t,
sortByAngle:function(a,c){a.sort(function(a,e){return void 0!==a.angle&&(e.angle-a.angle)*c})},drawLegendSymbol:a.LegendSymbolMixin.drawRectangle,getCenter:E.getCenter,getSymbol:t},{init:function(){z.prototype.init.apply(this,arguments);var a=this,c;a.name=u(a.name,"Slice");c=function(b){a.slice("select"===b.type)};G(a,"select",c);G(a,"unselect",c);return a},isValid:function(){return a.isNumber(this.y,!0)&&0<=this.y},setVisible:function(a,c){var b=this,e=b.series,l=e.chart,f=e.options.ignoreHiddenPoint;
c=u(c,f);a!==b.visible&&(b.visible=b.options.visible=a=void 0===a?!b.visible:a,e.options.data[w(b,e.data)]=b.options,v(["graphic","dataLabel","connector","shadowGroup"],function(c){if(b[c])b[c][a?"show":"hide"](!0)}),b.legendItem&&l.legend.colorizeItem(b,a),a||"hover"!==b.state||b.setState(""),f&&(e.isDirty=!0),c&&l.redraw())},slice:function(a,c,b){var e=this.series;f(b,e.chart);u(c,!0);this.sliced=this.options.sliced=H(a)?a:!this.sliced;e.options.data[w(this,e.data)]=this.options;this.graphic.animate(this.getTranslate());
this.shadowGroup&&this.shadowGroup.animate(this.getTranslate())},getTranslate:function(){return this.sliced?this.slicedTranslation:{translateX:0,translateY:0}},haloPath:function(a){var c=this.shapeArgs;return this.sliced||!this.visible?[]:this.series.chart.renderer.symbols.arc(c.x,c.y,c.r+a,c.r+a,{innerR:this.shapeArgs.r-1,start:c.start,end:c.end})}})})(L);(function(a){var G=a.addEvent,E=a.arrayMax,H=a.defined,v=a.each,k=a.extend,q=a.format,w=a.map,t=a.merge,u=a.noop,z=a.pick,m=a.relativeLength,g=
a.Series,f=a.seriesTypes,e=a.stableSort;a.distribute=function(a,b){function c(a,b){return a.target-b.target}var l,f=!0,g=a,x=[],k;k=0;for(l=a.length;l--;)k+=a[l].size;if(k>b){e(a,function(a,b){return(b.rank||0)-(a.rank||0)});for(k=l=0;k<=b;)k+=a[l].size,l++;x=a.splice(l-1,a.length)}e(a,c);for(a=w(a,function(a){return{size:a.size,targets:[a.target],align:z(a.align,.5)}});f;){for(l=a.length;l--;)f=a[l],k=(Math.min.apply(0,f.targets)+Math.max.apply(0,f.targets))/2,f.pos=Math.min(Math.max(0,k-f.size*
f.align),b-f.size);l=a.length;for(f=!1;l--;)0<l&&a[l-1].pos+a[l-1].size>a[l].pos&&(a[l-1].size+=a[l].size,a[l-1].targets=a[l-1].targets.concat(a[l].targets),a[l-1].align=.5,a[l-1].pos+a[l-1].size>b&&(a[l-1].pos=b-a[l-1].size),a.splice(l,1),f=!0)}l=0;v(a,function(a){var b=0;v(a.targets,function(){g[l].pos=a.pos+b;b+=g[l].size;l++})});g.push.apply(g,x);e(g,c)};g.prototype.drawDataLabels=function(){function c(a,b){var d=b.filter;return d?(b=d.operator,a=a[d.property],d=d.value,"\x3e"===b&&a>d||"\x3c"===
b&&a<d||"\x3e\x3d"===b&&a>=d||"\x3c\x3d"===b&&a<=d||"\x3d\x3d"===b&&a==d||"\x3d\x3d\x3d"===b&&a===d?!0:!1):!0}var b=this,e=b.options,f=e.dataLabels,g=b.points,k,x,m=b.hasRendered||0,n,B,u=z(f.defer,!!e.animation),A=b.chart.renderer;if(f.enabled||b._hasPointLabels)b.dlProcessOptions&&b.dlProcessOptions(f),B=b.plotGroup("dataLabelsGroup","data-labels",u&&!m?"hidden":"visible",f.zIndex||6),u&&(B.attr({opacity:+m}),m||G(b,"afterAnimate",function(){b.visible&&B.show(!0);B[e.animation?"animate":"attr"]({opacity:1},
{duration:200})})),x=f,v(g,function(d){var p,l=d.dataLabel,h,g,r=d.connector,m=!l,F;k=d.dlOptions||d.options&&d.options.dataLabels;(p=z(k&&k.enabled,x.enabled)&&!d.isNull)&&(p=!0===c(d,k||f));p&&(f=t(x,k),h=d.getLabelConfig(),F=f[d.formatPrefix+"Format"]||f.format,n=H(F)?q(F,h):(f[d.formatPrefix+"Formatter"]||f.formatter).call(h,f),F=f.style,h=f.rotation,F.color=z(f.color,F.color,b.color,"#000000"),"contrast"===F.color&&(d.contrastColor=A.getContrast(d.color||b.color),F.color=f.inside||0>z(d.labelDistance,
f.distance)||e.stacking?d.contrastColor:"#000000"),e.cursor&&(F.cursor=e.cursor),g={fill:f.backgroundColor,stroke:f.borderColor,"stroke-width":f.borderWidth,r:f.borderRadius||0,rotation:h,padding:f.padding,zIndex:1},a.objectEach(g,function(a,d){void 0===a&&delete g[d]}));!l||p&&H(n)?p&&H(n)&&(l?g.text=n:(l=d.dataLabel=h?A.text(n,0,-9999).addClass("highcharts-data-label"):A.label(n,0,-9999,f.shape,null,null,f.useHTML,null,"data-label"),l.addClass(" highcharts-data-label-color-"+d.colorIndex+" "+(f.className||
"")+(f.useHTML?"highcharts-tracker":""))),l.attr(g),l.css(F).shadow(f.shadow),l.added||l.add(B),b.alignDataLabel(d,l,f,null,m)):(d.dataLabel=l=l.destroy(),r&&(d.connector=r.destroy()))})};g.prototype.alignDataLabel=function(a,b,e,f,g){var c=this.chart,l=c.inverted,r=z(a.dlBox&&a.dlBox.centerX,a.plotX,-9999),n=z(a.plotY,-9999),m=b.getBBox(),q,t=e.rotation,d=e.align,p=this.visible&&(a.series.forceDL||c.isInsidePlot(r,Math.round(n),l)||f&&c.isInsidePlot(r,l?f.x+1:f.y+f.height-1,l)),D="justify"===z(e.overflow,
"justify");if(p&&(q=e.style.fontSize,q=c.renderer.fontMetrics(q,b).b,f=k({x:l?this.yAxis.len-n:r,y:Math.round(l?this.xAxis.len-r:n),width:0,height:0},f),k(e,{width:m.width,height:m.height}),t?(D=!1,r=c.renderer.rotCorr(q,t),r={x:f.x+e.x+f.width/2+r.x,y:f.y+e.y+{top:0,middle:.5,bottom:1}[e.verticalAlign]*f.height},b[g?"attr":"animate"](r).attr({align:d}),n=(t+720)%360,n=180<n&&360>n,"left"===d?r.y-=n?m.height:0:"center"===d?(r.x-=m.width/2,r.y-=m.height/2):"right"===d&&(r.x-=m.width,r.y-=n?0:m.height)):
(b.align(e,null,f),r=b.alignAttr),D?a.isLabelJustified=this.justifyDataLabel(b,e,r,m,f,g):z(e.crop,!0)&&(p=c.isInsidePlot(r.x,r.y)&&c.isInsidePlot(r.x+m.width,r.y+m.height)),e.shape&&!t))b[g?"attr":"animate"]({anchorX:l?c.plotWidth-a.plotY:a.plotX,anchorY:l?c.plotHeight-a.plotX:a.plotY});p||(b.attr({y:-9999}),b.placed=!1)};g.prototype.justifyDataLabel=function(a,b,e,f,g,k){var c=this.chart,l=b.align,n=b.verticalAlign,r,m,q=a.box?0:a.padding||0;r=e.x+q;0>r&&("right"===l?b.align="left":b.x=-r,m=!0);
r=e.x+f.width-q;r>c.plotWidth&&("left"===l?b.align="right":b.x=c.plotWidth-r,m=!0);r=e.y+q;0>r&&("bottom"===n?b.verticalAlign="top":b.y=-r,m=!0);r=e.y+f.height-q;r>c.plotHeight&&("top"===n?b.verticalAlign="bottom":b.y=c.plotHeight-r,m=!0);m&&(a.placed=!k,a.align(b,null,g));return m};f.pie&&(f.pie.prototype.drawDataLabels=function(){var c=this,b=c.data,e,f=c.chart,k=c.options.dataLabels,m=z(k.connectorPadding,10),x=z(k.connectorWidth,1),q=f.plotWidth,n=f.plotHeight,t,u=c.center,A=u[2]/2,d=u[1],p,D,
h,y,w=[[],[]],M,O,N,G,K=[0,0,0,0];c.visible&&(k.enabled||c._hasPointLabels)&&(v(b,function(a){a.dataLabel&&a.visible&&a.dataLabel.shortened&&(a.dataLabel.attr({width:"auto"}).css({width:"auto",textOverflow:"clip"}),a.dataLabel.shortened=!1)}),g.prototype.drawDataLabels.apply(c),v(b,function(a){a.dataLabel&&a.visible&&(w[a.half].push(a),a.dataLabel._pos=null)}),v(w,function(b,l){var g,r,x=b.length,t=[],B;if(x)for(c.sortByAngle(b,l-.5),0<c.maxLabelDistance&&(g=Math.max(0,d-A-c.maxLabelDistance),r=Math.min(d+
A+c.maxLabelDistance,f.plotHeight),v(b,function(a){0<a.labelDistance&&a.dataLabel&&(a.top=Math.max(0,d-A-a.labelDistance),a.bottom=Math.min(d+A+a.labelDistance,f.plotHeight),B=a.dataLabel.getBBox().height||21,a.positionsIndex=t.push({target:a.labelPos[1]-a.top+B/2,size:B,rank:a.y})-1)}),a.distribute(t,r+B-g)),G=0;G<x;G++)e=b[G],r=e.positionsIndex,h=e.labelPos,p=e.dataLabel,N=!1===e.visible?"hidden":"inherit",O=g=h[1],t&&H(t[r])&&(void 0===t[r].pos?N="hidden":(y=t[r].size,O=e.top+t[r].pos)),delete e.positionIndex,
M=k.justify?u[0]+(l?-1:1)*(A+e.labelDistance):c.getX(O<e.top+2||O>e.bottom-2?g:O,l,e),p._attr={visibility:N,align:h[6]},p._pos={x:M+k.x+({left:m,right:-m}[h[6]]||0),y:O+k.y-10},h.x=M,h.y=O,z(k.crop,!0)&&(D=p.getBBox().width,g=null,M-D<m?(g=Math.round(D-M+m),K[3]=Math.max(g,K[3])):M+D>q-m&&(g=Math.round(M+D-q+m),K[1]=Math.max(g,K[1])),0>O-y/2?K[0]=Math.max(Math.round(-O+y/2),K[0]):O+y/2>n&&(K[2]=Math.max(Math.round(O+y/2-n),K[2])),p.sideOverflow=g)}),0===E(K)||this.verifyDataLabelOverflow(K))&&(this.placeDataLabels(),
x&&v(this.points,function(a){var d;t=a.connector;if((p=a.dataLabel)&&p._pos&&a.visible&&0<a.labelDistance){N=p._attr.visibility;if(d=!t)a.connector=t=f.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-"+a.colorIndex).add(c.dataLabelsGroup),t.attr({"stroke-width":x,stroke:k.connectorColor||a.color||"#666666"});t[d?"attr":"animate"]({d:c.connectorPath(a.labelPos)});t.attr("visibility",N)}else t&&(a.connector=t.destroy())}))},f.pie.prototype.connectorPath=function(a){var b=
a.x,c=a.y;return z(this.options.dataLabels.softConnector,!0)?["M",b+("left"===a[6]?5:-5),c,"C",b,c,2*a[2]-a[4],2*a[3]-a[5],a[2],a[3],"L",a[4],a[5]]:["M",b+("left"===a[6]?5:-5),c,"L",a[2],a[3],"L",a[4],a[5]]},f.pie.prototype.placeDataLabels=function(){v(this.points,function(a){var b=a.dataLabel;b&&a.visible&&((a=b._pos)?(b.sideOverflow&&(b._attr.width=b.getBBox().width-b.sideOverflow,b.css({width:b._attr.width+"px",textOverflow:"ellipsis"}),b.shortened=!0),b.attr(b._attr),b[b.moved?"animate":"attr"](a),
b.moved=!0):b&&b.attr({y:-9999}))},this)},f.pie.prototype.alignDataLabel=u,f.pie.prototype.verifyDataLabelOverflow=function(a){var b=this.center,c=this.options,e=c.center,f=c.minSize||80,g,k=null!==c.size;k||(null!==e[0]?g=Math.max(b[2]-Math.max(a[1],a[3]),f):(g=Math.max(b[2]-a[1]-a[3],f),b[0]+=(a[3]-a[1])/2),null!==e[1]?g=Math.max(Math.min(g,b[2]-Math.max(a[0],a[2])),f):(g=Math.max(Math.min(g,b[2]-a[0]-a[2]),f),b[1]+=(a[0]-a[2])/2),g<b[2]?(b[2]=g,b[3]=Math.min(m(c.innerSize||0,g),g),this.translate(b),
this.drawDataLabels&&this.drawDataLabels()):k=!0);return k});f.column&&(f.column.prototype.alignDataLabel=function(a,b,e,f,k){var c=this.chart.inverted,l=a.series,r=a.dlBox||a.shapeArgs,n=z(a.below,a.plotY>z(this.translatedThreshold,l.yAxis.len)),m=z(e.inside,!!this.options.stacking);r&&(f=t(r),0>f.y&&(f.height+=f.y,f.y=0),r=f.y+f.height-l.yAxis.len,0<r&&(f.height-=r),c&&(f={x:l.yAxis.len-f.y-f.height,y:l.xAxis.len-f.x-f.width,width:f.height,height:f.width}),m||(c?(f.x+=n?0:f.width,f.width=0):(f.y+=
n?f.height:0,f.height=0)));e.align=z(e.align,!c||m?"center":n?"right":"left");e.verticalAlign=z(e.verticalAlign,c||m?"middle":n?"top":"bottom");g.prototype.alignDataLabel.call(this,a,b,e,f,k);a.isLabelJustified&&a.contrastColor&&a.dataLabel.css({color:a.contrastColor})})})(L);(function(a){var G=a.Chart,E=a.each,H=a.objectEach,v=a.pick;a=a.addEvent;a(G.prototype,"render",function(){var a=[];E(this.labelCollectors||[],function(k){a=a.concat(k())});E(this.yAxis||[],function(k){k.options.stackLabels&&
!k.options.stackLabels.allowOverlap&&H(k.stacks,function(k){H(k,function(k){a.push(k.label)})})});E(this.series||[],function(k){var q=k.options.dataLabels,t=k.dataLabelCollections||["dataLabel"];(q.enabled||k._hasPointLabels)&&!q.allowOverlap&&k.visible&&E(t,function(q){E(k.points,function(k){k[q]&&(k[q].labelrank=v(k.labelrank,k.shapeArgs&&k.shapeArgs.height),a.push(k[q]))})})});this.hideOverlappingLabels(a)});G.prototype.hideOverlappingLabels=function(a){var k=a.length,v,t,u,z,m,g,f,e,c,b=function(a,
b,c,e,f,g,n,k){return!(f>a+c||f+n<a||g>b+e||g+k<b)};for(t=0;t<k;t++)if(v=a[t])v.oldOpacity=v.opacity,v.newOpacity=1,v.width||(u=v.getBBox(),v.width=u.width,v.height=u.height);a.sort(function(a,b){return(b.labelrank||0)-(a.labelrank||0)});for(t=0;t<k;t++)for(u=a[t],v=t+1;v<k;++v)if(z=a[v],u&&z&&u!==z&&u.placed&&z.placed&&0!==u.newOpacity&&0!==z.newOpacity&&(m=u.alignAttr,g=z.alignAttr,f=u.parentGroup,e=z.parentGroup,c=2*(u.box?0:u.padding||0),m=b(m.x+f.translateX,m.y+f.translateY,u.width-c,u.height-
c,g.x+e.translateX,g.y+e.translateY,z.width-c,z.height-c)))(u.labelrank<z.labelrank?u:z).newOpacity=0;E(a,function(a){var b,c;a&&(c=a.newOpacity,a.oldOpacity!==c&&a.placed&&(c?a.show(!0):b=function(){a.hide()},a.alignAttr.opacity=c,a[a.isOld?"animate":"attr"](a.alignAttr,null,b)),a.isOld=!0)})}})(L);(function(a){var G=a.addEvent,E=a.Chart,H=a.createElement,v=a.css,k=a.defaultOptions,q=a.defaultPlotOptions,w=a.each,t=a.extend,u=a.fireEvent,z=a.hasTouch,m=a.inArray,g=a.isObject,f=a.Legend,e=a.merge,
c=a.pick,b=a.Point,r=a.Series,l=a.seriesTypes,C=a.svg,I;I=a.TrackerMixin={drawTrackerPoint:function(){var a=this,b=a.chart.pointer,c=function(a){var c=b.getPointFromEvent(a);void 0!==c&&(b.isDirectTouch=!0,c.onMouseOver(a))};w(a.points,function(a){a.graphic&&(a.graphic.element.point=a);a.dataLabel&&(a.dataLabel.div?a.dataLabel.div.point=a:a.dataLabel.element.point=a)});a._hasTracking||(w(a.trackerGroups,function(e){if(a[e]){a[e].addClass("highcharts-tracker").on("mouseover",c).on("mouseout",function(a){b.onTrackerMouseOut(a)});
if(z)a[e].on("touchstart",c);a.options.cursor&&a[e].css(v).css({cursor:a.options.cursor})}}),a._hasTracking=!0)},drawTrackerGraph:function(){var a=this,b=a.options,c=b.trackByArea,e=[].concat(c?a.areaPath:a.graphPath),f=e.length,g=a.chart,d=g.pointer,p=g.renderer,l=g.options.tooltip.snap,h=a.tracker,k,m=function(){if(g.hoverSeries!==a)a.onMouseOver()},r="rgba(192,192,192,"+(C?.0001:.002)+")";if(f&&!c)for(k=f+1;k--;)"M"===e[k]&&e.splice(k+1,0,e[k+1]-l,e[k+2],"L"),(k&&"M"===e[k]||k===f)&&e.splice(k,
0,"L",e[k-2]+l,e[k-1]);h?h.attr({d:e}):a.graph&&(a.tracker=p.path(e).attr({"stroke-linejoin":"round",visibility:a.visible?"visible":"hidden",stroke:r,fill:c?r:"none","stroke-width":a.graph.strokeWidth()+(c?0:2*l),zIndex:2}).add(a.group),w([a.tracker,a.markerGroup],function(a){a.addClass("highcharts-tracker").on("mouseover",m).on("mouseout",function(a){d.onTrackerMouseOut(a)});b.cursor&&a.css({cursor:b.cursor});if(z)a.on("touchstart",m)}))}};l.column&&(l.column.prototype.drawTracker=I.drawTrackerPoint);
l.pie&&(l.pie.prototype.drawTracker=I.drawTrackerPoint);l.scatter&&(l.scatter.prototype.drawTracker=I.drawTrackerPoint);t(f.prototype,{setItemEvents:function(a,c,f){var n=this,g=n.chart.renderer.boxWrapper,l="highcharts-legend-"+(a instanceof b?"point":"series")+"-active";(f?c:a.legendGroup).on("mouseover",function(){a.setState("hover");g.addClass(l);c.css(n.options.itemHoverStyle)}).on("mouseout",function(){c.css(e(a.visible?n.itemStyle:n.itemHiddenStyle));g.removeClass(l);a.setState()}).on("click",
function(d){var b=function(){a.setVisible&&a.setVisible()};g.removeClass(l);d={browserEvent:d};a.firePointEvent?a.firePointEvent("legendItemClick",d,b):u(a,"legendItemClick",d,b)})},createCheckboxForItem:function(a){a.checkbox=H("input",{type:"checkbox",checked:a.selected,defaultChecked:a.selected},this.options.itemCheckboxStyle,this.chart.container);G(a.checkbox,"click",function(b){u(a.series||a,"checkboxClick",{checked:b.target.checked,item:a},function(){a.select()})})}});k.legend.itemStyle.cursor=
"pointer";t(E.prototype,{showResetZoom:function(){var a=this,b=k.lang,c=a.options.chart.resetZoomButton,e=c.theme,f=e.states,g="chart"===c.relativeTo?null:"plotBox";this.resetZoomButton=a.renderer.button(b.resetZoom,null,null,function(){a.zoomOut()},e,f&&f.hover).attr({align:c.position.align,title:b.resetZoomTitle}).addClass("highcharts-reset-zoom").add().align(c.position,!1,g)},zoomOut:function(){var a=this;u(a,"selection",{resetSelection:!0},function(){a.zoom()})},zoom:function(a){var b,e=this.pointer,
f=!1,l;!a||a.resetSelection?(w(this.axes,function(a){b=a.zoom()}),e.initiated=!1):w(a.xAxis.concat(a.yAxis),function(a){var d=a.axis;e[d.isXAxis?"zoomX":"zoomY"]&&(b=d.zoom(a.min,a.max),d.displayBtn&&(f=!0))});l=this.resetZoomButton;f&&!l?this.showResetZoom():!f&&g(l)&&(this.resetZoomButton=l.destroy());b&&this.redraw(c(this.options.chart.animation,a&&a.animation,100>this.pointCount))},pan:function(a,b){var c=this,e=c.hoverPoints,f;e&&w(e,function(a){a.setState()});w("xy"===b?[1,0]:[1],function(b){b=
c[b?"xAxis":"yAxis"][0];var d=b.horiz,e=a[d?"chartX":"chartY"],d=d?"mouseDownX":"mouseDownY",g=c[d],h=(b.pointRange||0)/2,n=b.getExtremes(),l=b.toValue(g-e,!0)+h,k=b.toValue(g+b.len-e,!0)-h,m=k<l,g=m?k:l,l=m?l:k,k=Math.min(n.dataMin,h?n.min:b.toValue(b.toPixels(n.min)-b.minPixelPadding)),h=Math.max(n.dataMax,h?n.max:b.toValue(b.toPixels(n.max)+b.minPixelPadding)),m=k-g;0<m&&(l+=m,g=k);m=l-h;0<m&&(l=h,g-=m);b.series.length&&g!==n.min&&l!==n.max&&(b.setExtremes(g,l,!1,!1,{trigger:"pan"}),f=!0);c[d]=
e});f&&c.redraw(!1);v(c.container,{cursor:"move"})}});t(b.prototype,{select:function(a,b){var e=this,f=e.series,g=f.chart;a=c(a,!e.selected);e.firePointEvent(a?"select":"unselect",{accumulate:b},function(){e.selected=e.options.selected=a;f.options.data[m(e,f.data)]=e.options;e.setState(a&&"select");b||w(g.getSelectedPoints(),function(a){a.selected&&a!==e&&(a.selected=a.options.selected=!1,f.options.data[m(a,f.data)]=a.options,a.setState(""),a.firePointEvent("unselect"))})})},onMouseOver:function(a){var b=
this.series.chart,c=b.pointer;a=a?c.normalize(a):c.getChartCoordinatesFromPoint(this,b.inverted);c.runPointActions(a,this)},onMouseOut:function(){var a=this.series.chart;this.firePointEvent("mouseOut");w(a.hoverPoints||[],function(a){a.setState()});a.hoverPoints=a.hoverPoint=null},importEvents:function(){if(!this.hasImportedEvents){var b=this,c=e(b.series.options.point,b.options).events;b.events=c;a.objectEach(c,function(a,c){G(b,c,a)});this.hasImportedEvents=!0}},setState:function(a,b){var e=Math.floor(this.plotX),
f=this.plotY,g=this.series,l=g.options.states[a]||{},d=q[g.type].marker&&g.options.marker,p=d&&!1===d.enabled,k=d&&d.states&&d.states[a]||{},h=!1===k.enabled,m=g.stateMarkerGraphic,r=this.marker||{},x=g.chart,u=g.halo,v,F=d&&g.markerAttribs;a=a||"";if(!(a===this.state&&!b||this.selected&&"select"!==a||!1===l.enabled||a&&(h||p&&!1===k.enabled)||a&&r.states&&r.states[a]&&!1===r.states[a].enabled)){F&&(v=g.markerAttribs(this,a));if(this.graphic)this.state&&this.graphic.removeClass("highcharts-point-"+
this.state),a&&this.graphic.addClass("highcharts-point-"+a),this.graphic.animate(g.pointAttribs(this,a),c(x.options.chart.animation,l.animation)),v&&this.graphic.animate(v,c(x.options.chart.animation,k.animation,d.animation)),m&&m.hide();else{if(a&&k){d=r.symbol||g.symbol;m&&m.currentSymbol!==d&&(m=m.destroy());if(m)m[b?"animate":"attr"]({x:v.x,y:v.y});else d&&(g.stateMarkerGraphic=m=x.renderer.symbol(d,v.x,v.y,v.width,v.height).add(g.markerGroup),m.currentSymbol=d);m&&m.attr(g.pointAttribs(this,
a))}m&&(m[a&&x.isInsidePlot(e,f,x.inverted)?"show":"hide"](),m.element.point=this)}(e=l.halo)&&e.size?(u||(g.halo=u=x.renderer.path().add((this.graphic||m).parentGroup)),u[b?"animate":"attr"]({d:this.haloPath(e.size)}),u.attr({"class":"highcharts-halo highcharts-color-"+c(this.colorIndex,g.colorIndex)}),u.point=this,u.attr(t({fill:this.color||g.color,"fill-opacity":e.opacity,zIndex:-1},e.attributes))):u&&u.point&&u.point.haloPath&&u.animate({d:u.point.haloPath(0)});this.state=a}},haloPath:function(a){return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX)-
a,this.plotY-a,2*a,2*a)}});t(r.prototype,{onMouseOver:function(){var a=this.chart,b=a.hoverSeries;if(b&&b!==this)b.onMouseOut();this.options.events.mouseOver&&u(this,"mouseOver");this.setState("hover");a.hoverSeries=this},onMouseOut:function(){var a=this.options,b=this.chart,c=b.tooltip,e=b.hoverPoint;b.hoverSeries=null;if(e)e.onMouseOut();this&&a.events.mouseOut&&u(this,"mouseOut");!c||this.stickyTracking||c.shared&&!this.noSharedTooltip||c.hide();this.setState()},setState:function(a){var b=this,
e=b.options,f=b.graph,g=e.states,l=e.lineWidth,e=0;a=a||"";if(b.state!==a&&(w([b.group,b.markerGroup,b.dataLabelsGroup],function(d){d&&(b.state&&d.removeClass("highcharts-series-"+b.state),a&&d.addClass("highcharts-series-"+a))}),b.state=a,!g[a]||!1!==g[a].enabled)&&(a&&(l=g[a].lineWidth||l+(g[a].lineWidthPlus||0)),f&&!f.dashstyle))for(l={"stroke-width":l},f.animate(l,c(b.chart.options.chart.animation,g[a]&&g[a].animation));b["zone-graph-"+e];)b["zone-graph-"+e].attr(l),e+=1},setVisible:function(a,
b){var c=this,e=c.chart,f=c.legendItem,g,d=e.options.chart.ignoreHiddenSeries,p=c.visible;g=(c.visible=a=c.options.visible=c.userOptions.visible=void 0===a?!p:a)?"show":"hide";w(["group","dataLabelsGroup","markerGroup","tracker","tt"],function(a){if(c[a])c[a][g]()});if(e.hoverSeries===c||(e.hoverPoint&&e.hoverPoint.series)===c)c.onMouseOut();f&&e.legend.colorizeItem(c,a);c.isDirty=!0;c.options.stacking&&w(e.series,function(a){a.options.stacking&&a.visible&&(a.isDirty=!0)});w(c.linkedSeries,function(b){b.setVisible(a,
!1)});d&&(e.isDirtyBox=!0);!1!==b&&e.redraw();u(c,g)},show:function(){this.setVisible(!0)},hide:function(){this.setVisible(!1)},select:function(a){this.selected=a=void 0===a?!this.selected:a;this.checkbox&&(this.checkbox.checked=a);u(this,a?"select":"unselect")},drawTracker:I.drawTrackerGraph})})(L);(function(a){var G=a.Chart,E=a.each,H=a.inArray,v=a.isArray,k=a.isObject,q=a.pick,w=a.splat;G.prototype.setResponsive=function(k){var q=this.options.responsive,t=[],m=this.currentResponsive;q&&q.rules&&
E(q.rules,function(f){void 0===f._id&&(f._id=a.uniqueKey());this.matchResponsiveRule(f,t,k)},this);var g=a.merge.apply(0,a.map(t,function(f){return a.find(q.rules,function(a){return a._id===f}).chartOptions})),t=t.toString()||void 0;t!==(m&&m.ruleIds)&&(m&&this.update(m.undoOptions,k),t?(this.currentResponsive={ruleIds:t,mergedOptions:g,undoOptions:this.currentOptions(g)},this.update(g,k)):this.currentResponsive=void 0)};G.prototype.matchResponsiveRule=function(a,k){var t=a.condition;(t.callback||
function(){return this.chartWidth<=q(t.maxWidth,Number.MAX_VALUE)&&this.chartHeight<=q(t.maxHeight,Number.MAX_VALUE)&&this.chartWidth>=q(t.minWidth,0)&&this.chartHeight>=q(t.minHeight,0)}).call(this)&&k.push(a._id)};G.prototype.currentOptions=function(q){function t(m,g,f,e){var c;a.objectEach(m,function(a,m){if(!e&&-1<H(m,["series","xAxis","yAxis"]))for(a=w(a),f[m]=[],c=0;c<a.length;c++)g[m][c]&&(f[m][c]={},t(a[c],g[m][c],f[m][c],e+1));else k(a)?(f[m]=v(a)?[]:{},t(a,g[m]||{},f[m],e+1)):f[m]=g[m]||
null})}var z={};t(q,this.options,z,0);return z}})(L);(function(a){var G=a.addEvent,E=a.Axis,H=a.Chart,v=a.css,k=a.dateFormat,q=a.defined,w=a.each,t=a.extend,u=a.noop,z=a.pick,m=a.timeUnits,g=a.wrap;g(a.Series.prototype,"init",function(a){var e;a.apply(this,Array.prototype.slice.call(arguments,1));(e=this.xAxis)&&e.options.ordinal&&G(this,"updatedData",function(){delete e.ordinalIndex})});g(E.prototype,"getTimeTicks",function(a,e,c,b,g,l,t,u){var f=0,r,n,v={},C,A,d,p=[],D=-Number.MAX_VALUE,h=this.options.tickPixelInterval;
if(!this.options.ordinal&&!this.options.breaks||!l||3>l.length||void 0===c)return a.call(this,e,c,b,g);A=l.length;for(r=0;r<A;r++){d=r&&l[r-1]>b;l[r]<c&&(f=r);if(r===A-1||l[r+1]-l[r]>5*t||d){if(l[r]>D){for(n=a.call(this,e,l[f],l[r],g);n.length&&n[0]<=D;)n.shift();n.length&&(D=n[n.length-1]);p=p.concat(n)}f=r+1}if(d)break}a=n.info;if(u&&a.unitRange<=m.hour){r=p.length-1;for(f=1;f<r;f++)k("%d",p[f])!==k("%d",p[f-1])&&(v[p[f]]="day",C=!0);C&&(v[p[0]]="day");a.higherRanks=v}p.info=a;if(u&&q(h)){u=a=p.length;
r=[];var y;for(C=[];u--;)f=this.translate(p[u]),y&&(C[u]=y-f),r[u]=y=f;C.sort();C=C[Math.floor(C.length/2)];C<.6*h&&(C=null);u=p[a-1]>b?a-1:a;for(y=void 0;u--;)f=r[u],b=Math.abs(y-f),y&&b<.8*h&&(null===C||b<.8*C)?(v[p[u]]&&!v[p[u+1]]?(b=u+1,y=f):b=u,p.splice(b,1)):y=f}return p});t(E.prototype,{beforeSetTickPositions:function(){var a,e=[],c=!1,b,g=this.getExtremes(),l=g.min,k=g.max,m,t=this.isXAxis&&!!this.options.breaks,g=this.options.ordinal,u=Number.MAX_VALUE,n=this.chart.options.chart.ignoreHiddenSeries;
b="highcharts-navigator-xaxis"===this.options.className;!this.options.overscroll||this.max!==this.dataMax||this.chart.mouseIsDown&&!b||this.eventArgs&&(!this.eventArgs||"navigator"===this.eventArgs.trigger)||(this.max+=this.options.overscroll,!b&&q(this.userMin)&&(this.min+=this.options.overscroll));if(g||t){w(this.series,function(b,c){if(!(n&&!1===b.visible||!1===b.takeOrdinalPosition&&!t)&&(e=e.concat(b.processedXData),a=e.length,e.sort(function(a,b){return a-b}),u=Math.min(u,z(b.closestPointRange,
u)),a))for(c=a-1;c--;)e[c]===e[c+1]&&e.splice(c,1)});a=e.length;if(2<a){b=e[1]-e[0];for(m=a-1;m--&&!c;)e[m+1]-e[m]!==b&&(c=!0);!this.options.keepOrdinalPadding&&(e[0]-l>b||k-e[e.length-1]>b)&&(c=!0)}else this.options.overscroll&&(2===a?u=e[1]-e[0]:1===a?(u=this.options.overscroll,e=[e[0],e[0]+u]):u=this.overscrollPointsRange);c?(this.options.overscroll&&(this.overscrollPointsRange=u,e=e.concat(this.getOverscrollPositions())),this.ordinalPositions=e,b=this.ordinal2lin(Math.max(l,e[0]),!0),m=Math.max(this.ordinal2lin(Math.min(k,
e[e.length-1]),!0),1),this.ordinalSlope=k=(k-l)/(m-b),this.ordinalOffset=l-b*k):(this.overscrollPointsRange=z(this.closestPointRange,this.overscrollPointsRange),this.ordinalPositions=this.ordinalSlope=this.ordinalOffset=void 0)}this.isOrdinal=g&&c;this.groupIntervalFactor=null},val2lin:function(a,e){var c=this.ordinalPositions;if(c){var b=c.length,f,g;for(f=b;f--;)if(c[f]===a){g=f;break}for(f=b-1;f--;)if(a>c[f]||0===f){a=(a-c[f])/(c[f+1]-c[f]);g=f+a;break}e=e?g:this.ordinalSlope*(g||0)+this.ordinalOffset}else e=
a;return e},lin2val:function(a,e){var c=this.ordinalPositions;if(c){var b=this.ordinalSlope,f=this.ordinalOffset,g=c.length-1,k;if(e)0>a?a=c[0]:a>g?a=c[g]:(g=Math.floor(a),k=a-g);else for(;g--;)if(e=b*g+f,a>=e){b=b*(g+1)+f;k=(a-e)/(b-e);break}return void 0!==k&&void 0!==c[g]?c[g]+(k?k*(c[g+1]-c[g]):0):a}return a},getExtendedPositions:function(){var a=this,e=a.chart,c=a.series[0].currentDataGrouping,b=a.ordinalIndex,g=c?c.count+c.unitName:"raw",l=a.options.overscroll,k=a.getExtremes(),m,q;b||(b=a.ordinalIndex=
{});b[g]||(m={series:[],chart:e,getExtremes:function(){return{min:k.dataMin,max:k.dataMax+l}},options:{ordinal:!0},val2lin:E.prototype.val2lin,ordinal2lin:E.prototype.ordinal2lin},w(a.series,function(b){q={xAxis:m,xData:b.xData.slice(),chart:e,destroyGroupedData:u};q.xData=q.xData.concat(a.getOverscrollPositions());q.options={dataGrouping:c?{enabled:!0,forced:!0,approximation:"open",units:[[c.unitName,[c.count]]]}:{enabled:!1}};b.processData.apply(q);m.series.push(q)}),a.beforeSetTickPositions.apply(m),
b[g]=m.ordinalPositions);return b[g]},getOverscrollPositions:function(){var f=this.options.overscroll,e=this.overscrollPointsRange,c=[],b=this.dataMax;if(a.defined(e))for(c.push(b);b<=this.dataMax+f;)b+=e,c.push(b);return c},getGroupIntervalFactor:function(a,e,c){var b;c=c.processedXData;var f=c.length,g=[];b=this.groupIntervalFactor;if(!b){for(b=0;b<f-1;b++)g[b]=c[b+1]-c[b];g.sort(function(a,b){return a-b});g=g[Math.floor(f/2)];a=Math.max(a,c[0]);e=Math.min(e,c[f-1]);this.groupIntervalFactor=b=f*
g/(e-a)}return b},postProcessTickInterval:function(a){var e=this.ordinalSlope;return e?this.options.breaks?this.closestPointRange||a:a/(e/this.closestPointRange):a}});E.prototype.ordinal2lin=E.prototype.val2lin;g(H.prototype,"pan",function(a,e){var c=this.xAxis[0],b=c.options.overscroll,f=e.chartX,g=!1;if(c.options.ordinal&&c.series.length){var k=this.mouseDownX,m=c.getExtremes(),q=m.dataMax,t=m.min,n=m.max,u=this.hoverPoints,z=c.closestPointRange||c.overscrollPointsRange,k=(k-f)/(c.translationSlope*
(c.ordinalSlope||z)),A={ordinalPositions:c.getExtendedPositions()},z=c.lin2val,d=c.val2lin,p;A.ordinalPositions?1<Math.abs(k)&&(u&&w(u,function(a){a.setState()}),0>k?(u=A,p=c.ordinalPositions?c:A):(u=c.ordinalPositions?c:A,p=A),A=p.ordinalPositions,q>A[A.length-1]&&A.push(q),this.fixedRange=n-t,k=c.toFixedRange(null,null,z.apply(u,[d.apply(u,[t,!0])+k,!0]),z.apply(p,[d.apply(p,[n,!0])+k,!0])),k.min>=Math.min(m.dataMin,t)&&k.max<=Math.max(q,n)+b&&c.setExtremes(k.min,k.max,!0,!1,{trigger:"pan"}),this.mouseDownX=
f,v(this.container,{cursor:"move"})):g=!0}else g=!0;g&&(b&&(c.max=c.dataMax+b),a.apply(this,Array.prototype.slice.call(arguments,1)))})})(L);(function(a){function G(){return Array.prototype.slice.call(arguments,1)}function E(a){a.apply(this);this.drawBreaks(this.xAxis,["x"]);this.drawBreaks(this.yAxis,H(this.pointArrayMap,["y"]))}var H=a.pick,v=a.wrap,k=a.each,q=a.extend,w=a.isArray,t=a.fireEvent,u=a.Axis,z=a.Series;q(u.prototype,{isInBreak:function(a,g){var f=a.repeat||Infinity,e=a.from,c=a.to-a.from;
g=g>=e?(g-e)%f:f-(e-g)%f;return a.inclusive?g<=c:g<c&&0!==g},isInAnyBreak:function(a,g){var f=this.options.breaks,e=f&&f.length,c,b,k;if(e){for(;e--;)this.isInBreak(f[e],a)&&(c=!0,b||(b=H(f[e].showPoints,this.isXAxis?!1:!0)));k=c&&g?c&&!b:c}return k}});v(u.prototype,"setTickPositions",function(a){a.apply(this,Array.prototype.slice.call(arguments,1));if(this.options.breaks){var g=this.tickPositions,f=this.tickPositions.info,e=[],c;for(c=0;c<g.length;c++)this.isInAnyBreak(g[c])||e.push(g[c]);this.tickPositions=
e;this.tickPositions.info=f}});v(u.prototype,"init",function(a,g,f){var e=this;f.breaks&&f.breaks.length&&(f.ordinal=!1);a.call(this,g,f);a=this.options.breaks;e.isBroken=w(a)&&!!a.length;e.isBroken&&(e.val2lin=function(a){var b=a,c,f;for(f=0;f<e.breakArray.length;f++)if(c=e.breakArray[f],c.to<=a)b-=c.len;else if(c.from>=a)break;else if(e.isInBreak(c,a)){b-=a-c.from;break}return b},e.lin2val=function(a){var b,c;for(c=0;c<e.breakArray.length&&!(b=e.breakArray[c],b.from>=a);c++)b.to<a?a+=b.len:e.isInBreak(b,
a)&&(a+=b.len);return a},e.setExtremes=function(a,b,e,f,g){for(;this.isInAnyBreak(a);)a-=this.closestPointRange;for(;this.isInAnyBreak(b);)b-=this.closestPointRange;u.prototype.setExtremes.call(this,a,b,e,f,g)},e.setAxisTranslation=function(a){u.prototype.setAxisTranslation.call(this,a);a=e.options.breaks;var b=[],c=[],f=0,g,m,q=e.userMin||e.min,v=e.userMax||e.max,n=H(e.pointRangePadding,0),B,w;k(a,function(a){m=a.repeat||Infinity;e.isInBreak(a,q)&&(q+=a.to%m-q%m);e.isInBreak(a,v)&&(v-=v%m-a.from%
m)});k(a,function(a){B=a.from;for(m=a.repeat||Infinity;B-m>q;)B-=m;for(;B<q;)B+=m;for(w=B;w<v;w+=m)b.push({value:w,move:"in"}),b.push({value:w+(a.to-a.from),move:"out",size:a.breakSize})});b.sort(function(a,b){return a.value===b.value?("in"===a.move?0:1)-("in"===b.move?0:1):a.value-b.value});g=0;B=q;k(b,function(a){g+="in"===a.move?1:-1;1===g&&"in"===a.move&&(B=a.value);0===g&&(c.push({from:B,to:a.value,len:a.value-B-(a.size||0)}),f+=a.value-B-(a.size||0))});e.breakArray=c;e.unitLength=v-q-f+n;t(e,
"afterBreaks");e.options.staticScale?e.transA=e.options.staticScale:e.unitLength&&(e.transA*=(v-e.min+n)/e.unitLength);n&&(e.minPixelPadding=e.transA*e.minPointOffset);e.min=q;e.max=v})});v(z.prototype,"generatePoints",function(a){a.apply(this,G(arguments));var g=this.xAxis,f=this.yAxis,e=this.points,c,b=e.length,k=this.options.connectNulls,l;if(g&&f&&(g.options.breaks||f.options.breaks))for(;b--;)c=e[b],l=null===c.y&&!1===k,l||!g.isInAnyBreak(c.x,!0)&&!f.isInAnyBreak(c.y,!0)||(e.splice(b,1),this.data[b]&&
this.data[b].destroyElements())});a.Series.prototype.drawBreaks=function(a,g){var f=this,e=f.points,c,b,m,l;a&&k(g,function(g){c=a.breakArray||[];b=a.isXAxis?a.min:H(f.options.threshold,a.min);k(e,function(e){l=H(e["stack"+g.toUpperCase()],e[g]);k(c,function(c){m=!1;if(b<c.from&&l>c.to||b>c.from&&l<c.from)m="pointBreak";else if(b<c.from&&l>c.from&&l<c.to||b>c.from&&l>c.to&&l<c.from)m="pointInBreak";m&&t(a,m,{point:e,brk:c})})})})};a.Series.prototype.gappedPath=function(){var k=this.options.gapSize,
g=this.points.slice(),f=g.length-1,e=this.yAxis,c;if(k&&0<f)for("value"!==this.options.gapUnit&&(k*=this.closestPointRange);f--;)g[f+1].x-g[f].x>k&&(c=(g[f].x+g[f+1].x)/2,g.splice(f+1,0,{isNull:!0,x:c}),this.options.stacking&&(c=e.stacks[this.stackKey][c]=new a.StackItem(e,e.options.stackLabels,!1,c,this.stack),c.total=0));return this.getGraphPath(g)};v(a.seriesTypes.column.prototype,"drawPoints",E);v(a.Series.prototype,"drawPoints",E)})(L);(function(a){var G=a.arrayMax,E=a.arrayMin,H=a.Axis,v=a.defaultPlotOptions,
k=a.defined,q=a.each,w=a.extend,t=a.format,u=a.isNumber,z=a.merge,m=a.pick,g=a.Point,f=a.Tooltip,e=a.wrap,c=a.Series.prototype,b=c.processData,r=c.generatePoints,l={approximation:"average",groupPixelWidth:2,dateTimeLabelFormats:{millisecond:["%A, %b %e, %H:%M:%S.%L","%A, %b %e, %H:%M:%S.%L","-%H:%M:%S.%L"],second:["%A, %b %e, %H:%M:%S","%A, %b %e, %H:%M:%S","-%H:%M:%S"],minute:["%A, %b %e, %H:%M","%A, %b %e, %H:%M","-%H:%M"],hour:["%A, %b %e, %H:%M","%A, %b %e, %H:%M","-%H:%M"],day:["%A, %b %e, %Y",
"%A, %b %e","-%A, %b %e, %Y"],week:["Week from %A, %b %e, %Y","%A, %b %e","-%A, %b %e, %Y"],month:["%B %Y","%B","-%B %Y"],year:["%Y","%Y","-%Y"]}},C={line:{},spline:{},area:{},areaspline:{},column:{approximation:"sum",groupPixelWidth:10},arearange:{approximation:"range"},areasplinerange:{approximation:"range"},columnrange:{approximation:"range",groupPixelWidth:10},candlestick:{approximation:"ohlc",groupPixelWidth:10},ohlc:{approximation:"ohlc",groupPixelWidth:5}},I=a.defaultDataGroupingUnits=[["millisecond",
[1,2,5,10,20,25,50,100,200,500]],["second",[1,2,5,10,15,30]],["minute",[1,2,5,10,15,30]],["hour",[1,2,3,4,6,8,12]],["day",[1]],["week",[1]],["month",[1,3,6]],["year",null]],x=a.approximations={sum:function(a){var b=a.length,c;if(!b&&a.hasNulls)c=null;else if(b)for(c=0;b--;)c+=a[b];return c},average:function(a){var b=a.length;a=x.sum(a);u(a)&&b&&(a/=b);return a},averages:function(){var a=[];q(arguments,function(b){a.push(x.average(b))});return void 0===a[0]?void 0:a},open:function(a){return a.length?
a[0]:a.hasNulls?null:void 0},high:function(a){return a.length?G(a):a.hasNulls?null:void 0},low:function(a){return a.length?E(a):a.hasNulls?null:void 0},close:function(a){return a.length?a[a.length-1]:a.hasNulls?null:void 0},ohlc:function(a,b,c,e){a=x.open(a);b=x.high(b);c=x.low(c);e=x.close(e);if(u(a)||u(b)||u(c)||u(e))return[a,b,c,e]},range:function(a,b){a=x.low(a);b=x.high(b);if(u(a)||u(b))return[a,b];if(null===a&&null===b)return null}};c.groupData=function(a,b,c,e){var f=this.data,d=this.options.data,
g=[],n=[],h=[],k=a.length,m,r,t=!!b,v=[];e="function"===typeof e?e:x[e]||C[this.type]&&x[C[this.type].approximation]||x[l.approximation];var B=this.pointArrayMap,w=B&&B.length,z=0;r=0;var F,J;w?q(B,function(){v.push([])}):v.push([]);F=w||1;for(J=0;J<=k&&!(a[J]>=c[0]);J++);for(J;J<=k;J++){for(;void 0!==c[z+1]&&a[J]>=c[z+1]||J===k;){m=c[z];this.dataGroupInfo={start:r,length:v[0].length};r=e.apply(this,v);void 0!==r&&(g.push(m),n.push(r),h.push(this.dataGroupInfo));r=J;for(m=0;m<F;m++)v[m].length=0,
v[m].hasNulls=!1;z+=1;if(J===k)break}if(J===k)break;if(B){m=this.cropStart+J;var E=f&&f[m]||this.pointClass.prototype.applyOptions.apply({series:this},[d[m]]),I;for(m=0;m<w;m++)I=E[B[m]],u(I)?v[m].push(I):null===I&&(v[m].hasNulls=!0)}else m=t?b[J]:null,u(m)?v[0].push(m):null===m&&(v[0].hasNulls=!0)}return[g,n,h]};c.processData=function(){var a=this.chart,e=this.options.dataGrouping,f=!1!==this.allowDG&&e&&m(e.enabled,a.options.isStock),g=this.visible||!a.options.chart.ignoreHiddenSeries,l,d=this.currentDataGrouping,
p;this.forceCrop=f;this.groupPixelWidth=null;this.hasProcessed=!0;if(!1!==b.apply(this,arguments)&&f){this.destroyGroupedData();var q=this.processedXData,h=this.processedYData,r=a.plotSizeX,a=this.xAxis,t=a.options.ordinal,u=this.groupPixelWidth=a.getGroupPixelWidth&&a.getGroupPixelWidth();if(u){this.isDirty=l=!0;this.points=null;f=a.getExtremes();p=f.min;f=f.max;t=t&&a.getGroupIntervalFactor(p,f,this)||1;u=u*(f-p)/r*t;r=a.getTimeTicks(a.normalizeTimeTickInterval(u,e.units||I),Math.min(p,q[0]),Math.max(f,
q[q.length-1]),a.options.startOfWeek,q,this.closestPointRange);q=c.groupData.apply(this,[q,h,r,e.approximation]);h=q[0];t=q[1];if(e.smoothed&&h.length){e=h.length-1;for(h[e]=Math.min(h[e],f);e--&&0<e;)h[e]+=u/2;h[0]=Math.max(h[0],p)}p=r.info;this.closestPointRange=r.info.totalRange;this.groupMap=q[2];k(h[0])&&h[0]<a.dataMin&&g&&(a.min===a.dataMin&&(a.min=h[0]),a.dataMin=h[0]);this.processedXData=h;this.processedYData=t}else this.groupMap=null;this.hasGroupedData=l;this.currentDataGrouping=p;this.preventGraphAnimation=
(d&&d.totalRange)!==(p&&p.totalRange)}};c.destroyGroupedData=function(){var a=this.groupedData;q(a||[],function(b,c){b&&(a[c]=b.destroy?b.destroy():null)});this.groupedData=null};c.generatePoints=function(){r.apply(this);this.destroyGroupedData();this.groupedData=this.hasGroupedData?this.points:null};e(g.prototype,"update",function(b){this.dataGroup?a.error(24):b.apply(this,[].slice.call(arguments,1))});e(f.prototype,"tooltipFooterHeaderFormatter",function(b,c,e){var f=c.series,g=f.tooltipOptions,
d=f.options.dataGrouping,p=g.xDateFormat,l,h=f.xAxis,n=a.dateFormat;return h&&"datetime"===h.options.type&&d&&u(c.key)?(b=f.currentDataGrouping,d=d.dateTimeLabelFormats,b?(h=d[b.unitName],1===b.count?p=h[0]:(p=h[1],l=h[2])):!p&&d&&(p=this.getXDateFormat(c,g,h)),p=n(p,c.key),l&&(p+=n(l,c.key+b.totalRange-1)),t(g[(e?"footer":"header")+"Format"],{point:w(c.point,{key:p}),series:f})):b.call(this,c,e)});e(c,"destroy",function(a){a.call(this);this.destroyGroupedData()});e(c,"setOptions",function(a,b){a=
a.call(this,b);var c=this.type,e=this.chart.options.plotOptions,f=v[c].dataGrouping;C[c]&&(f||(f=z(l,C[c])),a.dataGrouping=z(f,e.series&&e.series.dataGrouping,e[c].dataGrouping,b.dataGrouping));this.chart.options.isStock&&(this.requireSorting=!0);return a});e(H.prototype,"setScale",function(a){a.call(this);q(this.series,function(a){a.hasProcessed=!1})});H.prototype.getGroupPixelWidth=function(){var a=this.series,b=a.length,c,e=0,f=!1,d;for(c=b;c--;)(d=a[c].options.dataGrouping)&&(e=Math.max(e,d.groupPixelWidth));
for(c=b;c--;)(d=a[c].options.dataGrouping)&&a[c].hasProcessed&&(b=(a[c].processedXData||a[c].data).length,a[c].groupPixelWidth||b>this.chart.plotSizeX/e||b&&d.forced)&&(f=!0);return f?e:0};H.prototype.setDataGrouping=function(a,b){var c;b=m(b,!0);a||(a={forced:!1,units:null});if(this instanceof H)for(c=this.series.length;c--;)this.series[c].update({dataGrouping:a},!1);else q(this.chart.options.series,function(b){b.dataGrouping=a},!1);b&&this.chart.redraw()}})(L);(function(a){var G=a.each,E=a.Point,
H=a.seriesType,v=a.seriesTypes;H("ohlc","column",{lineWidth:1,tooltip:{pointFormat:'\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e \x3cb\x3e {series.name}\x3c/b\x3e\x3cbr/\x3eOpen: {point.open}\x3cbr/\x3eHigh: {point.high}\x3cbr/\x3eLow: {point.low}\x3cbr/\x3eClose: {point.close}\x3cbr/\x3e'},threshold:null,states:{hover:{lineWidth:3}},stickyTracking:!0},{directTouch:!1,pointArrayMap:["open","high","low","close"],toYData:function(a){return[a.open,a.high,a.low,a.close]},pointValKey:"close",
pointAttrToOptions:{stroke:"color","stroke-width":"lineWidth"},pointAttribs:function(a,q){q=v.column.prototype.pointAttribs.call(this,a,q);var k=this.options;delete q.fill;!a.options.color&&k.upColor&&a.open<a.close&&(q.stroke=k.upColor);return q},translate:function(){var a=this,q=a.yAxis,w=!!a.modifyValue,t=["plotOpen","plotHigh","plotLow","plotClose","yBottom"];v.column.prototype.translate.apply(a);G(a.points,function(k){G([k.open,k.high,k.low,k.close,k.low],function(u,m){null!==u&&(w&&(u=a.modifyValue(u)),
k[t[m]]=q.toPixels(u,!0))});k.tooltipPos[1]=k.plotHigh+q.pos-a.chart.plotTop})},drawPoints:function(){var a=this,q=a.chart;G(a.points,function(k){var t,u,v,m,g=k.graphic,f,e=!g;void 0!==k.plotY&&(g||(k.graphic=g=q.renderer.path().add(a.group)),g.attr(a.pointAttribs(k,k.selected&&"select")),u=g.strokeWidth()%2/2,f=Math.round(k.plotX)-u,v=Math.round(k.shapeArgs.width/2),m=["M",f,Math.round(k.yBottom),"L",f,Math.round(k.plotHigh)],null!==k.open&&(t=Math.round(k.plotOpen)+u,m.push("M",f,t,"L",f-v,t)),
null!==k.close&&(t=Math.round(k.plotClose)+u,m.push("M",f,t,"L",f+v,t)),g[e?"attr":"animate"]({d:m}).addClass(k.getClassName(),!0))})},animate:null},{getClassName:function(){return E.prototype.getClassName.call(this)+(this.open<this.close?" highcharts-point-up":" highcharts-point-down")}})})(L);(function(a){var G=a.defaultPlotOptions,E=a.each,H=a.merge,v=a.seriesType,k=a.seriesTypes;v("candlestick","ohlc",H(G.column,{states:{hover:{lineWidth:2}},tooltip:G.ohlc.tooltip,threshold:null,lineColor:"#000000",
lineWidth:1,upColor:"#ffffff",stickyTracking:!0}),{pointAttribs:function(a,v){var q=k.column.prototype.pointAttribs.call(this,a,v),u=this.options,w=a.open<a.close,m=u.lineColor||this.color;q["stroke-width"]=u.lineWidth;q.fill=a.options.color||(w?u.upColor||this.color:this.color);q.stroke=a.lineColor||(w?u.upLineColor||m:m);v&&(a=u.states[v],q.fill=a.color||q.fill,q.stroke=a.lineColor||q.stroke,q["stroke-width"]=a.lineWidth||q["stroke-width"]);return q},drawPoints:function(){var a=this,k=a.chart;E(a.points,
function(q){var t=q.graphic,v,m,g,f,e,c,b,r=!t;void 0!==q.plotY&&(t||(q.graphic=t=k.renderer.path().add(a.group)),t.attr(a.pointAttribs(q,q.selected&&"select")).shadow(a.options.shadow),e=t.strokeWidth()%2/2,c=Math.round(q.plotX)-e,v=q.plotOpen,m=q.plotClose,g=Math.min(v,m),v=Math.max(v,m),b=Math.round(q.shapeArgs.width/2),m=Math.round(g)!==Math.round(q.plotHigh),f=v!==q.yBottom,g=Math.round(g)+e,v=Math.round(v)+e,e=[],e.push("M",c-b,v,"L",c-b,g,"L",c+b,g,"L",c+b,v,"Z","M",c,g,"L",c,m?Math.round(q.plotHigh):
g,"M",c,v,"L",c,f?Math.round(q.yBottom):v),t[r?"attr":"animate"]({d:e}).addClass(q.getClassName(),!0))})}})})(L);Z=function(a){var G=a.each,E=a.seriesTypes,H=a.stableSort;return{translate:function(){E.column.prototype.translate.apply(this);var a=this.options,k=this.chart,q=this.points,w=q.length-1,t,u,z=a.onSeries;t=z&&k.get(z);var a=a.onKey||"y",z=t&&t.options.step,m=t&&t.points,g=m&&m.length,f=this.xAxis,e=this.yAxis,c=f.getExtremes(),b=0,r,l,C,I;if(t&&t.visible&&g)for(b=(t.pointXOffset||0)+(t.barW||
0)/2,t=t.currentDataGrouping,l=m[g-1].x+(t?t.totalRange:0),H(q,function(a,b){return a.x-b.x}),a="plot"+a[0].toUpperCase()+a.substr(1);g--&&q[w]&&!(r=m[g],t=q[w],t.y=r.y,r.x<=t.x&&void 0!==r[a]&&(t.x<=l&&(t.plotY=r[a],r.x<t.x&&!z&&(C=m[g+1])&&void 0!==C[a]&&(I=(t.x-r.x)/(C.x-r.x),t.plotY+=I*(C[a]-r[a]),t.y+=I*(C.y-r.y))),w--,g++,0>w)););G(q,function(a,g){var l;void 0===a.plotY&&(a.x>=c.min&&a.x<=c.max?a.plotY=k.chartHeight-f.bottom-(f.opposite?f.height:0)+f.offset-e.top:a.shapeArgs={});a.plotX+=b;
(u=q[g-1])&&u.plotX===a.plotX&&(void 0===u.stackIndex&&(u.stackIndex=0),l=u.stackIndex+1);a.stackIndex=l})}}}(L);(function(a,G){function E(a){m[a+"pin"]=function(f,e,c,b,g){var l=g&&g.anchorX;g=g&&g.anchorY;"circle"===a&&b>c&&(f-=Math.round((b-c)/2),c=b);f=m[a](f,e,c,b);l&&g&&(f.push("M","circle"===a?f[1]-f[4]:f[1]+f[4]/2,e>g?e:e+b,"L",l,g),f=f.concat(m.circle(l-1,g-1,2,2)));return f}}var H=a.addEvent,v=a.each,k=a.merge,q=a.noop,w=a.Renderer,t=a.seriesType,u=a.TrackerMixin,z=a.VMLRenderer,m=a.SVGRenderer.prototype.symbols;
t("flags","column",{pointRange:0,allowOverlapX:!1,shape:"flag",stackDistance:12,textAlign:"center",tooltip:{pointFormat:"{point.text}\x3cbr/\x3e"},threshold:null,y:-30,fillColor:"#ffffff",lineWidth:1,states:{hover:{lineColor:"#000000",fillColor:"#ccd6eb"}},style:{fontSize:"11px",fontWeight:"bold"}},{sorted:!1,noSharedTooltip:!0,allowDG:!1,takeOrdinalPosition:!1,trackerGroups:["markerGroup"],forceCrop:!0,init:a.Series.prototype.init,pointAttribs:function(a,f){var e=this.options,c=a&&a.color||this.color,
b=e.lineColor,g=a&&a.lineWidth;a=a&&a.fillColor||e.fillColor;f&&(a=e.states[f].fillColor,b=e.states[f].lineColor,g=e.states[f].lineWidth);return{fill:a||c,stroke:b||c,"stroke-width":g||e.lineWidth||0}},translate:G.translate,drawPoints:function(){var g=this.points,f=this.chart,e=f.renderer,c,b,m=this.options,l=m.y,q,t,u,w,n,B,z=this.yAxis,A={},d=[];for(t=g.length;t--;)u=g[t],B=u.plotX>this.xAxis.len,c=u.plotX,w=u.stackIndex,q=u.options.shape||m.shape,b=u.plotY,void 0!==b&&(b=u.plotY+l-(void 0!==w&&
w*m.stackDistance)),u.anchorX=w?void 0:u.plotX,n=w?void 0:u.plotY,w=u.graphic,void 0!==b&&0<=c&&!B?(w||(w=u.graphic=e.label("",null,null,q,null,null,m.useHTML).attr(this.pointAttribs(u)).css(k(m.style,u.style)).attr({align:"flag"===q?"left":"center",width:m.width,height:m.height,"text-align":m.textAlign}).addClass("highcharts-point").add(this.markerGroup),u.graphic.div&&(u.graphic.div.point=u),w.shadow(m.shadow),w.isNew=!0),0<c&&(c-=w.strokeWidth()%2),q={y:b,anchorY:n},m.allowOverlapX&&(q.x=c,q.anchorX=
u.anchorX),w.attr({text:u.options.title||m.title||"A"})[w.isNew?"attr":"animate"](q),m.allowOverlapX||(A[u.plotX]?A[u.plotX].size=Math.max(A[u.plotX].size,w.width):A[u.plotX]={align:0,size:w.width,target:c,anchorX:c}),u.tooltipPos=f.inverted?[z.len+z.pos-f.plotLeft-b,this.xAxis.len-c]:[c,b+z.pos-f.plotTop]):w&&(u.graphic=w.destroy());m.allowOverlapX||(a.objectEach(A,function(a){a.plotX=a.anchorX;d.push(a)}),a.distribute(d,this.xAxis.len),v(g,function(a){var b=a.graphic&&A[a.plotX];b&&(a.graphic[a.graphic.isNew?
"attr":"animate"]({x:b.pos,anchorX:a.anchorX}),a.graphic.isNew=!1)}));m.useHTML&&a.wrap(this.markerGroup,"on",function(b){return a.SVGElement.prototype.on.apply(b.apply(this,[].slice.call(arguments,1)),[].slice.call(arguments,1))})},drawTracker:function(){var a=this.points;u.drawTrackerPoint.apply(this);v(a,function(f){var e=f.graphic;e&&H(e.element,"mouseover",function(){0<f.stackIndex&&!f.raised&&(f._y=e.y,e.attr({y:f._y-8}),f.raised=!0);v(a,function(a){a!==f&&a.raised&&a.graphic&&(a.graphic.attr({y:a._y}),
a.raised=!1)})})})},animate:q,buildKDTree:q,setClip:q});m.flag=function(a,f,e,c,b){var g=b&&b.anchorX||a;b=b&&b.anchorY||f;return m.circle(g-1,b-1,2,2).concat(["M",g,b,"L",a,f+c,a,f,a+e,f,a+e,f+c,a,f+c,"Z"])};E("circle");E("square");w===z&&v(["flag","circlepin","squarepin"],function(a){z.prototype.symbols[a]=m[a]})})(L,Z);(function(a){function G(a,b,c){this.init(a,b,c)}var E=a.addEvent,H=a.Axis,v=a.correctFloat,k=a.defaultOptions,q=a.defined,w=a.destroyObjectProperties,t=a.each,u=a.fireEvent,z=a.hasTouch,
m=a.isTouchDevice,g=a.merge,f=a.pick,e=a.removeEvent,c=a.wrap,b,r={height:m?20:14,barBorderRadius:0,buttonBorderRadius:0,liveRedraw:a.svg&&!m,margin:10,minWidth:6,step:.2,zIndex:3,barBackgroundColor:"#cccccc",barBorderWidth:1,barBorderColor:"#cccccc",buttonArrowColor:"#333333",buttonBackgroundColor:"#e6e6e6",buttonBorderColor:"#cccccc",buttonBorderWidth:1,rifleColor:"#333333",trackBackgroundColor:"#f2f2f2",trackBorderColor:"#f2f2f2",trackBorderWidth:1};k.scrollbar=g(!0,r,k.scrollbar);a.swapXY=b=function(a,
b){var c=a.length,e;if(b)for(b=0;b<c;b+=3)e=a[b+1],a[b+1]=a[b+2],a[b+2]=e;return a};G.prototype={init:function(a,b,c){this.scrollbarButtons=[];this.renderer=a;this.userOptions=b;this.options=g(r,b);this.chart=c;this.size=f(this.options.size,this.options.height);b.enabled&&(this.render(),this.initEvents(),this.addEvents())},render:function(){var a=this.renderer,c=this.options,e=this.size,f;this.group=f=a.g("scrollbar").attr({zIndex:c.zIndex,translateY:-99999}).add();this.track=a.rect().addClass("highcharts-scrollbar-track").attr({x:0,
r:c.trackBorderRadius||0,height:e,width:e}).add(f);this.track.attr({fill:c.trackBackgroundColor,stroke:c.trackBorderColor,"stroke-width":c.trackBorderWidth});this.trackBorderWidth=this.track.strokeWidth();this.track.attr({y:-this.trackBorderWidth%2/2});this.scrollbarGroup=a.g().add(f);this.scrollbar=a.rect().addClass("highcharts-scrollbar-thumb").attr({height:e,width:e,r:c.barBorderRadius||0}).add(this.scrollbarGroup);this.scrollbarRifles=a.path(b(["M",-3,e/4,"L",-3,2*e/3,"M",0,e/4,"L",0,2*e/3,"M",
3,e/4,"L",3,2*e/3],c.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup);this.scrollbar.attr({fill:c.barBackgroundColor,stroke:c.barBorderColor,"stroke-width":c.barBorderWidth});this.scrollbarRifles.attr({stroke:c.rifleColor,"stroke-width":1});this.scrollbarStrokeWidth=this.scrollbar.strokeWidth();this.scrollbarGroup.translate(-this.scrollbarStrokeWidth%2/2,-this.scrollbarStrokeWidth%2/2);this.drawScrollbarButton(0);this.drawScrollbarButton(1)},position:function(a,b,c,e){var f=
this.options.vertical,g=0,l=this.rendered?"animate":"attr";this.x=a;this.y=b+this.trackBorderWidth;this.width=c;this.xOffset=this.height=e;this.yOffset=g;f?(this.width=this.yOffset=c=g=this.size,this.xOffset=b=0,this.barWidth=e-2*c,this.x=a+=this.options.margin):(this.height=this.xOffset=e=b=this.size,this.barWidth=c-2*e,this.y+=this.options.margin);this.group[l]({translateX:a,translateY:this.y});this.track[l]({width:c,height:e});this.scrollbarButtons[1][l]({translateX:f?0:c-b,translateY:f?e-g:0})},
drawScrollbarButton:function(a){var c=this.renderer,e=this.scrollbarButtons,f=this.options,g=this.size,l;l=c.g().add(this.group);e.push(l);l=c.rect().addClass("highcharts-scrollbar-button").add(l);l.attr({stroke:f.buttonBorderColor,"stroke-width":f.buttonBorderWidth,fill:f.buttonBackgroundColor});l.attr(l.crisp({x:-.5,y:-.5,width:g+1,height:g+1,r:f.buttonBorderRadius},l.strokeWidth()));l=c.path(b(["M",g/2+(a?-1:1),g/2-3,"L",g/2+(a?-1:1),g/2+3,"L",g/2+(a?2:-2),g/2],f.vertical)).addClass("highcharts-scrollbar-arrow").add(e[a]);
l.attr({fill:f.buttonArrowColor})},setRange:function(a,b){var c=this.options,e=c.vertical,f=c.minWidth,g=this.barWidth,l,k,m=this.rendered&&!this.hasDragged?"animate":"attr";q(g)&&(a=Math.max(a,0),l=Math.ceil(g*a),this.calculatedWidth=k=v(g*Math.min(b,1)-l),k<f&&(l=(g-f+k)*a,k=f),f=Math.floor(l+this.xOffset+this.yOffset),g=k/2-.5,this.from=a,this.to=b,e?(this.scrollbarGroup[m]({translateY:f}),this.scrollbar[m]({height:k}),this.scrollbarRifles[m]({translateY:g}),this.scrollbarTop=f,this.scrollbarLeft=
0):(this.scrollbarGroup[m]({translateX:f}),this.scrollbar[m]({width:k}),this.scrollbarRifles[m]({translateX:g}),this.scrollbarLeft=f,this.scrollbarTop=0),12>=k?this.scrollbarRifles.hide():this.scrollbarRifles.show(!0),!1===c.showFull&&(0>=a&&1<=b?this.group.hide():this.group.show()),this.rendered=!0)},initEvents:function(){var a=this;a.mouseMoveHandler=function(b){var c=a.chart.pointer.normalize(b),e=a.options.vertical?"chartY":"chartX",f=a.initPositions;!a.grabbedCenter||b.touches&&0===b.touches[0][e]||
(c=a.cursorToScrollbarPosition(c)[e],e=a[e],e=c-e,a.hasDragged=!0,a.updatePosition(f[0]+e,f[1]+e),a.hasDragged&&u(a,"changed",{from:a.from,to:a.to,trigger:"scrollbar",DOMType:b.type,DOMEvent:b}))};a.mouseUpHandler=function(b){a.hasDragged&&u(a,"changed",{from:a.from,to:a.to,trigger:"scrollbar",DOMType:b.type,DOMEvent:b});a.grabbedCenter=a.hasDragged=a.chartX=a.chartY=null};a.mouseDownHandler=function(b){b=a.chart.pointer.normalize(b);b=a.cursorToScrollbarPosition(b);a.chartX=b.chartX;a.chartY=b.chartY;
a.initPositions=[a.from,a.to];a.grabbedCenter=!0};a.buttonToMinClick=function(b){var c=v(a.to-a.from)*a.options.step;a.updatePosition(v(a.from-c),v(a.to-c));u(a,"changed",{from:a.from,to:a.to,trigger:"scrollbar",DOMEvent:b})};a.buttonToMaxClick=function(b){var c=(a.to-a.from)*a.options.step;a.updatePosition(a.from+c,a.to+c);u(a,"changed",{from:a.from,to:a.to,trigger:"scrollbar",DOMEvent:b})};a.trackClick=function(b){var c=a.chart.pointer.normalize(b),e=a.to-a.from,f=a.y+a.scrollbarTop,g=a.x+a.scrollbarLeft;
a.options.vertical&&c.chartY>f||!a.options.vertical&&c.chartX>g?a.updatePosition(a.from+e,a.to+e):a.updatePosition(a.from-e,a.to-e);u(a,"changed",{from:a.from,to:a.to,trigger:"scrollbar",DOMEvent:b})}},cursorToScrollbarPosition:function(a){var b=this.options,b=b.minWidth>this.calculatedWidth?b.minWidth:0;return{chartX:(a.chartX-this.x-this.xOffset)/(this.barWidth-b),chartY:(a.chartY-this.y-this.yOffset)/(this.barWidth-b)}},updatePosition:function(a,b){1<b&&(a=v(1-v(b-a)),b=1);0>a&&(b=v(b-a),a=0);
this.from=a;this.to=b},update:function(a){this.destroy();this.init(this.chart.renderer,g(!0,this.options,a),this.chart)},addEvents:function(){var a=this.options.inverted?[1,0]:[0,1],b=this.scrollbarButtons,c=this.scrollbarGroup.element,e=this.mouseDownHandler,f=this.mouseMoveHandler,g=this.mouseUpHandler,a=[[b[a[0]].element,"click",this.buttonToMinClick],[b[a[1]].element,"click",this.buttonToMaxClick],[this.track.element,"click",this.trackClick],[c,"mousedown",e],[c.ownerDocument,"mousemove",f],[c.ownerDocument,
"mouseup",g]];z&&a.push([c,"touchstart",e],[c.ownerDocument,"touchmove",f],[c.ownerDocument,"touchend",g]);t(a,function(a){E.apply(null,a)});this._events=a},removeEvents:function(){t(this._events,function(a){e.apply(null,a)});this._events.length=0},destroy:function(){var a=this.chart.scroller;this.removeEvents();t(["track","scrollbarRifles","scrollbar","scrollbarGroup","group"],function(a){this[a]&&this[a].destroy&&(this[a]=this[a].destroy())},this);a&&this===a.scrollbar&&(a.scrollbar=null,w(a.scrollbarButtons))}};
c(H.prototype,"init",function(a){var b=this;a.apply(b,Array.prototype.slice.call(arguments,1));b.options.scrollbar&&b.options.scrollbar.enabled&&(b.options.scrollbar.vertical=!b.horiz,b.options.startOnTick=b.options.endOnTick=!1,b.scrollbar=new G(b.chart.renderer,b.options.scrollbar,b.chart),E(b.scrollbar,"changed",function(a){var c=Math.min(f(b.options.min,b.min),b.min,b.dataMin),e=Math.max(f(b.options.max,b.max),b.max,b.dataMax)-c,g;b.horiz&&!b.reversed||!b.horiz&&b.reversed?(g=c+e*this.to,c+=e*
this.from):(g=c+e*(1-this.from),c+=e*(1-this.to));b.setExtremes(c,g,!0,!1,a)}))});c(H.prototype,"render",function(a){var b=Math.min(f(this.options.min,this.min),this.min,f(this.dataMin,this.min)),c=Math.max(f(this.options.max,this.max),this.max,f(this.dataMax,this.max)),e=this.scrollbar,g=this.titleOffset||0;a.apply(this,Array.prototype.slice.call(arguments,1));if(e){this.horiz?(e.position(this.left,this.top+this.height+2+this.chart.scrollbarsOffsets[1]+(this.opposite?0:g+this.axisTitleMargin+this.offset),
this.width,this.height),g=1):(e.position(this.left+this.width+2+this.chart.scrollbarsOffsets[0]+(this.opposite?g+this.axisTitleMargin+this.offset:0),this.top,this.width,this.height),g=0);if(!this.opposite&&!this.horiz||this.opposite&&this.horiz)this.chart.scrollbarsOffsets[g]+=this.scrollbar.size+this.scrollbar.options.margin;isNaN(b)||isNaN(c)||!q(this.min)||!q(this.max)?e.setRange(0,0):(g=(this.min-b)/(c-b),b=(this.max-b)/(c-b),this.horiz&&!this.reversed||!this.horiz&&this.reversed?e.setRange(g,
b):e.setRange(1-b,1-g))}});c(H.prototype,"getOffset",function(a){var b=this.horiz?2:1,c=this.scrollbar;a.apply(this,Array.prototype.slice.call(arguments,1));c&&(this.chart.scrollbarsOffsets=[0,0],this.chart.axisOffset[b]+=c.size+c.options.margin)});c(H.prototype,"destroy",function(a){this.scrollbar&&(this.scrollbar=this.scrollbar.destroy());a.apply(this,Array.prototype.slice.call(arguments,1))});a.Scrollbar=G})(L);(function(a){function G(a){this.init(a)}var E=a.addEvent,H=a.Axis,v=a.Chart,k=a.color,
q=a.defaultOptions,w=a.defined,t=a.destroyObjectProperties,u=a.each,z=a.erase,m=a.error,g=a.extend,f=a.grep,e=a.hasTouch,c=a.isArray,b=a.isNumber,r=a.isObject,l=a.merge,C=a.pick,I=a.removeEvent,x=a.Scrollbar,F=a.Series,n=a.seriesTypes,B=a.wrap,J=[].concat(a.defaultDataGroupingUnits),A=function(a){var d=f(arguments,b);if(d.length)return Math[a].apply(0,d)};J[4]=["day",[1,2,3,4]];J[5]=["week",[1,2,3]];n=void 0===n.areaspline?"line":"areaspline";g(q,{navigator:{height:40,margin:25,maskInside:!0,handles:{width:7,
height:15,symbols:["navigator-handle","navigator-handle"],enabled:!0,lineWidth:1,backgroundColor:"#f2f2f2",borderColor:"#999999"},maskFill:k("#6685c2").setOpacity(.3).get(),outlineColor:"#cccccc",outlineWidth:1,series:{type:n,fillOpacity:.05,lineWidth:1,compare:null,dataGrouping:{approximation:"average",enabled:!0,groupPixelWidth:2,smoothed:!0,units:J},dataLabels:{enabled:!1,zIndex:2},id:"highcharts-navigator-series",className:"highcharts-navigator-series",lineColor:null,marker:{enabled:!1},pointRange:0,
threshold:null},xAxis:{overscroll:0,className:"highcharts-navigator-xaxis",tickLength:0,lineWidth:0,gridLineColor:"#e6e6e6",gridLineWidth:1,tickPixelInterval:200,labels:{align:"left",style:{color:"#999999"},x:3,y:-4},crosshair:!1},yAxis:{className:"highcharts-navigator-yaxis",gridLineWidth:0,startOnTick:!1,endOnTick:!1,minPadding:.1,maxPadding:.1,labels:{enabled:!1},crosshair:!1,title:{text:null},tickLength:0,tickWidth:0}}});a.Renderer.prototype.symbols["navigator-handle"]=function(a,b,c,e,f){a=f.width/
2;b=Math.round(a/3)+.5;f=f.height;return["M",-a-1,.5,"L",a,.5,"L",a,f+.5,"L",-a-1,f+.5,"L",-a-1,.5,"M",-b,4,"L",-b,f-3,"M",b-1,4,"L",b-1,f-3]};G.prototype={drawHandle:function(a,b,c,e){var d=this.navigatorOptions.handles.height;this.handles[b][e](c?{translateX:Math.round(this.left+this.height/2),translateY:Math.round(this.top+parseInt(a,10)+.5-d)}:{translateX:Math.round(this.left+parseInt(a,10)),translateY:Math.round(this.top+this.height/2-d/2-1)})},drawOutline:function(a,b,c,e){var d=this.navigatorOptions.maskInside,
h=this.outline.strokeWidth(),f=h/2,h=h%2/2,g=this.outlineHeight,p=this.scrollbarHeight,k=this.size,n=this.left-p,l=this.top;c?(n-=f,c=l+b+h,b=l+a+h,a=["M",n+g,l-p-h,"L",n+g,c,"L",n,c,"L",n,b,"L",n+g,b,"L",n+g,l+k+p].concat(d?["M",n+g,c-f,"L",n+g,b+f]:[])):(a+=n+p-h,b+=n+p-h,l+=f,a=["M",n,l,"L",a,l,"L",a,l+g,"L",b,l+g,"L",b,l,"L",n+k+2*p,l].concat(d?["M",a-f,l,"L",b+f,l]:[]));this.outline[e]({d:a})},drawMasks:function(a,b,c,e){var d=this.left,h=this.top,f=this.height,g,p,n,k;c?(n=[d,d,d],k=[h,h+a,
h+b],p=[f,f,f],g=[a,b-a,this.size-b]):(n=[d,d+a,d+b],k=[h,h,h],p=[a,b-a,this.size-b],g=[f,f,f]);u(this.shades,function(a,b){a[e]({x:n[b],y:k[b],width:p[b],height:g[b]})})},renderElements:function(){var a=this,b=a.navigatorOptions,c=b.maskInside,e=a.chart,f=e.inverted,g=e.renderer,n;a.navigatorGroup=n=g.g("navigator").attr({zIndex:8,visibility:"hidden"}).add();var k={cursor:f?"ns-resize":"ew-resize"};u([!c,c,!c],function(d,c){a.shades[c]=g.rect().addClass("highcharts-navigator-mask"+(1===c?"-inside":
"-outside")).attr({fill:d?b.maskFill:"rgba(0,0,0,0)"}).css(1===c&&k).add(n)});a.outline=g.path().addClass("highcharts-navigator-outline").attr({"stroke-width":b.outlineWidth,stroke:b.outlineColor}).add(n);b.handles.enabled&&u([0,1],function(d){b.handles.inverted=e.inverted;a.handles[d]=g.symbol(b.handles.symbols[d],-b.handles.width/2-1,0,b.handles.width,b.handles.height,b.handles);a.handles[d].attr({zIndex:7-d}).addClass("highcharts-navigator-handle highcharts-navigator-handle-"+["left","right"][d]).add(n);
var c=b.handles;a.handles[d].attr({fill:c.backgroundColor,stroke:c.borderColor,"stroke-width":c.lineWidth}).css(k)})},update:function(a){u(this.series||[],function(a){a.baseSeries&&delete a.baseSeries.navigatorSeries});this.destroy();l(!0,this.chart.options.navigator,this.options,a);this.init(this.chart)},render:function(d,c,e,h){var f=this.chart,g,p,n=this.scrollbarHeight,k,l=this.xAxis;g=l.fake?f.xAxis[0]:l;var m=this.navigatorEnabled,q,r=this.rendered;p=f.inverted;var t,u=f.xAxis[0].minRange,v=
f.xAxis[0].options.maxRange;if(!this.hasDragged||w(e)){if(!b(d)||!b(c))if(r)e=0,h=C(l.width,g.width);else return;this.left=C(l.left,f.plotLeft+n+(p?f.plotWidth:0));this.size=q=k=C(l.len,(p?f.plotHeight:f.plotWidth)-2*n);f=p?n:k+2*n;e=C(e,l.toPixels(d,!0));h=C(h,l.toPixels(c,!0));b(e)&&Infinity!==Math.abs(e)||(e=0,h=f);d=l.toValue(e,!0);c=l.toValue(h,!0);t=Math.abs(a.correctFloat(c-d));t<u?this.grabbedLeft?e=l.toPixels(c-u,!0):this.grabbedRight&&(h=l.toPixels(d+u,!0)):w(v)&&t>v&&(this.grabbedLeft?
e=l.toPixels(c-v,!0):this.grabbedRight&&(h=l.toPixels(d+v,!0)));this.zoomedMax=Math.min(Math.max(e,h,0),q);this.zoomedMin=Math.min(Math.max(this.fixedWidth?this.zoomedMax-this.fixedWidth:Math.min(e,h),0),q);this.range=this.zoomedMax-this.zoomedMin;q=Math.round(this.zoomedMax);e=Math.round(this.zoomedMin);m&&(this.navigatorGroup.attr({visibility:"visible"}),r=r&&!this.hasDragged?"animate":"attr",this.drawMasks(e,q,p,r),this.drawOutline(e,q,p,r),this.navigatorOptions.handles.enabled&&(this.drawHandle(e,
0,p,r),this.drawHandle(q,1,p,r)));this.scrollbar&&(p?(p=this.top-n,g=this.left-n+(m||!g.opposite?0:(g.titleOffset||0)+g.axisTitleMargin),n=k+2*n):(p=this.top+(m?this.height:-n),g=this.left-n),this.scrollbar.position(g,p,f,n),this.scrollbar.setRange(this.zoomedMin/k,this.zoomedMax/k));this.rendered=!0}},addMouseEvents:function(){var a=this,b=a.chart,c=b.container,h=[],f,g;a.mouseMoveHandler=f=function(b){a.onMouseMove(b)};a.mouseUpHandler=g=function(b){a.onMouseUp(b)};h=a.getPartsEvents("mousedown");
h.push(E(c,"mousemove",f),E(c.ownerDocument,"mouseup",g));e&&(h.push(E(c,"touchmove",f),E(c.ownerDocument,"touchend",g)),h.concat(a.getPartsEvents("touchstart")));a.eventsToUnbind=h;a.series&&a.series[0]&&h.push(E(a.series[0].xAxis,"foundExtremes",function(){b.navigator.modifyNavigatorAxisExtremes()}))},getPartsEvents:function(a){var b=this,d=[];u(["shades","handles"],function(c){u(b[c],function(e,h){d.push(E(e.element,a,function(a){b[c+"Mousedown"](a,h)}))})});return d},shadesMousedown:function(a,
b){a=this.chart.pointer.normalize(a);var d=this.chart,c=this.xAxis,e=this.zoomedMin,f=this.left,g=this.size,p=this.range,n=a.chartX,k;d.inverted&&(n=a.chartY,f=this.top);1===b?(this.grabbedCenter=n,this.fixedWidth=p,this.dragOffset=n-e):(a=n-f-p/2,0===b?a=Math.max(0,a):2===b&&a+p>=g&&(a=g-p,k=this.getUnionExtremes().dataMax),a!==e&&(this.fixedWidth=p,b=c.toFixedRange(a,a+p,null,k),w(b.min)&&d.xAxis[0].setExtremes(Math.min(b.min,b.max),Math.max(b.min,b.max),!0,null,{trigger:"navigator"})))},handlesMousedown:function(a,
b){this.chart.pointer.normalize(a);a=this.chart;var d=a.xAxis[0],c=a.inverted&&!d.reversed||!a.inverted&&d.reversed;0===b?(this.grabbedLeft=!0,this.otherHandlePos=this.zoomedMax,this.fixedExtreme=c?d.min:d.max):(this.grabbedRight=!0,this.otherHandlePos=this.zoomedMin,this.fixedExtreme=c?d.max:d.min);a.fixedRange=null},onMouseMove:function(a){var b=this,d=b.chart,c=b.left,e=b.navigatorSize,f=b.range,g=b.dragOffset,n=d.inverted;a.touches&&0===a.touches[0].pageX||(a=d.pointer.normalize(a),d=a.chartX,
n&&(c=b.top,d=a.chartY),b.grabbedLeft?(b.hasDragged=!0,b.render(0,0,d-c,b.otherHandlePos)):b.grabbedRight?(b.hasDragged=!0,b.render(0,0,b.otherHandlePos,d-c)):b.grabbedCenter&&(b.hasDragged=!0,d<g?d=g:d>e+g-f&&(d=e+g-f),b.render(0,0,d-g,d-g+f)),b.hasDragged&&b.scrollbar&&b.scrollbar.options.liveRedraw&&(a.DOMType=a.type,setTimeout(function(){b.onMouseUp(a)},0)))},onMouseUp:function(a){var b=this.chart,d=this.xAxis,c=this.scrollbar,e,f,g=a.DOMEvent||a;(!this.hasDragged||c&&c.hasDragged)&&"scrollbar"!==
a.trigger||(this.zoomedMin===this.otherHandlePos?e=this.fixedExtreme:this.zoomedMax===this.otherHandlePos&&(f=this.fixedExtreme),this.zoomedMax===this.size&&(f=this.getUnionExtremes().dataMax),d=d.toFixedRange(this.zoomedMin,this.zoomedMax,e,f),w(d.min)&&b.xAxis[0].setExtremes(Math.min(d.min,d.max),Math.max(d.min,d.max),!0,this.hasDragged?!1:null,{trigger:"navigator",triggerOp:"navigator-drag",DOMEvent:g}));"mousemove"!==a.DOMType&&(this.grabbedLeft=this.grabbedRight=this.grabbedCenter=this.fixedWidth=
this.fixedExtreme=this.otherHandlePos=this.hasDragged=this.dragOffset=null)},removeEvents:function(){this.eventsToUnbind&&(u(this.eventsToUnbind,function(a){a()}),this.eventsToUnbind=void 0);this.removeBaseSeriesEvents()},removeBaseSeriesEvents:function(){var a=this.baseSeries||[];this.navigatorEnabled&&a[0]&&(!1!==this.navigatorOptions.adaptToUpdatedData&&u(a,function(a){I(a,"updatedData",this.updatedDataHandler)},this),a[0].xAxis&&I(a[0].xAxis,"foundExtremes",this.modifyBaseAxisExtremes))},init:function(a){var b=
a.options,d=b.navigator,c=d.enabled,e=b.scrollbar,f=e.enabled,b=c?d.height:0,g=f?e.height:0;this.handles=[];this.shades=[];this.chart=a;this.setBaseSeries();this.height=b;this.scrollbarHeight=g;this.scrollbarEnabled=f;this.navigatorEnabled=c;this.navigatorOptions=d;this.scrollbarOptions=e;this.outlineHeight=b+g;this.opposite=C(d.opposite,!c&&a.inverted);var n=this,e=n.baseSeries,f=a.xAxis.length,k=a.yAxis.length,m=e&&e[0]&&e[0].xAxis||a.xAxis[0];a.extraMargin={type:n.opposite?"plotTop":"marginBottom",
value:(c||!a.inverted?n.outlineHeight:0)+d.margin};a.inverted&&(a.extraMargin.type=n.opposite?"marginRight":"plotLeft");a.isDirtyBox=!0;n.navigatorEnabled?(n.xAxis=new H(a,l({breaks:m.options.breaks,ordinal:m.options.ordinal},d.xAxis,{id:"navigator-x-axis",yAxis:"navigator-y-axis",isX:!0,type:"datetime",index:f,offset:0,keepOrdinalPadding:!0,startOnTick:!1,endOnTick:!1,minPadding:0,maxPadding:0,zoomEnabled:!1},a.inverted?{offsets:[g,0,-g,0],width:b}:{offsets:[0,-g,0,g],height:b})),n.yAxis=new H(a,
l(d.yAxis,{id:"navigator-y-axis",alignTicks:!1,offset:0,index:k,zoomEnabled:!1},a.inverted?{width:b}:{height:b})),e||d.series.data?n.updateNavigatorSeries():0===a.series.length&&B(a,"redraw",function(b,d){0<a.series.length&&!n.series&&(n.setBaseSeries(),a.redraw=b);b.call(a,d)}),n.renderElements(),n.addMouseEvents()):n.xAxis={translate:function(b,d){var c=a.xAxis[0],e=c.getExtremes(),f=c.len-2*g,h=A("min",c.options.min,e.dataMin),c=A("max",c.options.max,e.dataMax)-h;return d?b*c/f+h:f*(b-h)/c},toPixels:function(a){return this.translate(a)},
toValue:function(a){return this.translate(a,!0)},toFixedRange:H.prototype.toFixedRange,fake:!0};a.options.scrollbar.enabled&&(a.scrollbar=n.scrollbar=new x(a.renderer,l(a.options.scrollbar,{margin:n.navigatorEnabled?0:10,vertical:a.inverted}),a),E(n.scrollbar,"changed",function(b){var d=n.size,c=d*this.to,d=d*this.from;n.hasDragged=n.scrollbar.hasDragged;n.render(0,0,d,c);(a.options.scrollbar.liveRedraw||"mousemove"!==b.DOMType)&&setTimeout(function(){n.onMouseUp(b)})}));n.addBaseSeriesEvents();n.addChartEvents()},
getUnionExtremes:function(a){var b=this.chart.xAxis[0],d=this.xAxis,c=d.options,e=b.options,f;a&&null===b.dataMin||(f={dataMin:C(c&&c.min,A("min",e.min,b.dataMin,d.dataMin,d.min)),dataMax:C(c&&c.max,A("max",e.max,b.dataMax,d.dataMax,d.max))});return f},setBaseSeries:function(a,b){var d=this.chart,c=this.baseSeries=[];a=a||d.options&&d.options.navigator.baseSeries||0;u(d.series||[],function(b,d){b.options.isInternal||!b.options.showInNavigator&&(d!==a&&b.options.id!==a||!1===b.options.showInNavigator)||
c.push(b)});this.xAxis&&!this.xAxis.fake&&this.updateNavigatorSeries(b)},updateNavigatorSeries:function(b){var d=this,e=d.chart,f=d.baseSeries,n,k,m=d.navigatorOptions.series,r,t={enableMouseTracking:!1,index:null,linkedTo:null,group:"nav",padXAxis:!1,xAxis:"navigator-x-axis",yAxis:"navigator-y-axis",showInLegend:!1,stacking:!1,isInternal:!0,visible:!0},v=d.series=a.grep(d.series||[],function(b){var c=b.baseSeries;return 0>a.inArray(c,f)?(c&&(I(c,"updatedData",d.updatedDataHandler),delete c.navigatorSeries),
b.destroy(),!1):!0});f&&f.length&&u(f,function(a){var h=a.navigatorSeries,p=g({color:a.color},c(m)?q.navigator.series:m);h&&!1===d.navigatorOptions.adaptToUpdatedData||(t.name="Navigator "+f.length,n=a.options||{},r=n.navigatorOptions||{},k=l(n,t,p,r),p=r.data||p.data,d.hasNavigatorData=d.hasNavigatorData||!!p,k.data=p||n.data&&n.data.slice(0),h&&h.options?h.update(k,b):(a.navigatorSeries=e.initSeries(k),a.navigatorSeries.baseSeries=a,v.push(a.navigatorSeries)))});if(m.data&&(!f||!f.length)||c(m))d.hasNavigatorData=
!1,m=a.splat(m),u(m,function(a,b){t.name="Navigator "+(v.length+1);k=l(q.navigator.series,{color:e.series[b]&&!e.series[b].options.isInternal&&e.series[b].color||e.options.colors[b]||e.options.colors[0]},t,a);k.data=a.data;k.data&&(d.hasNavigatorData=!0,v.push(e.initSeries(k)))});this.addBaseSeriesEvents()},addBaseSeriesEvents:function(){var a=this,b=a.baseSeries||[];b[0]&&b[0].xAxis&&E(b[0].xAxis,"foundExtremes",this.modifyBaseAxisExtremes);u(b,function(b){E(b,"show",function(){this.navigatorSeries&&
this.navigatorSeries.setVisible(!0,!1)});E(b,"hide",function(){this.navigatorSeries&&this.navigatorSeries.setVisible(!1,!1)});!1!==this.navigatorOptions.adaptToUpdatedData&&b.xAxis&&E(b,"updatedData",this.updatedDataHandler);E(b,"remove",function(){this.navigatorSeries&&(z(a.series,this.navigatorSeries),this.navigatorSeries.remove(!1),delete this.navigatorSeries)})},this)},modifyNavigatorAxisExtremes:function(){var a=this.xAxis,b;a.getExtremes&&(!(b=this.getUnionExtremes(!0))||b.dataMin===a.min&&
b.dataMax===a.max||(a.min=b.dataMin,a.max=b.dataMax))},modifyBaseAxisExtremes:function(){var a=this.chart.navigator,c=this.getExtremes(),e=c.dataMin,f=c.dataMax,c=c.max-c.min,g=a.stickToMin,n=a.stickToMax,k=this.options.overscroll,l,m,q=a.series&&a.series[0],r=!!this.setExtremes;this.eventArgs&&"rangeSelectorButton"===this.eventArgs.trigger||(g&&(m=e,l=m+c),n&&(l=f+k,g||(m=Math.max(l-c,q&&q.xData?q.xData[0]:-Number.MAX_VALUE))),r&&(g||n)&&b(m)&&(this.min=this.userMin=m,this.max=this.userMax=l));a.stickToMin=
a.stickToMax=null},updatedDataHandler:function(){var a=this.chart.navigator,c=this.navigatorSeries;a.stickToMax=Math.round(a.zoomedMax)>=Math.round(a.size);a.stickToMin=b(this.xAxis.min)&&this.xAxis.min<=this.xData[0]&&(!this.chart.fixedRange||!a.stickToMax);c&&!a.hasNavigatorData&&(c.options.pointStart=this.xData[0],c.setData(this.options.data,!1,null,!1))},addChartEvents:function(){E(this.chart,"redraw",function(){var a=this.navigator,b=a&&(a.baseSeries&&a.baseSeries[0]&&a.baseSeries[0].xAxis||
a.scrollbar&&this.xAxis[0]);b&&a.render(b.min,b.max)})},destroy:function(){this.removeEvents();this.xAxis&&(z(this.chart.xAxis,this.xAxis),z(this.chart.axes,this.xAxis));this.yAxis&&(z(this.chart.yAxis,this.yAxis),z(this.chart.axes,this.yAxis));u(this.series||[],function(a){a.destroy&&a.destroy()});u("series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered".split(" "),function(a){this[a]&&this[a].destroy&&this[a].destroy();this[a]=null},this);
u([this.handles],function(a){t(a)},this)}};a.Navigator=G;B(H.prototype,"zoom",function(a,b,c){var d=this.chart,e=d.options,f=e.chart.zoomType,g=e.navigator,e=e.rangeSelector,n;this.isXAxis&&(g&&g.enabled||e&&e.enabled)&&("x"===f?d.resetZoomButton="blocked":"y"===f?n=!1:"xy"===f&&this.options.range&&(d=this.previousZoom,w(b)?this.previousZoom=[this.min,this.max]:d&&(b=d[0],c=d[1],delete this.previousZoom)));return void 0!==n?n:a.call(this,b,c)});B(v.prototype,"init",function(a,b,c){E(this,"beforeRender",
function(){var a=this.options;if(a.navigator.enabled||a.scrollbar.enabled)this.scroller=this.navigator=new G(this)});a.call(this,b,c)});B(v.prototype,"setChartSize",function(a){var b=this.legend,c=this.navigator,d,e,f,g;a.apply(this,[].slice.call(arguments,1));c&&(e=b&&b.options,f=c.xAxis,g=c.yAxis,d=c.scrollbarHeight,this.inverted?(c.left=c.opposite?this.chartWidth-d-c.height:this.spacing[3]+d,c.top=this.plotTop+d):(c.left=this.plotLeft+d,c.top=c.navigatorOptions.top||this.chartHeight-c.height-d-
this.spacing[2]-(this.rangeSelector&&this.extraBottomMargin?this.rangeSelector.getHeight():0)-(e&&"bottom"===e.verticalAlign&&e.enabled&&!e.floating?b.legendHeight+C(e.margin,10):0)),f&&g&&(this.inverted?f.options.left=g.options.left=c.left:f.options.top=g.options.top=c.top,f.setAxisSize(),g.setAxisSize()))});B(F.prototype,"addPoint",function(a,b,c,e,f){var d=this.options.turboThreshold;d&&this.xData.length>d&&r(b,!0)&&this.chart.navigator&&m(20,!0);a.call(this,b,c,e,f)});B(v.prototype,"addSeries",
function(a,b,c,e){a=a.call(this,b,!1,e);this.navigator&&this.navigator.setBaseSeries(null,!1);C(c,!0)&&this.redraw();return a});B(F.prototype,"update",function(a,b,c){a.call(this,b,!1);this.chart.navigator&&!this.options.isInternal&&this.chart.navigator.setBaseSeries(null,!1);C(c,!0)&&this.chart.redraw()});v.prototype.callbacks.push(function(a){var b=a.navigator;b&&(a=a.xAxis[0].getExtremes(),b.render(a.min,a.max))})})(L);(function(a){function G(a){this.init(a)}var E=a.addEvent,H=a.Axis,v=a.Chart,
k=a.css,q=a.createElement,w=a.dateFormat,t=a.defaultOptions,u=t.global.useUTC,z=a.defined,m=a.destroyObjectProperties,g=a.discardElement,f=a.each,e=a.extend,c=a.fireEvent,b=a.Date,r=a.isNumber,l=a.merge,C=a.pick,I=a.pInt,x=a.splat,F=a.wrap;e(t,{rangeSelector:{verticalAlign:"top",buttonTheme:{"stroke-width":0,width:28,height:18,padding:2,zIndex:7},floating:!1,x:0,y:0,height:void 0,inputPosition:{align:"right",x:0,y:0},buttonPosition:{align:"left",x:0,y:0},labelStyle:{color:"#666666"}}});t.lang=l(t.lang,
{rangeSelectorZoom:"Zoom",rangeSelectorFrom:"From",rangeSelectorTo:"To"});G.prototype={clickButton:function(a,b){var c=this,e=c.chart,d=c.buttonOptions[a],g=e.xAxis[0],n=e.scroller&&e.scroller.getUnionExtremes()||g||{},h=n.dataMin,k=n.dataMax,l,m=g&&Math.round(Math.min(g.max,C(k,g.max))),q=d.type,t,n=d._range,v,w,B,z=d.dataGrouping;if(null!==h&&null!==k){e.fixedRange=n;z&&(this.forcedDataGrouping=!0,H.prototype.setDataGrouping.call(g||{chart:this.chart},z,!1));if("month"===q||"year"===q)g?(q={range:d,
max:m,dataMin:h,dataMax:k},l=g.minFromRange.call(q),r(q.newMax)&&(m=q.newMax)):n=d;else if(n)l=Math.max(m-n,h),m=Math.min(l+n,k);else if("ytd"===q)if(g)void 0===k&&(h=Number.MAX_VALUE,k=Number.MIN_VALUE,f(e.series,function(a){a=a.xData;h=Math.min(a[0],h);k=Math.max(a[a.length-1],k)}),b=!1),m=c.getYTDExtremes(k,h,u),l=v=m.min,m=m.max;else{E(e,"beforeRender",function(){c.clickButton(a)});return}else"all"===q&&g&&(l=h,m=k);l+=d._offsetMin;m+=d._offsetMax;c.setSelected(a);g?g.setExtremes(l,m,C(b,1),null,
{trigger:"rangeSelectorButton",rangeSelectorButton:d}):(t=x(e.options.xAxis)[0],B=t.range,t.range=n,w=t.min,t.min=v,E(e,"load",function(){t.range=B;t.min=w}))}},setSelected:function(a){this.selected=this.options.selected=a},defaultButtons:[{type:"month",count:1,text:"1m"},{type:"month",count:3,text:"3m"},{type:"month",count:6,text:"6m"},{type:"ytd",text:"YTD"},{type:"year",count:1,text:"1y"},{type:"all",text:"All"}],init:function(a){var b=this,e=a.options.rangeSelector,g=e.buttons||[].concat(b.defaultButtons),
d=e.selected,n=function(){var a=b.minInput,d=b.maxInput;a&&a.blur&&c(a,"blur");d&&d.blur&&c(d,"blur")};b.chart=a;b.options=e;b.buttons=[];a.extraTopMargin=e.height;b.buttonOptions=g;this.unMouseDown=E(a.container,"mousedown",n);this.unResize=E(a,"resize",n);f(g,b.computeButtonRange);void 0!==d&&g[d]&&this.clickButton(d,!1);E(a,"load",function(){a.xAxis&&a.xAxis[0]&&E(a.xAxis[0],"setExtremes",function(c){this.max-this.min!==a.fixedRange&&"rangeSelectorButton"!==c.trigger&&"updatedData"!==c.trigger&&
b.forcedDataGrouping&&this.setDataGrouping(!1,!1)})})},updateButtonStates:function(){var a=this.chart,b=a.xAxis[0],c=Math.round(b.max-b.min),e=!b.hasVisibleSeries,a=a.scroller&&a.scroller.getUnionExtremes()||b,d=a.dataMin,g=a.dataMax,a=this.getYTDExtremes(g,d,u),k=a.min,h=a.max,l=this.selected,m=r(l),q=this.options.allButtonsEnabled,t=this.buttons;f(this.buttonOptions,function(a,f){var n=a._range,p=a.type,r=a.count||1,u=t[f],v=0;a=a._offsetMax-a._offsetMin;f=f===l;var y=n>g-d,A=n<b.minRange,w=!1,
x=!1,n=n===c;("month"===p||"year"===p)&&c+36E5>=864E5*{month:28,year:365}[p]*r+a&&c-36E5<=864E5*{month:31,year:366}[p]*r+a?n=!0:"ytd"===p?(n=h-k+a===c,w=!f):"all"===p&&(n=b.max-b.min>=g-d,x=!f&&m&&n);p=!q&&(y||A||x||e);r=f&&n||n&&!m&&!w;p?v=3:r&&(m=!0,v=2);u.state!==v&&u.setState(v)})},computeButtonRange:function(a){var b=a.type,c=a.count||1,e={millisecond:1,second:1E3,minute:6E4,hour:36E5,day:864E5,week:6048E5};if(e[b])a._range=e[b]*c;else if("month"===b||"year"===b)a._range=864E5*{month:30,year:365}[b]*
c;a._offsetMin=C(a.offsetMin,0);a._offsetMax=C(a.offsetMax,0);a._range+=a._offsetMax-a._offsetMin},setInputValue:function(a,b){var c=this.chart.options.rangeSelector,e=this[a+"Input"];z(b)&&(e.previousValue=e.HCTime,e.HCTime=b);e.value=w(c.inputEditDateFormat||"%Y-%m-%d",e.HCTime);this[a+"DateBox"].attr({text:w(c.inputDateFormat||"%b %e, %Y",e.HCTime)})},showInput:function(a){var b=this.inputGroup,c=this[a+"DateBox"];k(this[a+"Input"],{left:b.translateX+c.x+"px",top:b.translateY+"px",width:c.width-
2+"px",height:c.height-2+"px",border:"2px solid silver"})},hideInput:function(a){k(this[a+"Input"],{border:0,width:"1px",height:"1px"});this.setInputValue(a)},drawInput:function(a){function b(){var a=v.value,b=(n.inputDateParser||Date.parse)(a),d=f.xAxis[0],e=f.scroller&&f.scroller.xAxis?f.scroller.xAxis:d,g=e.dataMin,e=e.dataMax;b!==v.previousValue&&(v.previousValue=b,r(b)||(b=a.split("-"),b=Date.UTC(I(b[0]),I(b[1])-1,I(b[2]))),r(b)&&(u||(b+=6E4*(new Date).getTimezoneOffset()),m?b>c.maxInput.HCTime?
b=void 0:b<g&&(b=g):b<c.minInput.HCTime?b=void 0:b>e&&(b=e),void 0!==b&&d.setExtremes(m?b:d.min,m?d.max:b,void 0,void 0,{trigger:"rangeSelectorInput"})))}var c=this,f=c.chart,d=f.renderer.style||{},g=f.renderer,n=f.options.rangeSelector,h=c.div,m="min"===a,v,w,x=this.inputGroup;this[a+"Label"]=w=g.label(t.lang[m?"rangeSelectorFrom":"rangeSelectorTo"],this.inputGroup.offset).addClass("highcharts-range-label").attr({padding:2}).add(x);x.offset+=w.width+5;this[a+"DateBox"]=g=g.label("",x.offset).addClass("highcharts-range-input").attr({padding:2,
width:n.inputBoxWidth||90,height:n.inputBoxHeight||17,stroke:n.inputBoxBorderColor||"#cccccc","stroke-width":1,"text-align":"center"}).on("click",function(){c.showInput(a);c[a+"Input"].focus()}).add(x);x.offset+=g.width+(m?10:0);this[a+"Input"]=v=q("input",{name:a,className:"highcharts-range-selector",type:"text"},{top:f.plotTop+"px"},h);w.css(l(d,n.labelStyle));g.css(l({color:"#333333"},d,n.inputStyle));k(v,e({position:"absolute",border:0,width:"1px",height:"1px",padding:0,textAlign:"center",fontSize:d.fontSize,
fontFamily:d.fontFamily,top:"-9999em"},n.inputStyle));v.onfocus=function(){c.showInput(a)};v.onblur=function(){c.hideInput(a)};v.onchange=b;v.onkeypress=function(a){13===a.keyCode&&b()}},getPosition:function(){var a=this.chart,b=a.options.rangeSelector,a="top"===b.verticalAlign?a.plotTop-a.axisOffset[0]:0;return{buttonTop:a+b.buttonPosition.y,inputTop:a+b.inputPosition.y-10}},getYTDExtremes:function(a,c,e){var f=new b(a),d=f[b.hcGetFullYear]();e=e?b.UTC(d,0,1):+new b(d,0,1);c=Math.max(c||0,e);f=f.getTime();
return{max:Math.min(a||f,f),min:c}},render:function(a,b){var c=this,e=c.chart,d=e.renderer,g=e.container,k=e.options,h=k.exporting&&!1!==k.exporting.enabled&&k.navigation&&k.navigation.buttonOptions,n=t.lang,l=c.div,m=k.rangeSelector,k=m.floating,r=c.buttons,l=c.inputGroup,u=m.buttonTheme,v=m.buttonPosition,w=m.inputPosition,x=m.inputEnabled,z=u&&u.states,B=e.plotLeft,E,F=c.buttonGroup,G;G=c.rendered;var H=c.options.verticalAlign,I=e.legend,L=I&&I.options,Y=v.y,X=w.y,Q=G||!1,T=0,U=0,V;if(!1!==m.enabled){G||
(c.group=G=d.g("range-selector-group").attr({zIndex:7}).add(),c.buttonGroup=F=d.g("range-selector-buttons").add(G),c.zoomText=d.text(n.rangeSelectorZoom,C(B+v.x,B),15).css(m.labelStyle).add(F),E=C(B+v.x,B)+c.zoomText.getBBox().width+5,f(c.buttonOptions,function(a,b){r[b]=d.button(a.text,E,0,function(){var d=a.events&&a.events.click,e;d&&(e=d.call(a));!1!==e&&c.clickButton(b);c.isActive=!0},u,z&&z.hover,z&&z.select,z&&z.disabled).attr({"text-align":"center"}).add(F);E+=r[b].width+C(m.buttonSpacing,
5)}),!1!==x&&(c.div=l=q("div",null,{position:"relative",height:0,zIndex:1}),g.parentNode.insertBefore(l,g),c.inputGroup=l=d.g("input-group").add(G),l.offset=0,c.drawInput("min"),c.drawInput("max")));B=e.plotLeft-e.spacing[3];c.updateButtonStates();h&&this.titleCollision(e)&&"top"===H&&"right"===v.align&&v.y+F.getBBox().height-12<(h.y||0)+h.height&&(T=-40);"left"===v.align?V=v.x-e.spacing[3]:"right"===v.align&&(V=v.x+T-e.spacing[1]);F.align({y:v.y,width:F.getBBox().width,align:v.align,x:V},!0,e.spacingBox);
c.group.placed=Q;c.buttonGroup.placed=Q;!1!==x&&(T=h&&this.titleCollision(e)&&"top"===H&&"right"===w.align&&w.y-l.getBBox().height-12<(h.y||0)+h.height+e.spacing[0]?-40:0,"left"===w.align?V=B:"right"===w.align&&(V=-Math.max(e.axisOffset[1],-T)),l.align({y:w.y,width:l.getBBox().width,align:w.align,x:w.x+V-2},!0,e.spacingBox),g=l.alignAttr.translateX+l.alignOptions.x-T+l.getBBox().x+2,h=l.alignOptions.width,n=F.alignAttr.translateX+F.getBBox().x,V=F.getBBox().width+20,(w.align===v.align||n+V>g&&g+h>
n&&Y<X+l.getBBox().height)&&l.attr({translateX:l.alignAttr.translateX+(e.axisOffset[1]>=-T?0:-T),translateY:l.alignAttr.translateY+F.getBBox().height+10}),c.setInputValue("min",a),c.setInputValue("max",b),c.inputGroup.placed=Q);c.group.align({verticalAlign:H},!0,e.spacingBox);a=c.group.getBBox().height+20;b=c.group.alignAttr.translateY;"bottom"===H&&(I=L&&"bottom"===L.verticalAlign&&L.enabled&&!L.floating?I.legendHeight+C(L.margin,10):0,a=a+I-20,U=b-a-(k?0:m.y)-10);if("top"===H)k&&(U=0),e.titleOffset&&
(U=e.titleOffset+e.options.title.margin),U+=e.margin[0]-e.spacing[0]||0;else if("middle"===H)if(X===Y)U=0>X?b+void 0:b;else if(X||Y)U=0>X||0>Y?U-Math.min(X,Y):b-a+NaN;c.group.translate(m.x,m.y+Math.floor(U));!1!==x&&(c.minInput.style.marginTop=c.group.translateY+"px",c.maxInput.style.marginTop=c.group.translateY+"px");c.rendered=!0}},getHeight:function(){var a=this.options,b=this.group,c=a.y,e=a.buttonPosition.y,a=a.inputPosition.y,b=b?b.getBBox(!0).height+13+c:0,c=Math.min(a,e);if(0>a&&0>e||0<a&&
0<e)b+=Math.abs(c);return b},titleCollision:function(a){return!(a.options.title.text||a.options.subtitle.text)},update:function(a){var b=this.chart;l(!0,b.options.rangeSelector,a);this.destroy();this.init(b);b.rangeSelector.render()},destroy:function(){var b=this,c=b.minInput,e=b.maxInput;b.unMouseDown();b.unResize();m(b.buttons);c&&(c.onfocus=c.onblur=c.onchange=null);e&&(e.onfocus=e.onblur=e.onchange=null);a.objectEach(b,function(a,c){a&&"chart"!==c&&(a.destroy?a.destroy():a.nodeType&&g(this[c]));
a!==G.prototype[c]&&(b[c]=null)},this)}};H.prototype.toFixedRange=function(a,b,c,e){var d=this.chart&&this.chart.fixedRange;a=C(c,this.translate(a,!0,!this.horiz));b=C(e,this.translate(b,!0,!this.horiz));c=d&&(b-a)/d;.7<c&&1.3>c&&(e?a=b-d:b=a+d);r(a)&&r(b)||(a=b=void 0);return{min:a,max:b}};H.prototype.minFromRange=function(){var a=this.range,b={month:"Month",year:"FullYear"}[a.type],c,e=this.max,d,f,g=function(a,c){var d=new Date(a),e=d["get"+b]();d["set"+b](e+c);e===d["get"+b]()&&d.setDate(0);return d.getTime()-
a};r(a)?(c=e-a,f=a):(c=e+g(e,-a.count),this.chart&&(this.chart.fixedRange=e-c));d=C(this.dataMin,Number.MIN_VALUE);r(c)||(c=d);c<=d&&(c=d,void 0===f&&(f=g(c,a.count)),this.newMax=Math.min(c+f,this.dataMax));r(e)||(c=void 0);return c};F(v.prototype,"init",function(a,b,c){E(this,"init",function(){this.options.rangeSelector.enabled&&(this.rangeSelector=new G(this))});a.call(this,b,c)});F(v.prototype,"render",function(a,b,c){var e=this.axes,d=this.rangeSelector;d&&(f(e,function(a){a.updateNames();a.setScale()}),
this.getAxisMargins(),d.render(),e=d.options.verticalAlign,d.options.floating||("bottom"===e?this.extraBottomMargin=!0:"middle"!==e&&(this.extraTopMargin=!0)));a.call(this,b,c)});F(v.prototype,"update",function(b,c,e,f){var d=this.rangeSelector,g;this.extraTopMargin=this.extraBottomMargin=!1;d&&(d.render(),g=c.rangeSelector&&c.rangeSelector.verticalAlign||d.options&&d.options.verticalAlign,d.options.floating||("bottom"===g?this.extraBottomMargin=!0:"middle"!==g&&(this.extraTopMargin=!0)));b.call(this,
a.merge(!0,c,{chart:{marginBottom:C(c.chart&&c.chart.marginBottom,this.margin.bottom),spacingBottom:C(c.chart&&c.chart.spacingBottom,this.spacing.bottom)}}),e,f)});F(v.prototype,"redraw",function(a,b,c){var e=this.rangeSelector;e&&!e.options.floating&&(e.render(),e=e.options.verticalAlign,"bottom"===e?this.extraBottomMargin=!0:"middle"!==e&&(this.extraTopMargin=!0));a.call(this,b,c)});v.prototype.adjustPlotArea=function(){var a=this.rangeSelector;this.rangeSelector&&(a=a.getHeight(),this.extraTopMargin&&
(this.plotTop+=a),this.extraBottomMargin&&(this.marginBottom+=a))};v.prototype.callbacks.push(function(a){function b(){c=a.xAxis[0].getExtremes();r(c.min)&&e.render(c.min,c.max)}var c,e=a.rangeSelector,d,f;e&&(f=E(a.xAxis[0],"afterSetExtremes",function(a){e.render(a.min,a.max)}),d=E(a,"redraw",b),b());E(a,"destroy",function(){e&&(d(),f())})});a.RangeSelector=G})(L);(function(a){var G=a.arrayMax,E=a.arrayMin,H=a.Axis,v=a.Chart,k=a.defined,q=a.each,w=a.extend,t=a.format,u=a.grep,z=a.inArray,m=a.isNumber,
g=a.isString,f=a.map,e=a.merge,c=a.pick,b=a.Point,r=a.Renderer,l=a.Series,C=a.splat,I=a.SVGRenderer,x=a.VMLRenderer,F=a.wrap,n=l.prototype,B=n.init,J=n.processData,A=b.prototype.tooltipFormatter;a.StockChart=a.stockChart=function(b,k,l){var d=g(b)||b.nodeName,m=arguments[d?1:0],p=m.series,n=a.getOptions(),q,r=c(m.navigator&&m.navigator.enabled,n.navigator.enabled,!0),t=r?{startOnTick:!1,endOnTick:!1}:null,u={marker:{enabled:!1,radius:2}},w={shadow:!1,borderWidth:0};m.xAxis=f(C(m.xAxis||{}),function(a){return e({minPadding:0,
maxPadding:0,overscroll:0,ordinal:!0,title:{text:null},labels:{overflow:"justify"},showLastLabel:!0},n.xAxis,a,{type:"datetime",categories:null},t)});m.yAxis=f(C(m.yAxis||{}),function(a){q=c(a.opposite,!0);return e({labels:{y:-2},opposite:q,showLastLabel:!1,title:{text:null}},n.yAxis,a)});m.series=null;m=e({chart:{panning:!0,pinchType:"x"},navigator:{enabled:r},scrollbar:{enabled:c(n.scrollbar.enabled,!0)},rangeSelector:{enabled:c(n.rangeSelector.enabled,!0)},title:{text:null},tooltip:{split:c(n.tooltip.split,
!0),crosshairs:!0},legend:{enabled:!1},plotOptions:{line:u,spline:u,area:u,areaspline:u,arearange:u,areasplinerange:u,column:w,columnrange:w,candlestick:w,ohlc:w}},m,{isStock:!0});m.series=p;return d?new v(b,m,l):new v(m,k)};F(H.prototype,"autoLabelAlign",function(a){var b=this.chart,c=this.options,b=b._labelPanes=b._labelPanes||{},d=this.options.labels;return this.chart.options.isStock&&"yAxis"===this.coll&&(c=c.top+","+c.height,!b[c]&&d.enabled)?(15===d.x&&(d.x=0),void 0===d.align&&(d.align="right"),
b[c]=this,"right"):a.apply(this,[].slice.call(arguments,1))});F(H.prototype,"destroy",function(a){var b=this.chart,c=this.options&&this.options.top+","+this.options.height;c&&b._labelPanes&&b._labelPanes[c]===this&&delete b._labelPanes[c];return a.apply(this,Array.prototype.slice.call(arguments,1))});F(H.prototype,"getPlotLinePath",function(b,e,l,h,n,r){var d=this,p=this.isLinked&&!this.series?this.linkedParent.series:this.series,t=d.chart,u=t.renderer,v=d.left,w=d.top,y,x,A,B,D=[],C=[],E,F;if("xAxis"!==
d.coll&&"yAxis"!==d.coll)return b.apply(this,[].slice.call(arguments,1));C=function(a){var b="xAxis"===a?"yAxis":"xAxis";a=d.options[b];return m(a)?[t[b][a]]:g(a)?[t.get(a)]:f(p,function(a){return a[b]})}(d.coll);q(d.isXAxis?t.yAxis:t.xAxis,function(a){if(k(a.options.id)?-1===a.options.id.indexOf("navigator"):1){var b=a.isXAxis?"yAxis":"xAxis",b=k(a.options[b])?t[b][a.options[b]]:t[b][0];d===b&&C.push(a)}});E=C.length?[]:[d.isXAxis?t.yAxis[0]:t.xAxis[0]];q(C,function(b){-1!==z(b,E)||a.find(E,function(a){return a.pos===
b.pos&&a.len&&b.len})||E.push(b)});F=c(r,d.translate(e,null,null,h));m(F)&&(d.horiz?q(E,function(a){var b;x=a.pos;B=x+a.len;y=A=Math.round(F+d.transB);if(y<v||y>v+d.width)n?y=A=Math.min(Math.max(v,y),v+d.width):b=!0;b||D.push("M",y,x,"L",A,B)}):q(E,function(a){var b;y=a.pos;A=y+a.len;x=B=Math.round(w+d.height-F);if(x<w||x>w+d.height)n?x=B=Math.min(Math.max(w,x),d.top+d.height):b=!0;b||D.push("M",y,x,"L",A,B)}));return 0<D.length?u.crispPolyLine(D,l||1):null});I.prototype.crispPolyLine=function(a,
b){var c;for(c=0;c<a.length;c+=6)a[c+1]===a[c+4]&&(a[c+1]=a[c+4]=Math.round(a[c+1])-b%2/2),a[c+2]===a[c+5]&&(a[c+2]=a[c+5]=Math.round(a[c+2])+b%2/2);return a};r===x&&(x.prototype.crispPolyLine=I.prototype.crispPolyLine);F(H.prototype,"hideCrosshair",function(a,b){a.call(this,b);this.crossLabel&&(this.crossLabel=this.crossLabel.hide())});F(H.prototype,"drawCrosshair",function(a,b,e){var d,f;a.call(this,b,e);if(k(this.crosshair.label)&&this.crosshair.label.enabled&&this.cross){a=this.chart;var g=this.options.crosshair.label,
l=this.horiz;d=this.opposite;f=this.left;var m=this.top,n=this.crossLabel,p,q=g.format,r="",u="inside"===this.options.tickPosition,v=!1!==this.crosshair.snap,x=0;b||(b=this.cross&&this.cross.e);p=l?"center":d?"right"===this.labelAlign?"right":"left":"left"===this.labelAlign?"left":"center";n||(n=this.crossLabel=a.renderer.label(null,null,null,g.shape||"callout").addClass("highcharts-crosshair-label"+(this.series[0]&&" highcharts-color-"+this.series[0].colorIndex)).attr({align:g.align||p,padding:c(g.padding,
8),r:c(g.borderRadius,3),zIndex:2}).add(this.labelGroup),n.attr({fill:g.backgroundColor||this.series[0]&&this.series[0].color||"#666666",stroke:g.borderColor||"","stroke-width":g.borderWidth||0}).css(w({color:"#ffffff",fontWeight:"normal",fontSize:"11px",textAlign:"center"},g.style)));l?(p=v?e.plotX+f:b.chartX,m+=d?0:this.height):(p=d?this.width+f:0,m=v?e.plotY+m:b.chartY);q||g.formatter||(this.isDatetimeAxis&&(r="%b %d, %Y"),q="{value"+(r?":"+r:"")+"}");b=v?e[this.isXAxis?"x":"y"]:this.toValue(l?
b.chartX:b.chartY);n.attr({text:q?t(q,{value:b}):g.formatter.call(this,b),x:p,y:m,visibility:"visible"});b=n.getBBox();if(l){if(u&&!d||!u&&d)m=n.y-b.height}else m=n.y-b.height/2;l?(d=f-b.x,f=f+this.width-b.x):(d="left"===this.labelAlign?f:0,f="right"===this.labelAlign?f+this.width:a.chartWidth);n.translateX<d&&(x=d-n.translateX);n.translateX+b.width>=f&&(x=-(n.translateX+b.width-f));n.attr({x:p+x,y:m,anchorX:l?p:this.opposite?0:a.chartWidth,anchorY:l?this.opposite?a.chartHeight:0:m+b.height/2})}});
n.init=function(){B.apply(this,arguments);this.setCompare(this.options.compare)};n.setCompare=function(a){this.modifyValue="value"===a||"percent"===a?function(b,c){var d=this.compareValue;if(void 0!==b&&void 0!==d)return b="value"===a?b-d:b/d*100-(100===this.options.compareBase?0:100),c&&(c.change=b),b}:null;this.userOptions.compare=a;this.chart.hasRendered&&(this.isDirty=!0)};n.processData=function(){var a,b=-1,c,e,f=!0===this.options.compareStart?0:1,g,k;J.apply(this,arguments);if(this.xAxis&&this.processedYData)for(c=
this.processedXData,e=this.processedYData,g=e.length,this.pointArrayMap&&(b=z("close",this.pointArrayMap),-1===b&&(b=z(this.pointValKey||"y",this.pointArrayMap))),a=0;a<g-f;a++)if(k=e[a]&&-1<b?e[a][b]:e[a],m(k)&&c[a+f]>=this.xAxis.min&&0!==k){this.compareValue=k;break}};F(n,"getExtremes",function(a){var b;a.apply(this,[].slice.call(arguments,1));this.modifyValue&&(b=[this.modifyValue(this.dataMin),this.modifyValue(this.dataMax)],this.dataMin=E(b),this.dataMax=G(b))});H.prototype.setCompare=function(a,
b){this.isXAxis||(q(this.series,function(b){b.setCompare(a)}),c(b,!0)&&this.chart.redraw())};b.prototype.tooltipFormatter=function(b){b=b.replace("{point.change}",(0<this.change?"+":"")+a.numberFormat(this.change,c(this.series.tooltipOptions.changeDecimals,2)));return A.apply(this,[b])};F(l.prototype,"render",function(a){this.chart.is3d&&this.chart.is3d()||this.chart.polar||!this.xAxis||this.xAxis.isRadial||(!this.clipBox&&this.animate?(this.clipBox=e(this.chart.clipBox),this.clipBox.width=this.xAxis.len,
this.clipBox.height=this.yAxis.len):this.chart[this.sharedClipKey]?this.chart[this.sharedClipKey].attr({width:this.xAxis.len,height:this.yAxis.len}):this.clipBox&&(this.clipBox.width=this.xAxis.len,this.clipBox.height=this.yAxis.len));a.call(this)});F(v.prototype,"getSelectedPoints",function(a){var b=a.call(this);q(this.series,function(a){a.hasGroupedData&&(b=b.concat(u(a.points||[],function(a){return a.selected})))});return b});F(v.prototype,"update",function(a,b){"scrollbar"in b&&this.navigator&&
(e(!0,this.options.scrollbar,b.scrollbar),this.navigator.update({},!1),delete b.scrollbar);return a.apply(this,Array.prototype.slice.call(arguments,1))})})(L);return L});


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */


var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try { // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
};


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getRawTag_js__ = __webpack_require__(141);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__objectToString_js__ = __webpack_require__(142);




/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */].toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__getRawTag_js__["a" /* default */])(value)
    : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__objectToString_js__["a" /* default */])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (baseGetTag);


/***/ }),
/* 139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/* harmony default export */ __webpack_exports__["a"] = (freeGlobal);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(11)))

/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__overArg_js__ = __webpack_require__(143);


/** Built-in value references. */
var getPrototype = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__overArg_js__["a" /* default */])(Object.getPrototypeOf, Object);

/* harmony default export */ __webpack_exports__["a"] = (getPrototype);


/***/ }),
/* 141 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(35);


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */].toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (getRawTag);


/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/* harmony default export */ __webpack_exports__["a"] = (objectToString);


/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* harmony default export */ __webpack_exports__["a"] = (overArg);


/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__ = __webpack_require__(139);


/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__["a" /* default */] || freeSelf || Function('return this')();

/* harmony default export */ __webpack_exports__["a"] = (root);


/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/* harmony default export */ __webpack_exports__["a"] = (isObjectLike);


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var trim = __webpack_require__(173)
  , forEach = __webpack_require__(133)
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(4);
var invariant = __webpack_require__(6);
var ReactPropTypesSecret = __webpack_require__(17);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(4);
var invariant = __webpack_require__(6);
var warning = __webpack_require__(10);
var assign = __webpack_require__(7);

var ReactPropTypesSecret = __webpack_require__(17);
var checkPropTypes = __webpack_require__(16);

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(
            false,
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            warning(
              false,
              'You are manually calling a React.PropTypes validation ' +
              'function for the `%s` prop on `%s`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
              propFullName,
              componentName
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(
          false,
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received %s at index %s.',
          getPostfixForTypeWarning(checker),
          i
        );
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0
 * react-dom.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (process.env.NODE_ENV !== "production") {
  (function() {
'use strict';

var React = __webpack_require__(0);
var invariant = __webpack_require__(6);
var warning = __webpack_require__(10);
var ExecutionEnvironment = __webpack_require__(29);
var _assign = __webpack_require__(7);
var emptyFunction = __webpack_require__(4);
var EventListener = __webpack_require__(28);
var getActiveElement = __webpack_require__(32);
var shallowEqual = __webpack_require__(33);
var containsNode = __webpack_require__(30);
var focusNode = __webpack_require__(31);
var emptyObject = __webpack_require__(9);
var checkPropTypes = __webpack_require__(16);
var hyphenateStyleName = __webpack_require__(130);
var camelizeStyleName = __webpack_require__(128);

/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

!React ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;

// These attributes should be all lowercase to allow for
// case insensitive checks
var RESERVED_PROPS = {
  children: true,
  dangerouslySetInnerHTML: true,
  defaultValue: true,
  defaultChecked: true,
  innerHTML: true,
  suppressContentEditableWarning: true,
  suppressHydrationWarning: true,
  style: true
};

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_PROPERTY: 0x1,
  HAS_BOOLEAN_VALUE: 0x4,
  HAS_NUMERIC_VALUE: 0x8,
  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
  HAS_STRING_BOOLEAN_VALUE: 0x40,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    for (var propName in Properties) {
      !!properties.hasOwnProperty(propName) ? invariant(false, "injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.", propName) : void 0;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE),
        hasStringBooleanValue: checkMask(propConfig, Injection.HAS_STRING_BOOLEAN_VALUE)
      };
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? invariant(false, "DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s", propName) : void 0;

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];

        propertyInfo.attributeName = attributeName;
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      // Downcase references to whitelist properties to check for membership
      // without case-sensitivity. This allows the whitelist to pick up
      // `allowfullscreen`, which should be written using the property configuration
      // for `allowFullscreen`
      properties[propName] = propertyInfo;
    }
  }
};

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
/* eslint-enable max-len */
var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";


var ROOT_ATTRIBUTE_NAME = 'data-reactroot';

/**
 * Map from property "standard name" to an object with info about how to set
 * the property in the DOM. Each object contains:
 *
 * attributeName:
 *   Used when rendering markup or with `*Attribute()`.
 * attributeNamespace
 * propertyName:
 *   Used on DOM node instances. (This includes properties that mutate due to
 *   external factors.)
 * mutationMethod:
 *   If non-null, used instead of the property or `setAttribute()` after
 *   initial render.
 * mustUseProperty:
 *   Whether the property must be accessed and mutated as an object property.
 * hasBooleanValue:
 *   Whether the property should be removed when set to a falsey value.
 * hasNumericValue:
 *   Whether the property must be numeric or parse as a numeric and should be
 *   removed when set to a falsey value.
 * hasPositiveNumericValue:
 *   Whether the property must be positive numeric or parse as a positive
 *   numeric and should be removed when set to a falsey value.
 * hasOverloadedBooleanValue:
 *   Whether the property can be used as a flag as well as with a value.
 *   Removed when strictly equal to false; present without a value when
 *   strictly equal to true; present with a value otherwise.
 */
var properties = {};

/**
 * Checks whether a property name is a writeable attribute.
 * @method
 */
function shouldSetAttribute(name, value) {
  if (isReservedProp(name)) {
    return false;
  }
  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
    return false;
  }
  if (value === null) {
    return true;
  }
  switch (typeof value) {
    case 'boolean':
      return shouldAttributeAcceptBooleanValue(name);
    case 'undefined':
    case 'number':
    case 'string':
    case 'object':
      return true;
    default:
      // function, symbol
      return false;
  }
}

function getPropertyInfo(name) {
  return properties.hasOwnProperty(name) ? properties[name] : null;
}

function shouldAttributeAcceptBooleanValue(name) {
  if (isReservedProp(name)) {
    return true;
  }
  var propertyInfo = getPropertyInfo(name);
  if (propertyInfo) {
    return propertyInfo.hasBooleanValue || propertyInfo.hasStringBooleanValue || propertyInfo.hasOverloadedBooleanValue;
  }
  var prefix = name.toLowerCase().slice(0, 5);
  return prefix === 'data-' || prefix === 'aria-';
}

/**
 * Checks to see if a property name is within the list of properties
 * reserved for internal React operations. These properties should
 * not be set on an HTML element.
 *
 * @private
 * @param {string} name
 * @return {boolean} If the name is within reserved props
 */
function isReservedProp(name) {
  return RESERVED_PROPS.hasOwnProperty(name);
}

var injection = DOMPropertyInjection;

var MUST_USE_PROPERTY = injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = injection.HAS_BOOLEAN_VALUE;
var HAS_NUMERIC_VALUE = injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = injection.HAS_OVERLOADED_BOOLEAN_VALUE;
var HAS_STRING_BOOLEAN_VALUE = injection.HAS_STRING_BOOLEAN_VALUE;

var HTMLDOMPropertyConfig = {
  // When adding attributes to this list, be sure to also add them to
  // the `possibleStandardNames` module to ensure casing and incorrect
  // name warnings.
  Properties: {
    allowFullScreen: HAS_BOOLEAN_VALUE,
    // specifies target context for links with `preload` type
    async: HAS_BOOLEAN_VALUE,
    // Note: there is a special case that prevents it from being written to the DOM
    // on the client side because the browsers are inconsistent. Instead we call focus().
    autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: HAS_OVERLOADED_BOOLEAN_VALUE,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    cols: HAS_POSITIVE_NUMERIC_VALUE,
    contentEditable: HAS_STRING_BOOLEAN_VALUE,
    controls: HAS_BOOLEAN_VALUE,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    disabled: HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: HAS_STRING_BOOLEAN_VALUE,
    formNoValidate: HAS_BOOLEAN_VALUE,
    hidden: HAS_BOOLEAN_VALUE,
    loop: HAS_BOOLEAN_VALUE,
    // Caution; `option.selected` is not updated if `select.multiple` is
    // disabled with `removeAttribute`.
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    playsInline: HAS_BOOLEAN_VALUE,
    readOnly: HAS_BOOLEAN_VALUE,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    rows: HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: HAS_NUMERIC_VALUE,
    scoped: HAS_BOOLEAN_VALUE,
    seamless: HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    size: HAS_POSITIVE_NUMERIC_VALUE,
    start: HAS_NUMERIC_VALUE,
    // support for projecting regular DOM Elements via V1 named slots ( shadow dom )
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: HAS_STRING_BOOLEAN_VALUE,
    // Style must be explicitly set in the attribute list. React components
    // expect a style object
    style: 0,
    // Keep it in the whitelist because it is case-sensitive for SVG.
    tabIndex: 0,
    // itemScope is for for Microdata support.
    // See http://schema.org/docs/gs.html
    itemScope: HAS_BOOLEAN_VALUE,
    // These attributes must stay in the white-list because they have
    // different attribute names (see DOMAttributeNames below)
    acceptCharset: 0,
    className: 0,
    htmlFor: 0,
    httpEquiv: 0,
    // Attributes with mutation methods must be specified in the whitelist
    // Set the string boolean flag to allow the behavior
    value: HAS_STRING_BOOLEAN_VALUE
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMMutationMethods: {
    value: function (node, value) {
      if (value == null) {
        return node.removeAttribute('value');
      }

      // Number inputs get special treatment due to some edge cases in
      // Chrome. Let everything else assign the value attribute as normal.
      // https://github.com/facebook/react/issues/7253#issuecomment-236074326
      if (node.type !== 'number' || node.hasAttribute('value') === false) {
        node.setAttribute('value', '' + value);
      } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {
        // Don't assign an attribute if validation reports bad
        // input. Chrome will clear the value. Additionally, don't
        // operate on inputs that have focus, otherwise Chrome might
        // strip off trailing decimal places and cause the user's
        // cursor position to jump to the beginning of the input.
        //
        // In ReactDOMInput, we have an onBlur event that will trigger
        // this function again when focus is lost.
        node.setAttribute('value', '' + value);
      }
    }
  }
};

var HAS_STRING_BOOLEAN_VALUE$1 = injection.HAS_STRING_BOOLEAN_VALUE;


var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

/**
 * This is a list of all SVG attributes that need special casing,
 * namespacing, or boolean value assignment.
 *
 * When adding attributes to this list, be sure to also add them to
 * the `possibleStandardNames` module to ensure casing and incorrect
 * name warnings.
 *
 * SVG Attributes List:
 * https://www.w3.org/TR/SVG/attindex.html
 * SMIL Spec:
 * https://www.w3.org/TR/smil
 */
var ATTRS = ['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'x-height', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xmlns:xlink', 'xml:lang', 'xml:space'];

var SVGDOMPropertyConfig = {
  Properties: {
    autoReverse: HAS_STRING_BOOLEAN_VALUE$1,
    externalResourcesRequired: HAS_STRING_BOOLEAN_VALUE$1,
    preserveAlpha: HAS_STRING_BOOLEAN_VALUE$1
  },
  DOMAttributeNames: {
    autoReverse: 'autoReverse',
    externalResourcesRequired: 'externalResourcesRequired',
    preserveAlpha: 'preserveAlpha'
  },
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  }
};

var CAMELIZE = /[\-\:]([a-z])/g;
var capitalize = function (token) {
  return token[1].toUpperCase();
};

ATTRS.forEach(function (original) {
  var reactName = original.replace(CAMELIZE, capitalize);

  SVGDOMPropertyConfig.Properties[reactName] = 0;
  SVGDOMPropertyConfig.DOMAttributeNames[reactName] = original;
});

injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
injection.injectDOMPropertyConfig(SVGDOMPropertyConfig);

var ReactErrorUtils = {
  // Used by Fiber to simulate a try-catch.
  _caughtError: null,
  _hasCaughtError: false,

  // Used by event system to capture/rethrow the first error.
  _rethrowError: null,
  _hasRethrowError: false,

  injection: {
    injectErrorUtils: function (injectedErrorUtils) {
      !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;
      invokeGuardedCallback = injectedErrorUtils.invokeGuardedCallback;
    }
  },

  /**
   * Call a function while guarding against errors that happens within it.
   * Returns an error if it throws, otherwise null.
   *
   * In production, this is implemented using a try-catch. The reason we don't
   * use a try-catch directly is so that we can swap out a different
   * implementation in DEV mode.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */
  invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {
    invokeGuardedCallback.apply(ReactErrorUtils, arguments);
  },

  /**
   * Same as invokeGuardedCallback, but instead of returning an error, it stores
   * it in a global so it can be rethrown by `rethrowCaughtError` later.
   * TODO: See if _caughtError and _rethrowError can be unified.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */
  invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {
    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);
    if (ReactErrorUtils.hasCaughtError()) {
      var error = ReactErrorUtils.clearCaughtError();
      if (!ReactErrorUtils._hasRethrowError) {
        ReactErrorUtils._hasRethrowError = true;
        ReactErrorUtils._rethrowError = error;
      }
    }
  },

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function () {
    return rethrowCaughtError.apply(ReactErrorUtils, arguments);
  },

  hasCaughtError: function () {
    return ReactErrorUtils._hasCaughtError;
  },

  clearCaughtError: function () {
    if (ReactErrorUtils._hasCaughtError) {
      var error = ReactErrorUtils._caughtError;
      ReactErrorUtils._caughtError = null;
      ReactErrorUtils._hasCaughtError = false;
      return error;
    } else {
      invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');
    }
  }
};

var invokeGuardedCallback = function (name, func, context, a, b, c, d, e, f) {
  ReactErrorUtils._hasCaughtError = false;
  ReactErrorUtils._caughtError = null;
  var funcArgs = Array.prototype.slice.call(arguments, 3);
  try {
    func.apply(context, funcArgs);
  } catch (error) {
    ReactErrorUtils._caughtError = error;
    ReactErrorUtils._hasCaughtError = true;
  }
};

{
  // In DEV mode, we swap out invokeGuardedCallback for a special version
  // that plays more nicely with the browser's DevTools. The idea is to preserve
  // "Pause on exceptions" behavior. Because React wraps all user-provided
  // functions in invokeGuardedCallback, and the production version of
  // invokeGuardedCallback uses a try-catch, all user exceptions are treated
  // like caught exceptions, and the DevTools won't pause unless the developer
  // takes the extra step of enabling pause on caught exceptions. This is
  // untintuitive, though, because even though React has caught the error, from
  // the developer's perspective, the error is uncaught.
  //
  // To preserve the expected "Pause on exceptions" behavior, we don't use a
  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
  // DOM node, and call the user-provided callback from inside an event handler
  // for that fake event. If the callback throws, the error is "captured" using
  // a global event handler. But because the error happens in a different
  // event loop context, it does not interrupt the normal program flow.
  // Effectively, this gives us try-catch behavior without actually using
  // try-catch. Neat!

  // Check that the browser supports the APIs we need to implement our special
  // DEV version of invokeGuardedCallback
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');

    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {
      // Keeps track of whether the user-provided callback threw an error. We
      // set this to true at the beginning, then set it to false right after
      // calling the function. If the function errors, `didError` will never be
      // set to false. This strategy works even if the browser is flaky and
      // fails to call our global error handler, because it doesn't rely on
      // the error event at all.
      var didError = true;

      // Create an event handler for our fake event. We will synchronously
      // dispatch our fake event using `dispatchEvent`. Inside the handler, we
      // call the user-provided callback.
      var funcArgs = Array.prototype.slice.call(arguments, 3);
      function callCallback() {
        // We immediately remove the callback from event listeners so that
        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
        // nested call would trigger the fake event handlers of any call higher
        // in the stack.
        fakeNode.removeEventListener(evtType, callCallback, false);
        func.apply(context, funcArgs);
        didError = false;
      }

      // Create a global error event handler. We use this to capture the value
      // that was thrown. It's possible that this error handler will fire more
      // than once; for example, if non-React code also calls `dispatchEvent`
      // and a handler for that event throws. We should be resilient to most of
      // those cases. Even if our error event handler fires more than once, the
      // last error event is always used. If the callback actually does error,
      // we know that the last error event is the correct one, because it's not
      // possible for anything else to have happened in between our callback
      // erroring and the code that follows the `dispatchEvent` call below. If
      // the callback doesn't error, but the error event was fired, we know to
      // ignore it because `didError` will be false, as described above.
      var error = void 0;
      // Use this to track whether the error event is ever called.
      var didSetError = false;
      var isCrossOriginError = false;

      function onError(event) {
        error = event.error;
        didSetError = true;
        if (error === null && event.colno === 0 && event.lineno === 0) {
          isCrossOriginError = true;
        }
      }

      // Create a fake event type.
      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');

      // Attach our event handlers
      window.addEventListener('error', onError);
      fakeNode.addEventListener(evtType, callCallback, false);

      // Synchronously dispatch our fake event. If the user-provided function
      // errors, it will trigger our global error handler.
      var evt = document.createEvent('Event');
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);

      if (didError) {
        if (!didSetError) {
          // The callback errored, but the error event never fired.
          error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
        } else if (isCrossOriginError) {
          error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');
        }
        ReactErrorUtils._hasCaughtError = true;
        ReactErrorUtils._caughtError = error;
      } else {
        ReactErrorUtils._hasCaughtError = false;
        ReactErrorUtils._caughtError = null;
      }

      // Remove our event listeners
      window.removeEventListener('error', onError);
    };

    invokeGuardedCallback = invokeGuardedCallbackDev;
  }
}

var rethrowCaughtError = function () {
  if (ReactErrorUtils._hasRethrowError) {
    var error = ReactErrorUtils._rethrowError;
    ReactErrorUtils._rethrowError = null;
    ReactErrorUtils._hasRethrowError = false;
    throw error;
  }
};

/**
 * Injectable ordering of event plugins.
 */
var eventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!eventPluginOrder) {
    // Wait until an `eventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var pluginModule = namesToPlugins[pluginName];
    var pluginIndex = eventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;
    if (plugins[pluginIndex]) {
      continue;
    }
    !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;
    plugins[pluginIndex] = pluginModule;
    var publishedEvents = pluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
  !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;
  eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, pluginModule, eventName) {
  !!registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;
  registrationNameModules[registrationName] = pluginModule;
  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

  {
    var lowerCasedName = registrationName.toLowerCase();
    possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      possibleRegistrationNames.ondblclick = registrationName;
    }
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */

/**
 * Ordered list of injected plugins.
 */
var plugins = [];

/**
 * Mapping from event name to dispatch config
 */
var eventNameDispatchConfigs = {};

/**
 * Mapping from registration name to plugin module
 */
var registrationNameModules = {};

/**
 * Mapping from registration name to event name
 */
var registrationNameDependencies = {};

/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */
var possibleRegistrationNames = {};
// Trust the developer to only use possibleRegistrationNames in true

/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */
function injectEventPluginOrder(injectedEventPluginOrder) {
  !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;
  // Clone the ordering so it cannot be dynamically mutated.
  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
  recomputePluginOrdering();
}

/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */
function injectEventPluginsByName(injectedNamesToPlugins) {
  var isOrderingDirty = false;
  for (var pluginName in injectedNamesToPlugins) {
    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
      continue;
    }
    var pluginModule = injectedNamesToPlugins[pluginName];
    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
      !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;
      namesToPlugins[pluginName] = pluginModule;
      isOrderingDirty = true;
    }
  }
  if (isOrderingDirty) {
    recomputePluginOrdering();
  }
}

var EventPluginRegistry = Object.freeze({
	plugins: plugins,
	eventNameDispatchConfigs: eventNameDispatchConfigs,
	registrationNameModules: registrationNameModules,
	registrationNameDependencies: registrationNameDependencies,
	possibleRegistrationNames: possibleRegistrationNames,
	injectEventPluginOrder: injectEventPluginOrder,
	injectEventPluginsByName: injectEventPluginsByName
});

var getFiberCurrentPropsFromNode = null;
var getInstanceFromNode = null;
var getNodeFromInstance = null;

var injection$2 = {
  injectComponentTree: function (Injected) {
    getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;
    getInstanceFromNode = Injected.getInstanceFromNode;
    getNodeFromInstance = Injected.getNodeFromInstance;

    {
      warning(getNodeFromInstance && getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');
    }
  }
};






var validateEventDispatches;
{
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    var instancesIsArr = Array.isArray(dispatchInstances);
    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

    warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.');
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = getNodeFromInstance(inst);
  ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */


/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */


/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */

/**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;

  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 * @param {function} cb Callback invoked with each element or a collection.
 * @param {?} [scope] Scope used as `this` in a callback.
 */
function forEachAccumulated(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
}

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
      return !!(props.disabled && isInteractive(type));
    default:
      return false;
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */

/**
 * Methods for injecting dependencies.
 */
var injection$1 = {
  /**
   * @param {array} InjectedEventPluginOrder
   * @public
   */
  injectEventPluginOrder: injectEventPluginOrder,

  /**
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   */
  injectEventPluginsByName: injectEventPluginsByName
};

/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */
function getListener(inst, registrationName) {
  var listener;

  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
  // live here; needs to be moved to a better place soon
  var stateNode = inst.stateNode;
  if (!stateNode) {
    // Work in progress (ex: onload events in incremental mode).
    return null;
  }
  var props = getFiberCurrentPropsFromNode(stateNode);
  if (!props) {
    // Work in progress.
    return null;
  }
  listener = props[registrationName];
  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
    return null;
  }
  !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;
  return listener;
}

/**
 * Allows registered plugins an opportunity to extract events from top-level
 * native browser events.
 *
 * @return {*} An accumulation of synthetic events.
 * @internal
 */
function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  for (var i = 0; i < plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
}

/**
 * Enqueues a synthetic event that should be dispatched when
 * `processEventQueue` is invoked.
 *
 * @param {*} events An accumulation of synthetic events.
 * @internal
 */
function enqueueEvents(events) {
  if (events) {
    eventQueue = accumulateInto(eventQueue, events);
  }
}

/**
 * Dispatches all synthetic events on the event queue.
 *
 * @internal
 */
function processEventQueue(simulated) {
  // Set `eventQueue` to null before processing it so that we can tell if more
  // events get enqueued while processing.
  var processingEventQueue = eventQueue;
  eventQueue = null;

  if (!processingEventQueue) {
    return;
  }

  if (simulated) {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
  } else {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
  }
  !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;
  // This would be a good time to rethrow if any of the event handlers threw.
  ReactErrorUtils.rethrowCaughtError();
}

var EventPluginHub = Object.freeze({
	injection: injection$1,
	getListener: getListener,
	extractEvents: extractEvents,
	enqueueEvents: enqueueEvents,
	processEventQueue: processEventQueue
});

var IndeterminateComponent = 0; // Before we know whether it is functional or class
var FunctionalComponent = 1;
var ClassComponent = 2;
var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
var HostComponent = 5;
var HostText = 6;
var CallComponent = 7;
var CallHandlerPhase = 8;
var ReturnComponent = 9;
var Fragment = 10;

var randomKey = Math.random().toString(36).slice(2);
var internalInstanceKey = '__reactInternalInstance$' + randomKey;
var internalEventHandlersKey = '__reactEventHandlers$' + randomKey;

function precacheFiberNode$1(hostInst, node) {
  node[internalInstanceKey] = hostInst;
}

/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */
function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  // Walk up the tree until we find an ancestor whose instance we have cached.
  var parents = [];
  while (!node[internalInstanceKey]) {
    parents.push(node);
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var closest = void 0;
  var inst = node[internalInstanceKey];
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber, this will always be the deepest root.
    return inst;
  }
  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
    closest = inst;
  }

  return closest;
}

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */
function getInstanceFromNode$1(node) {
  var inst = node[internalInstanceKey];
  if (inst) {
    if (inst.tag === HostComponent || inst.tag === HostText) {
      return inst;
    } else {
      return null;
    }
  }
  return null;
}

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */
function getNodeFromInstance$1(inst) {
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber this, is just the state node right now. We assume it will be
    // a host component or host text.
    return inst.stateNode;
  }

  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  invariant(false, 'getNodeFromInstance: Invalid argument.');
}

function getFiberCurrentPropsFromNode$1(node) {
  return node[internalEventHandlersKey] || null;
}

function updateFiberProps$1(node, props) {
  node[internalEventHandlersKey] = props;
}

var ReactDOMComponentTree = Object.freeze({
	precacheFiberNode: precacheFiberNode$1,
	getClosestInstanceFromNode: getClosestInstanceFromNode,
	getInstanceFromNode: getInstanceFromNode$1,
	getNodeFromInstance: getNodeFromInstance$1,
	getFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,
	updateFiberProps: updateFiberProps$1
});

function getParent(inst) {
  do {
    inst = inst['return'];
    // TODO: If this is a HostRoot we might want to bail out.
    // That is depending on if we want nested subtrees (layers) to bubble
    // events to their parent. We could also go through parentNode on the
    // host node but that wouldn't work for React Native and doesn't let us
    // do the portal feature.
  } while (inst && inst.tag !== HostComponent);
  if (inst) {
    return inst;
  }
  return null;
}

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */
function getLowestCommonAncestor(instA, instB) {
  var depthA = 0;
  for (var tempA = instA; tempA; tempA = getParent(tempA)) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = getParent(tempB)) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB > 0) {
    instA = getParent(instA);
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA > 0) {
    instB = getParent(instB);
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB || instA === instB.alternate) {
      return instA;
    }
    instA = getParent(instA);
    instB = getParent(instB);
  }
  return null;
}

/**
 * Return if A is an ancestor of B.
 */


/**
 * Return the parent instance of the passed-in instance.
 */
function getParentInstance(inst) {
  return getParent(inst);
}

/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */
function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = getParent(inst);
  }
  var i;
  for (i = path.length; i-- > 0;) {
    fn(path[i], 'captured', arg);
  }
  for (i = 0; i < path.length; i++) {
    fn(path[i], 'bubbled', arg);
  }
}

/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */
function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (true) {
    if (!from) {
      break;
    }
    if (from === common) {
      break;
    }
    var alternate = from.alternate;
    if (alternate !== null && alternate === common) {
      break;
    }
    pathFrom.push(from);
    from = getParent(from);
  }
  var pathTo = [];
  while (true) {
    if (!to) {
      break;
    }
    if (to === common) {
      break;
    }
    var _alternate = to.alternate;
    if (_alternate !== null && _alternate === common) {
      break;
    }
    pathTo.push(to);
    to = getParent(to);
  }
  for (var i = 0; i < pathFrom.length; i++) {
    fn(pathFrom[i], 'bubbled', argFrom);
  }
  for (var _i = pathTo.length; _i-- > 0;) {
    fn(pathTo[_i], 'captured', argTo);
  }
}

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(inst, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(inst, registrationName);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing even a
 * single one.
 */

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(inst, phase, event) {
  {
    warning(inst, 'Dispatching inst must not be null');
  }
  var listener = listenerAtPhase(inst, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    var targetInst = event._targetInst;
    var parentInst = targetInst ? getParentInstance(targetInst) : null;
    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(inst, ignoredDirection, event) {
  if (inst && event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(inst, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event._targetInst, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

var EventPropagators = Object.freeze({
	accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,
	accumulateDirectDispatches: accumulateDirectDispatches
});

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

/**
 * This helper object stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */
var compositionState = {
  _root: null,
  _startText: null,
  _fallbackText: null
};

function initialize(nativeEventTarget) {
  compositionState._root = nativeEventTarget;
  compositionState._startText = getText();
  return true;
}

function reset() {
  compositionState._root = null;
  compositionState._startText = null;
  compositionState._fallbackText = null;
}

function getData() {
  if (compositionState._fallbackText) {
    return compositionState._fallbackText;
  }

  var start;
  var startValue = compositionState._startText;
  var startLength = startValue.length;
  var end;
  var endValue = getText();
  var endLength = endValue.length;

  for (start = 0; start < startLength; start++) {
    if (startValue[start] !== endValue[start]) {
      break;
    }
  }

  var minEnd = startLength - start;
  for (end = 1; end <= minEnd; end++) {
    if (startValue[startLength - end] !== endValue[endLength - end]) {
      break;
    }
  }

  var sliceTail = end > 1 ? 1 - end : undefined;
  compositionState._fallbackText = endValue.slice(start, sliceTail);
  return compositionState._fallbackText;
}

function getText() {
  if ('value' in compositionState._root) {
    return compositionState._root.value;
  }
  return compositionState._root[getTextContentAccessor()];
}

/* eslint valid-typeof: 0 */

var didWarnForAddedNewProperty = false;
var isProxySupported = typeof Proxy === 'function';
var EVENT_POOL_SIZE = 10;

var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */
function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
  {
    // these have a getter/setter for warnings
    delete this.nativeEvent;
    delete this.preventDefault;
    delete this.stopPropagation;
  }

  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    {
      delete this[propName]; // this has a getter/setter for warnings
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  return this;
}

_assign(SyntheticEvent.prototype, {
  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else if (typeof event.returnValue !== 'unknown') {
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else if (typeof event.cancelBubble !== 'unknown') {
      // The ChangeEventPlugin registers a "propertychange" event for
      // IE. This event does not support bubbling or cancelling, and
      // any references to cancelBubble throw "Member not found".  A
      // typeof check of "unknown" circumvents this issue (and is also
      // IE specific).
      event.cancelBubble = true;
    }

    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      {
        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
      }
    }
    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
      this[shouldBeReleasedProperties[i]] = null;
    }
    {
      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
    }
  }
});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;
  addEventPoolingTo(Class);
};

/** Proxying after everything set on SyntheticEvent
 * to resolve Proxy issue on some WebKit browsers
 * in which some Event properties are set to undefined (GH#10010)
 */
{
  if (isProxySupported) {
    /*eslint-disable no-func-assign */
    SyntheticEvent = new Proxy(SyntheticEvent, {
      construct: function (target, args) {
        return this.apply(target, Object.create(target.prototype), args);
      },
      apply: function (constructor, that, args) {
        return new Proxy(constructor.apply(that, args), {
          set: function (target, prop, value) {
            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
              warning(didWarnForAddedNewProperty || target.isPersistent(), "This synthetic event is reused for performance reasons. If you're " + "seeing this, you're adding a new property in the synthetic event object. " + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.');
              didWarnForAddedNewProperty = true;
            }
            target[prop] = value;
            return true;
          }
        });
      }
    });
    /*eslint-enable no-func-assign */
  }
}

addEventPoolingTo(SyntheticEvent);

/**
 * Helper to nullify syntheticEvent instance properties when destructing
 *
 * @param {String} propName
 * @param {?object} getVal
 * @return {object} defineProperty object
 */
function getPooledWarningPropertyDefinition(propName, getVal) {
  var isFunction = typeof getVal === 'function';
  return {
    configurable: true,
    set: set,
    get: get
  };

  function set(val) {
    var action = isFunction ? 'setting the method' : 'setting the property';
    warn(action, 'This is effectively a no-op');
    return val;
  }

  function get() {
    var action = isFunction ? 'accessing the method' : 'accessing the property';
    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    warning(warningCondition, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);
  }
}

function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
  var EventConstructor = this;
  if (EventConstructor.eventPool.length) {
    var instance = EventConstructor.eventPool.pop();
    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
    return instance;
  }
  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
}

function releasePooledEvent(event) {
  var EventConstructor = this;
  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance  into a pool of a different type.') : void 0;
  event.destructor();
  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
    EventConstructor.eventPool.push(event);
  }
}

function addEventPoolingTo(EventConstructor) {
  EventConstructor.eventPool = [];
  EventConstructor.getPooled = getPooledEvent;
  EventConstructor.release = releasePooledEvent;
}

var SyntheticEvent$1 = SyntheticEvent;

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticInputEvent, InputEventInterface);

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: 'onBeforeInput',
      captured: 'onBeforeInputCapture'
    },
    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionEnd',
      captured: 'onCompositionEndCapture'
    },
    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionStart',
      captured: 'onCompositionStartCapture'
    },
    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionUpdate',
      captured: 'onCompositionUpdateCapture'
    },
    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case 'topCompositionStart':
      return eventTypes.compositionStart;
    case 'topCompositionEnd':
      return eventTypes.compositionEnd;
    case 'topCompositionUpdate':
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topKeyUp':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case 'topKeyDown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case 'topKeyPress':
    case 'topMouseDown':
    case 'topBlur':
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition status, if any.
var isComposing = false;

/**
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!isComposing) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!isComposing && eventType === eventTypes.compositionStart) {
      isComposing = initialize(nativeEventTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (isComposing) {
        fallbackData = getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topCompositionEnd':
      return getDataFromCustomEvent(nativeEvent);
    case 'topKeyPress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'topTextInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (isComposing) {
    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = getData();
      reset();
      isComposing = false;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case 'topPaste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case 'topKeyPress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (!isKeypressCommand(nativeEvent)) {
        // IE fires the `keypress` event when a user types an emoji via
        // Touch keyboard of Windows.  In such a case, the `char` property
        // holds an emoji character like `\uD83D\uDE0A`.  Because its length
        // is 2, the property `which` does not represent an emoji correctly.
        // In such a case, we directly return the `char` property instead of
        // using `which`.
        if (nativeEvent.char && nativeEvent.char.length > 1) {
          return nativeEvent.char;
        } else if (nativeEvent.which) {
          return String.fromCharCode(nativeEvent.which);
        }
      }
      return null;
    case 'topCompositionEnd':
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

  event.data = chars;
  accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {
  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
  }
};

// Use to restore controlled state after a change event has fired.

var fiberHostComponent = null;

var ReactControlledComponentInjection = {
  injectFiberControlledHostComponent: function (hostComponentImpl) {
    // The fiber implementation doesn't use dynamic dispatch so we need to
    // inject the implementation.
    fiberHostComponent = hostComponentImpl;
  }
};

var restoreTarget = null;
var restoreQueue = null;

function restoreStateOfTarget(target) {
  // We perform this translation at the end of the event loop so that we
  // always receive the correct fiber here
  var internalInstance = getInstanceFromNode(target);
  if (!internalInstance) {
    // Unmounted
    return;
  }
  !(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === 'function') ? invariant(false, 'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);
  fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);
}

var injection$3 = ReactControlledComponentInjection;

function enqueueStateRestore(target) {
  if (restoreTarget) {
    if (restoreQueue) {
      restoreQueue.push(target);
    } else {
      restoreQueue = [target];
    }
  } else {
    restoreTarget = target;
  }
}

function restoreStateIfNeeded() {
  if (!restoreTarget) {
    return;
  }
  var target = restoreTarget;
  var queuedTargets = restoreQueue;
  restoreTarget = null;
  restoreQueue = null;

  restoreStateOfTarget(target);
  if (queuedTargets) {
    for (var i = 0; i < queuedTargets.length; i++) {
      restoreStateOfTarget(queuedTargets[i]);
    }
  }
}

var ReactControlledComponent = Object.freeze({
	injection: injection$3,
	enqueueStateRestore: enqueueStateRestore,
	restoreStateIfNeeded: restoreStateIfNeeded
});

// Used as a way to call batchedUpdates when we don't have a reference to
// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.

// Defaults
var fiberBatchedUpdates = function (fn, bookkeeping) {
  return fn(bookkeeping);
};

var isNestingBatched = false;
function batchedUpdates(fn, bookkeeping) {
  if (isNestingBatched) {
    // If we are currently inside another batch, we need to wait until it
    // fully completes before restoring state. Therefore, we add the target to
    // a queue of work.
    return fiberBatchedUpdates(fn, bookkeeping);
  }
  isNestingBatched = true;
  try {
    return fiberBatchedUpdates(fn, bookkeeping);
  } finally {
    // Here we wait until all updates have propagated, which is important
    // when using controlled components within layers:
    // https://github.com/facebook/react/issues/1698
    // Then we restore state of any controlled component.
    isNestingBatched = false;
    restoreStateIfNeeded();
  }
}

var ReactGenericBatchingInjection = {
  injectFiberBatchedUpdates: function (_batchedUpdates) {
    fiberBatchedUpdates = _batchedUpdates;
  }
};

var injection$4 = ReactGenericBatchingInjection;

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  color: true,
  date: true,
  datetime: true,
  'datetime-local': true,
  email: true,
  month: true,
  number: true,
  password: true,
  range: true,
  search: true,
  tel: true,
  text: true,
  time: true,
  url: true,
  week: true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

/**
 * HTML nodeType values that represent the type of the node
 */

var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */
function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;

  // Normalize SVG <use> element events #4963
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }

  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === TEXT_NODE ? target.parentNode : target;
}

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

function isCheckable(elem) {
  var type = elem.type;
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
}

function getTracker(node) {
  return node._valueTracker;
}

function detachTracker(node) {
  node._valueTracker = null;
}

function getValueFromNode(node) {
  var value = '';
  if (!node) {
    return value;
  }

  if (isCheckable(node)) {
    value = node.checked ? 'true' : 'false';
  } else {
    value = node.value;
  }

  return value;
}

function trackValueOnNode(node) {
  var valueField = isCheckable(node) ? 'checked' : 'value';
  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);

  var currentValue = '' + node[valueField];

  // if someone has already defined a value or Safari, then bail
  // and don't track value will cause over reporting of changes,
  // but it's better then a hard failure
  // (needed for certain tests that spyOn input values and Safari)
  if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
    return;
  }

  Object.defineProperty(node, valueField, {
    enumerable: descriptor.enumerable,
    configurable: true,
    get: function () {
      return descriptor.get.call(this);
    },
    set: function (value) {
      currentValue = '' + value;
      descriptor.set.call(this, value);
    }
  });

  var tracker = {
    getValue: function () {
      return currentValue;
    },
    setValue: function (value) {
      currentValue = '' + value;
    },
    stopTracking: function () {
      detachTracker(node);
      delete node[valueField];
    }
  };
  return tracker;
}

function track(node) {
  if (getTracker(node)) {
    return;
  }

  // TODO: Once it's just Fiber we can move this to node._wrapperState
  node._valueTracker = trackValueOnNode(node);
}

function updateValueIfChanged(node) {
  if (!node) {
    return false;
  }

  var tracker = getTracker(node);
  // if there is no tracker at this point it's unlikely
  // that trying again will succeed
  if (!tracker) {
    return true;
  }

  var lastValue = tracker.getValue();
  var nextValue = getValueFromNode(node);
  if (nextValue !== lastValue) {
    tracker.setValue(nextValue);
    return true;
  }
  return false;
}

var eventTypes$1 = {
  change: {
    phasedRegistrationNames: {
      bubbled: 'onChange',
      captured: 'onChangeCapture'
    },
    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
  }
};

function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
  var event = SyntheticEvent$1.getPooled(eventTypes$1.change, inst, nativeEvent, target);
  event.type = 'change';
  // Flag this event loop as needing state restore.
  enqueueStateRestore(target);
  accumulateTwoPhaseDispatches(event);
  return event;
}
/**
 * For IE shims
 */
var activeElement = null;
var activeElementInst = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  enqueueEvents(event);
  processEventQueue(false);
}

function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance$1(targetInst);
  if (updateValueIfChanged(targetNode)) {
    return targetInst;
  }
}

function getTargetInstForChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topChange') {
    return targetInst;
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
}

/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onpropertychange', handlePropertyChange);
  activeElement = null;
  activeElementInst = null;
}

/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  if (getInstIfValueChanged(activeElementInst)) {
    manualDispatchChangeEvent(nativeEvent);
  }
}

function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType, targetInst) {
  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    return getInstIfValueChanged(activeElementInst);
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(topLevelType, targetInst) {
  if (topLevelType === 'topClick') {
    return getInstIfValueChanged(targetInst);
  }
}

function getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topInput' || topLevelType === 'topChange') {
    return getInstIfValueChanged(targetInst);
  }
}

function handleControlledInputBlur(inst, node) {
  // TODO: In IE, inst is occasionally null. Why?
  if (inst == null) {
    return;
  }

  // Fiber and ReactDOM keep wrapper state in separate places
  var state = inst._wrapperState || node._wrapperState;

  if (!state || !state.controlled || node.type !== 'number') {
    return;
  }

  // If controlled, assign the value attribute to the current value on blur
  var value = '' + node.value;
  if (node.getAttribute('value') !== value) {
    node.setAttribute('value', value);
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {
  eventTypes: eventTypes$1,

  _isInputEventSupported: isInputEventSupported,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

    var getTargetInstFunc, handleEventFunc;
    if (shouldUseChangeEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForChangeEvent;
    } else if (isTextInputElement(targetNode)) {
      if (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputOrChangeEvent;
      } else {
        getTargetInstFunc = getTargetInstForInputEventPolyfill;
        handleEventFunc = handleEventsForInputEventPolyfill;
      }
    } else if (shouldUseClickEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    if (getTargetInstFunc) {
      var inst = getTargetInstFunc(topLevelType, targetInst);
      if (inst) {
        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, targetNode, targetInst);
    }

    // When blurring, set the value attribute for number inputs
    if (topLevelType === 'topBlur') {
      handleControlledInputBlur(targetInst, targetNode);
    }
  }
};

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */
var DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: null,
  detail: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticUIEvent, UIEventInterface);

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  Alt: 'altKey',
  Control: 'ctrlKey',
  Meta: 'metaKey',
  Shift: 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  pageX: null,
  pageY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: null,
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

var eventTypes$2 = {
  mouseEnter: {
    registrationName: 'onMouseEnter',
    dependencies: ['topMouseOut', 'topMouseOver']
  },
  mouseLeave: {
    registrationName: 'onMouseLeave',
    dependencies: ['topMouseOut', 'topMouseOver']
  }
};

var EnterLeaveEventPlugin = {
  eventTypes: eventTypes$2,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (nativeEventTarget.window === nativeEventTarget) {
      // `nativeEventTarget` is probably a window object.
      win = nativeEventTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = nativeEventTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    if (topLevelType === 'topMouseOut') {
      from = targetInst;
      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
      to = related ? getClosestInstanceFromNode(related) : null;
    } else {
      // Moving to a node from outside the window.
      from = null;
      to = targetInst;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromNode = from == null ? win : getNodeFromInstance$1(from);
    var toNode = to == null ? win : getNodeFromInstance$1(to);

    var leave = SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave, from, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = fromNode;
    leave.relatedTarget = toNode;

    var enter = SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter, to, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    accumulateEnterLeaveDispatches(leave, enter, from, to);

    return [leave, enter];
  }
};

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */

/**
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 */


function get(key) {
  return key._reactInternalFiber;
}

function has(key) {
  return key._reactInternalFiber !== undefined;
}

function set(key, value) {
  key._reactInternalFiber = value;
}

var ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

var ReactCurrentOwner = ReactInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;

function getComponentName(fiber) {
  var type = fiber.type;

  if (typeof type === 'string') {
    return type;
  }
  if (typeof type === 'function') {
    return type.displayName || type.name;
  }
  return null;
}

// Don't change these two values:
var NoEffect = 0; //           0b00000000
var PerformedWork = 1; //      0b00000001

// You can change the rest (and add more).
var Placement = 2; //          0b00000010
var Update = 4; //             0b00000100
var PlacementAndUpdate = 6; // 0b00000110
var Deletion = 8; //           0b00001000
var ContentReset = 16; //      0b00010000
var Callback = 32; //          0b00100000
var Err = 64; //               0b01000000
var Ref = 128; //              0b10000000

var MOUNTING = 1;
var MOUNTED = 2;
var UNMOUNTED = 3;

function isFiberMountedImpl(fiber) {
  var node = fiber;
  if (!fiber.alternate) {
    // If there is no alternate, this might be a new tree that isn't inserted
    // yet. If it is, then it will have a pending insertion effect on it.
    if ((node.effectTag & Placement) !== NoEffect) {
      return MOUNTING;
    }
    while (node['return']) {
      node = node['return'];
      if ((node.effectTag & Placement) !== NoEffect) {
        return MOUNTING;
      }
    }
  } else {
    while (node['return']) {
      node = node['return'];
    }
  }
  if (node.tag === HostRoot) {
    // TODO: Check if this was a nested HostRoot when used with
    // renderContainerIntoSubtree.
    return MOUNTED;
  }
  // If we didn't hit the root, that means that we're in an disconnected tree
  // that has been unmounted.
  return UNMOUNTED;
}

function isFiberMounted(fiber) {
  return isFiberMountedImpl(fiber) === MOUNTED;
}

function isMounted(component) {
  {
    var owner = ReactCurrentOwner.current;
    if (owner !== null && owner.tag === ClassComponent) {
      var ownerFiber = owner;
      var instance = ownerFiber.stateNode;
      warning(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component');
      instance._warnedAboutRefsInRender = true;
    }
  }

  var fiber = get(component);
  if (!fiber) {
    return false;
  }
  return isFiberMountedImpl(fiber) === MOUNTED;
}

function assertIsMounted(fiber) {
  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
}

function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;
  if (!alternate) {
    // If there is no alternate, then we only need to check if it is mounted.
    var state = isFiberMountedImpl(fiber);
    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
    if (state === MOUNTING) {
      return null;
    }
    return fiber;
  }
  // If we have two possible branches, we'll walk backwards up to the root
  // to see what path the root points to. On the way we may hit one of the
  // special cases and we'll deal with them.
  var a = fiber;
  var b = alternate;
  while (true) {
    var parentA = a['return'];
    var parentB = parentA ? parentA.alternate : null;
    if (!parentA || !parentB) {
      // We're at the root.
      break;
    }

    // If both copies of the parent fiber point to the same child, we can
    // assume that the child is current. This happens when we bailout on low
    // priority: the bailed out fiber's child reuses the current child.
    if (parentA.child === parentB.child) {
      var child = parentA.child;
      while (child) {
        if (child === a) {
          // We've determined that A is the current branch.
          assertIsMounted(parentA);
          return fiber;
        }
        if (child === b) {
          // We've determined that B is the current branch.
          assertIsMounted(parentA);
          return alternate;
        }
        child = child.sibling;
      }
      // We should never have an alternate for any mounting node. So the only
      // way this could possibly happen is if this was unmounted, if at all.
      invariant(false, 'Unable to find node on an unmounted component.');
    }

    if (a['return'] !== b['return']) {
      // The return pointer of A and the return pointer of B point to different
      // fibers. We assume that return pointers never criss-cross, so A must
      // belong to the child set of A.return, and B must belong to the child
      // set of B.return.
      a = parentA;
      b = parentB;
    } else {
      // The return pointers point to the same fiber. We'll have to use the
      // default, slow path: scan the child sets of each parent alternate to see
      // which child belongs to which set.
      //
      // Search parent A's child set
      var didFindChild = false;
      var _child = parentA.child;
      while (_child) {
        if (_child === a) {
          didFindChild = true;
          a = parentA;
          b = parentB;
          break;
        }
        if (_child === b) {
          didFindChild = true;
          b = parentA;
          a = parentB;
          break;
        }
        _child = _child.sibling;
      }
      if (!didFindChild) {
        // Search parent B's child set
        _child = parentB.child;
        while (_child) {
          if (_child === a) {
            didFindChild = true;
            a = parentB;
            b = parentA;
            break;
          }
          if (_child === b) {
            didFindChild = true;
            b = parentB;
            a = parentA;
            break;
          }
          _child = _child.sibling;
        }
        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;
      }
    }

    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  }
  // If the root is not a host container, we're in a disconnected tree. I.e.
  // unmounted.
  !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
  if (a.stateNode.current === a) {
    // We've determined that A is the current branch.
    return fiber;
  }
  // Otherwise B has to be current branch.
  return alternate;
}

function findCurrentHostFiber(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);
  if (!currentParent) {
    return null;
  }

  // Next we'll drill down this component to find the first HostComponent/Text.
  var node = currentParent;
  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child) {
      node.child['return'] = node;
      node = node.child;
      continue;
    }
    if (node === currentParent) {
      return null;
    }
    while (!node.sibling) {
      if (!node['return'] || node['return'] === currentParent) {
        return null;
      }
      node = node['return'];
    }
    node.sibling['return'] = node['return'];
    node = node.sibling;
  }
  // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;
}

function findCurrentHostFiberWithNoPortals(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);
  if (!currentParent) {
    return null;
  }

  // Next we'll drill down this component to find the first HostComponent/Text.
  var node = currentParent;
  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child && node.tag !== HostPortal) {
      node.child['return'] = node;
      node = node.child;
      continue;
    }
    if (node === currentParent) {
      return null;
    }
    while (!node.sibling) {
      if (!node['return'] || node['return'] === currentParent) {
        return null;
      }
      node = node['return'];
    }
    node.sibling['return'] = node['return'];
    node = node.sibling;
  }
  // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;
}

var CALLBACK_BOOKKEEPING_POOL_SIZE = 10;
var callbackBookkeepingPool = [];

/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */
function findRootContainerNode(inst) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while (inst['return']) {
    inst = inst['return'];
  }
  if (inst.tag !== HostRoot) {
    // This can happen if we're in a detached tree.
    return null;
  }
  return inst.stateNode.containerInfo;
}

// Used to store ancestor hierarchy in top level callback
function getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {
  if (callbackBookkeepingPool.length) {
    var instance = callbackBookkeepingPool.pop();
    instance.topLevelType = topLevelType;
    instance.nativeEvent = nativeEvent;
    instance.targetInst = targetInst;
    return instance;
  }
  return {
    topLevelType: topLevelType,
    nativeEvent: nativeEvent,
    targetInst: targetInst,
    ancestors: []
  };
}

function releaseTopLevelCallbackBookKeeping(instance) {
  instance.topLevelType = null;
  instance.nativeEvent = null;
  instance.targetInst = null;
  instance.ancestors.length = 0;
  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {
    callbackBookkeepingPool.push(instance);
  }
}

function handleTopLevelImpl(bookKeeping) {
  var targetInst = bookKeeping.targetInst;

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    if (!ancestor) {
      bookKeeping.ancestors.push(ancestor);
      break;
    }
    var root = findRootContainerNode(ancestor);
    if (!root) {
      break;
    }
    bookKeeping.ancestors.push(ancestor);
    ancestor = getClosestInstanceFromNode(root);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    _handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

// TODO: can we stop exporting these?
var _enabled = true;
var _handleTopLevel = void 0;

function setHandleTopLevel(handleTopLevel) {
  _handleTopLevel = handleTopLevel;
}

function setEnabled(enabled) {
  _enabled = !!enabled;
}

function isEnabled() {
  return _enabled;
}

/**
 * Traps top-level events by using event bubbling.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */
function trapBubbledEvent(topLevelType, handlerBaseName, element) {
  if (!element) {
    return null;
  }
  return EventListener.listen(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));
}

/**
 * Traps a top-level event by using event capturing.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */
function trapCapturedEvent(topLevelType, handlerBaseName, element) {
  if (!element) {
    return null;
  }
  return EventListener.capture(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));
}

function dispatchEvent(topLevelType, nativeEvent) {
  if (!_enabled) {
    return;
  }

  var nativeEventTarget = getEventTarget(nativeEvent);
  var targetInst = getClosestInstanceFromNode(nativeEventTarget);
  if (targetInst !== null && typeof targetInst.tag === 'number' && !isFiberMounted(targetInst)) {
    // If we get an event (ex: img onload) before committing that
    // component's mount, ignore it for now (that is, treat it as if it was an
    // event on a non-React tree). We might also consider queueing events and
    // dispatching them after the mount.
    targetInst = null;
  }

  var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);

  try {
    // Event queue being processed in the same cycle allows
    // `preventDefault`.
    batchedUpdates(handleTopLevelImpl, bookKeeping);
  } finally {
    releaseTopLevelCallbackBookKeeping(bookKeeping);
  }
}

var ReactDOMEventListener = Object.freeze({
	get _enabled () { return _enabled; },
	get _handleTopLevel () { return _handleTopLevel; },
	setHandleTopLevel: setHandleTopLevel,
	setEnabled: setEnabled,
	isEnabled: isEnabled,
	trapBubbledEvent: trapBubbledEvent,
	trapCapturedEvent: trapCapturedEvent,
	dispatchEvent: dispatchEvent
});

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};

  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  prefixes['ms' + styleProp] = 'MS' + eventName;
  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

  return prefixes;
}

/**
 * A list of event names to a configurable list of vendor prefixes.
 */
var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};

/**
 * Event names that have already been detected and prefixed (if applicable).
 */
var prefixedEventNames = {};

/**
 * Element to check for prefixes on.
 */
var style = {};

/**
 * Bootstrap if a DOM exists.
 */
if (ExecutionEnvironment.canUseDOM) {
  style = document.createElement('div').style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }

  // Same as above
  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return '';
}

/**
 * Types of raw signals from the browser caught at the top level.
 *
 * For events like 'submit' which don't consistently bubble (which we
 * trap at a lower node than `document`), binding at `document` would
 * cause duplicate events so we don't include them here.
 */
var topLevelTypes$1 = {
  topAbort: 'abort',
  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
  topBlur: 'blur',
  topCancel: 'cancel',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topClose: 'close',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoad: 'load',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topToggle: 'toggle',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

var BrowserEventConstants = {
  topLevelTypes: topLevelTypes$1
};

function runEventQueueInBatch(events) {
  enqueueEvents(events);
  processEventQueue(false);
}

/**
 * Streams a fired top-level event to `EventPluginHub` where plugins have the
 * opportunity to create `ReactEvent`s to be dispatched.
 */
function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
  runEventQueueInBatch(events);
}

var topLevelTypes = BrowserEventConstants.topLevelTypes;

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactDOMEventListener, which is injected and can therefore support
 *    pluggable event sources. This is the only work that occurs in the main
 *    thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var alreadyListeningTo = {};
var reactTopListenersCounter = 0;

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
 * element. The symptoms were that if your mouse is not moving over something
 * contained within that mount point (for example on the background) the
 * top-level listeners for `onmousemove` won't be called. However, if you
 * register the `mousemove` on the document object, then it will of course
 * catch all `mousemove`s. This along with iOS quirks, justifies restricting
 * top-level listeners to the document object only, at least for these
 * movement types of events and possibly all events.
 *
 * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
 *
 * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
 * they bubble to document.
 *
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @param {object} contentDocumentHandle Document which owns the container
 */
function listenTo(registrationName, contentDocumentHandle) {
  var mountAt = contentDocumentHandle;
  var isListening = getListeningForDocument(mountAt);
  var dependencies = registrationNameDependencies[registrationName];

  for (var i = 0; i < dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
      if (dependency === 'topScroll') {
        trapCapturedEvent('topScroll', 'scroll', mountAt);
      } else if (dependency === 'topFocus' || dependency === 'topBlur') {
        trapCapturedEvent('topFocus', 'focus', mountAt);
        trapCapturedEvent('topBlur', 'blur', mountAt);

        // to make sure blur and focus event listeners are only attached once
        isListening.topBlur = true;
        isListening.topFocus = true;
      } else if (dependency === 'topCancel') {
        if (isEventSupported('cancel', true)) {
          trapCapturedEvent('topCancel', 'cancel', mountAt);
        }
        isListening.topCancel = true;
      } else if (dependency === 'topClose') {
        if (isEventSupported('close', true)) {
          trapCapturedEvent('topClose', 'close', mountAt);
        }
        isListening.topClose = true;
      } else if (topLevelTypes.hasOwnProperty(dependency)) {
        trapBubbledEvent(dependency, topLevelTypes[dependency], mountAt);
      }

      isListening[dependency] = true;
    }
  }
}

function isListeningToAllDependencies(registrationName, mountAt) {
  var isListening = getListeningForDocument(mountAt);
  var dependencies = registrationNameDependencies[registrationName];
  for (var i = 0; i < dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
      return false;
    }
  }
  return true;
}

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */
function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === TEXT_NODE) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */
function getOffsets(outerNode) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode,
      anchorOffset = selection.anchorOffset,
      focusNode$$1 = selection.focusNode,
      focusOffset = selection.focusOffset;

  // In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
  // up/down buttons on an <input type="number">. Anonymous divs do not seem to
  // expose properties, triggering a "Permission denied error" if any of its
  // properties are accessed. The only seemingly possible way to avoid erroring
  // is to access a property that typically works for non-anonymous divs and
  // catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427

  try {
    /* eslint-disable no-unused-expressions */
    anchorNode.nodeType;
    focusNode$$1.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset);
}

/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */
function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset) {
  var length = 0;
  var start = -1;
  var end = -1;
  var indexWithinAnchor = 0;
  var indexWithinFocus = 0;
  var node = outerNode;
  var parentNode = null;

  outer: while (true) {
    var next = null;

    while (true) {
      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
        start = length + anchorOffset;
      }
      if (node === focusNode$$1 && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
        end = length + focusOffset;
      }

      if (node.nodeType === TEXT_NODE) {
        length += node.nodeValue.length;
      }

      if ((next = node.firstChild) === null) {
        break;
      }
      // Moving from `node` to its first child `next`.
      parentNode = node;
      node = next;
    }

    while (true) {
      if (node === outerNode) {
        // If `outerNode` has children, this is always the second time visiting
        // it. If it has no children, this is still the first loop, and the only
        // valid selection is anchorNode and focusNode both equal to this node
        // and both offsets 0, in which case we will have handled above.
        break outer;
      }
      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
        start = length;
      }
      if (parentNode === focusNode$$1 && ++indexWithinFocus === focusOffset) {
        end = length;
      }
      if ((next = node.nextSibling) !== null) {
        break;
      }
      node = parentNode;
      parentNode = node.parentNode;
    }

    // Moving from `node` to its next sibling `next`.
    node = next;
  }

  if (start === -1 || end === -1) {
    // This should never happen. (Would happen if the anchor/focus nodes aren't
    // actually inside the passed-in node.)
    return null;
  }

  return {
    start: start,
    end: end
  };
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
      return;
    }
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */

function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
}

function getSelectionInformation() {
  var focusedElem = getActiveElement();
  return {
    focusedElem: focusedElem,
    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null
  };
}

/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */
function restoreSelection(priorSelectionInformation) {
  var curFocusedElem = getActiveElement();
  var priorFocusedElem = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;
  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
    if (hasSelectionCapabilities(priorFocusedElem)) {
      setSelection(priorFocusedElem, priorSelectionRange);
    }

    // Focusing a node can change the scroll position, which is undesirable
    var ancestors = [];
    var ancestor = priorFocusedElem;
    while (ancestor = ancestor.parentNode) {
      if (ancestor.nodeType === ELEMENT_NODE) {
        ancestors.push({
          element: ancestor,
          left: ancestor.scrollLeft,
          top: ancestor.scrollTop
        });
      }
    }

    focusNode(priorFocusedElem);

    for (var i = 0; i < ancestors.length; i++) {
      var info = ancestors[i];
      info.element.scrollLeft = info.left;
      info.element.scrollTop = info.top;
    }
  }
}

/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */
function getSelection$1(input) {
  var selection = void 0;

  if ('selectionStart' in input) {
    // Modern browser with input or textarea.
    selection = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } else {
    // Content editable or old IE textarea.
    selection = getOffsets(input);
  }

  return selection || { start: 0, end: 0 };
}

/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */
function setSelection(input, offsets) {
  var start = offsets.start,
      end = offsets.end;

  if (end === undefined) {
    end = start;
  }

  if ('selectionStart' in input) {
    input.selectionStart = start;
    input.selectionEnd = Math.min(end, input.value.length);
  } else {
    setOffsets(input, offsets);
  }
}

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes$3 = {
  select: {
    phasedRegistrationNames: {
      bubbled: 'onSelect',
      captured: 'onSelectCapture'
    },
    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
  }
};

var activeElement$1 = null;
var activeElementInst$1 = null;
var lastSelection = null;
var mouseDown = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement$1);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent$1.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement$1;

    accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {
  eventTypes: eventTypes$3,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === DOCUMENT_NODE ? nativeEventTarget : nativeEventTarget.ownerDocument;
    // Track whether all listeners exists for this plugin. If none exist, we do
    // not extract events. See #3639.
    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {
      return null;
    }

    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

    switch (topLevelType) {
      // Track the input node that has focus.
      case 'topFocus':
        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
          activeElement$1 = targetNode;
          activeElementInst$1 = targetInst;
          lastSelection = null;
        }
        break;
      case 'topBlur':
        activeElement$1 = null;
        activeElementInst$1 = null;
        lastSelection = null;
        break;
      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case 'topMouseDown':
        mouseDown = true;
        break;
      case 'topContextMenu':
      case 'topMouseUp':
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);
      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case 'topSelectionChange':
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case 'topKeyDown':
      case 'topKeyUp':
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  }
};

/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */
var AnimationEventInterface = {
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */
function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  Esc: 'Escape',
  Spacebar: ' ',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Del: 'Delete',
  Win: 'OS',
  Menu: 'ContextMenu',
  Apps: 'ContextMenu',
  Scroll: 'ScrollLock',
  MozPrintableKey: 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  '8': 'Backspace',
  '9': 'Tab',
  '12': 'Clear',
  '13': 'Enter',
  '16': 'Shift',
  '17': 'Control',
  '18': 'Alt',
  '19': 'Pause',
  '20': 'CapsLock',
  '27': 'Escape',
  '32': ' ',
  '33': 'PageUp',
  '34': 'PageDown',
  '35': 'End',
  '36': 'Home',
  '37': 'ArrowLeft',
  '38': 'ArrowUp',
  '39': 'ArrowRight',
  '40': 'ArrowDown',
  '45': 'Insert',
  '46': 'Delete',
  '112': 'F1',
  '113': 'F2',
  '114': 'F3',
  '115': 'F4',
  '116': 'F5',
  '117': 'F6',
  '118': 'F7',
  '119': 'F8',
  '120': 'F9',
  '121': 'F10',
  '122': 'F11',
  '123': 'F12',
  '144': 'NumLock',
  '145': 'ScrollLock',
  '224': 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */
var TransitionEventInterface = {
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */
var eventTypes$4 = {};
var topLevelEventsToDispatchConfig = {};
['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'cancel', 'canPlay', 'canPlayThrough', 'click', 'close', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'toggle', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
  var onEvent = 'on' + capitalizedEvent;
  var topEvent = 'top' + capitalizedEvent;

  var type = {
    phasedRegistrationNames: {
      bubbled: onEvent,
      captured: onEvent + 'Capture'
    },
    dependencies: [topEvent]
  };
  eventTypes$4[event] = type;
  topLevelEventsToDispatchConfig[topEvent] = type;
});

// Only used in DEV for exhaustiveness validation.
var knownHTMLTopLevelTypes = ['topAbort', 'topCancel', 'topCanPlay', 'topCanPlayThrough', 'topClose', 'topDurationChange', 'topEmptied', 'topEncrypted', 'topEnded', 'topError', 'topInput', 'topInvalid', 'topLoad', 'topLoadedData', 'topLoadedMetadata', 'topLoadStart', 'topPause', 'topPlay', 'topPlaying', 'topProgress', 'topRateChange', 'topReset', 'topSeeked', 'topSeeking', 'topStalled', 'topSubmit', 'topSuspend', 'topTimeUpdate', 'topToggle', 'topVolumeChange', 'topWaiting'];

var SimpleEventPlugin = {
  eventTypes: eventTypes$4,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case 'topKeyPress':
        // Firefox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case 'topKeyDown':
      case 'topKeyUp':
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case 'topBlur':
      case 'topFocus':
        EventConstructor = SyntheticFocusEvent;
        break;
      case 'topClick':
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case 'topDoubleClick':
      case 'topMouseDown':
      case 'topMouseMove':
      case 'topMouseUp':
      // TODO: Disabled elements should not respond to mouse events
      /* falls through */
      case 'topMouseOut':
      case 'topMouseOver':
      case 'topContextMenu':
        EventConstructor = SyntheticMouseEvent;
        break;
      case 'topDrag':
      case 'topDragEnd':
      case 'topDragEnter':
      case 'topDragExit':
      case 'topDragLeave':
      case 'topDragOver':
      case 'topDragStart':
      case 'topDrop':
        EventConstructor = SyntheticDragEvent;
        break;
      case 'topTouchCancel':
      case 'topTouchEnd':
      case 'topTouchMove':
      case 'topTouchStart':
        EventConstructor = SyntheticTouchEvent;
        break;
      case 'topAnimationEnd':
      case 'topAnimationIteration':
      case 'topAnimationStart':
        EventConstructor = SyntheticAnimationEvent;
        break;
      case 'topTransitionEnd':
        EventConstructor = SyntheticTransitionEvent;
        break;
      case 'topScroll':
        EventConstructor = SyntheticUIEvent;
        break;
      case 'topWheel':
        EventConstructor = SyntheticWheelEvent;
        break;
      case 'topCopy':
      case 'topCut':
      case 'topPaste':
        EventConstructor = SyntheticClipboardEvent;
        break;
      default:
        {
          if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {
            warning(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);
          }
        }
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent$1;
        break;
    }
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    accumulateTwoPhaseDispatches(event);
    return event;
  }
};

setHandleTopLevel(handleTopLevel);

/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */
injection$1.injectEventPluginOrder(DOMEventPluginOrder);
injection$2.injectComponentTree(ReactDOMComponentTree);

/**
 * Some important event plugins included by default (without having to require
 * them).
 */
injection$1.injectEventPluginsByName({
  SimpleEventPlugin: SimpleEventPlugin,
  EnterLeaveEventPlugin: EnterLeaveEventPlugin,
  ChangeEventPlugin: ChangeEventPlugin,
  SelectEventPlugin: SelectEventPlugin,
  BeforeInputEventPlugin: BeforeInputEventPlugin
});

var enableAsyncSubtreeAPI = true;
var enableAsyncSchedulingByDefaultInReactDOM = false;
// Exports ReactDOM.createRoot
var enableCreateRoot = false;
var enableUserTimingAPI = true;

// Mutating mode (React DOM, React ART, React Native):
var enableMutatingReconciler = true;
// Experimental noop mode (currently unused):
var enableNoopReconciler = false;
// Experimental persistent mode (CS):
var enablePersistentReconciler = false;

// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:
var debugRenderPhaseSideEffects = false;

// Only used in www builds.

var valueStack = [];

{
  var fiberStack = [];
}

var index = -1;

function createCursor(defaultValue) {
  return {
    current: defaultValue
  };
}



function pop(cursor, fiber) {
  if (index < 0) {
    {
      warning(false, 'Unexpected pop.');
    }
    return;
  }

  {
    if (fiber !== fiberStack[index]) {
      warning(false, 'Unexpected Fiber popped.');
    }
  }

  cursor.current = valueStack[index];

  valueStack[index] = null;

  {
    fiberStack[index] = null;
  }

  index--;
}

function push(cursor, value, fiber) {
  index++;

  valueStack[index] = cursor.current;

  {
    fiberStack[index] = fiber;
  }

  cursor.current = value;
}

function reset$1() {
  while (index > -1) {
    valueStack[index] = null;

    {
      fiberStack[index] = null;
    }

    index--;
  }
}

var describeComponentFrame = function (name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
};

function describeFiber(fiber) {
  switch (fiber.tag) {
    case IndeterminateComponent:
    case FunctionalComponent:
    case ClassComponent:
    case HostComponent:
      var owner = fiber._debugOwner;
      var source = fiber._debugSource;
      var name = getComponentName(fiber);
      var ownerName = null;
      if (owner) {
        ownerName = getComponentName(owner);
      }
      return describeComponentFrame(name, source, ownerName);
    default:
      return '';
  }
}

// This function can only be called with a work-in-progress fiber and
// only during begin or complete phase. Do not call it under any other
// circumstances.
function getStackAddendumByWorkInProgressFiber(workInProgress) {
  var info = '';
  var node = workInProgress;
  do {
    info += describeFiber(node);
    // Otherwise this return pointer might point to the wrong tree:
    node = node['return'];
  } while (node);
  return info;
}

function getCurrentFiberOwnerName() {
  {
    var fiber = ReactDebugCurrentFiber.current;
    if (fiber === null) {
      return null;
    }
    var owner = fiber._debugOwner;
    if (owner !== null && typeof owner !== 'undefined') {
      return getComponentName(owner);
    }
  }
  return null;
}

function getCurrentFiberStackAddendum() {
  {
    var fiber = ReactDebugCurrentFiber.current;
    if (fiber === null) {
      return null;
    }
    // Safe because if current fiber exists, we are reconciling,
    // and it is guaranteed to be the work-in-progress version.
    return getStackAddendumByWorkInProgressFiber(fiber);
  }
  return null;
}

function resetCurrentFiber() {
  ReactDebugCurrentFrame.getCurrentStack = null;
  ReactDebugCurrentFiber.current = null;
  ReactDebugCurrentFiber.phase = null;
}

function setCurrentFiber(fiber) {
  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;
  ReactDebugCurrentFiber.current = fiber;
  ReactDebugCurrentFiber.phase = null;
}

function setCurrentPhase(phase) {
  ReactDebugCurrentFiber.phase = phase;
}

var ReactDebugCurrentFiber = {
  current: null,
  phase: null,
  resetCurrentFiber: resetCurrentFiber,
  setCurrentFiber: setCurrentFiber,
  setCurrentPhase: setCurrentPhase,
  getCurrentFiberOwnerName: getCurrentFiberOwnerName,
  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum
};

// Prefix measurements so that it's possible to filter them.
// Longer prefixes are hard to read in DevTools.
var reactEmoji = '\u269B';
var warningEmoji = '\u26D4';
var supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

// Keep track of current fiber so that we know the path to unwind on pause.
// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
var currentFiber = null;
// If we're in the middle of user code, which fiber and method is it?
// Reusing `currentFiber` would be confusing for this because user code fiber
// can change during commit phase too, but we don't need to unwind it (since
// lifecycles in the commit phase don't resemble a tree).
var currentPhase = null;
var currentPhaseFiber = null;
// Did lifecycle hook schedule an update? This is often a performance problem,
// so we will keep track of it, and include it in the report.
// Track commits caused by cascading updates.
var isCommitting = false;
var hasScheduledUpdateInCurrentCommit = false;
var hasScheduledUpdateInCurrentPhase = false;
var commitCountInCurrentWorkLoop = 0;
var effectCountInCurrentCommit = 0;
var isWaitingForCallback = false;
// During commits, we only show a measurement once per method name
// to avoid stretch the commit phase with measurement overhead.
var labelsInCurrentCommit = new Set();

var formatMarkName = function (markName) {
  return reactEmoji + ' ' + markName;
};

var formatLabel = function (label, warning$$1) {
  var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';
  var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';
  return '' + prefix + label + suffix;
};

var beginMark = function (markName) {
  performance.mark(formatMarkName(markName));
};

var clearMark = function (markName) {
  performance.clearMarks(formatMarkName(markName));
};

var endMark = function (label, markName, warning$$1) {
  var formattedMarkName = formatMarkName(markName);
  var formattedLabel = formatLabel(label, warning$$1);
  try {
    performance.measure(formattedLabel, formattedMarkName);
  } catch (err) {}
  // If previous mark was missing for some reason, this will throw.
  // This could only happen if React crashed in an unexpected place earlier.
  // Don't pile on with more errors.

  // Clear marks immediately to avoid growing buffer.
  performance.clearMarks(formattedMarkName);
  performance.clearMeasures(formattedLabel);
};

var getFiberMarkName = function (label, debugID) {
  return label + ' (#' + debugID + ')';
};

var getFiberLabel = function (componentName, isMounted, phase) {
  if (phase === null) {
    // These are composite component total time measurements.
    return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';
  } else {
    // Composite component methods.
    return componentName + '.' + phase;
  }
};

var beginFiberMark = function (fiber, phase) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);

  if (isCommitting && labelsInCurrentCommit.has(label)) {
    // During the commit phase, we don't show duplicate labels because
    // there is a fixed overhead for every measurement, and we don't
    // want to stretch the commit phase beyond necessary.
    return false;
  }
  labelsInCurrentCommit.add(label);

  var markName = getFiberMarkName(label, debugID);
  beginMark(markName);
  return true;
};

var clearFiberMark = function (fiber, phase) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);
  var markName = getFiberMarkName(label, debugID);
  clearMark(markName);
};

var endFiberMark = function (fiber, phase, warning$$1) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);
  var markName = getFiberMarkName(label, debugID);
  endMark(label, markName, warning$$1);
};

var shouldIgnoreFiber = function (fiber) {
  // Host components should be skipped in the timeline.
  // We could check typeof fiber.type, but does this work with RN?
  switch (fiber.tag) {
    case HostRoot:
    case HostComponent:
    case HostText:
    case HostPortal:
    case ReturnComponent:
    case Fragment:
      return true;
    default:
      return false;
  }
};

var clearPendingPhaseMeasurement = function () {
  if (currentPhase !== null && currentPhaseFiber !== null) {
    clearFiberMark(currentPhaseFiber, currentPhase);
  }
  currentPhaseFiber = null;
  currentPhase = null;
  hasScheduledUpdateInCurrentPhase = false;
};

var pauseTimers = function () {
  // Stops all currently active measurements so that they can be resumed
  // if we continue in a later deferred loop from the same unit of work.
  var fiber = currentFiber;
  while (fiber) {
    if (fiber._debugIsCurrentlyTiming) {
      endFiberMark(fiber, null, null);
    }
    fiber = fiber['return'];
  }
};

var resumeTimersRecursively = function (fiber) {
  if (fiber['return'] !== null) {
    resumeTimersRecursively(fiber['return']);
  }
  if (fiber._debugIsCurrentlyTiming) {
    beginFiberMark(fiber, null);
  }
};

var resumeTimers = function () {
  // Resumes all measurements that were active during the last deferred loop.
  if (currentFiber !== null) {
    resumeTimersRecursively(currentFiber);
  }
};

function recordEffect() {
  if (enableUserTimingAPI) {
    effectCountInCurrentCommit++;
  }
}

function recordScheduleUpdate() {
  if (enableUserTimingAPI) {
    if (isCommitting) {
      hasScheduledUpdateInCurrentCommit = true;
    }
    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {
      hasScheduledUpdateInCurrentPhase = true;
    }
  }
}

function startRequestCallbackTimer() {
  if (enableUserTimingAPI) {
    if (supportsUserTiming && !isWaitingForCallback) {
      isWaitingForCallback = true;
      beginMark('(Waiting for async callback...)');
    }
  }
}

function stopRequestCallbackTimer(didExpire) {
  if (enableUserTimingAPI) {
    if (supportsUserTiming) {
      isWaitingForCallback = false;
      var warning$$1 = didExpire ? 'React was blocked by main thread' : null;
      endMark('(Waiting for async callback...)', '(Waiting for async callback...)', warning$$1);
    }
  }
}

function startWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, this is the fiber to unwind from.
    currentFiber = fiber;
    if (!beginFiberMark(fiber, null)) {
      return;
    }
    fiber._debugIsCurrentlyTiming = true;
  }
}

function cancelWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // Remember we shouldn't complete measurement for this fiber.
    // Otherwise flamechart will be deep even for small updates.
    fiber._debugIsCurrentlyTiming = false;
    clearFiberMark(fiber, null);
  }
}

function stopWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, its parent is the fiber to unwind from.
    currentFiber = fiber['return'];
    if (!fiber._debugIsCurrentlyTiming) {
      return;
    }
    fiber._debugIsCurrentlyTiming = false;
    endFiberMark(fiber, null, null);
  }
}

function stopFailedWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, its parent is the fiber to unwind from.
    currentFiber = fiber['return'];
    if (!fiber._debugIsCurrentlyTiming) {
      return;
    }
    fiber._debugIsCurrentlyTiming = false;
    var warning$$1 = 'An error was thrown inside this error boundary';
    endFiberMark(fiber, null, warning$$1);
  }
}

function startPhaseTimer(fiber, phase) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    clearPendingPhaseMeasurement();
    if (!beginFiberMark(fiber, phase)) {
      return;
    }
    currentPhaseFiber = fiber;
    currentPhase = phase;
  }
}

function stopPhaseTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    if (currentPhase !== null && currentPhaseFiber !== null) {
      var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;
      endFiberMark(currentPhaseFiber, currentPhase, warning$$1);
    }
    currentPhase = null;
    currentPhaseFiber = null;
  }
}

function startWorkLoopTimer(nextUnitOfWork) {
  if (enableUserTimingAPI) {
    currentFiber = nextUnitOfWork;
    if (!supportsUserTiming) {
      return;
    }
    commitCountInCurrentWorkLoop = 0;
    // This is top level call.
    // Any other measurements are performed within.
    beginMark('(React Tree Reconciliation)');
    // Resume any measurements that were in progress during the last loop.
    resumeTimers();
  }
}

function stopWorkLoopTimer(interruptedBy) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var warning$$1 = null;
    if (interruptedBy !== null) {
      if (interruptedBy.tag === HostRoot) {
        warning$$1 = 'A top-level update interrupted the previous render';
      } else {
        var componentName = getComponentName(interruptedBy) || 'Unknown';
        warning$$1 = 'An update to ' + componentName + ' interrupted the previous render';
      }
    } else if (commitCountInCurrentWorkLoop > 1) {
      warning$$1 = 'There were cascading updates';
    }
    commitCountInCurrentWorkLoop = 0;
    // Pause any measurements until the next loop.
    pauseTimers();
    endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning$$1);
  }
}

function startCommitTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    isCommitting = true;
    hasScheduledUpdateInCurrentCommit = false;
    labelsInCurrentCommit.clear();
    beginMark('(Committing Changes)');
  }
}

function stopCommitTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }

    var warning$$1 = null;
    if (hasScheduledUpdateInCurrentCommit) {
      warning$$1 = 'Lifecycle hook scheduled a cascading update';
    } else if (commitCountInCurrentWorkLoop > 0) {
      warning$$1 = 'Caused by a cascading update in earlier commit';
    }
    hasScheduledUpdateInCurrentCommit = false;
    commitCountInCurrentWorkLoop++;
    isCommitting = false;
    labelsInCurrentCommit.clear();

    endMark('(Committing Changes)', '(Committing Changes)', warning$$1);
  }
}

function startCommitHostEffectsTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Committing Host Effects)');
  }
}

function stopCommitHostEffectsTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);
  }
}

function startCommitLifeCyclesTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Calling Lifecycle Methods)');
  }
}

function stopCommitLifeCyclesTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);
  }
}

{
  var warnedAboutMissingGetChildContext = {};
}

// A cursor to the current merged context object on the stack.
var contextStackCursor = createCursor(emptyObject);
// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor = createCursor(false);
// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext = emptyObject;

function getUnmaskedContext(workInProgress) {
  var hasOwnContext = isContextProvider(workInProgress);
  if (hasOwnContext) {
    // If the fiber is a context provider itself, when we read its context
    // we have already pushed its own child context on the stack. A context
    // provider should not "see" its own child context. Therefore we read the
    // previous (parent) context instead for a context provider.
    return previousContext;
  }
  return contextStackCursor.current;
}

function cacheContext(workInProgress, unmaskedContext, maskedContext) {
  var instance = workInProgress.stateNode;
  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
}

function getMaskedContext(workInProgress, unmaskedContext) {
  var type = workInProgress.type;
  var contextTypes = type.contextTypes;
  if (!contextTypes) {
    return emptyObject;
  }

  // Avoid recreating masked context unless unmasked context has changed.
  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
  // This may trigger infinite loops if componentWillReceiveProps calls setState.
  var instance = workInProgress.stateNode;
  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
    return instance.__reactInternalMemoizedMaskedChildContext;
  }

  var context = {};
  for (var key in contextTypes) {
    context[key] = unmaskedContext[key];
  }

  {
    var name = getComponentName(workInProgress) || 'Unknown';
    checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
  }

  // Cache unmasked context so we can avoid recreating masked context unless necessary.
  // Context is created before the class component is instantiated so check for instance.
  if (instance) {
    cacheContext(workInProgress, unmaskedContext, context);
  }

  return context;
}

function hasContextChanged() {
  return didPerformWorkStackCursor.current;
}

function isContextConsumer(fiber) {
  return fiber.tag === ClassComponent && fiber.type.contextTypes != null;
}

function isContextProvider(fiber) {
  return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;
}

function popContextProvider(fiber) {
  if (!isContextProvider(fiber)) {
    return;
  }

  pop(didPerformWorkStackCursor, fiber);
  pop(contextStackCursor, fiber);
}

function popTopLevelContextObject(fiber) {
  pop(didPerformWorkStackCursor, fiber);
  pop(contextStackCursor, fiber);
}

function pushTopLevelContextObject(fiber, context, didChange) {
  !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  push(contextStackCursor, context, fiber);
  push(didPerformWorkStackCursor, didChange, fiber);
}

function processChildContext(fiber, parentContext) {
  var instance = fiber.stateNode;
  var childContextTypes = fiber.type.childContextTypes;

  // TODO (bvaughn) Replace this behavior with an invariant() in the future.
  // It has only been added in Fiber to match the (unintentional) behavior in Stack.
  if (typeof instance.getChildContext !== 'function') {
    {
      var componentName = getComponentName(fiber) || 'Unknown';

      if (!warnedAboutMissingGetChildContext[componentName]) {
        warnedAboutMissingGetChildContext[componentName] = true;
        warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);
      }
    }
    return parentContext;
  }

  var childContext = void 0;
  {
    ReactDebugCurrentFiber.setCurrentPhase('getChildContext');
  }
  startPhaseTimer(fiber, 'getChildContext');
  childContext = instance.getChildContext();
  stopPhaseTimer();
  {
    ReactDebugCurrentFiber.setCurrentPhase(null);
  }
  for (var contextKey in childContext) {
    !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;
  }
  {
    var name = getComponentName(fiber) || 'Unknown';
    checkPropTypes(childContextTypes, childContext, 'child context', name,
    // In practice, there is one case in which we won't get a stack. It's when
    // somebody calls unstable_renderSubtreeIntoContainer() and we process
    // context from the parent component instance. The stack will be missing
    // because it's outside of the reconciliation, and so the pointer has not
    // been set. This is rare and doesn't matter. We'll also remove that API.
    ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
  }

  return _assign({}, parentContext, childContext);
}

function pushContextProvider(workInProgress) {
  if (!isContextProvider(workInProgress)) {
    return false;
  }

  var instance = workInProgress.stateNode;
  // We push the context as early as possible to ensure stack integrity.
  // If the instance does not exist yet, we will push null at first,
  // and replace it on the stack later when invalidating the context.
  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;

  // Remember the parent context so we can merge with it later.
  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
  previousContext = contextStackCursor.current;
  push(contextStackCursor, memoizedMergedChildContext, workInProgress);
  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);

  return true;
}

function invalidateContextProvider(workInProgress, didChange) {
  var instance = workInProgress.stateNode;
  !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  if (didChange) {
    // Merge parent and own context.
    // Skip this if we're not updating due to sCU.
    // This avoids unnecessarily recomputing memoized values.
    var mergedContext = processChildContext(workInProgress, previousContext);
    instance.__reactInternalMemoizedMergedChildContext = mergedContext;

    // Replace the old (or empty) context with the new one.
    // It is important to unwind the context in the reverse order.
    pop(didPerformWorkStackCursor, workInProgress);
    pop(contextStackCursor, workInProgress);
    // Now push the new context and mark that it has changed.
    push(contextStackCursor, mergedContext, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  } else {
    pop(didPerformWorkStackCursor, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  }
}

function resetContext() {
  previousContext = emptyObject;
  contextStackCursor.current = emptyObject;
  didPerformWorkStackCursor.current = false;
}

function findCurrentUnmaskedContext(fiber) {
  // Currently this is only used with renderSubtreeIntoContainer; not sure if it
  // makes sense elsewhere
  !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  var node = fiber;
  while (node.tag !== HostRoot) {
    if (isContextProvider(node)) {
      return node.stateNode.__reactInternalMemoizedMergedChildContext;
    }
    var parent = node['return'];
    !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    node = parent;
  }
  return node.stateNode.context;
}

var NoWork = 0; // TODO: Use an opaque type once ESLint et al support the syntax

var Sync = 1;
var Never = 2147483647; // Max int32: Math.pow(2, 31) - 1

var UNIT_SIZE = 10;
var MAGIC_NUMBER_OFFSET = 2;

// 1 unit of expiration time represents 10ms.
function msToExpirationTime(ms) {
  // Always add an offset so that we don't clash with the magic number for NoWork.
  return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;
}

function expirationTimeToMs(expirationTime) {
  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;
}

function ceiling(num, precision) {
  return ((num / precision | 0) + 1) * precision;
}

function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
  return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
}

var NoContext = 0;
var AsyncUpdates = 1;

{
  var hasBadMapPolyfill = false;
  try {
    var nonExtensibleObject = Object.preventExtensions({});
    /* eslint-disable no-new */
    
    /* eslint-enable no-new */
  } catch (e) {
    // TODO: Consider warning about bad polyfills
    hasBadMapPolyfill = true;
  }
}

// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.


{
  var debugCounter = 1;
}

function FiberNode(tag, key, internalContextTag) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  // Fiber
  this['return'] = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;

  this.pendingProps = null;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.internalContextTag = internalContextTag;

  // Effects
  this.effectTag = NoEffect;
  this.nextEffect = null;

  this.firstEffect = null;
  this.lastEffect = null;

  this.expirationTime = NoWork;

  this.alternate = null;

  {
    this._debugID = debugCounter++;
    this._debugSource = null;
    this._debugOwner = null;
    this._debugIsCurrentlyTiming = false;
    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
      Object.preventExtensions(this);
    }
  }
}

// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber = function (tag, key, internalContextTag) {
  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
  return new FiberNode(tag, key, internalContextTag);
};

function shouldConstruct(Component) {
  return !!(Component.prototype && Component.prototype.isReactComponent);
}

// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current, pendingProps, expirationTime) {
  var workInProgress = current.alternate;
  if (workInProgress === null) {
    // We use a double buffering pooling technique because we know that we'll
    // only ever need at most two versions of a tree. We pool the "other" unused
    // node that we're free to reuse. This is lazily created to avoid allocating
    // extra objects for things that are never updated. It also allow us to
    // reclaim the extra memory if needed.
    workInProgress = createFiber(current.tag, current.key, current.internalContextTag);
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;

    {
      // DEV-only fields
      workInProgress._debugID = current._debugID;
      workInProgress._debugSource = current._debugSource;
      workInProgress._debugOwner = current._debugOwner;
    }

    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    // We already have an alternate.
    // Reset the effect tag.
    workInProgress.effectTag = NoEffect;

    // The effect list is no longer valid.
    workInProgress.nextEffect = null;
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;
  }

  workInProgress.expirationTime = expirationTime;
  workInProgress.pendingProps = pendingProps;

  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;

  // These will be overridden during the parent's reconciliation
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;

  return workInProgress;
}

function createHostRootFiber() {
  var fiber = createFiber(HostRoot, null, NoContext);
  return fiber;
}

function createFiberFromElement(element, internalContextTag, expirationTime) {
  var owner = null;
  {
    owner = element._owner;
  }

  var fiber = void 0;
  var type = element.type,
      key = element.key;

  if (typeof type === 'function') {
    fiber = shouldConstruct(type) ? createFiber(ClassComponent, key, internalContextTag) : createFiber(IndeterminateComponent, key, internalContextTag);
    fiber.type = type;
    fiber.pendingProps = element.props;
  } else if (typeof type === 'string') {
    fiber = createFiber(HostComponent, key, internalContextTag);
    fiber.type = type;
    fiber.pendingProps = element.props;
  } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {
    // Currently assumed to be a continuation and therefore is a fiber already.
    // TODO: The yield system is currently broken for updates in some cases.
    // The reified yield stores a fiber, but we don't know which fiber that is;
    // the current or a workInProgress? When the continuation gets rendered here
    // we don't know if we can reuse that fiber or if we need to clone it.
    // There is probably a clever way to restructure this.
    fiber = type;
    fiber.pendingProps = element.props;
  } else {
    var info = '';
    {
      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }
      var ownerName = owner ? getComponentName(owner) : null;
      if (ownerName) {
        info += '\n\nCheck the render method of `' + ownerName + '`.';
      }
    }
    invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);
  }

  {
    fiber._debugSource = element._source;
    fiber._debugOwner = element._owner;
  }

  fiber.expirationTime = expirationTime;

  return fiber;
}

function createFiberFromFragment(elements, internalContextTag, expirationTime, key) {
  var fiber = createFiber(Fragment, key, internalContextTag);
  fiber.pendingProps = elements;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromText(content, internalContextTag, expirationTime) {
  var fiber = createFiber(HostText, null, internalContextTag);
  fiber.pendingProps = content;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromHostInstanceForDeletion() {
  var fiber = createFiber(HostComponent, null, NoContext);
  fiber.type = 'DELETED';
  return fiber;
}

function createFiberFromCall(call, internalContextTag, expirationTime) {
  var fiber = createFiber(CallComponent, call.key, internalContextTag);
  fiber.type = call.handler;
  fiber.pendingProps = call;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromReturn(returnNode, internalContextTag, expirationTime) {
  var fiber = createFiber(ReturnComponent, null, internalContextTag);
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromPortal(portal, internalContextTag, expirationTime) {
  var fiber = createFiber(HostPortal, portal.key, internalContextTag);
  fiber.pendingProps = portal.children || [];
  fiber.expirationTime = expirationTime;
  fiber.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null, // Used by persistent updates
    implementation: portal.implementation
  };
  return fiber;
}

function createFiberRoot(containerInfo, hydrate) {
  // Cyclic construction. This cheats the type system right now because
  // stateNode is any.
  var uninitializedFiber = createHostRootFiber();
  var root = {
    current: uninitializedFiber,
    containerInfo: containerInfo,
    pendingChildren: null,
    remainingExpirationTime: NoWork,
    isReadyForCommit: false,
    finishedWork: null,
    context: null,
    pendingContext: null,
    hydrate: hydrate,
    nextScheduledRoot: null
  };
  uninitializedFiber.stateNode = root;
  return root;
}

var onCommitFiberRoot = null;
var onCommitFiberUnmount = null;
var hasLoggedError = false;

function catchErrors(fn) {
  return function (arg) {
    try {
      return fn(arg);
    } catch (err) {
      if (true && !hasLoggedError) {
        hasLoggedError = true;
        warning(false, 'React DevTools encountered an error: %s', err);
      }
    }
  };
}

function injectInternals(internals) {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
    // No DevTools
    return false;
  }
  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (hook.isDisabled) {
    // This isn't a real property on the hook, but it can be set to opt out
    // of DevTools integration and associated warnings and logs.
    // https://github.com/facebook/react/issues/3877
    return true;
  }
  if (!hook.supportsFiber) {
    {
      warning(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');
    }
    // DevTools exists, even though it doesn't support Fiber.
    return true;
  }
  try {
    var rendererID = hook.inject(internals);
    // We have successfully injected, so now it is safe to set up hooks.
    onCommitFiberRoot = catchErrors(function (root) {
      return hook.onCommitFiberRoot(rendererID, root);
    });
    onCommitFiberUnmount = catchErrors(function (fiber) {
      return hook.onCommitFiberUnmount(rendererID, fiber);
    });
  } catch (err) {
    // Catch all errors because it is unsafe to throw during initialization.
    {
      warning(false, 'React DevTools encountered an error: %s.', err);
    }
  }
  // DevTools exists
  return true;
}

function onCommitRoot(root) {
  if (typeof onCommitFiberRoot === 'function') {
    onCommitFiberRoot(root);
  }
}

function onCommitUnmount(fiber) {
  if (typeof onCommitFiberUnmount === 'function') {
    onCommitFiberUnmount(fiber);
  }
}

{
  var didWarnUpdateInsideUpdate = false;
}

// Callbacks are not validated until invocation


// Singly linked-list of updates. When an update is scheduled, it is added to
// the queue of the current fiber and the work-in-progress fiber. The two queues
// are separate but they share a persistent structure.
//
// During reconciliation, updates are removed from the work-in-progress fiber,
// but they remain on the current fiber. That ensures that if a work-in-progress
// is aborted, the aborted updates are recovered by cloning from current.
//
// The work-in-progress queue is always a subset of the current queue.
//
// When the tree is committed, the work-in-progress becomes the current.


function createUpdateQueue(baseState) {
  var queue = {
    baseState: baseState,
    expirationTime: NoWork,
    first: null,
    last: null,
    callbackList: null,
    hasForceUpdate: false,
    isInitialized: false
  };
  {
    queue.isProcessing = false;
  }
  return queue;
}

function insertUpdateIntoQueue(queue, update) {
  // Append the update to the end of the list.
  if (queue.last === null) {
    // Queue is empty
    queue.first = queue.last = update;
  } else {
    queue.last.next = update;
    queue.last = update;
  }
  if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {
    queue.expirationTime = update.expirationTime;
  }
}

function insertUpdateIntoFiber(fiber, update) {
  // We'll have at least one and at most two distinct update queues.
  var alternateFiber = fiber.alternate;
  var queue1 = fiber.updateQueue;
  if (queue1 === null) {
    // TODO: We don't know what the base state will be until we begin work.
    // It depends on which fiber is the next current. Initialize with an empty
    // base state, then set to the memoizedState when rendering. Not super
    // happy with this approach.
    queue1 = fiber.updateQueue = createUpdateQueue(null);
  }

  var queue2 = void 0;
  if (alternateFiber !== null) {
    queue2 = alternateFiber.updateQueue;
    if (queue2 === null) {
      queue2 = alternateFiber.updateQueue = createUpdateQueue(null);
    }
  } else {
    queue2 = null;
  }
  queue2 = queue2 !== queue1 ? queue2 : null;

  // Warn if an update is scheduled from inside an updater function.
  {
    if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {
      warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');
      didWarnUpdateInsideUpdate = true;
    }
  }

  // If there's only one queue, add the update to that queue and exit.
  if (queue2 === null) {
    insertUpdateIntoQueue(queue1, update);
    return;
  }

  // If either queue is empty, we need to add to both queues.
  if (queue1.last === null || queue2.last === null) {
    insertUpdateIntoQueue(queue1, update);
    insertUpdateIntoQueue(queue2, update);
    return;
  }

  // If both lists are not empty, the last update is the same for both lists
  // because of structural sharing. So, we should only append to one of
  // the lists.
  insertUpdateIntoQueue(queue1, update);
  // But we still need to update the `last` pointer of queue2.
  queue2.last = update;
}

function getUpdateExpirationTime(fiber) {
  if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {
    return NoWork;
  }
  var updateQueue = fiber.updateQueue;
  if (updateQueue === null) {
    return NoWork;
  }
  return updateQueue.expirationTime;
}

function getStateFromUpdate(update, instance, prevState, props) {
  var partialState = update.partialState;
  if (typeof partialState === 'function') {
    var updateFn = partialState;

    // Invoke setState callback an extra time to help detect side-effects.
    if (debugRenderPhaseSideEffects) {
      updateFn.call(instance, prevState, props);
    }

    return updateFn.call(instance, prevState, props);
  } else {
    return partialState;
  }
}

function processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {
  if (current !== null && current.updateQueue === queue) {
    // We need to create a work-in-progress queue, by cloning the current queue.
    var currentQueue = queue;
    queue = workInProgress.updateQueue = {
      baseState: currentQueue.baseState,
      expirationTime: currentQueue.expirationTime,
      first: currentQueue.first,
      last: currentQueue.last,
      isInitialized: currentQueue.isInitialized,
      // These fields are no longer valid because they were already committed.
      // Reset them.
      callbackList: null,
      hasForceUpdate: false
    };
  }

  {
    // Set this flag so we can warn if setState is called inside the update
    // function of another setState.
    queue.isProcessing = true;
  }

  // Reset the remaining expiration time. If we skip over any updates, we'll
  // increase this accordingly.
  queue.expirationTime = NoWork;

  // TODO: We don't know what the base state will be until we begin work.
  // It depends on which fiber is the next current. Initialize with an empty
  // base state, then set to the memoizedState when rendering. Not super
  // happy with this approach.
  var state = void 0;
  if (queue.isInitialized) {
    state = queue.baseState;
  } else {
    state = queue.baseState = workInProgress.memoizedState;
    queue.isInitialized = true;
  }
  var dontMutatePrevState = true;
  var update = queue.first;
  var didSkip = false;
  while (update !== null) {
    var updateExpirationTime = update.expirationTime;
    if (updateExpirationTime > renderExpirationTime) {
      // This update does not have sufficient priority. Skip it.
      var remainingExpirationTime = queue.expirationTime;
      if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {
        // Update the remaining expiration time.
        queue.expirationTime = updateExpirationTime;
      }
      if (!didSkip) {
        didSkip = true;
        queue.baseState = state;
      }
      // Continue to the next update.
      update = update.next;
      continue;
    }

    // This update does have sufficient priority.

    // If no previous updates were skipped, drop this update from the queue by
    // advancing the head of the list.
    if (!didSkip) {
      queue.first = update.next;
      if (queue.first === null) {
        queue.last = null;
      }
    }

    // Process the update
    var _partialState = void 0;
    if (update.isReplace) {
      state = getStateFromUpdate(update, instance, state, props);
      dontMutatePrevState = true;
    } else {
      _partialState = getStateFromUpdate(update, instance, state, props);
      if (_partialState) {
        if (dontMutatePrevState) {
          // $FlowFixMe: Idk how to type this properly.
          state = _assign({}, state, _partialState);
        } else {
          state = _assign(state, _partialState);
        }
        dontMutatePrevState = false;
      }
    }
    if (update.isForced) {
      queue.hasForceUpdate = true;
    }
    if (update.callback !== null) {
      // Append to list of callbacks.
      var _callbackList = queue.callbackList;
      if (_callbackList === null) {
        _callbackList = queue.callbackList = [];
      }
      _callbackList.push(update);
    }
    update = update.next;
  }

  if (queue.callbackList !== null) {
    workInProgress.effectTag |= Callback;
  } else if (queue.first === null && !queue.hasForceUpdate) {
    // The queue is empty. We can reset it.
    workInProgress.updateQueue = null;
  }

  if (!didSkip) {
    didSkip = true;
    queue.baseState = state;
  }

  {
    // No longer processing.
    queue.isProcessing = false;
  }

  return state;
}

function commitCallbacks(queue, context) {
  var callbackList = queue.callbackList;
  if (callbackList === null) {
    return;
  }
  // Set the list to null to make sure they don't get called more than once.
  queue.callbackList = null;
  for (var i = 0; i < callbackList.length; i++) {
    var update = callbackList[i];
    var _callback = update.callback;
    // This update might be processed again. Clear the callback so it's only
    // called once.
    update.callback = null;
    !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;
    _callback.call(context);
  }
}

var fakeInternalInstance = {};
var isArray = Array.isArray;

{
  var didWarnAboutStateAssignmentForComponent = {};

  var warnOnInvalidCallback = function (callback, callerName) {
    warning(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
  };

  // This is so gross but it's at least non-critical and can be removed if
  // it causes problems. This is meant to give a nicer error message for
  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
  // ...)) which otherwise throws a "_processChildContext is not a function"
  // exception.
  Object.defineProperty(fakeInternalInstance, '_processChildContext', {
    enumerable: false,
    value: function () {
      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');
    }
  });
  Object.freeze(fakeInternalInstance);
}

var ReactFiberClassComponent = function (scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {
  // Class component state updater
  var updater = {
    isMounted: isMounted,
    enqueueSetState: function (instance, partialState, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'setState');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: partialState,
        callback: callback,
        isReplace: false,
        isForced: false,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    },
    enqueueReplaceState: function (instance, state, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'replaceState');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: state,
        callback: callback,
        isReplace: true,
        isForced: false,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    },
    enqueueForceUpdate: function (instance, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'forceUpdate');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: null,
        callback: callback,
        isReplace: false,
        isForced: true,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    }
  };

  function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {
    if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {
      // If the workInProgress already has an Update effect, return true
      return true;
    }

    var instance = workInProgress.stateNode;
    var type = workInProgress.type;
    if (typeof instance.shouldComponentUpdate === 'function') {
      startPhaseTimer(workInProgress, 'shouldComponentUpdate');
      var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);
      stopPhaseTimer();

      // Simulate an async bailout/interruption by invoking lifecycle twice.
      if (debugRenderPhaseSideEffects) {
        instance.shouldComponentUpdate(newProps, newState, newContext);
      }

      {
        warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Unknown');
      }

      return shouldUpdate;
    }

    if (type.prototype && type.prototype.isPureReactComponent) {
      return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
    }

    return true;
  }

  function checkClassInstance(workInProgress) {
    var instance = workInProgress.stateNode;
    var type = workInProgress.type;
    {
      var name = getComponentName(workInProgress);
      var renderPresent = instance.render;

      if (!renderPresent) {
        if (type.prototype && typeof type.prototype.render === 'function') {
          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);
        } else {
          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);
        }
      }

      var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;
      warning(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);
      var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;
      warning(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);
      var noInstancePropTypes = !instance.propTypes;
      warning(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);
      var noInstanceContextTypes = !instance.contextTypes;
      warning(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);
      var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';
      warning(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);
      if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {
        warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');
      }
      var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';
      warning(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);
      var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';
      warning(noComponentDidReceiveProps, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);
      var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';
      warning(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);
      var hasMutatedProps = instance.props !== workInProgress.pendingProps;
      warning(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", name, name);
      var noInstanceDefaultProps = !instance.defaultProps;
      warning(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);
    }

    var state = instance.state;
    if (state && (typeof state !== 'object' || isArray(state))) {
      warning(false, '%s.state: must be set to an object or null', getComponentName(workInProgress));
    }
    if (typeof instance.getChildContext === 'function') {
      warning(typeof workInProgress.type.childContextTypes === 'object', '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', getComponentName(workInProgress));
    }
  }

  function resetInputPointers(workInProgress, instance) {
    instance.props = workInProgress.memoizedProps;
    instance.state = workInProgress.memoizedState;
  }

  function adoptClassInstance(workInProgress, instance) {
    instance.updater = updater;
    workInProgress.stateNode = instance;
    // The instance needs access to the fiber so that it can schedule updates
    set(instance, workInProgress);
    {
      instance._reactInternalInstance = fakeInternalInstance;
    }
  }

  function constructClassInstance(workInProgress, props) {
    var ctor = workInProgress.type;
    var unmaskedContext = getUnmaskedContext(workInProgress);
    var needsContext = isContextConsumer(workInProgress);
    var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;
    var instance = new ctor(props, context);
    adoptClassInstance(workInProgress, instance);

    // Cache unmasked context so we can avoid recreating masked context unless necessary.
    // ReactFiberContext usually updates this cache but can't for newly-created instances.
    if (needsContext) {
      cacheContext(workInProgress, unmaskedContext, context);
    }

    return instance;
  }

  function callComponentWillMount(workInProgress, instance) {
    startPhaseTimer(workInProgress, 'componentWillMount');
    var oldState = instance.state;
    instance.componentWillMount();
    stopPhaseTimer();

    // Simulate an async bailout/interruption by invoking lifecycle twice.
    if (debugRenderPhaseSideEffects) {
      instance.componentWillMount();
    }

    if (oldState !== instance.state) {
      {
        warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + "deprecated (except inside a component's " + 'constructor). Use setState instead.', getComponentName(workInProgress));
      }
      updater.enqueueReplaceState(instance, instance.state, null);
    }
  }

  function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {
    startPhaseTimer(workInProgress, 'componentWillReceiveProps');
    var oldState = instance.state;
    instance.componentWillReceiveProps(newProps, newContext);
    stopPhaseTimer();

    // Simulate an async bailout/interruption by invoking lifecycle twice.
    if (debugRenderPhaseSideEffects) {
      instance.componentWillReceiveProps(newProps, newContext);
    }

    if (instance.state !== oldState) {
      {
        var componentName = getComponentName(workInProgress) || 'Component';
        if (!didWarnAboutStateAssignmentForComponent[componentName]) {
          warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + "this.state is deprecated (except inside a component's " + 'constructor). Use setState instead.', componentName);
          didWarnAboutStateAssignmentForComponent[componentName] = true;
        }
      }
      updater.enqueueReplaceState(instance, instance.state, null);
    }
  }

  // Invokes the mount life-cycles on a previously never rendered instance.
  function mountClassInstance(workInProgress, renderExpirationTime) {
    var current = workInProgress.alternate;

    {
      checkClassInstance(workInProgress);
    }

    var instance = workInProgress.stateNode;
    var state = instance.state || null;

    var props = workInProgress.pendingProps;
    !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    var unmaskedContext = getUnmaskedContext(workInProgress);

    instance.props = props;
    instance.state = workInProgress.memoizedState = state;
    instance.refs = emptyObject;
    instance.context = getMaskedContext(workInProgress, unmaskedContext);

    if (enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {
      workInProgress.internalContextTag |= AsyncUpdates;
    }

    if (typeof instance.componentWillMount === 'function') {
      callComponentWillMount(workInProgress, instance);
      // If we had additional state updates during this life-cycle, let's
      // process them now.
      var updateQueue = workInProgress.updateQueue;
      if (updateQueue !== null) {
        instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);
      }
    }
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.effectTag |= Update;
    }
  }

  // Called on a preexisting class instance. Returns false if a resumed render
  // could be reused.
  // function resumeMountClassInstance(
  //   workInProgress: Fiber,
  //   priorityLevel: PriorityLevel,
  // ): boolean {
  //   const instance = workInProgress.stateNode;
  //   resetInputPointers(workInProgress, instance);

  //   let newState = workInProgress.memoizedState;
  //   let newProps = workInProgress.pendingProps;
  //   if (!newProps) {
  //     // If there isn't any new props, then we'll reuse the memoized props.
  //     // This could be from already completed work.
  //     newProps = workInProgress.memoizedProps;
  //     invariant(
  //       newProps != null,
  //       'There should always be pending or memoized props. This error is ' +
  //         'likely caused by a bug in React. Please file an issue.',
  //     );
  //   }
  //   const newUnmaskedContext = getUnmaskedContext(workInProgress);
  //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);

  //   const oldContext = instance.context;
  //   const oldProps = workInProgress.memoizedProps;

  //   if (
  //     typeof instance.componentWillReceiveProps === 'function' &&
  //     (oldProps !== newProps || oldContext !== newContext)
  //   ) {
  //     callComponentWillReceiveProps(
  //       workInProgress,
  //       instance,
  //       newProps,
  //       newContext,
  //     );
  //   }

  //   // Process the update queue before calling shouldComponentUpdate
  //   const updateQueue = workInProgress.updateQueue;
  //   if (updateQueue !== null) {
  //     newState = processUpdateQueue(
  //       workInProgress,
  //       updateQueue,
  //       instance,
  //       newState,
  //       newProps,
  //       priorityLevel,
  //     );
  //   }

  //   // TODO: Should we deal with a setState that happened after the last
  //   // componentWillMount and before this componentWillMount? Probably
  //   // unsupported anyway.

  //   if (
  //     !checkShouldComponentUpdate(
  //       workInProgress,
  //       workInProgress.memoizedProps,
  //       newProps,
  //       workInProgress.memoizedState,
  //       newState,
  //       newContext,
  //     )
  //   ) {
  //     // Update the existing instance's state, props, and context pointers even
  //     // though we're bailing out.
  //     instance.props = newProps;
  //     instance.state = newState;
  //     instance.context = newContext;
  //     return false;
  //   }

  //   // Update the input pointers now so that they are correct when we call
  //   // componentWillMount
  //   instance.props = newProps;
  //   instance.state = newState;
  //   instance.context = newContext;

  //   if (typeof instance.componentWillMount === 'function') {
  //     callComponentWillMount(workInProgress, instance);
  //     // componentWillMount may have called setState. Process the update queue.
  //     const newUpdateQueue = workInProgress.updateQueue;
  //     if (newUpdateQueue !== null) {
  //       newState = processUpdateQueue(
  //         workInProgress,
  //         newUpdateQueue,
  //         instance,
  //         newState,
  //         newProps,
  //         priorityLevel,
  //       );
  //     }
  //   }

  //   if (typeof instance.componentDidMount === 'function') {
  //     workInProgress.effectTag |= Update;
  //   }

  //   instance.state = newState;

  //   return true;
  // }

  // Invokes the update life-cycles and returns false if it shouldn't rerender.
  function updateClassInstance(current, workInProgress, renderExpirationTime) {
    var instance = workInProgress.stateNode;
    resetInputPointers(workInProgress, instance);

    var oldProps = workInProgress.memoizedProps;
    var newProps = workInProgress.pendingProps;
    if (!newProps) {
      // If there aren't any new props, then we'll reuse the memoized props.
      // This could be from already completed work.
      newProps = oldProps;
      !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    }
    var oldContext = instance.context;
    var newUnmaskedContext = getUnmaskedContext(workInProgress);
    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);

    // Note: During these life-cycles, instance.props/instance.state are what
    // ever the previously attempted to render - not the "current". However,
    // during componentDidUpdate we pass the "current" props.

    if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {
      callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);
    }

    // Compute the next state using the memoized state and the update queue.
    var oldState = workInProgress.memoizedState;
    // TODO: Previous state can be null.
    var newState = void 0;
    if (workInProgress.updateQueue !== null) {
      newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);
    } else {
      newState = oldState;
    }

    if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {
      // If an update was already in progress, we should schedule an Update
      // effect even though we're bailing out, so that cWU/cDU are called.
      if (typeof instance.componentDidUpdate === 'function') {
        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
          workInProgress.effectTag |= Update;
        }
      }
      return false;
    }

    var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);

    if (shouldUpdate) {
      if (typeof instance.componentWillUpdate === 'function') {
        startPhaseTimer(workInProgress, 'componentWillUpdate');
        instance.componentWillUpdate(newProps, newState, newContext);
        stopPhaseTimer();

        // Simulate an async bailout/interruption by invoking lifecycle twice.
        if (debugRenderPhaseSideEffects) {
          instance.componentWillUpdate(newProps, newState, newContext);
        }
      }
      if (typeof instance.componentDidUpdate === 'function') {
        workInProgress.effectTag |= Update;
      }
    } else {
      // If an update was already in progress, we should schedule an Update
      // effect even though we're bailing out, so that cWU/cDU are called.
      if (typeof instance.componentDidUpdate === 'function') {
        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
          workInProgress.effectTag |= Update;
        }
      }

      // If shouldComponentUpdate returned false, we should still update the
      // memoized props/state to indicate that this work can be reused.
      memoizeProps(workInProgress, newProps);
      memoizeState(workInProgress, newState);
    }

    // Update the existing instance's state, props, and context pointers even
    // if shouldComponentUpdate returns false.
    instance.props = newProps;
    instance.state = newState;
    instance.context = newContext;

    return shouldUpdate;
  }

  return {
    adoptClassInstance: adoptClassInstance,
    constructClassInstance: constructClassInstance,
    mountClassInstance: mountClassInstance,
    // resumeMountClassInstance,
    updateClassInstance: updateClassInstance
  };
};

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol['for'];

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable === 'undefined') {
    return null;
  }
  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }
  return null;
}

var getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;


{
  var didWarnAboutMaps = false;
  /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */
  var ownerHasKeyUseWarning = {};
  var ownerHasFunctionTypeWarning = {};

  var warnForMissingKey = function (child) {
    if (child === null || typeof child !== 'object') {
      return;
    }
    if (!child._store || child._store.validated || child.key != null) {
      return;
    }
    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    child._store.validated = true;

    var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$1() || '');
    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }
    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

    warning(false, 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$1());
  };
}

var isArray$1 = Array.isArray;

function coerceRef(current, element) {
  var mixedRef = element.ref;
  if (mixedRef !== null && typeof mixedRef !== 'function') {
    if (element._owner) {
      var owner = element._owner;
      var inst = void 0;
      if (owner) {
        var ownerFiber = owner;
        !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;
        inst = ownerFiber.stateNode;
      }
      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;
      var stringRef = '' + mixedRef;
      // Check if previous string ref matches new string ref
      if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {
        return current.ref;
      }
      var ref = function (value) {
        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
        if (value === null) {
          delete refs[stringRef];
        } else {
          refs[stringRef] = value;
        }
      };
      ref._stringRef = stringRef;
      return ref;
    } else {
      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;
      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;
    }
  }
  return mixedRef;
}

function throwOnInvalidObjectType(returnFiber, newChild) {
  if (returnFiber.type !== 'textarea') {
    var addendum = '';
    {
      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$1() || '');
    }
    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);
  }
}

function warnOnFunctionType() {
  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$1() || '');

  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;

  warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$1() || '');
}

// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return;
    }
    // Deletions are added in reversed order so we add it to the front.
    // At this point, the return fiber's effect list is empty except for
    // deletions, so we can just append the deletion to the list. The remaining
    // effects aren't added until the complete phase. Once we implement
    // resuming, this may not be true.
    var last = returnFiber.lastEffect;
    if (last !== null) {
      last.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }
    childToDelete.nextEffect = null;
    childToDelete.effectTag = Deletion;
  }

  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return null;
    }

    // TODO: For the shouldClone case, this could be micro-optimized a bit by
    // assuming that after the first child we've already added everything.
    var childToDelete = currentFirstChild;
    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }
    return null;
  }

  function mapRemainingChildren(returnFiber, currentFirstChild) {
    // Add the remaining children to a temporary map so that we can find them by
    // keys quickly. Implicit (null) keys get added to this set with their index
    var existingChildren = new Map();

    var existingChild = currentFirstChild;
    while (existingChild !== null) {
      if (existingChild.key !== null) {
        existingChildren.set(existingChild.key, existingChild);
      } else {
        existingChildren.set(existingChild.index, existingChild);
      }
      existingChild = existingChild.sibling;
    }
    return existingChildren;
  }

  function useFiber(fiber, pendingProps, expirationTime) {
    // We currently set sibling to null and index to 0 here because it is easy
    // to forget to do before returning it. E.g. for the single child case.
    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }

  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects) {
      // Noop.
      return lastPlacedIndex;
    }
    var current = newFiber.alternate;
    if (current !== null) {
      var oldIndex = current.index;
      if (oldIndex < lastPlacedIndex) {
        // This is a move.
        newFiber.effectTag = Placement;
        return lastPlacedIndex;
      } else {
        // This item can stay in place.
        return oldIndex;
      }
    } else {
      // This is an insertion.
      newFiber.effectTag = Placement;
      return lastPlacedIndex;
    }
  }

  function placeSingleChild(newFiber) {
    // This is simpler for the single child case. We only need to do a
    // placement for inserting new children.
    if (shouldTrackSideEffects && newFiber.alternate === null) {
      newFiber.effectTag = Placement;
    }
    return newFiber;
  }

  function updateTextNode(returnFiber, current, textContent, expirationTime) {
    if (current === null || current.tag !== HostText) {
      // Insert
      var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, textContent, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateElement(returnFiber, current, element, expirationTime) {
    if (current !== null && current.type === element.type) {
      // Move based on index
      var existing = useFiber(current, element.props, expirationTime);
      existing.ref = coerceRef(current, element);
      existing['return'] = returnFiber;
      {
        existing._debugSource = element._source;
        existing._debugOwner = element._owner;
      }
      return existing;
    } else {
      // Insert
      var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
      created.ref = coerceRef(current, element);
      created['return'] = returnFiber;
      return created;
    }
  }

  function updateCall(returnFiber, current, call, expirationTime) {
    // TODO: Should this also compare handler to determine whether to reuse?
    if (current === null || current.tag !== CallComponent) {
      // Insert
      var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Move based on index
      var existing = useFiber(current, call, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateReturn(returnFiber, current, returnNode, expirationTime) {
    if (current === null || current.tag !== ReturnComponent) {
      // Insert
      var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
      created.type = returnNode.value;
      created['return'] = returnFiber;
      return created;
    } else {
      // Move based on index
      var existing = useFiber(current, null, expirationTime);
      existing.type = returnNode.value;
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updatePortal(returnFiber, current, portal, expirationTime) {
    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
      // Insert
      var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, portal.children || [], expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateFragment(returnFiber, current, fragment, expirationTime, key) {
    if (current === null || current.tag !== Fragment) {
      // Insert
      var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, fragment, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function createChild(returnFiber, newChild, expirationTime) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      var created = createFiberFromText('' + newChild, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            if (newChild.type === REACT_FRAGMENT_TYPE) {
              var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);
              _created['return'] = returnFiber;
              return _created;
            } else {
              var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);
              _created2.ref = coerceRef(null, newChild);
              _created2['return'] = returnFiber;
              return _created2;
            }
          }

        case REACT_CALL_TYPE:
          {
            var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);
            _created3['return'] = returnFiber;
            return _created3;
          }

        case REACT_RETURN_TYPE:
          {
            var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);
            _created4.type = newChild.value;
            _created4['return'] = returnFiber;
            return _created4;
          }

        case REACT_PORTAL_TYPE:
          {
            var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);
            _created5['return'] = returnFiber;
            return _created5;
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);
        _created6['return'] = returnFiber;
        return _created6;
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
    // Update the fiber if the keys match, otherwise return null.

    var key = oldFiber !== null ? oldFiber.key : null;

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      if (key !== null) {
        return null;
      }
      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            if (newChild.key === key) {
              if (newChild.type === REACT_FRAGMENT_TYPE) {
                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
              }
              return updateElement(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_CALL_TYPE:
          {
            if (newChild.key === key) {
              return updateCall(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_RETURN_TYPE:
          {
            // Returns don't have keys. If the previous node is implicitly keyed
            // we can continue to replace it without aborting even if it is not a
            // yield.
            if (key === null) {
              return updateReturn(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_PORTAL_TYPE:
          {
            if (newChild.key === key) {
              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        if (key !== null) {
          return null;
        }

        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys, so we neither have to check the old nor
      // new node for the key. If both are text nodes, they match.
      var matchedFiber = existingChildren.get(newIdx) || null;
      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            if (newChild.type === REACT_FRAGMENT_TYPE) {
              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
            }
            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
          }

        case REACT_CALL_TYPE:
          {
            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);
          }

        case REACT_RETURN_TYPE:
          {
            // Returns don't have keys, so we neither have to check the old nor
            // new node for the key. If both are returns, they match.
            var _matchedFiber3 = existingChildren.get(newIdx) || null;
            return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);
          }

        case REACT_PORTAL_TYPE:
          {
            var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _matchedFiber5 = existingChildren.get(newIdx) || null;
        return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  /**
   * Warns if there is a duplicate or missing key
   */
  function warnOnInvalidKey(child, knownKeys) {
    {
      if (typeof child !== 'object' || child === null) {
        return knownKeys;
      }
      switch (child.$$typeof) {
        case REACT_ELEMENT_TYPE:
        case REACT_CALL_TYPE:
        case REACT_PORTAL_TYPE:
          warnForMissingKey(child);
          var key = child.key;
          if (typeof key !== 'string') {
            break;
          }
          if (knownKeys === null) {
            knownKeys = new Set();
            knownKeys.add(key);
            break;
          }
          if (!knownKeys.has(key)) {
            knownKeys.add(key);
            break;
          }
          warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted  the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$1());
          break;
        default:
          break;
      }
    }
    return knownKeys;
  }

  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
    // This algorithm can't optimize by searching from boths ends since we
    // don't have backpointers on fibers. I'm trying to see how far we can get
    // with that model. If it ends up not being worth the tradeoffs, we can
    // add it later.

    // Even with a two ended optimization, we'd want to optimize for the case
    // where there are few changes and brute force the comparison instead of
    // going for the Map. It'd like to explore hitting that path first in
    // forward-only mode and only go for the Map once we notice that we need
    // lots of look ahead. This doesn't handle reversal as well as two ended
    // search but that's unusual. Besides, for the two ended optimization to
    // work on Iterables, we'd need to copy the whole set.

    // In this first iteration, we'll just live with hitting the bad case
    // (adding everything to a Map) in for every insert/move.

    // If you change this code, also update reconcileChildrenIterator() which
    // uses the same algorithm.

    {
      // First, validate keys.
      var knownKeys = null;
      for (var i = 0; i < newChildren.length; i++) {
        var child = newChildren[i];
        knownKeys = warnOnInvalidKey(child, knownKeys);
      }
    }

    var resultingFirstChild = null;
    var previousNewFiber = null;

    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;
    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);
      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (newIdx === newChildren.length) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; newIdx < newChildren.length; newIdx++) {
        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);
        if (!_newFiber) {
          continue;
        }
        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber;
        } else {
          previousNewFiber.sibling = _newFiber;
        }
        previousNewFiber = _newFiber;
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; newIdx < newChildren.length; newIdx++) {
      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);
      if (_newFiber2) {
        if (shouldTrackSideEffects) {
          if (_newFiber2.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);
          }
        }
        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber2;
        } else {
          previousNewFiber.sibling = _newFiber2;
        }
        previousNewFiber = _newFiber2;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
    // This is the same implementation as reconcileChildrenArray(),
    // but using the iterator instead.

    var iteratorFn = getIteratorFn(newChildrenIterable);
    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    {
      // Warn about using Maps as children
      if (typeof newChildrenIterable.entries === 'function') {
        var possibleMap = newChildrenIterable;
        if (possibleMap.entries === iteratorFn) {
          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$1());
          didWarnAboutMaps = true;
        }
      }

      // First, validate keys.
      // We'll get a different iterator later for the main pass.
      var _newChildren = iteratorFn.call(newChildrenIterable);
      if (_newChildren) {
        var knownKeys = null;
        var _step = _newChildren.next();
        for (; !_step.done; _step = _newChildren.next()) {
          var child = _step.value;
          knownKeys = warnOnInvalidKey(child, knownKeys);
        }
      }
    }

    var newChildren = iteratorFn.call(newChildrenIterable);
    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;

    var resultingFirstChild = null;
    var previousNewFiber = null;

    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;

    var step = newChildren.next();
    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);
      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (!oldFiber) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (step.done) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; !step.done; newIdx++, step = newChildren.next()) {
        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
        if (_newFiber3 === null) {
          continue;
        }
        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber3;
        } else {
          previousNewFiber.sibling = _newFiber3;
        }
        previousNewFiber = _newFiber3;
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; !step.done; newIdx++, step = newChildren.next()) {
      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);
      if (_newFiber4 !== null) {
        if (shouldTrackSideEffects) {
          if (_newFiber4.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);
          }
        }
        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber4;
        } else {
          previousNewFiber.sibling = _newFiber4;
        }
        previousNewFiber = _newFiber4;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
    // There's no need to check for keys on text nodes since we don't have a
    // way to define them.
    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
      // We already have an existing node so let's just update it and delete
      // the rest.
      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
      var existing = useFiber(currentFirstChild, textContent, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
    // The existing first child is not a text node so we need to create one
    // and delete the existing ones.
    deleteRemainingChildren(returnFiber, currentFirstChild);
    var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
    var key = element.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);
          existing.ref = coerceRef(child, element);
          existing['return'] = returnFiber;
          {
            existing._debugSource = element._source;
            existing._debugOwner = element._owner;
          }
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    if (element.type === REACT_FRAGMENT_TYPE) {
      var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);
      created['return'] = returnFiber;
      return created;
    } else {
      var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
      _created7.ref = coerceRef(currentFirstChild, element);
      _created7['return'] = returnFiber;
      return _created7;
    }
  }

  function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {
    var key = call.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === CallComponent) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, call, expirationTime);
          existing['return'] = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {
    // There's no need to check for keys on yields since they're stateless.
    var child = currentFirstChild;
    if (child !== null) {
      if (child.tag === ReturnComponent) {
        deleteRemainingChildren(returnFiber, child.sibling);
        var existing = useFiber(child, null, expirationTime);
        existing.type = returnNode.value;
        existing['return'] = returnFiber;
        return existing;
      } else {
        deleteRemainingChildren(returnFiber, child);
      }
    }

    var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
    created.type = returnNode.value;
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
    var key = portal.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, portal.children || [], expirationTime);
          existing['return'] = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  // This API will tag the children with the side-effect of the reconciliation
  // itself. They will be added to the side-effect list as we pass through the
  // children and the parent.
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
    // This function is not recursive.
    // If the top level item is an array, we treat it as a set of children,
    // not as a fragment. Nested arrays on the other hand will be treated as
    // fragment nodes. Recursion happens at the normal flow.

    // Handle top level unkeyed fragments as if they were arrays.
    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
    // We treat the ambiguous cases above the same.
    if (typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {
      newChild = newChild.props.children;
    }

    // Handle object types
    var isObject = typeof newChild === 'object' && newChild !== null;

    if (isObject) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));

        case REACT_CALL_TYPE:
          return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));
        case REACT_RETURN_TYPE:
          return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));
        case REACT_PORTAL_TYPE:
          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
      }
    }

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));
    }

    if (isArray$1(newChild)) {
      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
    }

    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
    }

    if (isObject) {
      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }
    if (typeof newChild === 'undefined') {
      // If the new child is undefined, and the return fiber is a composite
      // component, throw an error. If Fiber return types are disabled,
      // we already threw above.
      switch (returnFiber.tag) {
        case ClassComponent:
          {
            {
              var instance = returnFiber.stateNode;
              if (instance.render._isMockFunction) {
                // We allow auto-mocks to proceed as if they're returning null.
                break;
              }
            }
          }
        // Intentionally fall through to the next case, which handles both
        // functions and classes
        // eslint-disable-next-lined no-fallthrough
        case FunctionalComponent:
          {
            var Component = returnFiber.type;
            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');
          }
      }
    }

    // Remaining cases are all treated as empty.
    return deleteRemainingChildren(returnFiber, currentFirstChild);
  }

  return reconcileChildFibers;
}

var reconcileChildFibers = ChildReconciler(true);
var mountChildFibers = ChildReconciler(false);

function cloneChildFibers(current, workInProgress) {
  !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;

  if (workInProgress.child === null) {
    return;
  }

  var currentChild = workInProgress.child;
  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
  workInProgress.child = newChild;

  newChild['return'] = workInProgress;
  while (currentChild.sibling !== null) {
    currentChild = currentChild.sibling;
    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
    newChild['return'] = workInProgress;
  }
  newChild.sibling = null;
}

{
  var warnedAboutStatelessRefs = {};
}

var ReactFiberBeginWork = function (config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {
  var shouldSetTextContent = config.shouldSetTextContent,
      useSyncScheduling = config.useSyncScheduling,
      shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;
  var pushHostContext = hostContext.pushHostContext,
      pushHostContainer = hostContext.pushHostContainer;
  var enterHydrationState = hydrationContext.enterHydrationState,
      resetHydrationState = hydrationContext.resetHydrationState,
      tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;

  var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),
      adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,
      constructClassInstance = _ReactFiberClassCompo.constructClassInstance,
      mountClassInstance = _ReactFiberClassCompo.mountClassInstance,
      updateClassInstance = _ReactFiberClassCompo.updateClassInstance;

  // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.


  function reconcileChildren(current, workInProgress, nextChildren) {
    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);
  }

  function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {
    if (current === null) {
      // If this is a fresh new component that hasn't been rendered yet, we
      // won't update its child set by applying minimal side-effects. Instead,
      // we will add them all to the child before it gets rendered. That means
      // we can optimize this reconciliation pass by not tracking side-effects.
      workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
    } else {
      // If the current child is the same as the work in progress, it means that
      // we haven't yet started any work on these children. Therefore, we use
      // the clone algorithm to create a copy of all the current children.

      // If we had any progressed work already, that is invalid at this point so
      // let's throw it out.
      workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);
    }
  }

  function updateFragment(current, workInProgress) {
    var nextChildren = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextChildren === null) {
        nextChildren = workInProgress.memoizedProps;
      }
    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }
    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextChildren);
    return workInProgress.child;
  }

  function markRef(current, workInProgress) {
    var ref = workInProgress.ref;
    if (ref !== null && (!current || current.ref !== ref)) {
      // Schedule a Ref effect
      workInProgress.effectTag |= Ref;
    }
  }

  function updateFunctionalComponent(current, workInProgress) {
    var fn = workInProgress.type;
    var nextProps = workInProgress.pendingProps;

    var memoizedProps = workInProgress.memoizedProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextProps === null) {
        nextProps = memoizedProps;
      }
    } else {
      if (nextProps === null || memoizedProps === nextProps) {
        return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }
      // TODO: consider bringing fn.shouldComponentUpdate() back.
      // It used to be here.
    }

    var unmaskedContext = getUnmaskedContext(workInProgress);
    var context = getMaskedContext(workInProgress, unmaskedContext);

    var nextChildren;

    {
      ReactCurrentOwner.current = workInProgress;
      ReactDebugCurrentFiber.setCurrentPhase('render');
      nextChildren = fn(nextProps, context);
      ReactDebugCurrentFiber.setCurrentPhase(null);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;
    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextProps);
    return workInProgress.child;
  }

  function updateClassComponent(current, workInProgress, renderExpirationTime) {
    // Push context providers early to prevent context stack mismatches.
    // During mounting we don't know the child context yet as the instance doesn't exist.
    // We will invalidate the child context in finishClassComponent() right after rendering.
    var hasContext = pushContextProvider(workInProgress);

    var shouldUpdate = void 0;
    if (current === null) {
      if (!workInProgress.stateNode) {
        // In the initial pass we might need to construct the instance.
        constructClassInstance(workInProgress, workInProgress.pendingProps);
        mountClassInstance(workInProgress, renderExpirationTime);
        shouldUpdate = true;
      } else {
        invariant(false, 'Resuming work not yet implemented.');
        // In a resume, we'll already have an instance we can reuse.
        // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);
      }
    } else {
      shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);
    }
    return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);
  }

  function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {
    // Refs should update even if shouldComponentUpdate returns false
    markRef(current, workInProgress);

    if (!shouldUpdate) {
      // Context providers should defer to sCU for rendering
      if (hasContext) {
        invalidateContextProvider(workInProgress, false);
      }

      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var instance = workInProgress.stateNode;

    // Rerender
    ReactCurrentOwner.current = workInProgress;
    var nextChildren = void 0;
    {
      ReactDebugCurrentFiber.setCurrentPhase('render');
      nextChildren = instance.render();
      if (debugRenderPhaseSideEffects) {
        instance.render();
      }
      ReactDebugCurrentFiber.setCurrentPhase(null);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;
    reconcileChildren(current, workInProgress, nextChildren);
    // Memoize props and state using the values we just used to render.
    // TODO: Restructure so we never read values from the instance.
    memoizeState(workInProgress, instance.state);
    memoizeProps(workInProgress, instance.props);

    // The context might have changed so we need to recalculate it.
    if (hasContext) {
      invalidateContextProvider(workInProgress, true);
    }

    return workInProgress.child;
  }

  function pushHostRootContext(workInProgress) {
    var root = workInProgress.stateNode;
    if (root.pendingContext) {
      pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
    } else if (root.context) {
      // Should always be set
      pushTopLevelContextObject(workInProgress, root.context, false);
    }
    pushHostContainer(workInProgress, root.containerInfo);
  }

  function updateHostRoot(current, workInProgress, renderExpirationTime) {
    pushHostRootContext(workInProgress);
    var updateQueue = workInProgress.updateQueue;
    if (updateQueue !== null) {
      var prevState = workInProgress.memoizedState;
      var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);
      if (prevState === state) {
        // If the state is the same as before, that's a bailout because we had
        // no work that expires at this time.
        resetHydrationState();
        return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }
      var element = state.element;
      var root = workInProgress.stateNode;
      if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {
        // If we don't have any current children this might be the first pass.
        // We always try to hydrate. If this isn't a hydration pass there won't
        // be any children to hydrate which is effectively the same thing as
        // not hydrating.

        // This is a bit of a hack. We track the host root as a placement to
        // know that we're currently in a mounting state. That way isMounted
        // works as expected. We must reset this before committing.
        // TODO: Delete this when we delete isMounted and findDOMNode.
        workInProgress.effectTag |= Placement;

        // Ensure that children mount into this root without tracking
        // side-effects. This ensures that we don't store Placement effects on
        // nodes that will be hydrated.
        workInProgress.child = mountChildFibers(workInProgress, null, element, renderExpirationTime);
      } else {
        // Otherwise reset hydration state in case we aborted and resumed another
        // root.
        resetHydrationState();
        reconcileChildren(current, workInProgress, element);
      }
      memoizeState(workInProgress, state);
      return workInProgress.child;
    }
    resetHydrationState();
    // If there is no update queue, that's a bailout because the root has no props.
    return bailoutOnAlreadyFinishedWork(current, workInProgress);
  }

  function updateHostComponent(current, workInProgress, renderExpirationTime) {
    pushHostContext(workInProgress);

    if (current === null) {
      tryToClaimNextHydratableInstance(workInProgress);
    }

    var type = workInProgress.type;
    var memoizedProps = workInProgress.memoizedProps;
    var nextProps = workInProgress.pendingProps;
    if (nextProps === null) {
      nextProps = memoizedProps;
      !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    }
    var prevProps = current !== null ? current.memoizedProps : null;

    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
    } else if (nextProps === null || memoizedProps === nextProps) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var nextChildren = nextProps.children;
    var isDirectTextChild = shouldSetTextContent(type, nextProps);

    if (isDirectTextChild) {
      // We special case a direct text child of a host node. This is a common
      // case. We won't handle it as a reified child. We will instead handle
      // this in the host environment that also have access to this prop. That
      // avoids allocating another HostText fiber and traversing it.
      nextChildren = null;
    } else if (prevProps && shouldSetTextContent(type, prevProps)) {
      // If we're switching from a direct text child to a normal child, or to
      // empty, we need to schedule the text content to be reset.
      workInProgress.effectTag |= ContentReset;
    }

    markRef(current, workInProgress);

    // Check the host config to see if the children are offscreen/hidden.
    if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {
      // Down-prioritize the children.
      workInProgress.expirationTime = Never;
      // Bailout and come back to this fiber later.
      return null;
    }

    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextProps);
    return workInProgress.child;
  }

  function updateHostText(current, workInProgress) {
    if (current === null) {
      tryToClaimNextHydratableInstance(workInProgress);
    }
    var nextProps = workInProgress.pendingProps;
    if (nextProps === null) {
      nextProps = workInProgress.memoizedProps;
    }
    memoizeProps(workInProgress, nextProps);
    // Nothing to do here. This is terminal. We'll do the completion step
    // immediately after.
    return null;
  }

  function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {
    !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    var fn = workInProgress.type;
    var props = workInProgress.pendingProps;
    var unmaskedContext = getUnmaskedContext(workInProgress);
    var context = getMaskedContext(workInProgress, unmaskedContext);

    var value;

    {
      if (fn.prototype && typeof fn.prototype.render === 'function') {
        var componentName = getComponentName(workInProgress);
        warning(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);
      }
      ReactCurrentOwner.current = workInProgress;
      value = fn(props, context);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;

    if (typeof value === 'object' && value !== null && typeof value.render === 'function') {
      // Proceed under the assumption that this is a class instance
      workInProgress.tag = ClassComponent;

      // Push context providers early to prevent context stack mismatches.
      // During mounting we don't know the child context yet as the instance doesn't exist.
      // We will invalidate the child context in finishClassComponent() right after rendering.
      var hasContext = pushContextProvider(workInProgress);
      adoptClassInstance(workInProgress, value);
      mountClassInstance(workInProgress, renderExpirationTime);
      return finishClassComponent(current, workInProgress, true, hasContext);
    } else {
      // Proceed under the assumption that this is a functional component
      workInProgress.tag = FunctionalComponent;
      {
        var Component = workInProgress.type;

        if (Component) {
          warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');
        }
        if (workInProgress.ref !== null) {
          var info = '';
          var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();
          if (ownerName) {
            info += '\n\nCheck the render method of `' + ownerName + '`.';
          }

          var warningKey = ownerName || workInProgress._debugID || '';
          var debugSource = workInProgress._debugSource;
          if (debugSource) {
            warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
          }
          if (!warnedAboutStatelessRefs[warningKey]) {
            warnedAboutStatelessRefs[warningKey] = true;
            warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());
          }
        }
      }
      reconcileChildren(current, workInProgress, value);
      memoizeProps(workInProgress, props);
      return workInProgress.child;
    }
  }

  function updateCallComponent(current, workInProgress, renderExpirationTime) {
    var nextCall = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextCall === null) {
        nextCall = current && current.memoizedProps;
        !(nextCall !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      }
    } else if (nextCall === null || workInProgress.memoizedProps === nextCall) {
      nextCall = workInProgress.memoizedProps;
      // TODO: When bailing out, we might need to return the stateNode instead
      // of the child. To check it for work.
      // return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var nextChildren = nextCall.children;

    // The following is a fork of reconcileChildrenAtExpirationTime but using
    // stateNode to store the child.
    if (current === null) {
      workInProgress.stateNode = mountChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
    } else {
      workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
    }

    memoizeProps(workInProgress, nextCall);
    // This doesn't take arbitrary time so we could synchronously just begin
    // eagerly do the work of workInProgress.child as an optimization.
    return workInProgress.stateNode;
  }

  function updatePortalComponent(current, workInProgress, renderExpirationTime) {
    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
    var nextChildren = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextChildren === null) {
        nextChildren = current && current.memoizedProps;
        !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      }
    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    if (current === null) {
      // Portals are special because we don't append the children during mount
      // but at commit. Therefore we need to track insertions which the normal
      // flow doesn't do during mount. This doesn't happen at the root because
      // the root always starts with a "current" with a null child.
      // TODO: Consider unifying this with how the root works.
      workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
      memoizeProps(workInProgress, nextChildren);
    } else {
      reconcileChildren(current, workInProgress, nextChildren);
      memoizeProps(workInProgress, nextChildren);
    }
    return workInProgress.child;
  }

  /*
  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
    let child = firstChild;
    do {
      // Ensure that the first and last effect of the parent corresponds
      // to the children's first and last effect.
      if (!returnFiber.firstEffect) {
        returnFiber.firstEffect = child.firstEffect;
      }
      if (child.lastEffect) {
        if (returnFiber.lastEffect) {
          returnFiber.lastEffect.nextEffect = child.firstEffect;
        }
        returnFiber.lastEffect = child.lastEffect;
      }
    } while (child = child.sibling);
  }
  */

  function bailoutOnAlreadyFinishedWork(current, workInProgress) {
    cancelWorkTimer(workInProgress);

    // TODO: We should ideally be able to bail out early if the children have no
    // more work to do. However, since we don't have a separation of this
    // Fiber's priority and its children yet - we don't know without doing lots
    // of the same work we do anyway. Once we have that separation we can just
    // bail out here if the children has no more work at this priority level.
    // if (workInProgress.priorityOfChildren <= priorityLevel) {
    //   // If there are side-effects in these children that have not yet been
    //   // committed we need to ensure that they get properly transferred up.
    //   if (current && current.child !== workInProgress.child) {
    //     reuseChildrenEffects(workInProgress, child);
    //   }
    //   return null;
    // }

    cloneChildFibers(current, workInProgress);
    return workInProgress.child;
  }

  function bailoutOnLowPriority(current, workInProgress) {
    cancelWorkTimer(workInProgress);

    // TODO: Handle HostComponent tags here as well and call pushHostContext()?
    // See PR 8590 discussion for context
    switch (workInProgress.tag) {
      case HostRoot:
        pushHostRootContext(workInProgress);
        break;
      case ClassComponent:
        pushContextProvider(workInProgress);
        break;
      case HostPortal:
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        break;
    }
    // TODO: What if this is currently in progress?
    // How can that happen? How is this not being cloned?
    return null;
  }

  // TODO: Delete memoizeProps/State and move to reconcile/bailout instead
  function memoizeProps(workInProgress, nextProps) {
    workInProgress.memoizedProps = nextProps;
  }

  function memoizeState(workInProgress, nextState) {
    workInProgress.memoizedState = nextState;
    // Don't reset the updateQueue, in case there are pending updates. Resetting
    // is handled by processUpdateQueue.
  }

  function beginWork(current, workInProgress, renderExpirationTime) {
    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
      return bailoutOnLowPriority(current, workInProgress);
    }

    switch (workInProgress.tag) {
      case IndeterminateComponent:
        return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);
      case FunctionalComponent:
        return updateFunctionalComponent(current, workInProgress);
      case ClassComponent:
        return updateClassComponent(current, workInProgress, renderExpirationTime);
      case HostRoot:
        return updateHostRoot(current, workInProgress, renderExpirationTime);
      case HostComponent:
        return updateHostComponent(current, workInProgress, renderExpirationTime);
      case HostText:
        return updateHostText(current, workInProgress);
      case CallHandlerPhase:
        // This is a restart. Reset the tag to the initial phase.
        workInProgress.tag = CallComponent;
      // Intentionally fall through since this is now the same.
      case CallComponent:
        return updateCallComponent(current, workInProgress, renderExpirationTime);
      case ReturnComponent:
        // A return component is just a placeholder, we can just run through the
        // next one immediately.
        return null;
      case HostPortal:
        return updatePortalComponent(current, workInProgress, renderExpirationTime);
      case Fragment:
        return updateFragment(current, workInProgress);
      default:
        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  function beginFailedWork(current, workInProgress, renderExpirationTime) {
    // Push context providers here to avoid a push/pop context mismatch.
    switch (workInProgress.tag) {
      case ClassComponent:
        pushContextProvider(workInProgress);
        break;
      case HostRoot:
        pushHostRootContext(workInProgress);
        break;
      default:
        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');
    }

    // Add an error effect so we can handle the error during the commit phase
    workInProgress.effectTag |= Err;

    // This is a weird case where we do "resume" work  work that failed on
    // our first attempt. Because we no longer have a notion of "progressed
    // deletions," reset the child to the current child to make sure we delete
    // it again. TODO: Find a better way to handle this, perhaps during a more
    // general overhaul of error handling.
    if (current === null) {
      workInProgress.child = null;
    } else if (workInProgress.child !== current.child) {
      workInProgress.child = current.child;
    }

    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
      return bailoutOnLowPriority(current, workInProgress);
    }

    // If we don't bail out, we're going be recomputing our children so we need
    // to drop our effect list.
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;

    // Unmount the current children as if the component rendered null
    var nextChildren = null;
    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);

    if (workInProgress.tag === ClassComponent) {
      var instance = workInProgress.stateNode;
      workInProgress.memoizedProps = instance.props;
      workInProgress.memoizedState = instance.state;
    }

    return workInProgress.child;
  }

  return {
    beginWork: beginWork,
    beginFailedWork: beginFailedWork
  };
};

var ReactFiberCompleteWork = function (config, hostContext, hydrationContext) {
  var createInstance = config.createInstance,
      createTextInstance = config.createTextInstance,
      appendInitialChild = config.appendInitialChild,
      finalizeInitialChildren = config.finalizeInitialChildren,
      prepareUpdate = config.prepareUpdate,
      mutation = config.mutation,
      persistence = config.persistence;
  var getRootHostContainer = hostContext.getRootHostContainer,
      popHostContext = hostContext.popHostContext,
      getHostContext = hostContext.getHostContext,
      popHostContainer = hostContext.popHostContainer;
  var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,
      prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,
      popHydrationState = hydrationContext.popHydrationState;


  function markUpdate(workInProgress) {
    // Tag the fiber with an update effect. This turns a Placement into
    // an UpdateAndPlacement.
    workInProgress.effectTag |= Update;
  }

  function markRef(workInProgress) {
    workInProgress.effectTag |= Ref;
  }

  function appendAllReturns(returns, workInProgress) {
    var node = workInProgress.stateNode;
    if (node) {
      node['return'] = workInProgress;
    }
    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {
        invariant(false, 'A call cannot have host component children.');
      } else if (node.tag === ReturnComponent) {
        returns.push(node.type);
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === workInProgress) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {
    var call = workInProgress.memoizedProps;
    !call ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    // First step of the call has completed. Now we need to do the second.
    // TODO: It would be nice to have a multi stage call represented by a
    // single component, or at least tail call optimize nested ones. Currently
    // that requires additional fields that we don't want to add to the fiber.
    // So this requires nested handlers.
    // Note: This doesn't mutate the alternate node. I don't think it needs to
    // since this stage is reset for every pass.
    workInProgress.tag = CallHandlerPhase;

    // Build up the returns.
    // TODO: Compare this to a generator or opaque helpers like Children.
    var returns = [];
    appendAllReturns(returns, workInProgress);
    var fn = call.handler;
    var props = call.props;
    var nextChildren = fn(props, returns);

    var currentFirstChild = current !== null ? current.child : null;
    workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);
    return workInProgress.child;
  }

  function appendAllChildren(parent, workInProgress) {
    // We only have the top Fiber that was created but we need recurse down its
    // children to find all the terminal nodes.
    var node = workInProgress.child;
    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText) {
        appendInitialChild(parent, node.stateNode);
      } else if (node.tag === HostPortal) {
        // If we have a portal child, then we don't want to traverse
        // down its children. Instead, we'll get insertions from each child in
        // the portal directly.
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === workInProgress) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === workInProgress) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  var updateHostContainer = void 0;
  var updateHostComponent = void 0;
  var updateHostText = void 0;
  if (mutation) {
    if (enableMutatingReconciler) {
      // Mutation mode
      updateHostContainer = function (workInProgress) {
        // Noop
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // TODO: Type this specific to this type of component.
        workInProgress.updateQueue = updatePayload;
        // If the update payload indicates that there is a change or if there
        // is a new ref we mark this as an update. All the work is done in commitWork.
        if (updatePayload) {
          markUpdate(workInProgress);
        }
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        // If the text differs, mark it as an update. All the work in done in commitWork.
        if (oldText !== newText) {
          markUpdate(workInProgress);
        }
      };
    } else {
      invariant(false, 'Mutating reconciler is disabled.');
    }
  } else if (persistence) {
    if (enablePersistentReconciler) {
      // Persistent host tree mode
      var cloneInstance = persistence.cloneInstance,
          createContainerChildSet = persistence.createContainerChildSet,
          appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,
          finalizeContainerChildren = persistence.finalizeContainerChildren;

      // An unfortunate fork of appendAllChildren because we have two different parent types.

      var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {
        // We only have the top Fiber that was created but we need recurse down its
        // children to find all the terminal nodes.
        var node = workInProgress.child;
        while (node !== null) {
          if (node.tag === HostComponent || node.tag === HostText) {
            appendChildToContainerChildSet(containerChildSet, node.stateNode);
          } else if (node.tag === HostPortal) {
            // If we have a portal child, then we don't want to traverse
            // down its children. Instead, we'll get insertions from each child in
            // the portal directly.
          } else if (node.child !== null) {
            node.child['return'] = node;
            node = node.child;
            continue;
          }
          if (node === workInProgress) {
            return;
          }
          while (node.sibling === null) {
            if (node['return'] === null || node['return'] === workInProgress) {
              return;
            }
            node = node['return'];
          }
          node.sibling['return'] = node['return'];
          node = node.sibling;
        }
      };
      updateHostContainer = function (workInProgress) {
        var portalOrRoot = workInProgress.stateNode;
        var childrenUnchanged = workInProgress.firstEffect === null;
        if (childrenUnchanged) {
          // No changes, just reuse the existing instance.
        } else {
          var container = portalOrRoot.containerInfo;
          var newChildSet = createContainerChildSet(container);
          if (finalizeContainerChildren(container, newChildSet)) {
            markUpdate(workInProgress);
          }
          portalOrRoot.pendingChildren = newChildSet;
          // If children might have changed, we have to add them all to the set.
          appendAllChildrenToContainer(newChildSet, workInProgress);
          // Schedule an update on the container to swap out the container.
          markUpdate(workInProgress);
        }
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // If there are no effects associated with this node, then none of our children had any updates.
        // This guarantees that we can reuse all of them.
        var childrenUnchanged = workInProgress.firstEffect === null;
        var currentInstance = current.stateNode;
        if (childrenUnchanged && updatePayload === null) {
          // No changes, just reuse the existing instance.
          // Note that this might release a previous clone.
          workInProgress.stateNode = currentInstance;
        } else {
          var recyclableInstance = workInProgress.stateNode;
          var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);
          if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {
            markUpdate(workInProgress);
          }
          workInProgress.stateNode = newInstance;
          if (childrenUnchanged) {
            // If there are no other effects in this tree, we need to flag this node as having one.
            // Even though we're not going to use it for anything.
            // Otherwise parents won't know that there are new children to propagate upwards.
            markUpdate(workInProgress);
          } else {
            // If children might have changed, we have to add them all to the set.
            appendAllChildren(newInstance, workInProgress);
          }
        }
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        if (oldText !== newText) {
          // If the text content differs, we'll create a new text instance for it.
          var rootContainerInstance = getRootHostContainer();
          var currentHostContext = getHostContext();
          workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);
          // We'll have to mark it as having an effect, even though we won't use the effect for anything.
          // This lets the parents know that at least one of their children has changed.
          markUpdate(workInProgress);
        }
      };
    } else {
      invariant(false, 'Persistent reconciler is disabled.');
    }
  } else {
    if (enableNoopReconciler) {
      // No host operations
      updateHostContainer = function (workInProgress) {
        // Noop
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // Noop
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        // Noop
      };
    } else {
      invariant(false, 'Noop reconciler is disabled.');
    }
  }

  function completeWork(current, workInProgress, renderExpirationTime) {
    // Get the latest props.
    var newProps = workInProgress.pendingProps;
    if (newProps === null) {
      newProps = workInProgress.memoizedProps;
    } else if (workInProgress.expirationTime !== Never || renderExpirationTime === Never) {
      // Reset the pending props, unless this was a down-prioritization.
      workInProgress.pendingProps = null;
    }

    switch (workInProgress.tag) {
      case FunctionalComponent:
        return null;
      case ClassComponent:
        {
          // We are leaving this subtree, so pop context if any.
          popContextProvider(workInProgress);
          return null;
        }
      case HostRoot:
        {
          popHostContainer(workInProgress);
          popTopLevelContextObject(workInProgress);
          var fiberRoot = workInProgress.stateNode;
          if (fiberRoot.pendingContext) {
            fiberRoot.context = fiberRoot.pendingContext;
            fiberRoot.pendingContext = null;
          }

          if (current === null || current.child === null) {
            // If we hydrated, pop so that we can delete any remaining children
            // that weren't hydrated.
            popHydrationState(workInProgress);
            // This resets the hacky state to fix isMounted before committing.
            // TODO: Delete this when we delete isMounted and findDOMNode.
            workInProgress.effectTag &= ~Placement;
          }
          updateHostContainer(workInProgress);
          return null;
        }
      case HostComponent:
        {
          popHostContext(workInProgress);
          var rootContainerInstance = getRootHostContainer();
          var type = workInProgress.type;
          if (current !== null && workInProgress.stateNode != null) {
            // If we have an alternate, that means this is an update and we need to
            // schedule a side-effect to do the updates.
            var oldProps = current.memoizedProps;
            // If we get updated because one of our children updated, we don't
            // have newProps so we'll have to reuse them.
            // TODO: Split the update API as separate for the props vs. children.
            // Even better would be if children weren't special cased at all tho.
            var instance = workInProgress.stateNode;
            var currentHostContext = getHostContext();
            var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);

            updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);

            if (current.ref !== workInProgress.ref) {
              markRef(workInProgress);
            }
          } else {
            if (!newProps) {
              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
              // This can happen when we abort work.
              return null;
            }

            var _currentHostContext = getHostContext();
            // TODO: Move createInstance to beginWork and keep it on a context
            // "stack" as the parent. Then append children as we go in beginWork
            // or completeWork depending on we want to add then top->down or
            // bottom->up. Top->down is faster in IE11.
            var wasHydrated = popHydrationState(workInProgress);
            if (wasHydrated) {
              // TODO: Move this and createInstance step into the beginPhase
              // to consolidate.
              if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {
                // If changes to the hydrated node needs to be applied at the
                // commit-phase we mark this as such.
                markUpdate(workInProgress);
              }
            } else {
              var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);

              appendAllChildren(_instance, workInProgress);

              // Certain renderers require commit-time effects for initial mount.
              // (eg DOM renderer supports auto-focus for certain elements).
              // Make sure such renderers get scheduled for later work.
              if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {
                markUpdate(workInProgress);
              }
              workInProgress.stateNode = _instance;
            }

            if (workInProgress.ref !== null) {
              // If there is a ref on a host node we need to schedule a callback
              markRef(workInProgress);
            }
          }
          return null;
        }
      case HostText:
        {
          var newText = newProps;
          if (current && workInProgress.stateNode != null) {
            var oldText = current.memoizedProps;
            // If we have an alternate, that means this is an update and we need
            // to schedule a side-effect to do the updates.
            updateHostText(current, workInProgress, oldText, newText);
          } else {
            if (typeof newText !== 'string') {
              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
              // This can happen when we abort work.
              return null;
            }
            var _rootContainerInstance = getRootHostContainer();
            var _currentHostContext2 = getHostContext();
            var _wasHydrated = popHydrationState(workInProgress);
            if (_wasHydrated) {
              if (prepareToHydrateHostTextInstance(workInProgress)) {
                markUpdate(workInProgress);
              }
            } else {
              workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);
            }
          }
          return null;
        }
      case CallComponent:
        return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);
      case CallHandlerPhase:
        // Reset the tag to now be a first phase call.
        workInProgress.tag = CallComponent;
        return null;
      case ReturnComponent:
        // Does nothing.
        return null;
      case Fragment:
        return null;
      case HostPortal:
        popHostContainer(workInProgress);
        updateHostContainer(workInProgress);
        return null;
      // Error cases
      case IndeterminateComponent:
        invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');
      // eslint-disable-next-line no-fallthrough
      default:
        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  return {
    completeWork: completeWork
  };
};

var invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;
var hasCaughtError$1 = ReactErrorUtils.hasCaughtError;
var clearCaughtError$1 = ReactErrorUtils.clearCaughtError;


var ReactFiberCommitWork = function (config, captureError) {
  var getPublicInstance = config.getPublicInstance,
      mutation = config.mutation,
      persistence = config.persistence;


  var callComponentWillUnmountWithTimer = function (current, instance) {
    startPhaseTimer(current, 'componentWillUnmount');
    instance.props = current.memoizedProps;
    instance.state = current.memoizedState;
    instance.componentWillUnmount();
    stopPhaseTimer();
  };

  // Capture errors so they don't interrupt unmounting.
  function safelyCallComponentWillUnmount(current, instance) {
    {
      invokeGuardedCallback$2(null, callComponentWillUnmountWithTimer, null, current, instance);
      if (hasCaughtError$1()) {
        var unmountError = clearCaughtError$1();
        captureError(current, unmountError);
      }
    }
  }

  function safelyDetachRef(current) {
    var ref = current.ref;
    if (ref !== null) {
      {
        invokeGuardedCallback$2(null, ref, null, null);
        if (hasCaughtError$1()) {
          var refError = clearCaughtError$1();
          captureError(current, refError);
        }
      }
    }
  }

  function commitLifeCycles(current, finishedWork) {
    switch (finishedWork.tag) {
      case ClassComponent:
        {
          var instance = finishedWork.stateNode;
          if (finishedWork.effectTag & Update) {
            if (current === null) {
              startPhaseTimer(finishedWork, 'componentDidMount');
              instance.props = finishedWork.memoizedProps;
              instance.state = finishedWork.memoizedState;
              instance.componentDidMount();
              stopPhaseTimer();
            } else {
              var prevProps = current.memoizedProps;
              var prevState = current.memoizedState;
              startPhaseTimer(finishedWork, 'componentDidUpdate');
              instance.props = finishedWork.memoizedProps;
              instance.state = finishedWork.memoizedState;
              instance.componentDidUpdate(prevProps, prevState);
              stopPhaseTimer();
            }
          }
          var updateQueue = finishedWork.updateQueue;
          if (updateQueue !== null) {
            commitCallbacks(updateQueue, instance);
          }
          return;
        }
      case HostRoot:
        {
          var _updateQueue = finishedWork.updateQueue;
          if (_updateQueue !== null) {
            var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;
            commitCallbacks(_updateQueue, _instance);
          }
          return;
        }
      case HostComponent:
        {
          var _instance2 = finishedWork.stateNode;

          // Renderers may schedule work to be done after host components are mounted
          // (eg DOM renderer may schedule auto-focus for inputs and form controls).
          // These effects should only be committed when components are first mounted,
          // aka when there is no current/alternate.
          if (current === null && finishedWork.effectTag & Update) {
            var type = finishedWork.type;
            var props = finishedWork.memoizedProps;
            commitMount(_instance2, type, props, finishedWork);
          }

          return;
        }
      case HostText:
        {
          // We have no life-cycles associated with text.
          return;
        }
      case HostPortal:
        {
          // We have no life-cycles associated with portals.
          return;
        }
      default:
        {
          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
        }
    }
  }

  function commitAttachRef(finishedWork) {
    var ref = finishedWork.ref;
    if (ref !== null) {
      var instance = finishedWork.stateNode;
      switch (finishedWork.tag) {
        case HostComponent:
          ref(getPublicInstance(instance));
          break;
        default:
          ref(instance);
      }
    }
  }

  function commitDetachRef(current) {
    var currentRef = current.ref;
    if (currentRef !== null) {
      currentRef(null);
    }
  }

  // User-originating errors (lifecycles and refs) should not interrupt
  // deletion, so don't let them throw. Host-originating errors should
  // interrupt deletion, so it's okay
  function commitUnmount(current) {
    if (typeof onCommitUnmount === 'function') {
      onCommitUnmount(current);
    }

    switch (current.tag) {
      case ClassComponent:
        {
          safelyDetachRef(current);
          var instance = current.stateNode;
          if (typeof instance.componentWillUnmount === 'function') {
            safelyCallComponentWillUnmount(current, instance);
          }
          return;
        }
      case HostComponent:
        {
          safelyDetachRef(current);
          return;
        }
      case CallComponent:
        {
          commitNestedUnmounts(current.stateNode);
          return;
        }
      case HostPortal:
        {
          // TODO: this is recursive.
          // We are also not using this parent because
          // the portal will get pushed immediately.
          if (enableMutatingReconciler && mutation) {
            unmountHostComponents(current);
          } else if (enablePersistentReconciler && persistence) {
            emptyPortalContainer(current);
          }
          return;
        }
    }
  }

  function commitNestedUnmounts(root) {
    // While we're inside a removed host node we don't want to call
    // removeChild on the inner nodes because they're removed by the top
    // call anyway. We also want to call componentWillUnmount on all
    // composites before this host node is removed from the tree. Therefore
    var node = root;
    while (true) {
      commitUnmount(node);
      // Visit children because they may contain more composite or host nodes.
      // Skip portals because commitUnmount() currently visits them recursively.
      if (node.child !== null && (
      // If we use mutation we drill down into portals using commitUnmount above.
      // If we don't use mutation we drill down into portals here instead.
      !mutation || node.tag !== HostPortal)) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === root) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === root) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function detachFiber(current) {
    // Cut off the return pointers to disconnect it from the tree. Ideally, we
    // should clear the child pointer of the parent alternate to let this
    // get GC:ed but we don't know which for sure which parent is the current
    // one so we'll settle for GC:ing the subtree of this child. This child
    // itself will be GC:ed when the parent updates the next time.
    current['return'] = null;
    current.child = null;
    if (current.alternate) {
      current.alternate.child = null;
      current.alternate['return'] = null;
    }
  }

  if (!mutation) {
    var commitContainer = void 0;
    if (persistence) {
      var replaceContainerChildren = persistence.replaceContainerChildren,
          createContainerChildSet = persistence.createContainerChildSet;

      var emptyPortalContainer = function (current) {
        var portal = current.stateNode;
        var containerInfo = portal.containerInfo;

        var emptyChildSet = createContainerChildSet(containerInfo);
        replaceContainerChildren(containerInfo, emptyChildSet);
      };
      commitContainer = function (finishedWork) {
        switch (finishedWork.tag) {
          case ClassComponent:
            {
              return;
            }
          case HostComponent:
            {
              return;
            }
          case HostText:
            {
              return;
            }
          case HostRoot:
          case HostPortal:
            {
              var portalOrRoot = finishedWork.stateNode;
              var containerInfo = portalOrRoot.containerInfo,
                  _pendingChildren = portalOrRoot.pendingChildren;

              replaceContainerChildren(containerInfo, _pendingChildren);
              return;
            }
          default:
            {
              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
            }
        }
      };
    } else {
      commitContainer = function (finishedWork) {
        // Noop
      };
    }
    if (enablePersistentReconciler || enableNoopReconciler) {
      return {
        commitResetTextContent: function (finishedWork) {},
        commitPlacement: function (finishedWork) {},
        commitDeletion: function (current) {
          // Detach refs and call componentWillUnmount() on the whole subtree.
          commitNestedUnmounts(current);
          detachFiber(current);
        },
        commitWork: function (current, finishedWork) {
          commitContainer(finishedWork);
        },

        commitLifeCycles: commitLifeCycles,
        commitAttachRef: commitAttachRef,
        commitDetachRef: commitDetachRef
      };
    } else if (persistence) {
      invariant(false, 'Persistent reconciler is disabled.');
    } else {
      invariant(false, 'Noop reconciler is disabled.');
    }
  }
  var commitMount = mutation.commitMount,
      commitUpdate = mutation.commitUpdate,
      resetTextContent = mutation.resetTextContent,
      commitTextUpdate = mutation.commitTextUpdate,
      appendChild = mutation.appendChild,
      appendChildToContainer = mutation.appendChildToContainer,
      insertBefore = mutation.insertBefore,
      insertInContainerBefore = mutation.insertInContainerBefore,
      removeChild = mutation.removeChild,
      removeChildFromContainer = mutation.removeChildFromContainer;


  function getHostParentFiber(fiber) {
    var parent = fiber['return'];
    while (parent !== null) {
      if (isHostParent(parent)) {
        return parent;
      }
      parent = parent['return'];
    }
    invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');
  }

  function isHostParent(fiber) {
    return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
  }

  function getHostSibling(fiber) {
    // We're going to search forward into the tree until we find a sibling host
    // node. Unfortunately, if multiple insertions are done in a row we have to
    // search past them. This leads to exponential search for the next sibling.
    var node = fiber;
    siblings: while (true) {
      // If we didn't find anything, let's try the next sibling.
      while (node.sibling === null) {
        if (node['return'] === null || isHostParent(node['return'])) {
          // If we pop out of the root or hit the parent the fiber we are the
          // last sibling.
          return null;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
      while (node.tag !== HostComponent && node.tag !== HostText) {
        // If it is not host node and, we might have a host node inside it.
        // Try to search down until we find one.
        if (node.effectTag & Placement) {
          // If we don't have a child, try the siblings instead.
          continue siblings;
        }
        // If we don't have a child, try the siblings instead.
        // We also skip portals because they are not part of this host tree.
        if (node.child === null || node.tag === HostPortal) {
          continue siblings;
        } else {
          node.child['return'] = node;
          node = node.child;
        }
      }
      // Check if this host node is stable or about to be placed.
      if (!(node.effectTag & Placement)) {
        // Found it!
        return node.stateNode;
      }
    }
  }

  function commitPlacement(finishedWork) {
    // Recursively insert all host nodes into the parent.
    var parentFiber = getHostParentFiber(finishedWork);
    var parent = void 0;
    var isContainer = void 0;
    switch (parentFiber.tag) {
      case HostComponent:
        parent = parentFiber.stateNode;
        isContainer = false;
        break;
      case HostRoot:
        parent = parentFiber.stateNode.containerInfo;
        isContainer = true;
        break;
      case HostPortal:
        parent = parentFiber.stateNode.containerInfo;
        isContainer = true;
        break;
      default:
        invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');
    }
    if (parentFiber.effectTag & ContentReset) {
      // Reset the text content of the parent before doing any insertions
      resetTextContent(parent);
      // Clear ContentReset from the effect tag
      parentFiber.effectTag &= ~ContentReset;
    }

    var before = getHostSibling(finishedWork);
    // We only have the top Fiber that was inserted but we need recurse down its
    // children to find all the terminal nodes.
    var node = finishedWork;
    while (true) {
      if (node.tag === HostComponent || node.tag === HostText) {
        if (before) {
          if (isContainer) {
            insertInContainerBefore(parent, node.stateNode, before);
          } else {
            insertBefore(parent, node.stateNode, before);
          }
        } else {
          if (isContainer) {
            appendChildToContainer(parent, node.stateNode);
          } else {
            appendChild(parent, node.stateNode);
          }
        }
      } else if (node.tag === HostPortal) {
        // If the insertion itself is a portal, then we don't want to traverse
        // down its children. Instead, we'll get insertions from each child in
        // the portal directly.
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === finishedWork) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === finishedWork) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function unmountHostComponents(current) {
    // We only have the top Fiber that was inserted but we need recurse down its
    var node = current;

    // Each iteration, currentParent is populated with node's host parent if not
    // currentParentIsValid.
    var currentParentIsValid = false;
    var currentParent = void 0;
    var currentParentIsContainer = void 0;

    while (true) {
      if (!currentParentIsValid) {
        var parent = node['return'];
        findParent: while (true) {
          !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          switch (parent.tag) {
            case HostComponent:
              currentParent = parent.stateNode;
              currentParentIsContainer = false;
              break findParent;
            case HostRoot:
              currentParent = parent.stateNode.containerInfo;
              currentParentIsContainer = true;
              break findParent;
            case HostPortal:
              currentParent = parent.stateNode.containerInfo;
              currentParentIsContainer = true;
              break findParent;
          }
          parent = parent['return'];
        }
        currentParentIsValid = true;
      }

      if (node.tag === HostComponent || node.tag === HostText) {
        commitNestedUnmounts(node);
        // After all the children have unmounted, it is now safe to remove the
        // node from the tree.
        if (currentParentIsContainer) {
          removeChildFromContainer(currentParent, node.stateNode);
        } else {
          removeChild(currentParent, node.stateNode);
        }
        // Don't visit children because we already visited them.
      } else if (node.tag === HostPortal) {
        // When we go into a portal, it becomes the parent to remove from.
        // We will reassign it back when we pop the portal on the way up.
        currentParent = node.stateNode.containerInfo;
        // Visit children because portals might contain host components.
        if (node.child !== null) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }
      } else {
        commitUnmount(node);
        // Visit children because we may find more host components below.
        if (node.child !== null) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }
      }
      if (node === current) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === current) {
          return;
        }
        node = node['return'];
        if (node.tag === HostPortal) {
          // When we go out of the portal, we need to restore the parent.
          // Since we don't keep a stack of them, we will search for it.
          currentParentIsValid = false;
        }
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function commitDeletion(current) {
    // Recursively delete all host nodes from the parent.
    // Detach refs and call componentWillUnmount() on the whole subtree.
    unmountHostComponents(current);
    detachFiber(current);
  }

  function commitWork(current, finishedWork) {
    switch (finishedWork.tag) {
      case ClassComponent:
        {
          return;
        }
      case HostComponent:
        {
          var instance = finishedWork.stateNode;
          if (instance != null) {
            // Commit the work prepared earlier.
            var newProps = finishedWork.memoizedProps;
            // For hydration we reuse the update path but we treat the oldProps
            // as the newProps. The updatePayload will contain the real change in
            // this case.
            var oldProps = current !== null ? current.memoizedProps : newProps;
            var type = finishedWork.type;
            // TODO: Type the updateQueue to be specific to host components.
            var updatePayload = finishedWork.updateQueue;
            finishedWork.updateQueue = null;
            if (updatePayload !== null) {
              commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
            }
          }
          return;
        }
      case HostText:
        {
          !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          var textInstance = finishedWork.stateNode;
          var newText = finishedWork.memoizedProps;
          // For hydration we reuse the update path but we treat the oldProps
          // as the newProps. The updatePayload will contain the real change in
          // this case.
          var oldText = current !== null ? current.memoizedProps : newText;
          commitTextUpdate(textInstance, oldText, newText);
          return;
        }
      case HostRoot:
        {
          return;
        }
      default:
        {
          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
        }
    }
  }

  function commitResetTextContent(current) {
    resetTextContent(current.stateNode);
  }

  if (enableMutatingReconciler) {
    return {
      commitResetTextContent: commitResetTextContent,
      commitPlacement: commitPlacement,
      commitDeletion: commitDeletion,
      commitWork: commitWork,
      commitLifeCycles: commitLifeCycles,
      commitAttachRef: commitAttachRef,
      commitDetachRef: commitDetachRef
    };
  } else {
    invariant(false, 'Mutating reconciler is disabled.');
  }
};

var NO_CONTEXT = {};

var ReactFiberHostContext = function (config) {
  var getChildHostContext = config.getChildHostContext,
      getRootHostContext = config.getRootHostContext;


  var contextStackCursor = createCursor(NO_CONTEXT);
  var contextFiberStackCursor = createCursor(NO_CONTEXT);
  var rootInstanceStackCursor = createCursor(NO_CONTEXT);

  function requiredContext(c) {
    !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    return c;
  }

  function getRootHostContainer() {
    var rootInstance = requiredContext(rootInstanceStackCursor.current);
    return rootInstance;
  }

  function pushHostContainer(fiber, nextRootInstance) {
    // Push current root instance onto the stack;
    // This allows us to reset root when portals are popped.
    push(rootInstanceStackCursor, nextRootInstance, fiber);

    var nextRootContext = getRootHostContext(nextRootInstance);

    // Track the context and the Fiber that provided it.
    // This enables us to pop only Fibers that provide unique contexts.
    push(contextFiberStackCursor, fiber, fiber);
    push(contextStackCursor, nextRootContext, fiber);
  }

  function popHostContainer(fiber) {
    pop(contextStackCursor, fiber);
    pop(contextFiberStackCursor, fiber);
    pop(rootInstanceStackCursor, fiber);
  }

  function getHostContext() {
    var context = requiredContext(contextStackCursor.current);
    return context;
  }

  function pushHostContext(fiber) {
    var rootInstance = requiredContext(rootInstanceStackCursor.current);
    var context = requiredContext(contextStackCursor.current);
    var nextContext = getChildHostContext(context, fiber.type, rootInstance);

    // Don't push this Fiber's context unless it's unique.
    if (context === nextContext) {
      return;
    }

    // Track the context and the Fiber that provided it.
    // This enables us to pop only Fibers that provide unique contexts.
    push(contextFiberStackCursor, fiber, fiber);
    push(contextStackCursor, nextContext, fiber);
  }

  function popHostContext(fiber) {
    // Do not pop unless this Fiber provided the current context.
    // pushHostContext() only pushes Fibers that provide unique contexts.
    if (contextFiberStackCursor.current !== fiber) {
      return;
    }

    pop(contextStackCursor, fiber);
    pop(contextFiberStackCursor, fiber);
  }

  function resetHostContainer() {
    contextStackCursor.current = NO_CONTEXT;
    rootInstanceStackCursor.current = NO_CONTEXT;
  }

  return {
    getHostContext: getHostContext,
    getRootHostContainer: getRootHostContainer,
    popHostContainer: popHostContainer,
    popHostContext: popHostContext,
    pushHostContainer: pushHostContainer,
    pushHostContext: pushHostContext,
    resetHostContainer: resetHostContainer
  };
};

var ReactFiberHydrationContext = function (config) {
  var shouldSetTextContent = config.shouldSetTextContent,
      hydration = config.hydration;

  // If this doesn't have hydration mode.

  if (!hydration) {
    return {
      enterHydrationState: function () {
        return false;
      },
      resetHydrationState: function () {},
      tryToClaimNextHydratableInstance: function () {},
      prepareToHydrateHostInstance: function () {
        invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
      },
      prepareToHydrateHostTextInstance: function () {
        invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
      },
      popHydrationState: function (fiber) {
        return false;
      }
    };
  }

  var canHydrateInstance = hydration.canHydrateInstance,
      canHydrateTextInstance = hydration.canHydrateTextInstance,
      getNextHydratableSibling = hydration.getNextHydratableSibling,
      getFirstHydratableChild = hydration.getFirstHydratableChild,
      hydrateInstance = hydration.hydrateInstance,
      hydrateTextInstance = hydration.hydrateTextInstance,
      didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,
      didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,
      didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,
      didNotHydrateInstance = hydration.didNotHydrateInstance,
      didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,
      didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,
      didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,
      didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance;

  // The deepest Fiber on the stack involved in a hydration context.
  // This may have been an insertion or a hydration.

  var hydrationParentFiber = null;
  var nextHydratableInstance = null;
  var isHydrating = false;

  function enterHydrationState(fiber) {
    var parentInstance = fiber.stateNode.containerInfo;
    nextHydratableInstance = getFirstHydratableChild(parentInstance);
    hydrationParentFiber = fiber;
    isHydrating = true;
    return true;
  }

  function deleteHydratableInstance(returnFiber, instance) {
    {
      switch (returnFiber.tag) {
        case HostRoot:
          didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
          break;
        case HostComponent:
          didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
          break;
      }
    }

    var childToDelete = createFiberFromHostInstanceForDeletion();
    childToDelete.stateNode = instance;
    childToDelete['return'] = returnFiber;
    childToDelete.effectTag = Deletion;

    // This might seem like it belongs on progressedFirstDeletion. However,
    // these children are not part of the reconciliation list of children.
    // Even if we abort and rereconcile the children, that will try to hydrate
    // again and the nodes are still in the host tree so these will be
    // recreated.
    if (returnFiber.lastEffect !== null) {
      returnFiber.lastEffect.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }
  }

  function insertNonHydratedInstance(returnFiber, fiber) {
    fiber.effectTag |= Placement;
    {
      switch (returnFiber.tag) {
        case HostRoot:
          {
            var parentContainer = returnFiber.stateNode.containerInfo;
            switch (fiber.tag) {
              case HostComponent:
                var type = fiber.type;
                var props = fiber.pendingProps;
                didNotFindHydratableContainerInstance(parentContainer, type, props);
                break;
              case HostText:
                var text = fiber.pendingProps;
                didNotFindHydratableContainerTextInstance(parentContainer, text);
                break;
            }
            break;
          }
        case HostComponent:
          {
            var parentType = returnFiber.type;
            var parentProps = returnFiber.memoizedProps;
            var parentInstance = returnFiber.stateNode;
            switch (fiber.tag) {
              case HostComponent:
                var _type = fiber.type;
                var _props = fiber.pendingProps;
                didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
                break;
              case HostText:
                var _text = fiber.pendingProps;
                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                break;
            }
            break;
          }
        default:
          return;
      }
    }
  }

  function tryHydrate(fiber, nextInstance) {
    switch (fiber.tag) {
      case HostComponent:
        {
          var type = fiber.type;
          var props = fiber.pendingProps;
          var instance = canHydrateInstance(nextInstance, type, props);
          if (instance !== null) {
            fiber.stateNode = instance;
            return true;
          }
          return false;
        }
      case HostText:
        {
          var text = fiber.pendingProps;
          var textInstance = canHydrateTextInstance(nextInstance, text);
          if (textInstance !== null) {
            fiber.stateNode = textInstance;
            return true;
          }
          return false;
        }
      default:
        return false;
    }
  }

  function tryToClaimNextHydratableInstance(fiber) {
    if (!isHydrating) {
      return;
    }
    var nextInstance = nextHydratableInstance;
    if (!nextInstance) {
      // Nothing to hydrate. Make it an insertion.
      insertNonHydratedInstance(hydrationParentFiber, fiber);
      isHydrating = false;
      hydrationParentFiber = fiber;
      return;
    }
    if (!tryHydrate(fiber, nextInstance)) {
      // If we can't hydrate this instance let's try the next one.
      // We use this as a heuristic. It's based on intuition and not data so it
      // might be flawed or unnecessary.
      nextInstance = getNextHydratableSibling(nextInstance);
      if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
        // Nothing to hydrate. Make it an insertion.
        insertNonHydratedInstance(hydrationParentFiber, fiber);
        isHydrating = false;
        hydrationParentFiber = fiber;
        return;
      }
      // We matched the next one, we'll now assume that the first one was
      // superfluous and we'll delete it. Since we can't eagerly delete it
      // we'll have to schedule a deletion. To do that, this node needs a dummy
      // fiber associated with it.
      deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);
    }
    hydrationParentFiber = fiber;
    nextHydratableInstance = getFirstHydratableChild(nextInstance);
  }

  function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
    var instance = fiber.stateNode;
    var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
    // TODO: Type this specific to this type of component.
    fiber.updateQueue = updatePayload;
    // If the update payload indicates that there is a change or if there
    // is a new ref we mark this as an update.
    if (updatePayload !== null) {
      return true;
    }
    return false;
  }

  function prepareToHydrateHostTextInstance(fiber) {
    var textInstance = fiber.stateNode;
    var textContent = fiber.memoizedProps;
    var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
    {
      if (shouldUpdate) {
        // We assume that prepareToHydrateHostTextInstance is called in a context where the
        // hydration parent is the parent host component of this host text.
        var returnFiber = hydrationParentFiber;
        if (returnFiber !== null) {
          switch (returnFiber.tag) {
            case HostRoot:
              {
                var parentContainer = returnFiber.stateNode.containerInfo;
                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                break;
              }
            case HostComponent:
              {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                break;
              }
          }
        }
      }
    }
    return shouldUpdate;
  }

  function popToNextHostParent(fiber) {
    var parent = fiber['return'];
    while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {
      parent = parent['return'];
    }
    hydrationParentFiber = parent;
  }

  function popHydrationState(fiber) {
    if (fiber !== hydrationParentFiber) {
      // We're deeper than the current hydration context, inside an inserted
      // tree.
      return false;
    }
    if (!isHydrating) {
      // If we're not currently hydrating but we're in a hydration context, then
      // we were an insertion and now need to pop up reenter hydration of our
      // siblings.
      popToNextHostParent(fiber);
      isHydrating = true;
      return false;
    }

    var type = fiber.type;

    // If we have any remaining hydratable nodes, we need to delete them now.
    // We only do this deeper than head and body since they tend to have random
    // other nodes in them. We also ignore components with pure text content in
    // side of them.
    // TODO: Better heuristic.
    if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {
      var nextInstance = nextHydratableInstance;
      while (nextInstance) {
        deleteHydratableInstance(fiber, nextInstance);
        nextInstance = getNextHydratableSibling(nextInstance);
      }
    }

    popToNextHostParent(fiber);
    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
    return true;
  }

  function resetHydrationState() {
    hydrationParentFiber = null;
    nextHydratableInstance = null;
    isHydrating = false;
  }

  return {
    enterHydrationState: enterHydrationState,
    resetHydrationState: resetHydrationState,
    tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,
    prepareToHydrateHostInstance: prepareToHydrateHostInstance,
    prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,
    popHydrationState: popHydrationState
  };
};

// This lets us hook into Fiber to debug what it's doing.
// See https://github.com/facebook/react/pull/8033.
// This is not part of the public API, not even for React DevTools.
// You may only inject a debugTool if you work on React Fiber itself.
var ReactFiberInstrumentation = {
  debugTool: null
};

var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;

var defaultShowDialog = function (capturedError) {
  return true;
};

var showDialog = defaultShowDialog;

function logCapturedError(capturedError) {
  var logError = showDialog(capturedError);

  // Allow injected showDialog() to prevent default console.error logging.
  // This enables renderers like ReactNative to better manage redbox behavior.
  if (logError === false) {
    return;
  }

  var error = capturedError.error;
  var suppressLogging = error && error.suppressReactErrorLogging;
  if (suppressLogging) {
    return;
  }

  {
    var componentName = capturedError.componentName,
        componentStack = capturedError.componentStack,
        errorBoundaryName = capturedError.errorBoundaryName,
        errorBoundaryFound = capturedError.errorBoundaryFound,
        willRetry = capturedError.willRetry;


    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';

    var errorBoundaryMessage = void 0;
    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
    if (errorBoundaryFound && errorBoundaryName) {
      if (willRetry) {
        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');
      } else {
        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';
      }
    } else {
      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';
    }
    var combinedMessage = '' + componentNameMessage + componentStack + '\n\n' + ('' + errorBoundaryMessage);

    // In development, we provide our own message with just the component stack.
    // We don't include the original error message and JS stack because the browser
    // has already printed it. Even if the application swallows the error, it is still
    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
    console.error(combinedMessage);
  }
}

var invokeGuardedCallback$1 = ReactErrorUtils.invokeGuardedCallback;
var hasCaughtError = ReactErrorUtils.hasCaughtError;
var clearCaughtError = ReactErrorUtils.clearCaughtError;


{
  var didWarnAboutStateTransition = false;
  var didWarnSetStateChildContext = false;
  var didWarnStateUpdateForUnmountedComponent = {};

  var warnAboutUpdateOnUnmounted = function (fiber) {
    var componentName = getComponentName(fiber) || 'ReactClass';
    if (didWarnStateUpdateForUnmountedComponent[componentName]) {
      return;
    }
    warning(false, 'Can only update a mounted or mounting ' + 'component. This usually means you called setState, replaceState, ' + 'or forceUpdate on an unmounted component. This is a no-op.\n\nPlease ' + 'check the code for the %s component.', componentName);
    didWarnStateUpdateForUnmountedComponent[componentName] = true;
  };

  var warnAboutInvalidUpdates = function (instance) {
    switch (ReactDebugCurrentFiber.phase) {
      case 'getChildContext':
        if (didWarnSetStateChildContext) {
          return;
        }
        warning(false, 'setState(...): Cannot call setState() inside getChildContext()');
        didWarnSetStateChildContext = true;
        break;
      case 'render':
        if (didWarnAboutStateTransition) {
          return;
        }
        warning(false, 'Cannot update during an existing state transition (such as within ' + "`render` or another component's constructor). Render methods should " + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');
        didWarnAboutStateTransition = true;
        break;
    }
  };
}

var ReactFiberScheduler = function (config) {
  var hostContext = ReactFiberHostContext(config);
  var hydrationContext = ReactFiberHydrationContext(config);
  var popHostContainer = hostContext.popHostContainer,
      popHostContext = hostContext.popHostContext,
      resetHostContainer = hostContext.resetHostContainer;

  var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),
      beginWork = _ReactFiberBeginWork.beginWork,
      beginFailedWork = _ReactFiberBeginWork.beginFailedWork;

  var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),
      completeWork = _ReactFiberCompleteWo.completeWork;

  var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),
      commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,
      commitPlacement = _ReactFiberCommitWork.commitPlacement,
      commitDeletion = _ReactFiberCommitWork.commitDeletion,
      commitWork = _ReactFiberCommitWork.commitWork,
      commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,
      commitAttachRef = _ReactFiberCommitWork.commitAttachRef,
      commitDetachRef = _ReactFiberCommitWork.commitDetachRef;

  var now = config.now,
      scheduleDeferredCallback = config.scheduleDeferredCallback,
      cancelDeferredCallback = config.cancelDeferredCallback,
      useSyncScheduling = config.useSyncScheduling,
      prepareForCommit = config.prepareForCommit,
      resetAfterCommit = config.resetAfterCommit;

  // Represents the current time in ms.

  var startTime = now();
  var mostRecentCurrentTime = msToExpirationTime(0);

  // Represents the expiration time that incoming updates should use. (If this
  // is NoWork, use the default strategy: async updates in async mode, sync
  // updates in sync mode.)
  var expirationContext = NoWork;

  var isWorking = false;

  // The next work in progress fiber that we're currently working on.
  var nextUnitOfWork = null;
  var nextRoot = null;
  // The time at which we're currently rendering work.
  var nextRenderExpirationTime = NoWork;

  // The next fiber with an effect that we're currently committing.
  var nextEffect = null;

  // Keep track of which fibers have captured an error that need to be handled.
  // Work is removed from this collection after componentDidCatch is called.
  var capturedErrors = null;
  // Keep track of which fibers have failed during the current batch of work.
  // This is a different set than capturedErrors, because it is not reset until
  // the end of the batch. This is needed to propagate errors correctly if a
  // subtree fails more than once.
  var failedBoundaries = null;
  // Error boundaries that captured an error during the current commit.
  var commitPhaseBoundaries = null;
  var firstUncaughtError = null;
  var didFatal = false;

  var isCommitting = false;
  var isUnmounting = false;

  // Used for performance tracking.
  var interruptedBy = null;

  function resetContextStack() {
    // Reset the stack
    reset$1();
    // Reset the cursors
    resetContext();
    resetHostContainer();
  }

  function commitAllHostEffects() {
    while (nextEffect !== null) {
      {
        ReactDebugCurrentFiber.setCurrentFiber(nextEffect);
      }
      recordEffect();

      var effectTag = nextEffect.effectTag;
      if (effectTag & ContentReset) {
        commitResetTextContent(nextEffect);
      }

      if (effectTag & Ref) {
        var current = nextEffect.alternate;
        if (current !== null) {
          commitDetachRef(current);
        }
      }

      // The following switch statement is only concerned about placement,
      // updates, and deletions. To avoid needing to add a case for every
      // possible bitmap value, we remove the secondary effects from the
      // effect tag and switch on that value.
      var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);
      switch (primaryEffectTag) {
        case Placement:
          {
            commitPlacement(nextEffect);
            // Clear the "placement" from effect tag so that we know that this is inserted, before
            // any life-cycles like componentDidMount gets called.
            // TODO: findDOMNode doesn't rely on this any more but isMounted
            // does and isMounted is deprecated anyway so we should be able
            // to kill this.
            nextEffect.effectTag &= ~Placement;
            break;
          }
        case PlacementAndUpdate:
          {
            // Placement
            commitPlacement(nextEffect);
            // Clear the "placement" from effect tag so that we know that this is inserted, before
            // any life-cycles like componentDidMount gets called.
            nextEffect.effectTag &= ~Placement;

            // Update
            var _current = nextEffect.alternate;
            commitWork(_current, nextEffect);
            break;
          }
        case Update:
          {
            var _current2 = nextEffect.alternate;
            commitWork(_current2, nextEffect);
            break;
          }
        case Deletion:
          {
            isUnmounting = true;
            commitDeletion(nextEffect);
            isUnmounting = false;
            break;
          }
      }
      nextEffect = nextEffect.nextEffect;
    }

    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
  }

  function commitAllLifeCycles() {
    while (nextEffect !== null) {
      var effectTag = nextEffect.effectTag;

      if (effectTag & (Update | Callback)) {
        recordEffect();
        var current = nextEffect.alternate;
        commitLifeCycles(current, nextEffect);
      }

      if (effectTag & Ref) {
        recordEffect();
        commitAttachRef(nextEffect);
      }

      if (effectTag & Err) {
        recordEffect();
        commitErrorHandling(nextEffect);
      }

      var next = nextEffect.nextEffect;
      // Ensure that we clean these up so that we don't accidentally keep them.
      // I'm not actually sure this matters because we can't reset firstEffect
      // and lastEffect since they're on every node, not just the effectful
      // ones. So we have to clean everything as we reuse nodes anyway.
      nextEffect.nextEffect = null;
      // Ensure that we reset the effectTag here so that we can rely on effect
      // tags to reason about the current life-cycle.
      nextEffect = next;
    }
  }

  function commitRoot(finishedWork) {
    // We keep track of this so that captureError can collect any boundaries
    // that capture an error during the commit phase. The reason these aren't
    // local to this function is because errors that occur during cWU are
    // captured elsewhere, to prevent the unmount from being interrupted.
    isWorking = true;
    isCommitting = true;
    startCommitTimer();

    var root = finishedWork.stateNode;
    !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    root.isReadyForCommit = false;

    // Reset this to null before calling lifecycles
    ReactCurrentOwner.current = null;

    var firstEffect = void 0;
    if (finishedWork.effectTag > PerformedWork) {
      // A fiber's effect list consists only of its children, not itself. So if
      // the root has an effect, we need to add it to the end of the list. The
      // resulting list is the set that would belong to the root's parent, if
      // it had one; that is, all the effects in the tree including the root.
      if (finishedWork.lastEffect !== null) {
        finishedWork.lastEffect.nextEffect = finishedWork;
        firstEffect = finishedWork.firstEffect;
      } else {
        firstEffect = finishedWork;
      }
    } else {
      // There is no effect on the root.
      firstEffect = finishedWork.firstEffect;
    }

    prepareForCommit();

    // Commit all the side-effects within a tree. We'll do this in two passes.
    // The first pass performs all the host insertions, updates, deletions and
    // ref unmounts.
    nextEffect = firstEffect;
    startCommitHostEffectsTimer();
    while (nextEffect !== null) {
      var didError = false;
      var _error = void 0;
      {
        invokeGuardedCallback$1(null, commitAllHostEffects, null);
        if (hasCaughtError()) {
          didError = true;
          _error = clearCaughtError();
        }
      }
      if (didError) {
        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        captureError(nextEffect, _error);
        // Clean-up
        if (nextEffect !== null) {
          nextEffect = nextEffect.nextEffect;
        }
      }
    }
    stopCommitHostEffectsTimer();

    resetAfterCommit();

    // The work-in-progress tree is now the current tree. This must come after
    // the first pass of the commit phase, so that the previous tree is still
    // current during componentWillUnmount, but before the second pass, so that
    // the finished work is current during componentDidMount/Update.
    root.current = finishedWork;

    // In the second pass we'll perform all life-cycles and ref callbacks.
    // Life-cycles happen as a separate pass so that all placements, updates,
    // and deletions in the entire tree have already been invoked.
    // This pass also triggers any renderer-specific initial effects.
    nextEffect = firstEffect;
    startCommitLifeCyclesTimer();
    while (nextEffect !== null) {
      var _didError = false;
      var _error2 = void 0;
      {
        invokeGuardedCallback$1(null, commitAllLifeCycles, null);
        if (hasCaughtError()) {
          _didError = true;
          _error2 = clearCaughtError();
        }
      }
      if (_didError) {
        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        captureError(nextEffect, _error2);
        if (nextEffect !== null) {
          nextEffect = nextEffect.nextEffect;
        }
      }
    }

    isCommitting = false;
    isWorking = false;
    stopCommitLifeCyclesTimer();
    stopCommitTimer();
    if (typeof onCommitRoot === 'function') {
      onCommitRoot(finishedWork.stateNode);
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);
    }

    // If we caught any errors during this commit, schedule their boundaries
    // to update.
    if (commitPhaseBoundaries) {
      commitPhaseBoundaries.forEach(scheduleErrorRecovery);
      commitPhaseBoundaries = null;
    }

    if (firstUncaughtError !== null) {
      var _error3 = firstUncaughtError;
      firstUncaughtError = null;
      onUncaughtError(_error3);
    }

    var remainingTime = root.current.expirationTime;

    if (remainingTime === NoWork) {
      capturedErrors = null;
      failedBoundaries = null;
    }

    return remainingTime;
  }

  function resetExpirationTime(workInProgress, renderTime) {
    if (renderTime !== Never && workInProgress.expirationTime === Never) {
      // The children of this component are hidden. Don't bubble their
      // expiration times.
      return;
    }

    // Check for pending updates.
    var newExpirationTime = getUpdateExpirationTime(workInProgress);

    // TODO: Calls need to visit stateNode

    // Bubble up the earliest expiration time.
    var child = workInProgress.child;
    while (child !== null) {
      if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {
        newExpirationTime = child.expirationTime;
      }
      child = child.sibling;
    }
    workInProgress.expirationTime = newExpirationTime;
  }

  function completeUnitOfWork(workInProgress) {
    while (true) {
      // The current, flushed, state of this fiber is the alternate.
      // Ideally nothing should rely on this, but relying on it here
      // means that we don't need an additional field on the work in
      // progress.
      var current = workInProgress.alternate;
      {
        ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
      }
      var next = completeWork(current, workInProgress, nextRenderExpirationTime);
      {
        ReactDebugCurrentFiber.resetCurrentFiber();
      }

      var returnFiber = workInProgress['return'];
      var siblingFiber = workInProgress.sibling;

      resetExpirationTime(workInProgress, nextRenderExpirationTime);

      if (next !== null) {
        stopWorkTimer(workInProgress);
        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
        }
        // If completing this work spawned new work, do that next. We'll come
        // back here again.
        return next;
      }

      if (returnFiber !== null) {
        // Append all the effects of the subtree and this fiber onto the effect
        // list of the parent. The completion order of the children affects the
        // side-effect order.
        if (returnFiber.firstEffect === null) {
          returnFiber.firstEffect = workInProgress.firstEffect;
        }
        if (workInProgress.lastEffect !== null) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
          }
          returnFiber.lastEffect = workInProgress.lastEffect;
        }

        // If this fiber had side-effects, we append it AFTER the children's
        // side-effects. We can perform certain side-effects earlier if
        // needed, by doing multiple passes over the effect list. We don't want
        // to schedule our own side-effect on our own list because if end up
        // reusing children we'll schedule this effect onto itself since we're
        // at the end.
        var effectTag = workInProgress.effectTag;
        // Skip both NoWork and PerformedWork tags when creating the effect list.
        // PerformedWork effect is read by React DevTools but shouldn't be committed.
        if (effectTag > PerformedWork) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress;
          } else {
            returnFiber.firstEffect = workInProgress;
          }
          returnFiber.lastEffect = workInProgress;
        }
      }

      stopWorkTimer(workInProgress);
      if (true && ReactFiberInstrumentation_1.debugTool) {
        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
      }

      if (siblingFiber !== null) {
        // If there is more work to do in this returnFiber, do that next.
        return siblingFiber;
      } else if (returnFiber !== null) {
        // If there's no more work in this returnFiber. Complete the returnFiber.
        workInProgress = returnFiber;
        continue;
      } else {
        // We've reached the root.
        var root = workInProgress.stateNode;
        root.isReadyForCommit = true;
        return null;
      }
    }

    // Without this explicit null return Flow complains of invalid return type
    // TODO Remove the above while(true) loop
    // eslint-disable-next-line no-unreachable
    return null;
  }

  function performUnitOfWork(workInProgress) {
    // The current, flushed, state of this fiber is the alternate.
    // Ideally nothing should rely on this, but relying on it here
    // means that we don't need an additional field on the work in
    // progress.
    var current = workInProgress.alternate;

    // See if beginning this work spawns more work.
    startWorkTimer(workInProgress);
    {
      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
    }

    var next = beginWork(current, workInProgress, nextRenderExpirationTime);
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
    }

    if (next === null) {
      // If this doesn't spawn new work, complete the current work.
      next = completeUnitOfWork(workInProgress);
    }

    ReactCurrentOwner.current = null;

    return next;
  }

  function performFailedUnitOfWork(workInProgress) {
    // The current, flushed, state of this fiber is the alternate.
    // Ideally nothing should rely on this, but relying on it here
    // means that we don't need an additional field on the work in
    // progress.
    var current = workInProgress.alternate;

    // See if beginning this work spawns more work.
    startWorkTimer(workInProgress);
    {
      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
    }
    var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
    }

    if (next === null) {
      // If this doesn't spawn new work, complete the current work.
      next = completeUnitOfWork(workInProgress);
    }

    ReactCurrentOwner.current = null;

    return next;
  }

  function workLoop(expirationTime) {
    if (capturedErrors !== null) {
      // If there are unhandled errors, switch to the slow work loop.
      // TODO: How to avoid this check in the fast path? Maybe the renderer
      // could keep track of which roots have unhandled errors and call a
      // forked version of renderRoot.
      slowWorkLoopThatChecksForFailedWork(expirationTime);
      return;
    }
    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
      return;
    }

    if (nextRenderExpirationTime <= mostRecentCurrentTime) {
      // Flush all expired work.
      while (nextUnitOfWork !== null) {
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
      }
    } else {
      // Flush asynchronous work until the deadline runs out of time.
      while (nextUnitOfWork !== null && !shouldYield()) {
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
      }
    }
  }

  function slowWorkLoopThatChecksForFailedWork(expirationTime) {
    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
      return;
    }

    if (nextRenderExpirationTime <= mostRecentCurrentTime) {
      // Flush all expired work.
      while (nextUnitOfWork !== null) {
        if (hasCapturedError(nextUnitOfWork)) {
          // Use a forked version of performUnitOfWork
          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
        } else {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      }
    } else {
      // Flush asynchronous work until the deadline runs out of time.
      while (nextUnitOfWork !== null && !shouldYield()) {
        if (hasCapturedError(nextUnitOfWork)) {
          // Use a forked version of performUnitOfWork
          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
        } else {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      }
    }
  }

  function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {
    // We're going to restart the error boundary that captured the error.
    // Conceptually, we're unwinding the stack. We need to unwind the
    // context stack, too.
    unwindContexts(failedWork, boundary);

    // Restart the error boundary using a forked version of
    // performUnitOfWork that deletes the boundary's children. The entire
    // failed subree will be unmounted. During the commit phase, a special
    // lifecycle method is called on the error boundary, which triggers
    // a re-render.
    nextUnitOfWork = performFailedUnitOfWork(boundary);

    // Continue working.
    workLoop(expirationTime);
  }

  function renderRoot(root, expirationTime) {
    !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    isWorking = true;

    // We're about to mutate the work-in-progress tree. If the root was pending
    // commit, it no longer is: we'll need to complete it again.
    root.isReadyForCommit = false;

    // Check if we're starting from a fresh stack, or if we're resuming from
    // previously yielded work.
    if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {
      // Reset the stack and start working from the root.
      resetContextStack();
      nextRoot = root;
      nextRenderExpirationTime = expirationTime;
      nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);
    }

    startWorkLoopTimer(nextUnitOfWork);

    var didError = false;
    var error = null;
    {
      invokeGuardedCallback$1(null, workLoop, null, expirationTime);
      if (hasCaughtError()) {
        didError = true;
        error = clearCaughtError();
      }
    }

    // An error was thrown during the render phase.
    while (didError) {
      if (didFatal) {
        // This was a fatal error. Don't attempt to recover from it.
        firstUncaughtError = error;
        break;
      }

      var failedWork = nextUnitOfWork;
      if (failedWork === null) {
        // An error was thrown but there's no current unit of work. This can
        // happen during the commit phase if there's a bug in the renderer.
        didFatal = true;
        continue;
      }

      // "Capture" the error by finding the nearest boundary. If there is no
      // error boundary, we use the root.
      var boundary = captureError(failedWork, error);
      !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;

      if (didFatal) {
        // The error we just captured was a fatal error. This happens
        // when the error propagates to the root more than once.
        continue;
      }

      didError = false;
      error = null;
      {
        invokeGuardedCallback$1(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);
        if (hasCaughtError()) {
          didError = true;
          error = clearCaughtError();
          continue;
        }
      }
      // We're finished working. Exit the error loop.
      break;
    }

    var uncaughtError = firstUncaughtError;

    // We're done performing work. Time to clean up.
    stopWorkLoopTimer(interruptedBy);
    interruptedBy = null;
    isWorking = false;
    didFatal = false;
    firstUncaughtError = null;

    if (uncaughtError !== null) {
      onUncaughtError(uncaughtError);
    }

    return root.isReadyForCommit ? root.current.alternate : null;
  }

  // Returns the boundary that captured the error, or null if the error is ignored
  function captureError(failedWork, error) {
    // It is no longer valid because we exited the user code.
    ReactCurrentOwner.current = null;
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }

    // Search for the nearest error boundary.
    var boundary = null;

    // Passed to logCapturedError()
    var errorBoundaryFound = false;
    var willRetry = false;
    var errorBoundaryName = null;

    // Host containers are a special case. If the failed work itself is a host
    // container, then it acts as its own boundary. In all other cases, we
    // ignore the work itself and only search through the parents.
    if (failedWork.tag === HostRoot) {
      boundary = failedWork;

      if (isFailedBoundary(failedWork)) {
        // If this root already failed, there must have been an error when
        // attempting to unmount it. This is a worst-case scenario and
        // should only be possible if there's a bug in the renderer.
        didFatal = true;
      }
    } else {
      var node = failedWork['return'];
      while (node !== null && boundary === null) {
        if (node.tag === ClassComponent) {
          var instance = node.stateNode;
          if (typeof instance.componentDidCatch === 'function') {
            errorBoundaryFound = true;
            errorBoundaryName = getComponentName(node);

            // Found an error boundary!
            boundary = node;
            willRetry = true;
          }
        } else if (node.tag === HostRoot) {
          // Treat the root like a no-op error boundary
          boundary = node;
        }

        if (isFailedBoundary(node)) {
          // This boundary is already in a failed state.

          // If we're currently unmounting, that means this error was
          // thrown while unmounting a failed subtree. We should ignore
          // the error.
          if (isUnmounting) {
            return null;
          }

          // If we're in the commit phase, we should check to see if
          // this boundary already captured an error during this commit.
          // This case exists because multiple errors can be thrown during
          // a single commit without interruption.
          if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {
            // If so, we should ignore this error.
            return null;
          }

          // The error should propagate to the next boundary - we keep looking.
          boundary = null;
          willRetry = false;
        }

        node = node['return'];
      }
    }

    if (boundary !== null) {
      // Add to the collection of failed boundaries. This lets us know that
      // subsequent errors in this subtree should propagate to the next boundary.
      if (failedBoundaries === null) {
        failedBoundaries = new Set();
      }
      failedBoundaries.add(boundary);

      // This method is unsafe outside of the begin and complete phases.
      // We might be in the commit phase when an error is captured.
      // The risk is that the return path from this Fiber may not be accurate.
      // That risk is acceptable given the benefit of providing users more context.
      var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);
      var _componentName = getComponentName(failedWork);

      // Add to the collection of captured errors. This is stored as a global
      // map of errors and their component stack location keyed by the boundaries
      // that capture them. We mostly use this Map as a Set; it's a Map only to
      // avoid adding a field to Fiber to store the error.
      if (capturedErrors === null) {
        capturedErrors = new Map();
      }

      var capturedError = {
        componentName: _componentName,
        componentStack: _componentStack,
        error: error,
        errorBoundary: errorBoundaryFound ? boundary.stateNode : null,
        errorBoundaryFound: errorBoundaryFound,
        errorBoundaryName: errorBoundaryName,
        willRetry: willRetry
      };

      capturedErrors.set(boundary, capturedError);

      try {
        logCapturedError(capturedError);
      } catch (e) {
        // Prevent cycle if logCapturedError() throws.
        // A cycle may still occur if logCapturedError renders a component that throws.
        var suppressLogging = e && e.suppressReactErrorLogging;
        if (!suppressLogging) {
          console.error(e);
        }
      }

      // If we're in the commit phase, defer scheduling an update on the
      // boundary until after the commit is complete
      if (isCommitting) {
        if (commitPhaseBoundaries === null) {
          commitPhaseBoundaries = new Set();
        }
        commitPhaseBoundaries.add(boundary);
      } else {
        // Otherwise, schedule an update now.
        // TODO: Is this actually necessary during the render phase? Is it
        // possible to unwind and continue rendering at the same priority,
        // without corrupting internal state?
        scheduleErrorRecovery(boundary);
      }
      return boundary;
    } else if (firstUncaughtError === null) {
      // If no boundary is found, we'll need to throw the error
      firstUncaughtError = error;
    }
    return null;
  }

  function hasCapturedError(fiber) {
    // TODO: capturedErrors should store the boundary instance, to avoid needing
    // to check the alternate.
    return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));
  }

  function isFailedBoundary(fiber) {
    // TODO: failedBoundaries should store the boundary instance, to avoid
    // needing to check the alternate.
    return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));
  }

  function commitErrorHandling(effectfulFiber) {
    var capturedError = void 0;
    if (capturedErrors !== null) {
      capturedError = capturedErrors.get(effectfulFiber);
      capturedErrors['delete'](effectfulFiber);
      if (capturedError == null) {
        if (effectfulFiber.alternate !== null) {
          effectfulFiber = effectfulFiber.alternate;
          capturedError = capturedErrors.get(effectfulFiber);
          capturedErrors['delete'](effectfulFiber);
        }
      }
    }

    !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    switch (effectfulFiber.tag) {
      case ClassComponent:
        var instance = effectfulFiber.stateNode;

        var info = {
          componentStack: capturedError.componentStack
        };

        // Allow the boundary to handle the error, usually by scheduling
        // an update to itself
        instance.componentDidCatch(capturedError.error, info);
        return;
      case HostRoot:
        if (firstUncaughtError === null) {
          firstUncaughtError = capturedError.error;
        }
        return;
      default:
        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  function unwindContexts(from, to) {
    var node = from;
    while (node !== null) {
      switch (node.tag) {
        case ClassComponent:
          popContextProvider(node);
          break;
        case HostComponent:
          popHostContext(node);
          break;
        case HostRoot:
          popHostContainer(node);
          break;
        case HostPortal:
          popHostContainer(node);
          break;
      }
      if (node === to || node.alternate === to) {
        stopFailedWorkTimer(node);
        break;
      } else {
        stopWorkTimer(node);
      }
      node = node['return'];
    }
  }

  function computeAsyncExpiration() {
    // Given the current clock time, returns an expiration time. We use rounding
    // to batch like updates together.
    // Should complete within ~1000ms. 1200ms max.
    var currentTime = recalculateCurrentTime();
    var expirationMs = 1000;
    var bucketSizeMs = 200;
    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);
  }

  function computeExpirationForFiber(fiber) {
    var expirationTime = void 0;
    if (expirationContext !== NoWork) {
      // An explicit expiration context was set;
      expirationTime = expirationContext;
    } else if (isWorking) {
      if (isCommitting) {
        // Updates that occur during the commit phase should have sync priority
        // by default.
        expirationTime = Sync;
      } else {
        // Updates during the render phase should expire at the same time as
        // the work that is being rendered.
        expirationTime = nextRenderExpirationTime;
      }
    } else {
      // No explicit expiration context was set, and we're not currently
      // performing work. Calculate a new expiration time.
      if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {
        // This is a sync update
        expirationTime = Sync;
      } else {
        // This is an async update
        expirationTime = computeAsyncExpiration();
      }
    }
    return expirationTime;
  }

  function scheduleWork(fiber, expirationTime) {
    return scheduleWorkImpl(fiber, expirationTime, false);
  }

  function checkRootNeedsClearing(root, fiber, expirationTime) {
    if (!isWorking && root === nextRoot && expirationTime < nextRenderExpirationTime) {
      // Restart the root from the top.
      if (nextUnitOfWork !== null) {
        // This is an interruption. (Used for performance tracking.)
        interruptedBy = fiber;
      }
      nextRoot = null;
      nextUnitOfWork = null;
      nextRenderExpirationTime = NoWork;
    }
  }

  function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {
    recordScheduleUpdate();

    {
      if (!isErrorRecovery && fiber.tag === ClassComponent) {
        var instance = fiber.stateNode;
        warnAboutInvalidUpdates(instance);
      }
    }

    var node = fiber;
    while (node !== null) {
      // Walk the parent path to the root and update each node's
      // expiration time.
      if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {
        node.expirationTime = expirationTime;
      }
      if (node.alternate !== null) {
        if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {
          node.alternate.expirationTime = expirationTime;
        }
      }
      if (node['return'] === null) {
        if (node.tag === HostRoot) {
          var root = node.stateNode;

          checkRootNeedsClearing(root, fiber, expirationTime);
          requestWork(root, expirationTime);
          checkRootNeedsClearing(root, fiber, expirationTime);
        } else {
          {
            if (!isErrorRecovery && fiber.tag === ClassComponent) {
              warnAboutUpdateOnUnmounted(fiber);
            }
          }
          return;
        }
      }
      node = node['return'];
    }
  }

  function scheduleErrorRecovery(fiber) {
    scheduleWorkImpl(fiber, Sync, true);
  }

  function recalculateCurrentTime() {
    // Subtract initial time so it fits inside 32bits
    var ms = now() - startTime;
    mostRecentCurrentTime = msToExpirationTime(ms);
    return mostRecentCurrentTime;
  }

  function deferredUpdates(fn) {
    var previousExpirationContext = expirationContext;
    expirationContext = computeAsyncExpiration();
    try {
      return fn();
    } finally {
      expirationContext = previousExpirationContext;
    }
  }

  function syncUpdates(fn) {
    var previousExpirationContext = expirationContext;
    expirationContext = Sync;
    try {
      return fn();
    } finally {
      expirationContext = previousExpirationContext;
    }
  }

  // TODO: Everything below this is written as if it has been lifted to the
  // renderers. I'll do this in a follow-up.

  // Linked-list of roots
  var firstScheduledRoot = null;
  var lastScheduledRoot = null;

  var callbackExpirationTime = NoWork;
  var callbackID = -1;
  var isRendering = false;
  var nextFlushedRoot = null;
  var nextFlushedExpirationTime = NoWork;
  var deadlineDidExpire = false;
  var hasUnhandledError = false;
  var unhandledError = null;
  var deadline = null;

  var isBatchingUpdates = false;
  var isUnbatchingUpdates = false;

  // Use these to prevent an infinite loop of nested updates
  var NESTED_UPDATE_LIMIT = 1000;
  var nestedUpdateCount = 0;

  var timeHeuristicForUnitOfWork = 1;

  function scheduleCallbackWithExpiration(expirationTime) {
    if (callbackExpirationTime !== NoWork) {
      // A callback is already scheduled. Check its expiration time (timeout).
      if (expirationTime > callbackExpirationTime) {
        // Existing callback has sufficient timeout. Exit.
        return;
      } else {
        // Existing callback has insufficient timeout. Cancel and schedule a
        // new one.
        cancelDeferredCallback(callbackID);
      }
      // The request callback timer is already running. Don't start a new one.
    } else {
      startRequestCallbackTimer();
    }

    // Compute a timeout for the given expiration time.
    var currentMs = now() - startTime;
    var expirationMs = expirationTimeToMs(expirationTime);
    var timeout = expirationMs - currentMs;

    callbackExpirationTime = expirationTime;
    callbackID = scheduleDeferredCallback(performAsyncWork, { timeout: timeout });
  }

  // requestWork is called by the scheduler whenever a root receives an update.
  // It's up to the renderer to call renderRoot at some point in the future.
  function requestWork(root, expirationTime) {
    if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
      invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');
    }

    // Add the root to the schedule.
    // Check if this root is already part of the schedule.
    if (root.nextScheduledRoot === null) {
      // This root is not already scheduled. Add it.
      root.remainingExpirationTime = expirationTime;
      if (lastScheduledRoot === null) {
        firstScheduledRoot = lastScheduledRoot = root;
        root.nextScheduledRoot = root;
      } else {
        lastScheduledRoot.nextScheduledRoot = root;
        lastScheduledRoot = root;
        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
      }
    } else {
      // This root is already scheduled, but its priority may have increased.
      var remainingExpirationTime = root.remainingExpirationTime;
      if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {
        // Update the priority.
        root.remainingExpirationTime = expirationTime;
      }
    }

    if (isRendering) {
      // Prevent reentrancy. Remaining work will be scheduled at the end of
      // the currently rendering batch.
      return;
    }

    if (isBatchingUpdates) {
      // Flush work at the end of the batch.
      if (isUnbatchingUpdates) {
        // ...unless we're inside unbatchedUpdates, in which case we should
        // flush it now.
        nextFlushedRoot = root;
        nextFlushedExpirationTime = Sync;
        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);
      }
      return;
    }

    // TODO: Get rid of Sync and use current time?
    if (expirationTime === Sync) {
      performWork(Sync, null);
    } else {
      scheduleCallbackWithExpiration(expirationTime);
    }
  }

  function findHighestPriorityRoot() {
    var highestPriorityWork = NoWork;
    var highestPriorityRoot = null;

    if (lastScheduledRoot !== null) {
      var previousScheduledRoot = lastScheduledRoot;
      var root = firstScheduledRoot;
      while (root !== null) {
        var remainingExpirationTime = root.remainingExpirationTime;
        if (remainingExpirationTime === NoWork) {
          // This root no longer has work. Remove it from the scheduler.

          // TODO: This check is redudant, but Flow is confused by the branch
          // below where we set lastScheduledRoot to null, even though we break
          // from the loop right after.
          !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          if (root === root.nextScheduledRoot) {
            // This is the only root in the list.
            root.nextScheduledRoot = null;
            firstScheduledRoot = lastScheduledRoot = null;
            break;
          } else if (root === firstScheduledRoot) {
            // This is the first root in the list.
            var next = root.nextScheduledRoot;
            firstScheduledRoot = next;
            lastScheduledRoot.nextScheduledRoot = next;
            root.nextScheduledRoot = null;
          } else if (root === lastScheduledRoot) {
            // This is the last root in the list.
            lastScheduledRoot = previousScheduledRoot;
            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
            root.nextScheduledRoot = null;
            break;
          } else {
            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
            root.nextScheduledRoot = null;
          }
          root = previousScheduledRoot.nextScheduledRoot;
        } else {
          if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {
            // Update the priority, if it's higher
            highestPriorityWork = remainingExpirationTime;
            highestPriorityRoot = root;
          }
          if (root === lastScheduledRoot) {
            break;
          }
          previousScheduledRoot = root;
          root = root.nextScheduledRoot;
        }
      }
    }

    // If the next root is the same as the previous root, this is a nested
    // update. To prevent an infinite loop, increment the nested update count.
    var previousFlushedRoot = nextFlushedRoot;
    if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {
      nestedUpdateCount++;
    } else {
      // Reset whenever we switch roots.
      nestedUpdateCount = 0;
    }
    nextFlushedRoot = highestPriorityRoot;
    nextFlushedExpirationTime = highestPriorityWork;
  }

  function performAsyncWork(dl) {
    performWork(NoWork, dl);
  }

  function performWork(minExpirationTime, dl) {
    deadline = dl;

    // Keep working on roots until there's no more work, or until the we reach
    // the deadline.
    findHighestPriorityRoot();

    if (enableUserTimingAPI && deadline !== null) {
      var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();
      stopRequestCallbackTimer(didExpire);
    }

    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);
      // Find the next highest priority work.
      findHighestPriorityRoot();
    }

    // We're done flushing work. Either we ran out of time in this callback,
    // or there's no more work left with sufficient priority.

    // If we're inside a callback, set this to false since we just completed it.
    if (deadline !== null) {
      callbackExpirationTime = NoWork;
      callbackID = -1;
    }
    // If there's work left over, schedule a new callback.
    if (nextFlushedExpirationTime !== NoWork) {
      scheduleCallbackWithExpiration(nextFlushedExpirationTime);
    }

    // Clean-up.
    deadline = null;
    deadlineDidExpire = false;
    nestedUpdateCount = 0;

    if (hasUnhandledError) {
      var _error4 = unhandledError;
      unhandledError = null;
      hasUnhandledError = false;
      throw _error4;
    }
  }

  function performWorkOnRoot(root, expirationTime) {
    !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    isRendering = true;

    // Check if this is async work or sync/expired work.
    // TODO: Pass current time as argument to renderRoot, commitRoot
    if (expirationTime <= recalculateCurrentTime()) {
      // Flush sync work.
      var finishedWork = root.finishedWork;
      if (finishedWork !== null) {
        // This root is already complete. We can commit it.
        root.finishedWork = null;
        root.remainingExpirationTime = commitRoot(finishedWork);
      } else {
        root.finishedWork = null;
        finishedWork = renderRoot(root, expirationTime);
        if (finishedWork !== null) {
          // We've completed the root. Commit it.
          root.remainingExpirationTime = commitRoot(finishedWork);
        }
      }
    } else {
      // Flush async work.
      var _finishedWork = root.finishedWork;
      if (_finishedWork !== null) {
        // This root is already complete. We can commit it.
        root.finishedWork = null;
        root.remainingExpirationTime = commitRoot(_finishedWork);
      } else {
        root.finishedWork = null;
        _finishedWork = renderRoot(root, expirationTime);
        if (_finishedWork !== null) {
          // We've completed the root. Check the deadline one more time
          // before committing.
          if (!shouldYield()) {
            // Still time left. Commit the root.
            root.remainingExpirationTime = commitRoot(_finishedWork);
          } else {
            // There's no time left. Mark this root as complete. We'll come
            // back and commit it later.
            root.finishedWork = _finishedWork;
          }
        }
      }
    }

    isRendering = false;
  }

  // When working on async work, the reconciler asks the renderer if it should
  // yield execution. For DOM, we implement this with requestIdleCallback.
  function shouldYield() {
    if (deadline === null) {
      return false;
    }
    if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {
      // Disregard deadline.didTimeout. Only expired work should be flushed
      // during a timeout. This path is only hit for non-expired work.
      return false;
    }
    deadlineDidExpire = true;
    return true;
  }

  // TODO: Not happy about this hook. Conceptually, renderRoot should return a
  // tuple of (isReadyForCommit, didError, error)
  function onUncaughtError(error) {
    !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    // Unschedule this root so we don't work on it again until there's
    // another update.
    nextFlushedRoot.remainingExpirationTime = NoWork;
    if (!hasUnhandledError) {
      hasUnhandledError = true;
      unhandledError = error;
    }
  }

  // TODO: Batching should be implemented at the renderer level, not inside
  // the reconciler.
  function batchedUpdates(fn, a) {
    var previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = true;
    try {
      return fn(a);
    } finally {
      isBatchingUpdates = previousIsBatchingUpdates;
      if (!isBatchingUpdates && !isRendering) {
        performWork(Sync, null);
      }
    }
  }

  // TODO: Batching should be implemented at the renderer level, not inside
  // the reconciler.
  function unbatchedUpdates(fn) {
    if (isBatchingUpdates && !isUnbatchingUpdates) {
      isUnbatchingUpdates = true;
      try {
        return fn();
      } finally {
        isUnbatchingUpdates = false;
      }
    }
    return fn();
  }

  // TODO: Batching should be implemented at the renderer level, not within
  // the reconciler.
  function flushSync(fn) {
    var previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = true;
    try {
      return syncUpdates(fn);
    } finally {
      isBatchingUpdates = previousIsBatchingUpdates;
      !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;
      performWork(Sync, null);
    }
  }

  return {
    computeAsyncExpiration: computeAsyncExpiration,
    computeExpirationForFiber: computeExpirationForFiber,
    scheduleWork: scheduleWork,
    batchedUpdates: batchedUpdates,
    unbatchedUpdates: unbatchedUpdates,
    flushSync: flushSync,
    deferredUpdates: deferredUpdates
  };
};

{
  var didWarnAboutNestedUpdates = false;
}

// 0 is PROD, 1 is DEV.
// Might add PROFILE later.


function getContextForSubtree(parentComponent) {
  if (!parentComponent) {
    return emptyObject;
  }

  var fiber = get(parentComponent);
  var parentContext = findCurrentUnmaskedContext(fiber);
  return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;
}

var ReactFiberReconciler$1 = function (config) {
  var getPublicInstance = config.getPublicInstance;

  var _ReactFiberScheduler = ReactFiberScheduler(config),
      computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,
      computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,
      scheduleWork = _ReactFiberScheduler.scheduleWork,
      batchedUpdates = _ReactFiberScheduler.batchedUpdates,
      unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,
      flushSync = _ReactFiberScheduler.flushSync,
      deferredUpdates = _ReactFiberScheduler.deferredUpdates;

  function scheduleTopLevelUpdate(current, element, callback) {
    {
      if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {
        didWarnAboutNestedUpdates = true;
        warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\n\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');
      }
    }

    callback = callback === undefined ? null : callback;
    {
      warning(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);
    }

    var expirationTime = void 0;
    // Check if the top-level element is an async wrapper component. If so,
    // treat updates to the root as async. This is a bit weird but lets us
    // avoid a separate `renderAsync` API.
    if (enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {
      expirationTime = computeAsyncExpiration();
    } else {
      expirationTime = computeExpirationForFiber(current);
    }

    var update = {
      expirationTime: expirationTime,
      partialState: { element: element },
      callback: callback,
      isReplace: false,
      isForced: false,
      nextCallback: null,
      next: null
    };
    insertUpdateIntoFiber(current, update);
    scheduleWork(current, expirationTime);
  }

  function findHostInstance(fiber) {
    var hostFiber = findCurrentHostFiber(fiber);
    if (hostFiber === null) {
      return null;
    }
    return hostFiber.stateNode;
  }

  return {
    createContainer: function (containerInfo, hydrate) {
      return createFiberRoot(containerInfo, hydrate);
    },
    updateContainer: function (element, container, parentComponent, callback) {
      // TODO: If this is a nested container, this won't be the root.
      var current = container.current;

      {
        if (ReactFiberInstrumentation_1.debugTool) {
          if (current.alternate === null) {
            ReactFiberInstrumentation_1.debugTool.onMountContainer(container);
          } else if (element === null) {
            ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);
          } else {
            ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);
          }
        }
      }

      var context = getContextForSubtree(parentComponent);
      if (container.context === null) {
        container.context = context;
      } else {
        container.pendingContext = context;
      }

      scheduleTopLevelUpdate(current, element, callback);
    },


    batchedUpdates: batchedUpdates,

    unbatchedUpdates: unbatchedUpdates,

    deferredUpdates: deferredUpdates,

    flushSync: flushSync,

    getPublicRootInstance: function (container) {
      var containerFiber = container.current;
      if (!containerFiber.child) {
        return null;
      }
      switch (containerFiber.child.tag) {
        case HostComponent:
          return getPublicInstance(containerFiber.child.stateNode);
        default:
          return containerFiber.child.stateNode;
      }
    },


    findHostInstance: findHostInstance,

    findHostInstanceWithNoPortals: function (fiber) {
      var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
      if (hostFiber === null) {
        return null;
      }
      return hostFiber.stateNode;
    },
    injectIntoDevTools: function (devToolsConfig) {
      var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;

      return injectInternals(_assign({}, devToolsConfig, {
        findHostInstanceByFiber: function (fiber) {
          return findHostInstance(fiber);
        },
        findFiberByHostInstance: function (instance) {
          if (!findFiberByHostInstance) {
            // Might not be implemented by the renderer.
            return null;
          }
          return findFiberByHostInstance(instance);
        }
      }));
    }
  };
};

var ReactFiberReconciler$2 = Object.freeze({
	default: ReactFiberReconciler$1
});

var ReactFiberReconciler$3 = ( ReactFiberReconciler$2 && ReactFiberReconciler$1 ) || ReactFiberReconciler$2;

// TODO: bundle Flow types with the package.



// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactReconciler = ReactFiberReconciler$3['default'] ? ReactFiberReconciler$3['default'] : ReactFiberReconciler$3;

function createPortal$1(children, containerInfo,
// TODO: figure out the API for cross-renderer implementation.
implementation) {
  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  return {
    // This tag allow us to uniquely identify this as a React Portal
    $$typeof: REACT_PORTAL_TYPE,
    key: key == null ? null : '' + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
}

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.2.0';

// a requestAnimationFrame, storing the time for the start of the frame, then
// scheduling a postMessage which gets scheduled after paint. Within the
// postMessage handler do as much work as possible until time + frame rate.
// By separating the idle call into a separate event tick we ensure that
// layout, paint and other browser work is counted against the available time.
// The frame rate is dynamically adjusted.

{
  if (ExecutionEnvironment.canUseDOM && typeof requestAnimationFrame !== 'function') {
    warning(false, 'React depends on requestAnimationFrame. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');
  }
}

var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';

var now = void 0;
if (hasNativePerformanceNow) {
  now = function () {
    return performance.now();
  };
} else {
  now = function () {
    return Date.now();
  };
}

// TODO: There's no way to cancel, because Fiber doesn't atm.
var rIC = void 0;
var cIC = void 0;

if (!ExecutionEnvironment.canUseDOM) {
  rIC = function (frameCallback) {
    return setTimeout(function () {
      frameCallback({
        timeRemaining: function () {
          return Infinity;
        }
      });
    });
  };
  cIC = function (timeoutID) {
    clearTimeout(timeoutID);
  };
} else if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {
  // Polyfill requestIdleCallback and cancelIdleCallback

  var scheduledRICCallback = null;
  var isIdleScheduled = false;
  var timeoutTime = -1;

  var isAnimationFrameScheduled = false;

  var frameDeadline = 0;
  // We start out assuming that we run at 30fps but then the heuristic tracking
  // will adjust this value to a faster fps if we get more frequent animation
  // frames.
  var previousFrameTime = 33;
  var activeFrameTime = 33;

  var frameDeadlineObject;
  if (hasNativePerformanceNow) {
    frameDeadlineObject = {
      didTimeout: false,
      timeRemaining: function () {
        // We assume that if we have a performance timer that the rAF callback
        // gets a performance timer value. Not sure if this is always true.
        var remaining = frameDeadline - performance.now();
        return remaining > 0 ? remaining : 0;
      }
    };
  } else {
    frameDeadlineObject = {
      didTimeout: false,
      timeRemaining: function () {
        // Fallback to Date.now()
        var remaining = frameDeadline - Date.now();
        return remaining > 0 ? remaining : 0;
      }
    };
  }

  // We use the postMessage trick to defer idle work until after the repaint.
  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);
  var idleTick = function (event) {
    if (event.source !== window || event.data !== messageKey) {
      return;
    }

    isIdleScheduled = false;

    var currentTime = now();
    if (frameDeadline - currentTime <= 0) {
      // There's no time left in this idle period. Check if the callback has
      // a timeout and whether it's been exceeded.
      if (timeoutTime !== -1 && timeoutTime <= currentTime) {
        // Exceeded the timeout. Invoke the callback even though there's no
        // time left.
        frameDeadlineObject.didTimeout = true;
      } else {
        // No timeout.
        if (!isAnimationFrameScheduled) {
          // Schedule another animation callback so we retry later.
          isAnimationFrameScheduled = true;
          requestAnimationFrame(animationTick);
        }
        // Exit without invoking the callback.
        return;
      }
    } else {
      // There's still time left in this idle period.
      frameDeadlineObject.didTimeout = false;
    }

    timeoutTime = -1;
    var callback = scheduledRICCallback;
    scheduledRICCallback = null;
    if (callback !== null) {
      callback(frameDeadlineObject);
    }
  };
  // Assumes that we have addEventListener in this environment. Might need
  // something better for old IE.
  window.addEventListener('message', idleTick, false);

  var animationTick = function (rafTime) {
    isAnimationFrameScheduled = false;
    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;
    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {
      if (nextFrameTime < 8) {
        // Defensive coding. We don't support higher frame rates than 120hz.
        // If we get lower than that, it is probably a bug.
        nextFrameTime = 8;
      }
      // If one frame goes long, then the next one can be short to catch up.
      // If two frames are short in a row, then that's an indication that we
      // actually have a higher frame rate than what we're currently optimizing.
      // We adjust our heuristic dynamically accordingly. For example, if we're
      // running on 120hz display or 90hz VR display.
      // Take the max of the two in case one of them was an anomaly due to
      // missed frame deadlines.
      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;
    } else {
      previousFrameTime = nextFrameTime;
    }
    frameDeadline = rafTime + activeFrameTime;
    if (!isIdleScheduled) {
      isIdleScheduled = true;
      window.postMessage(messageKey, '*');
    }
  };

  rIC = function (callback, options) {
    // This assumes that we only schedule one callback at a time because that's
    // how Fiber uses it.
    scheduledRICCallback = callback;
    if (options != null && typeof options.timeout === 'number') {
      timeoutTime = now() + options.timeout;
    }
    if (!isAnimationFrameScheduled) {
      // If rAF didn't already schedule one, we need to schedule a frame.
      // TODO: If this rAF doesn't materialize because the browser throttles, we
      // might want to still have setTimeout trigger rIC as a backup to ensure
      // that we keep performing work.
      isAnimationFrameScheduled = true;
      requestAnimationFrame(animationTick);
    }
    return 0;
  };

  cIC = function () {
    scheduledRICCallback = null;
    isIdleScheduled = false;
    timeoutTime = -1;
  };
} else {
  rIC = window.requestIdleCallback;
  cIC = window.cancelIdleCallback;
}

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

// isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  {
    warning(false, 'Invalid attribute name: `%s`', attributeName);
  }
  return false;
}

// shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

/**
 * Operations for dealing with DOM properties.
 */





/**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */
function getValueForProperty(node, name, expected) {
  {
    var propertyInfo = getPropertyInfo(name);
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod || propertyInfo.mustUseProperty) {
        return node[propertyInfo.propertyName];
      } else {
        var attributeName = propertyInfo.attributeName;

        var stringValue = null;

        if (propertyInfo.hasOverloadedBooleanValue) {
          if (node.hasAttribute(attributeName)) {
            var value = node.getAttribute(attributeName);
            if (value === '') {
              return true;
            }
            if (shouldIgnoreValue(propertyInfo, expected)) {
              return value;
            }
            if (value === '' + expected) {
              return expected;
            }
            return value;
          }
        } else if (node.hasAttribute(attributeName)) {
          if (shouldIgnoreValue(propertyInfo, expected)) {
            // We had an attribute but shouldn't have had one, so read it
            // for the error message.
            return node.getAttribute(attributeName);
          }
          if (propertyInfo.hasBooleanValue) {
            // If this was a boolean, it doesn't matter what the value is
            // the fact that we have it is the same as the expected.
            return expected;
          }
          // Even if this property uses a namespace we use getAttribute
          // because we assume its namespaced name is the same as our config.
          // To use getAttributeNS we need the local name which we don't have
          // in our config atm.
          stringValue = node.getAttribute(attributeName);
        }

        if (shouldIgnoreValue(propertyInfo, expected)) {
          return stringValue === null ? expected : stringValue;
        } else if (stringValue === '' + expected) {
          return expected;
        } else {
          return stringValue;
        }
      }
    }
  }
}

/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */
function getValueForAttribute(node, name, expected) {
  {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (!node.hasAttribute(name)) {
      return expected === undefined ? undefined : null;
    }
    var value = node.getAttribute(name);
    if (value === '' + expected) {
      return expected;
    }
    return value;
  }
}

/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */
function setValueForProperty(node, name, value) {
  var propertyInfo = getPropertyInfo(name);

  if (propertyInfo && shouldSetAttribute(name, value)) {
    var mutationMethod = propertyInfo.mutationMethod;
    if (mutationMethod) {
      mutationMethod(node, value);
    } else if (shouldIgnoreValue(propertyInfo, value)) {
      deleteValueForProperty(node, name);
      return;
    } else if (propertyInfo.mustUseProperty) {
      // Contrary to `setAttribute`, object properties are properly
      // `toString`ed by IE8/9.
      node[propertyInfo.propertyName] = value;
    } else {
      var attributeName = propertyInfo.attributeName;
      var namespace = propertyInfo.attributeNamespace;
      // `setAttribute` with objects becomes only `[object]` in IE8/9,
      // ('' + value) makes it output the correct toString()-value.
      if (namespace) {
        node.setAttributeNS(namespace, attributeName, '' + value);
      } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        node.setAttribute(attributeName, '');
      } else {
        node.setAttribute(attributeName, '' + value);
      }
    }
  } else {
    setValueForAttribute(node, name, shouldSetAttribute(name, value) ? value : null);
    return;
  }

  {
    
  }
}

function setValueForAttribute(node, name, value) {
  if (!isAttributeNameSafe(name)) {
    return;
  }
  if (value == null) {
    node.removeAttribute(name);
  } else {
    node.setAttribute(name, '' + value);
  }

  {
    
  }
}

/**
 * Deletes an attributes from a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */
function deleteValueForAttribute(node, name) {
  node.removeAttribute(name);
}

/**
 * Deletes the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */
function deleteValueForProperty(node, name) {
  var propertyInfo = getPropertyInfo(name);
  if (propertyInfo) {
    var mutationMethod = propertyInfo.mutationMethod;
    if (mutationMethod) {
      mutationMethod(node, undefined);
    } else if (propertyInfo.mustUseProperty) {
      var propName = propertyInfo.propertyName;
      if (propertyInfo.hasBooleanValue) {
        node[propName] = false;
      } else {
        node[propName] = '';
      }
    } else {
      node.removeAttribute(propertyInfo.attributeName);
    }
  } else {
    node.removeAttribute(name);
  }
}

var ReactControlledValuePropTypes = {
  checkPropTypes: null
};

{
  var hasReadOnlyValue = {
    button: true,
    checkbox: true,
    image: true,
    hidden: true,
    radio: true,
    reset: true,
    submit: true
  };

  var propTypes = {
    value: function (props, propName, componentName) {
      if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
        return null;
      }
      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    },
    checked: function (props, propName, componentName) {
      if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
        return null;
      }
      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }
  };

  /**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */
  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props, getStack) {
    checkPropTypes(propTypes, props, 'prop', tagName, getStack);
  };
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$2 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$3 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}

/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */

function getHostProps(element, props) {
  var node = element;
  var value = props.value;
  var checked = props.checked;

  var hostProps = _assign({
    // Make sure we set .type before any other properties (setting .value
    // before .type means .value is lost in IE11 and below)
    type: undefined,
    // Make sure we set .step before .value (setting .value before .step
    // means .value is rounded on mount, based upon step precision)
    step: undefined,
    // Make sure we set .min & .max before .value (to ensure proper order
    // in corner cases such as min or max deriving from value, e.g. Issue #7170)
    min: undefined,
    max: undefined
  }, props, {
    defaultChecked: undefined,
    defaultValue: undefined,
    value: value != null ? value : node._wrapperState.initialValue,
    checked: checked != null ? checked : node._wrapperState.initialChecked
  });

  return hostProps;
}

function initWrapperState(element, props) {
  {
    ReactControlledValuePropTypes.checkPropTypes('input', props, getCurrentFiberStackAddendum$3);

    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
      warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);
      didWarnCheckedDefaultChecked = true;
    }
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);
      didWarnValueDefaultValue = true;
    }
  }

  var defaultValue = props.defaultValue;
  var node = element;
  node._wrapperState = {
    initialChecked: props.checked != null ? props.checked : props.defaultChecked,
    initialValue: props.value != null ? props.value : defaultValue,
    controlled: isControlled(props)
  };
}

function updateChecked(element, props) {
  var node = element;
  var checked = props.checked;
  if (checked != null) {
    setValueForProperty(node, 'checked', checked);
  }
}

function updateWrapper(element, props) {
  var node = element;
  {
    var controlled = isControlled(props);

    if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
      warning(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());
      didWarnUncontrolledToControlled = true;
    }
    if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
      warning(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());
      didWarnControlledToUncontrolled = true;
    }
  }

  updateChecked(element, props);

  var value = props.value;
  if (value != null) {
    if (value === 0 && node.value === '') {
      node.value = '0';
      // Note: IE9 reports a number inputs as 'text', so check props instead.
    } else if (props.type === 'number') {
      // Simulate `input.valueAsNumber`. IE9 does not support it
      var valueAsNumber = parseFloat(node.value) || 0;

      if (
      // eslint-disable-next-line
      value != valueAsNumber ||
      // eslint-disable-next-line
      value == valueAsNumber && node.value != value) {
        // Cast `value` to a string to ensure the value is set correctly. While
        // browsers typically do this as necessary, jsdom doesn't.
        node.value = '' + value;
      }
    } else if (node.value !== '' + value) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      node.value = '' + value;
    }
  } else {
    if (props.value == null && props.defaultValue != null) {
      // In Chrome, assigning defaultValue to certain input types triggers input validation.
      // For number inputs, the display value loses trailing decimal points. For email inputs,
      // Chrome raises "The specified value <x> is not a valid email address".
      //
      // Here we check to see if the defaultValue has actually changed, avoiding these problems
      // when the user is inputting text
      //
      // https://github.com/facebook/react/issues/7253
      if (node.defaultValue !== '' + props.defaultValue) {
        node.defaultValue = '' + props.defaultValue;
      }
    }
    if (props.checked == null && props.defaultChecked != null) {
      node.defaultChecked = !!props.defaultChecked;
    }
  }
}

function postMountWrapper(element, props) {
  var node = element;

  // Detach value from defaultValue. We won't do anything if we're working on
  // submit or reset inputs as those values & defaultValues are linked. They
  // are not resetable nodes so this operation doesn't matter and actually
  // removes browser-default values (eg "Submit Query") when no value is
  // provided.

  switch (props.type) {
    case 'submit':
    case 'reset':
      break;
    case 'color':
    case 'date':
    case 'datetime':
    case 'datetime-local':
    case 'month':
    case 'time':
    case 'week':
      // This fixes the no-show issue on iOS Safari and Android Chrome:
      // https://github.com/facebook/react/issues/7233
      node.value = '';
      node.value = node.defaultValue;
      break;
    default:
      node.value = node.value;
      break;
  }

  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
  // this is needed to work around a chrome bug where setting defaultChecked
  // will sometimes influence the value of checked (even after detachment).
  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
  // We need to temporarily unset name to avoid disrupting radio button groups.
  var name = node.name;
  if (name !== '') {
    node.name = '';
  }
  node.defaultChecked = !node.defaultChecked;
  node.defaultChecked = !node.defaultChecked;
  if (name !== '') {
    node.name = name;
  }
}

function restoreControlledState$1(element, props) {
  var node = element;
  updateWrapper(node, props);
  updateNamedCousins(node, props);
}

function updateNamedCousins(rootNode, props) {
  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form. It might not even be in the
    // document. Let's just use the local `querySelectorAll` to ensure we don't
    // miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.
      var otherProps = getFiberCurrentPropsFromNode$1(otherNode);
      !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;

      // We need update the tracked value on the named cousin since the value
      // was changed but the input saw no event or value set
      updateValueIfChanged(otherNode);

      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      updateWrapper(otherNode, otherProps);
    }
  }
}

function flattenChildren(children) {
  var content = '';

  // Flatten children and warn if they aren't strings or numbers;
  // invalid types are ignored.
  // We can silently skip them because invalid DOM nesting warning
  // catches these cases in Fiber.
  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }
    if (typeof child === 'string' || typeof child === 'number') {
      content += child;
    }
  });

  return content;
}

/**
 * Implements an <option> host component that warns when `selected` is set.
 */

function validateProps(element, props) {
  // TODO (yungsters): Remove support for `selected` in <option>.
  {
    warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');
  }
}

function postMountWrapper$1(element, props) {
  // value="" should make a value attribute (#6219)
  if (props.value != null) {
    element.setAttribute('value', props.value);
  }
}

function getHostProps$1(element, props) {
  var hostProps = _assign({ children: undefined }, props);
  var content = flattenChildren(props.children);

  if (content) {
    hostProps.children = content;
  }

  return hostProps;
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$3 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$4 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;


{
  var didWarnValueDefaultValue$1 = false;
}

function getDeclarationErrorAddendum() {
  var ownerName = getCurrentFiberOwnerName$3();
  if (ownerName) {
    return '\n\nCheck the render method of `' + ownerName + '`.';
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 */
function checkSelectPropTypes(props) {
  ReactControlledValuePropTypes.checkPropTypes('select', props, getCurrentFiberStackAddendum$4);

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    var isArray = Array.isArray(props[propName]);
    if (props.multiple && !isArray) {
      warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());
    } else if (!props.multiple && isArray) {
      warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());
    }
  }
}

function updateOptions(node, multiple, propValue, setDefaultSelected) {
  var options = node.options;

  if (multiple) {
    var selectedValues = propValue;
    var selectedValue = {};
    for (var i = 0; i < selectedValues.length; i++) {
      // Prefix to avoid chaos with special keys.
      selectedValue['$' + selectedValues[i]] = true;
    }
    for (var _i = 0; _i < options.length; _i++) {
      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);
      if (options[_i].selected !== selected) {
        options[_i].selected = selected;
      }
      if (selected && setDefaultSelected) {
        options[_i].defaultSelected = true;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    var _selectedValue = '' + propValue;
    var defaultSelected = null;
    for (var _i2 = 0; _i2 < options.length; _i2++) {
      if (options[_i2].value === _selectedValue) {
        options[_i2].selected = true;
        if (setDefaultSelected) {
          options[_i2].defaultSelected = true;
        }
        return;
      }
      if (defaultSelected === null && !options[_i2].disabled) {
        defaultSelected = options[_i2];
      }
    }
    if (defaultSelected !== null) {
      defaultSelected.selected = true;
    }
  }
}

/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */

function getHostProps$2(element, props) {
  return _assign({}, props, {
    value: undefined
  });
}

function initWrapperState$1(element, props) {
  var node = element;
  {
    checkSelectPropTypes(props);
  }

  var value = props.value;
  node._wrapperState = {
    initialValue: value != null ? value : props.defaultValue,
    wasMultiple: !!props.multiple
  };

  {
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
      warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
      didWarnValueDefaultValue$1 = true;
    }
  }
}

function postMountWrapper$2(element, props) {
  var node = element;
  node.multiple = !!props.multiple;
  var value = props.value;
  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (props.defaultValue != null) {
    updateOptions(node, !!props.multiple, props.defaultValue, true);
  }
}

function postUpdateWrapper(element, props) {
  var node = element;
  // After the initial mount, we control selected-ness manually so don't pass
  // this value down
  node._wrapperState.initialValue = undefined;

  var wasMultiple = node._wrapperState.wasMultiple;
  node._wrapperState.wasMultiple = !!props.multiple;

  var value = props.value;
  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (wasMultiple !== !!props.multiple) {
    // For simplicity, reapply `defaultValue` if `multiple` is toggled.
    if (props.defaultValue != null) {
      updateOptions(node, !!props.multiple, props.defaultValue, true);
    } else {
      // Revert the select back to its default unselected state.
      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);
    }
  }
}

function restoreControlledState$2(element, props) {
  var node = element;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  }
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$5 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnValDefaultVal = false;

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */

function getHostProps$3(element, props) {
  var node = element;
  !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;

  // Always set children to the same thing. In IE9, the selection range will
  // get reset if `textContent` is mutated.  We could add a check in setTextContent
  // to only set the value if/when the value differs from the node value (which would
  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
  // solution. The value can be a boolean or object so that's why it's forced
  // to be a string.
  var hostProps = _assign({}, props, {
    value: undefined,
    defaultValue: undefined,
    children: '' + node._wrapperState.initialValue
  });

  return hostProps;
}

function initWrapperState$2(element, props) {
  var node = element;
  {
    ReactControlledValuePropTypes.checkPropTypes('textarea', props, getCurrentFiberStackAddendum$5);
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
      warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
      didWarnValDefaultVal = true;
    }
  }

  var initialValue = props.value;

  // Only bother fetching default value if we're going to use it
  if (initialValue == null) {
    var defaultValue = props.defaultValue;
    // TODO (yungsters): Remove support for children content in <textarea>.
    var children = props.children;
    if (children != null) {
      {
        warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
      }
      !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;
      if (Array.isArray(children)) {
        !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;
        children = children[0];
      }

      defaultValue = '' + children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    initialValue = defaultValue;
  }

  node._wrapperState = {
    initialValue: '' + initialValue
  };
}

function updateWrapper$1(element, props) {
  var node = element;
  var value = props.value;
  if (value != null) {
    // Cast `value` to a string to ensure the value is set correctly. While
    // browsers typically do this as necessary, jsdom doesn't.
    var newValue = '' + value;

    // To avoid side effects (such as losing text selection), only set value if changed
    if (newValue !== node.value) {
      node.value = newValue;
    }
    if (props.defaultValue == null) {
      node.defaultValue = newValue;
    }
  }
  if (props.defaultValue != null) {
    node.defaultValue = props.defaultValue;
  }
}

function postMountWrapper$3(element, props) {
  var node = element;
  // This is in postMount because we need access to the DOM node, which is not
  // available until after the component has mounted.
  var textContent = node.textContent;

  // Only set node.value if textContent is equal to the expected
  // initial value. In IE10/IE11 there is a bug where the placeholder attribute
  // will populate textContent as well.
  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
  if (textContent === node._wrapperState.initialValue) {
    node.value = textContent;
  }
}

function restoreControlledState$3(element, props) {
  // DOM component is still mounted; update
  updateWrapper$1(element, props);
}

var HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';
var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';

var Namespaces = {
  html: HTML_NAMESPACE$1,
  mathml: MATH_NAMESPACE,
  svg: SVG_NAMESPACE
};

// Assumes there is no parent namespace.
function getIntrinsicNamespace(type) {
  switch (type) {
    case 'svg':
      return SVG_NAMESPACE;
    case 'math':
      return MATH_NAMESPACE;
    default:
      return HTML_NAMESPACE$1;
  }
}

function getChildNamespace(parentNamespace, type) {
  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {
    // No (or default) parent namespace: potential entry point.
    return getIntrinsicNamespace(type);
  }
  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
    // We're leaving SVG.
    return HTML_NAMESPACE$1;
  }
  // By default, pass namespace below.
  return parentNamespace;
}

/* globals MSApp */

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */
var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

// SVG temp container for IE lacking innerHTML
var reusableSVGContainer = void 0;

/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  // IE does not have innerHTML for SVG nodes, so instead we inject the
  // new markup in a temp node and then move the child nodes across into
  // the target node

  if (node.namespaceURI === Namespaces.svg && !('innerHTML' in node)) {
    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
    var svgNode = reusableSVGContainer.firstChild;
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
    while (svgNode.firstChild) {
      node.appendChild(svgNode.firstChild);
    }
  } else {
    node.innerHTML = html;
  }
});

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
};

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
  }

  return ('' + value).trim();
}

var warnValidStyle = emptyFunction;

{
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;
  var warnedForInfinityValue = false;

  var warnHyphenatedStyleName = function (name, getStack) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), getStack());
  };

  var warnBadVendoredStyleName = function (name, getStack) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), getStack());
  };

  var warnStyleValueWithSemicolon = function (name, value, getStack) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    warning(false, "Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.%s', name, value.replace(badStyleValueWithSemicolonPattern, ''), getStack());
  };

  var warnStyleValueIsNaN = function (name, value, getStack) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, getStack());
  };

  var warnStyleValueIsInfinity = function (name, value, getStack) {
    if (warnedForInfinityValue) {
      return;
    }

    warnedForInfinityValue = true;
    warning(false, '`Infinity` is an invalid value for the `%s` css style property.%s', name, getStack());
  };

  warnValidStyle = function (name, value, getStack) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name, getStack);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name, getStack);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value, getStack);
    }

    if (typeof value === 'number') {
      if (isNaN(value)) {
        warnStyleValueIsNaN(name, value, getStack);
      } else if (!isFinite(value)) {
        warnStyleValueIsInfinity(name, value, getStack);
      }
    }
  };
}

var warnValidStyle$1 = warnValidStyle;

/**
 * Operations for dealing with CSS properties.
 */

/**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */
function createDangerousStringForStyles(styles) {
  {
    var serialized = '';
    var delimiter = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if (styleValue != null) {
        var isCustomProperty = styleName.indexOf('--') === 0;
        serialized += delimiter + hyphenateStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);

        delimiter = ';';
      }
    }
    return serialized || null;
  }
}

/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */
function setValueForStyles(node, styles, getStack) {
  var style = node.style;
  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }
    var isCustomProperty = styleName.indexOf('--') === 0;
    {
      if (!isCustomProperty) {
        warnValidStyle$1(styleName, styles[styleName], getStack);
      }
    }
    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
    if (styleName === 'float') {
      styleName = 'cssFloat';
    }
    if (isCustomProperty) {
      style.setProperty(styleName, styleValue);
    } else {
      style[styleName] = styleValue;
    }
  }
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  menuitem: true
}, omittedCloseTags);

var HTML$1 = '__html';

function assertValidProps(tag, props, getStack) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (voidElementTags[tag]) {
    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, getStack()) : void 0;
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;
  }
  {
    warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.%s', getStack());
  }
  !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getStack()) : void 0;
}

function isCustomComponent(tagName, props) {
  if (tagName.indexOf('-') === -1) {
    return typeof props.is === 'string';
  }
  switch (tagName) {
    // These are reserved SVG and MathML elements.
    // We don't mind this whitelist too much because we expect it to never grow.
    // The alternative is to track the namespace in a few places which is convoluted.
    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return false;
    default:
      return true;
  }
}

var ariaProperties = {
  'aria-current': 0, // state
  'aria-details': 0,
  'aria-disabled': 0, // state
  'aria-hidden': 0, // state
  'aria-invalid': 0, // state
  'aria-keyshortcuts': 0,
  'aria-label': 0,
  'aria-roledescription': 0,
  // Widget Attributes
  'aria-autocomplete': 0,
  'aria-checked': 0,
  'aria-expanded': 0,
  'aria-haspopup': 0,
  'aria-level': 0,
  'aria-modal': 0,
  'aria-multiline': 0,
  'aria-multiselectable': 0,
  'aria-orientation': 0,
  'aria-placeholder': 0,
  'aria-pressed': 0,
  'aria-readonly': 0,
  'aria-required': 0,
  'aria-selected': 0,
  'aria-sort': 0,
  'aria-valuemax': 0,
  'aria-valuemin': 0,
  'aria-valuenow': 0,
  'aria-valuetext': 0,
  // Live Region Attributes
  'aria-atomic': 0,
  'aria-busy': 0,
  'aria-live': 0,
  'aria-relevant': 0,
  // Drag-and-Drop Attributes
  'aria-dropeffect': 0,
  'aria-grabbed': 0,
  // Relationship Attributes
  'aria-activedescendant': 0,
  'aria-colcount': 0,
  'aria-colindex': 0,
  'aria-colspan': 0,
  'aria-controls': 0,
  'aria-describedby': 0,
  'aria-errormessage': 0,
  'aria-flowto': 0,
  'aria-labelledby': 0,
  'aria-owns': 0,
  'aria-posinset': 0,
  'aria-rowcount': 0,
  'aria-rowindex': 0,
  'aria-rowspan': 0,
  'aria-setsize': 0
};

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

var hasOwnProperty = Object.prototype.hasOwnProperty;

function getStackAddendum() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

function validateProperty(tagName, name) {
  if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
    return true;
  }

  if (rARIACamel.test(name)) {
    var ariaName = 'aria-' + name.slice(4).toLowerCase();
    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (correctName == null) {
      warning(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s', name, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== correctName) {
      warning(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?%s', name, correctName, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
  }

  if (rARIA.test(name)) {
    var lowerCasedName = name.toLowerCase();
    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (standardName == null) {
      warnedProperties[name] = true;
      return false;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== standardName) {
      warning(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
  }

  return true;
}

function warnInvalidARIAProps(type, props) {
  var invalidProps = [];

  for (var key in props) {
    var isValid = validateProperty(type, key);
    if (!isValid) {
      invalidProps.push(key);
    }
  }

  var unknownPropString = invalidProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (invalidProps.length === 1) {
    warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());
  } else if (invalidProps.length > 1) {
    warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());
  }
}

function validateProperties(type, props) {
  if (isCustomComponent(type, props)) {
    return;
  }
  warnInvalidARIAProps(type, props);
}

var didWarnValueNull = false;

function getStackAddendum$1() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

function validateProperties$1(type, props) {
  if (type !== 'input' && type !== 'textarea' && type !== 'select') {
    return;
  }

  if (props != null && props.value === null && !didWarnValueNull) {
    didWarnValueNull = true;
    if (type === 'select' && props.multiple) {
      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.%s', type, getStackAddendum$1());
    } else {
      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', type, getStackAddendum$1());
    }
  }
}

// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames = {
  // HTML
  accept: 'accept',
  acceptcharset: 'acceptCharset',
  'accept-charset': 'acceptCharset',
  accesskey: 'accessKey',
  action: 'action',
  allowfullscreen: 'allowFullScreen',
  alt: 'alt',
  as: 'as',
  async: 'async',
  autocapitalize: 'autoCapitalize',
  autocomplete: 'autoComplete',
  autocorrect: 'autoCorrect',
  autofocus: 'autoFocus',
  autoplay: 'autoPlay',
  autosave: 'autoSave',
  capture: 'capture',
  cellpadding: 'cellPadding',
  cellspacing: 'cellSpacing',
  challenge: 'challenge',
  charset: 'charSet',
  checked: 'checked',
  children: 'children',
  cite: 'cite',
  'class': 'className',
  classid: 'classID',
  classname: 'className',
  cols: 'cols',
  colspan: 'colSpan',
  content: 'content',
  contenteditable: 'contentEditable',
  contextmenu: 'contextMenu',
  controls: 'controls',
  controlslist: 'controlsList',
  coords: 'coords',
  crossorigin: 'crossOrigin',
  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
  data: 'data',
  datetime: 'dateTime',
  'default': 'default',
  defaultchecked: 'defaultChecked',
  defaultvalue: 'defaultValue',
  defer: 'defer',
  dir: 'dir',
  disabled: 'disabled',
  download: 'download',
  draggable: 'draggable',
  enctype: 'encType',
  'for': 'htmlFor',
  form: 'form',
  formmethod: 'formMethod',
  formaction: 'formAction',
  formenctype: 'formEncType',
  formnovalidate: 'formNoValidate',
  formtarget: 'formTarget',
  frameborder: 'frameBorder',
  headers: 'headers',
  height: 'height',
  hidden: 'hidden',
  high: 'high',
  href: 'href',
  hreflang: 'hrefLang',
  htmlfor: 'htmlFor',
  httpequiv: 'httpEquiv',
  'http-equiv': 'httpEquiv',
  icon: 'icon',
  id: 'id',
  innerhtml: 'innerHTML',
  inputmode: 'inputMode',
  integrity: 'integrity',
  is: 'is',
  itemid: 'itemID',
  itemprop: 'itemProp',
  itemref: 'itemRef',
  itemscope: 'itemScope',
  itemtype: 'itemType',
  keyparams: 'keyParams',
  keytype: 'keyType',
  kind: 'kind',
  label: 'label',
  lang: 'lang',
  list: 'list',
  loop: 'loop',
  low: 'low',
  manifest: 'manifest',
  marginwidth: 'marginWidth',
  marginheight: 'marginHeight',
  max: 'max',
  maxlength: 'maxLength',
  media: 'media',
  mediagroup: 'mediaGroup',
  method: 'method',
  min: 'min',
  minlength: 'minLength',
  multiple: 'multiple',
  muted: 'muted',
  name: 'name',
  nonce: 'nonce',
  novalidate: 'noValidate',
  open: 'open',
  optimum: 'optimum',
  pattern: 'pattern',
  placeholder: 'placeholder',
  playsinline: 'playsInline',
  poster: 'poster',
  preload: 'preload',
  profile: 'profile',
  radiogroup: 'radioGroup',
  readonly: 'readOnly',
  referrerpolicy: 'referrerPolicy',
  rel: 'rel',
  required: 'required',
  reversed: 'reversed',
  role: 'role',
  rows: 'rows',
  rowspan: 'rowSpan',
  sandbox: 'sandbox',
  scope: 'scope',
  scoped: 'scoped',
  scrolling: 'scrolling',
  seamless: 'seamless',
  selected: 'selected',
  shape: 'shape',
  size: 'size',
  sizes: 'sizes',
  span: 'span',
  spellcheck: 'spellCheck',
  src: 'src',
  srcdoc: 'srcDoc',
  srclang: 'srcLang',
  srcset: 'srcSet',
  start: 'start',
  step: 'step',
  style: 'style',
  summary: 'summary',
  tabindex: 'tabIndex',
  target: 'target',
  title: 'title',
  type: 'type',
  usemap: 'useMap',
  value: 'value',
  width: 'width',
  wmode: 'wmode',
  wrap: 'wrap',

  // SVG
  about: 'about',
  accentheight: 'accentHeight',
  'accent-height': 'accentHeight',
  accumulate: 'accumulate',
  additive: 'additive',
  alignmentbaseline: 'alignmentBaseline',
  'alignment-baseline': 'alignmentBaseline',
  allowreorder: 'allowReorder',
  alphabetic: 'alphabetic',
  amplitude: 'amplitude',
  arabicform: 'arabicForm',
  'arabic-form': 'arabicForm',
  ascent: 'ascent',
  attributename: 'attributeName',
  attributetype: 'attributeType',
  autoreverse: 'autoReverse',
  azimuth: 'azimuth',
  basefrequency: 'baseFrequency',
  baselineshift: 'baselineShift',
  'baseline-shift': 'baselineShift',
  baseprofile: 'baseProfile',
  bbox: 'bbox',
  begin: 'begin',
  bias: 'bias',
  by: 'by',
  calcmode: 'calcMode',
  capheight: 'capHeight',
  'cap-height': 'capHeight',
  clip: 'clip',
  clippath: 'clipPath',
  'clip-path': 'clipPath',
  clippathunits: 'clipPathUnits',
  cliprule: 'clipRule',
  'clip-rule': 'clipRule',
  color: 'color',
  colorinterpolation: 'colorInterpolation',
  'color-interpolation': 'colorInterpolation',
  colorinterpolationfilters: 'colorInterpolationFilters',
  'color-interpolation-filters': 'colorInterpolationFilters',
  colorprofile: 'colorProfile',
  'color-profile': 'colorProfile',
  colorrendering: 'colorRendering',
  'color-rendering': 'colorRendering',
  contentscripttype: 'contentScriptType',
  contentstyletype: 'contentStyleType',
  cursor: 'cursor',
  cx: 'cx',
  cy: 'cy',
  d: 'd',
  datatype: 'datatype',
  decelerate: 'decelerate',
  descent: 'descent',
  diffuseconstant: 'diffuseConstant',
  direction: 'direction',
  display: 'display',
  divisor: 'divisor',
  dominantbaseline: 'dominantBaseline',
  'dominant-baseline': 'dominantBaseline',
  dur: 'dur',
  dx: 'dx',
  dy: 'dy',
  edgemode: 'edgeMode',
  elevation: 'elevation',
  enablebackground: 'enableBackground',
  'enable-background': 'enableBackground',
  end: 'end',
  exponent: 'exponent',
  externalresourcesrequired: 'externalResourcesRequired',
  fill: 'fill',
  fillopacity: 'fillOpacity',
  'fill-opacity': 'fillOpacity',
  fillrule: 'fillRule',
  'fill-rule': 'fillRule',
  filter: 'filter',
  filterres: 'filterRes',
  filterunits: 'filterUnits',
  floodopacity: 'floodOpacity',
  'flood-opacity': 'floodOpacity',
  floodcolor: 'floodColor',
  'flood-color': 'floodColor',
  focusable: 'focusable',
  fontfamily: 'fontFamily',
  'font-family': 'fontFamily',
  fontsize: 'fontSize',
  'font-size': 'fontSize',
  fontsizeadjust: 'fontSizeAdjust',
  'font-size-adjust': 'fontSizeAdjust',
  fontstretch: 'fontStretch',
  'font-stretch': 'fontStretch',
  fontstyle: 'fontStyle',
  'font-style': 'fontStyle',
  fontvariant: 'fontVariant',
  'font-variant': 'fontVariant',
  fontweight: 'fontWeight',
  'font-weight': 'fontWeight',
  format: 'format',
  from: 'from',
  fx: 'fx',
  fy: 'fy',
  g1: 'g1',
  g2: 'g2',
  glyphname: 'glyphName',
  'glyph-name': 'glyphName',
  glyphorientationhorizontal: 'glyphOrientationHorizontal',
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  glyphorientationvertical: 'glyphOrientationVertical',
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  glyphref: 'glyphRef',
  gradienttransform: 'gradientTransform',
  gradientunits: 'gradientUnits',
  hanging: 'hanging',
  horizadvx: 'horizAdvX',
  'horiz-adv-x': 'horizAdvX',
  horizoriginx: 'horizOriginX',
  'horiz-origin-x': 'horizOriginX',
  ideographic: 'ideographic',
  imagerendering: 'imageRendering',
  'image-rendering': 'imageRendering',
  in2: 'in2',
  'in': 'in',
  inlist: 'inlist',
  intercept: 'intercept',
  k1: 'k1',
  k2: 'k2',
  k3: 'k3',
  k4: 'k4',
  k: 'k',
  kernelmatrix: 'kernelMatrix',
  kernelunitlength: 'kernelUnitLength',
  kerning: 'kerning',
  keypoints: 'keyPoints',
  keysplines: 'keySplines',
  keytimes: 'keyTimes',
  lengthadjust: 'lengthAdjust',
  letterspacing: 'letterSpacing',
  'letter-spacing': 'letterSpacing',
  lightingcolor: 'lightingColor',
  'lighting-color': 'lightingColor',
  limitingconeangle: 'limitingConeAngle',
  local: 'local',
  markerend: 'markerEnd',
  'marker-end': 'markerEnd',
  markerheight: 'markerHeight',
  markermid: 'markerMid',
  'marker-mid': 'markerMid',
  markerstart: 'markerStart',
  'marker-start': 'markerStart',
  markerunits: 'markerUnits',
  markerwidth: 'markerWidth',
  mask: 'mask',
  maskcontentunits: 'maskContentUnits',
  maskunits: 'maskUnits',
  mathematical: 'mathematical',
  mode: 'mode',
  numoctaves: 'numOctaves',
  offset: 'offset',
  opacity: 'opacity',
  operator: 'operator',
  order: 'order',
  orient: 'orient',
  orientation: 'orientation',
  origin: 'origin',
  overflow: 'overflow',
  overlineposition: 'overlinePosition',
  'overline-position': 'overlinePosition',
  overlinethickness: 'overlineThickness',
  'overline-thickness': 'overlineThickness',
  paintorder: 'paintOrder',
  'paint-order': 'paintOrder',
  panose1: 'panose1',
  'panose-1': 'panose1',
  pathlength: 'pathLength',
  patterncontentunits: 'patternContentUnits',
  patterntransform: 'patternTransform',
  patternunits: 'patternUnits',
  pointerevents: 'pointerEvents',
  'pointer-events': 'pointerEvents',
  points: 'points',
  pointsatx: 'pointsAtX',
  pointsaty: 'pointsAtY',
  pointsatz: 'pointsAtZ',
  prefix: 'prefix',
  preservealpha: 'preserveAlpha',
  preserveaspectratio: 'preserveAspectRatio',
  primitiveunits: 'primitiveUnits',
  property: 'property',
  r: 'r',
  radius: 'radius',
  refx: 'refX',
  refy: 'refY',
  renderingintent: 'renderingIntent',
  'rendering-intent': 'renderingIntent',
  repeatcount: 'repeatCount',
  repeatdur: 'repeatDur',
  requiredextensions: 'requiredExtensions',
  requiredfeatures: 'requiredFeatures',
  resource: 'resource',
  restart: 'restart',
  result: 'result',
  results: 'results',
  rotate: 'rotate',
  rx: 'rx',
  ry: 'ry',
  scale: 'scale',
  security: 'security',
  seed: 'seed',
  shaperendering: 'shapeRendering',
  'shape-rendering': 'shapeRendering',
  slope: 'slope',
  spacing: 'spacing',
  specularconstant: 'specularConstant',
  specularexponent: 'specularExponent',
  speed: 'speed',
  spreadmethod: 'spreadMethod',
  startoffset: 'startOffset',
  stddeviation: 'stdDeviation',
  stemh: 'stemh',
  stemv: 'stemv',
  stitchtiles: 'stitchTiles',
  stopcolor: 'stopColor',
  'stop-color': 'stopColor',
  stopopacity: 'stopOpacity',
  'stop-opacity': 'stopOpacity',
  strikethroughposition: 'strikethroughPosition',
  'strikethrough-position': 'strikethroughPosition',
  strikethroughthickness: 'strikethroughThickness',
  'strikethrough-thickness': 'strikethroughThickness',
  string: 'string',
  stroke: 'stroke',
  strokedasharray: 'strokeDasharray',
  'stroke-dasharray': 'strokeDasharray',
  strokedashoffset: 'strokeDashoffset',
  'stroke-dashoffset': 'strokeDashoffset',
  strokelinecap: 'strokeLinecap',
  'stroke-linecap': 'strokeLinecap',
  strokelinejoin: 'strokeLinejoin',
  'stroke-linejoin': 'strokeLinejoin',
  strokemiterlimit: 'strokeMiterlimit',
  'stroke-miterlimit': 'strokeMiterlimit',
  strokewidth: 'strokeWidth',
  'stroke-width': 'strokeWidth',
  strokeopacity: 'strokeOpacity',
  'stroke-opacity': 'strokeOpacity',
  suppresscontenteditablewarning: 'suppressContentEditableWarning',
  suppresshydrationwarning: 'suppressHydrationWarning',
  surfacescale: 'surfaceScale',
  systemlanguage: 'systemLanguage',
  tablevalues: 'tableValues',
  targetx: 'targetX',
  targety: 'targetY',
  textanchor: 'textAnchor',
  'text-anchor': 'textAnchor',
  textdecoration: 'textDecoration',
  'text-decoration': 'textDecoration',
  textlength: 'textLength',
  textrendering: 'textRendering',
  'text-rendering': 'textRendering',
  to: 'to',
  transform: 'transform',
  'typeof': 'typeof',
  u1: 'u1',
  u2: 'u2',
  underlineposition: 'underlinePosition',
  'underline-position': 'underlinePosition',
  underlinethickness: 'underlineThickness',
  'underline-thickness': 'underlineThickness',
  unicode: 'unicode',
  unicodebidi: 'unicodeBidi',
  'unicode-bidi': 'unicodeBidi',
  unicoderange: 'unicodeRange',
  'unicode-range': 'unicodeRange',
  unitsperem: 'unitsPerEm',
  'units-per-em': 'unitsPerEm',
  unselectable: 'unselectable',
  valphabetic: 'vAlphabetic',
  'v-alphabetic': 'vAlphabetic',
  values: 'values',
  vectoreffect: 'vectorEffect',
  'vector-effect': 'vectorEffect',
  version: 'version',
  vertadvy: 'vertAdvY',
  'vert-adv-y': 'vertAdvY',
  vertoriginx: 'vertOriginX',
  'vert-origin-x': 'vertOriginX',
  vertoriginy: 'vertOriginY',
  'vert-origin-y': 'vertOriginY',
  vhanging: 'vHanging',
  'v-hanging': 'vHanging',
  videographic: 'vIdeographic',
  'v-ideographic': 'vIdeographic',
  viewbox: 'viewBox',
  viewtarget: 'viewTarget',
  visibility: 'visibility',
  vmathematical: 'vMathematical',
  'v-mathematical': 'vMathematical',
  vocab: 'vocab',
  widths: 'widths',
  wordspacing: 'wordSpacing',
  'word-spacing': 'wordSpacing',
  writingmode: 'writingMode',
  'writing-mode': 'writingMode',
  x1: 'x1',
  x2: 'x2',
  x: 'x',
  xchannelselector: 'xChannelSelector',
  xheight: 'xHeight',
  'x-height': 'xHeight',
  xlinkactuate: 'xlinkActuate',
  'xlink:actuate': 'xlinkActuate',
  xlinkarcrole: 'xlinkArcrole',
  'xlink:arcrole': 'xlinkArcrole',
  xlinkhref: 'xlinkHref',
  'xlink:href': 'xlinkHref',
  xlinkrole: 'xlinkRole',
  'xlink:role': 'xlinkRole',
  xlinkshow: 'xlinkShow',
  'xlink:show': 'xlinkShow',
  xlinktitle: 'xlinkTitle',
  'xlink:title': 'xlinkTitle',
  xlinktype: 'xlinkType',
  'xlink:type': 'xlinkType',
  xmlbase: 'xmlBase',
  'xml:base': 'xmlBase',
  xmllang: 'xmlLang',
  'xml:lang': 'xmlLang',
  xmlns: 'xmlns',
  'xml:space': 'xmlSpace',
  xmlnsxlink: 'xmlnsXlink',
  'xmlns:xlink': 'xmlnsXlink',
  xmlspace: 'xmlSpace',
  y1: 'y1',
  y2: 'y2',
  y: 'y',
  ychannelselector: 'yChannelSelector',
  z: 'z',
  zoomandpan: 'zoomAndPan'
};

function getStackAddendum$2() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

{
  var warnedProperties$1 = {};
  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var EVENT_NAME_REGEX = /^on./;
  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

  var validateProperty$1 = function (tagName, name, value, canUseEventSystem) {
    if (hasOwnProperty$1.call(warnedProperties$1, name) && warnedProperties$1[name]) {
      return true;
    }

    var lowerCasedName = name.toLowerCase();
    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
      warning(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');
      warnedProperties$1[name] = true;
      return true;
    }

    // We can't rely on the event system being injected on the server.
    if (canUseEventSystem) {
      if (registrationNameModules.hasOwnProperty(name)) {
        return true;
      }
      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
      if (registrationName != null) {
        warning(false, 'Invalid event handler property `%s`. Did you mean `%s`?%s', name, registrationName, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }
      if (EVENT_NAME_REGEX.test(name)) {
        warning(false, 'Unknown event handler property `%s`. It will be ignored.%s', name, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }
    } else if (EVENT_NAME_REGEX.test(name)) {
      // If no event plugins have been injected, we are in a server environment.
      // So we can't tell if the event name is correct for sure, but we can filter
      // out known bad ones like `onclick`. We can't suggest a specific replacement though.
      if (INVALID_EVENT_NAME_REGEX.test(name)) {
        warning(false, 'Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.%s', name, getStackAddendum$2());
      }
      warnedProperties$1[name] = true;
      return true;
    }

    // Let the ARIA attribute hook validate ARIA attributes
    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
      return true;
    }

    if (lowerCasedName === 'innerhtml') {
      warning(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'aria') {
      warning(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
      warning(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.%s', typeof value, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'number' && isNaN(value)) {
      warning(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.%s', name, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    var isReserved = isReservedProp(name);

    // Known attributes should match the casing specified in the property config.
    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      var standardName = possibleStandardNames[lowerCasedName];
      if (standardName !== name) {
        warning(false, 'Invalid DOM property `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }
    } else if (!isReserved && name !== lowerCasedName) {
      // Unknown attributes should have lowercase casing since that's how they
      // will be cased anyway with server rendering.
      warning(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.%s', name, lowerCasedName, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'boolean' && !shouldAttributeAcceptBooleanValue(name)) {
      if (value) {
        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.%s', value, name, name, value, name, getStackAddendum$2());
      } else {
        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', value, name, name, value, name, name, name, getStackAddendum$2());
      }
      warnedProperties$1[name] = true;
      return true;
    }

    // Now that we've validated casing, do not validate
    // data types for reserved props
    if (isReserved) {
      return true;
    }

    // Warn when a known attribute is a bad type
    if (!shouldSetAttribute(name, value)) {
      warnedProperties$1[name] = true;
      return false;
    }

    return true;
  };
}

var warnUnknownProperties = function (type, props, canUseEventSystem) {
  var unknownProps = [];
  for (var key in props) {
    var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);
    if (!isValid) {
      unknownProps.push(key);
    }
  }

  var unknownPropString = unknownProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');
  if (unknownProps.length === 1) {
    warning(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());
  } else if (unknownProps.length > 1) {
    warning(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());
  }
};

function validateProperties$2(type, props, canUseEventSystem) {
  if (isCustomComponent(type, props)) {
    return;
  }
  warnUnknownProperties(type, props, canUseEventSystem);
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$1 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$2 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnInvalidHydration = false;
var didWarnShadyDOM = false;

var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';
var SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';
var AUTOFOCUS = 'autoFocus';
var CHILDREN = 'children';
var STYLE = 'style';
var HTML = '__html';

var HTML_NAMESPACE = Namespaces.html;


var getStack = emptyFunction.thatReturns('');

{
  getStack = getCurrentFiberStackAddendum$2;

  var warnedUnknownTags = {
    // Chrome is the only major browser not shipping <time>. But as of July
    // 2017 it intends to ship it due to widespread usage. We intentionally
    // *don't* warn for <time> even if it's unrecognized by Chrome because
    // it soon will be, and many apps have been using it anyway.
    time: true,
    // There are working polyfills for <dialog>. Let people use it.
    dialog: true
  };

  var validatePropertiesInDevelopment = function (type, props) {
    validateProperties(type, props);
    validateProperties$1(type, props);
    validateProperties$2(type, props, /* canUseEventSystem */true);
  };

  // HTML parsing normalizes CR and CRLF to LF.
  // It also can turn \u0000 into \uFFFD inside attributes.
  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
  // If we have a mismatch, it might be caused by that.
  // We will still patch up in this case but not fire the warning.
  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;

  var normalizeMarkupForTextOrAttribute = function (markup) {
    var markupString = typeof markup === 'string' ? markup : '' + markup;
    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
  };

  var warnForTextDifference = function (serverText, clientText) {
    if (didWarnInvalidHydration) {
      return;
    }
    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
    if (normalizedServerText === normalizedClientText) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
  };

  var warnForPropDifference = function (propName, serverValue, clientValue) {
    if (didWarnInvalidHydration) {
      return;
    }
    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
    if (normalizedServerValue === normalizedClientValue) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
  };

  var warnForExtraAttributes = function (attributeNames) {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    var names = [];
    attributeNames.forEach(function (name) {
      names.push(name);
    });
    warning(false, 'Extra attributes from the server: %s', names);
  };

  var warnForInvalidEventListener = function (registrationName, listener) {
    if (listener === false) {
      warning(false, 'Expected `%s` listener to be a function, instead got `false`.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', registrationName, registrationName, registrationName, getCurrentFiberStackAddendum$2());
    } else {
      warning(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.%s', registrationName, typeof listener, getCurrentFiberStackAddendum$2());
    }
  };

  // Parse the HTML and read it back to normalize the HTML string so that it
  // can be used for comparison.
  var normalizeHTML = function (parent, html) {
    // We could have created a separate document here to avoid
    // re-initializing custom elements if they exist. But this breaks
    // how <noscript> is being handled. So we use the same document.
    // See the discussion in https://github.com/facebook/react/pull/11157.
    var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
    testElement.innerHTML = html;
    return testElement.innerHTML;
  };
}

function ensureListeningTo(rootContainerElement, registrationName) {
  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;
  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;
  listenTo(registrationName, doc);
}

function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trapClickOnNonInteractiveElement(node) {
  // Mobile Safari does not fire properly bubble click events on
  // non-interactive elements, which means delegated click listeners do not
  // fire. The workaround for this bug involves attaching an empty click
  // listener on the target node.
  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
  // Just set it using the onclick property so that we don't have to manage any
  // bookkeeping for it. Not sure if we need to clear it when the listener is
  // removed.
  // TODO: Only do this for the relevant Safaris maybe?
  node.onclick = emptyFunction;
}

function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
  for (var propKey in nextProps) {
    if (!nextProps.hasOwnProperty(propKey)) {
      continue;
    }
    var nextProp = nextProps[propKey];
    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }
      // Relies on `updateStylesByID` not mutating `styleUpdates`.
      setValueForStyles(domElement, nextProp, getStack);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML] : undefined;
      if (nextHtml != null) {
        setInnerHTML(domElement, nextHtml);
      }
    } else if (propKey === CHILDREN) {
      if (typeof nextProp === 'string') {
        // Avoid setting initial textContent when the text is empty. In IE11 setting
        // textContent on a <textarea> will cause the placeholder to not
        // show within the <textarea> until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        var canSetTextContent = tag !== 'textarea' || nextProp !== '';
        if (canSetTextContent) {
          setTextContent(domElement, nextProp);
        }
      } else if (typeof nextProp === 'number') {
        setTextContent(domElement, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (propKey === AUTOFOCUS) {
      // We polyfill it separately on the client during commit.
      // We blacklist it here rather than in the property list because we emit it in SSR.
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
    } else if (isCustomComponentTag) {
      setValueForAttribute(domElement, propKey, nextProp);
    } else if (nextProp != null) {
      // If we're updating to null or undefined, we should remove the property
      // from the DOM node instead of inadvertently setting to a string. This
      // brings us in line with the same behavior we have on initial render.
      setValueForProperty(domElement, propKey, nextProp);
    }
  }
}

function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
  // TODO: Handle wasCustomComponentTag
  for (var i = 0; i < updatePayload.length; i += 2) {
    var propKey = updatePayload[i];
    var propValue = updatePayload[i + 1];
    if (propKey === STYLE) {
      setValueForStyles(domElement, propValue, getStack);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      setInnerHTML(domElement, propValue);
    } else if (propKey === CHILDREN) {
      setTextContent(domElement, propValue);
    } else if (isCustomComponentTag) {
      if (propValue != null) {
        setValueForAttribute(domElement, propKey, propValue);
      } else {
        deleteValueForAttribute(domElement, propKey);
      }
    } else if (propValue != null) {
      setValueForProperty(domElement, propKey, propValue);
    } else {
      // If we're updating to null or undefined, we should remove the property
      // from the DOM node instead of inadvertently setting to a string. This
      // brings us in line with the same behavior we have on initial render.
      deleteValueForProperty(domElement, propKey);
    }
  }
}

function createElement$1(type, props, rootContainerElement, parentNamespace) {
  // We create tags in the namespace of their parent container, except HTML
  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
  var domElement;
  var namespaceURI = parentNamespace;
  if (namespaceURI === HTML_NAMESPACE) {
    namespaceURI = getIntrinsicNamespace(type);
  }
  if (namespaceURI === HTML_NAMESPACE) {
    {
      var isCustomComponentTag = isCustomComponent(type, props);
      // Should this check be gated by parent namespace? Not sure we want to
      // allow <SVG> or <mATH>.
      warning(isCustomComponentTag || type === type.toLowerCase(), '<%s /> is using uppercase HTML. Always use lowercase HTML tags ' + 'in React.', type);
    }

    if (type === 'script') {
      // Create the script via .innerHTML so its "parser-inserted" flag is
      // set to true and it does not execute
      var div = ownerDocument.createElement('div');
      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line
      // This is guaranteed to yield a script element.
      var firstChild = div.firstChild;
      domElement = div.removeChild(firstChild);
    } else if (typeof props.is === 'string') {
      // $FlowIssue `createElement` should be updated for Web Components
      domElement = ownerDocument.createElement(type, { is: props.is });
    } else {
      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
      // See discussion in https://github.com/facebook/react/pull/6896
      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
      domElement = ownerDocument.createElement(type);
    }
  } else {
    domElement = ownerDocument.createElementNS(namespaceURI, type);
  }

  {
    if (namespaceURI === HTML_NAMESPACE) {
      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
        warnedUnknownTags[type] = true;
        warning(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);
      }
    }
  }

  return domElement;
}

function createTextNode$1(text, rootContainerElement) {
  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
}

function setInitialProperties$1(domElement, tag, rawProps, rootContainerElement) {
  var isCustomComponentTag = isCustomComponent(tag, rawProps);
  {
    validatePropertiesInDevelopment(tag, rawProps);
    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');
      didWarnShadyDOM = true;
    }
  }

  // TODO: Make sure that we check isMounted before firing any of these events.
  var props;
  switch (tag) {
    case 'iframe':
    case 'object':
      trapBubbledEvent('topLoad', 'load', domElement);
      props = rawProps;
      break;
    case 'video':
    case 'audio':
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          trapBubbledEvent(event, mediaEvents[event], domElement);
        }
      }
      props = rawProps;
      break;
    case 'source':
      trapBubbledEvent('topError', 'error', domElement);
      props = rawProps;
      break;
    case 'img':
    case 'image':
      trapBubbledEvent('topError', 'error', domElement);
      trapBubbledEvent('topLoad', 'load', domElement);
      props = rawProps;
      break;
    case 'form':
      trapBubbledEvent('topReset', 'reset', domElement);
      trapBubbledEvent('topSubmit', 'submit', domElement);
      props = rawProps;
      break;
    case 'details':
      trapBubbledEvent('topToggle', 'toggle', domElement);
      props = rawProps;
      break;
    case 'input':
      initWrapperState(domElement, rawProps);
      props = getHostProps(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'option':
      validateProps(domElement, rawProps);
      props = getHostProps$1(domElement, rawProps);
      break;
    case 'select':
      initWrapperState$1(domElement, rawProps);
      props = getHostProps$2(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      props = getHostProps$3(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    default:
      props = rawProps;
  }

  assertValidProps(tag, props, getStack);

  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps);
      break;
    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement, rawProps);
      break;
    case 'option':
      postMountWrapper$1(domElement, rawProps);
      break;
    case 'select':
      postMountWrapper$2(domElement, rawProps);
      break;
    default:
      if (typeof props.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }
}

// Calculate the diff between the two objects.
function diffProperties$1(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
  {
    validatePropertiesInDevelopment(tag, nextRawProps);
  }

  var updatePayload = null;

  var lastProps;
  var nextProps;
  switch (tag) {
    case 'input':
      lastProps = getHostProps(domElement, lastRawProps);
      nextProps = getHostProps(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'option':
      lastProps = getHostProps$1(domElement, lastRawProps);
      nextProps = getHostProps$1(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'select':
      lastProps = getHostProps$2(domElement, lastRawProps);
      nextProps = getHostProps$2(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'textarea':
      lastProps = getHostProps$3(domElement, lastRawProps);
      nextProps = getHostProps$3(domElement, nextRawProps);
      updatePayload = [];
      break;
    default:
      lastProps = lastRawProps;
      nextProps = nextRawProps;
      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }

  assertValidProps(tag, nextProps, getStack);

  var propKey;
  var styleName;
  var styleUpdates = null;
  for (propKey in lastProps) {
    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
      continue;
    }
    if (propKey === STYLE) {
      var lastStyle = lastProps[propKey];
      for (styleName in lastStyle) {
        if (lastStyle.hasOwnProperty(styleName)) {
          if (!styleUpdates) {
            styleUpdates = {};
          }
          styleUpdates[styleName] = '';
        }
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {
      // Noop. This is handled by the clear text mechanism.
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (propKey === AUTOFOCUS) {
      // Noop. It doesn't work on updates anyway.
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      // This is a special case. If any listener updates we need to ensure
      // that the "current" fiber pointer gets updated so we need a commit
      // to update this element.
      if (!updatePayload) {
        updatePayload = [];
      }
    } else {
      // For all other deleted properties we add it to the queue. We use
      // the whitelist in the commit phase instead.
      (updatePayload = updatePayload || []).push(propKey, null);
    }
  }
  for (propKey in nextProps) {
    var nextProp = nextProps[propKey];
    var lastProp = lastProps != null ? lastProps[propKey] : undefined;
    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
      continue;
    }
    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }
      if (lastProp) {
        // Unset styles on `lastProp` but not on `nextProp`.
        for (styleName in lastProp) {
          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = '';
          }
        }
        // Update styles that changed since `lastProp`.
        for (styleName in nextProp) {
          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = nextProp[styleName];
          }
        }
      } else {
        // Relies on `updateStylesByID` not mutating `styleUpdates`.
        if (!styleUpdates) {
          if (!updatePayload) {
            updatePayload = [];
          }
          updatePayload.push(propKey, styleUpdates);
        }
        styleUpdates = nextProp;
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML] : undefined;
      var lastHtml = lastProp ? lastProp[HTML] : undefined;
      if (nextHtml != null) {
        if (lastHtml !== nextHtml) {
          (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);
        }
      } else {
        // TODO: It might be too late to clear this if we have children
        // inserted already.
      }
    } else if (propKey === CHILDREN) {
      if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {
        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        // We eagerly listen to this even though we haven't committed yet.
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
      if (!updatePayload && lastProp !== nextProp) {
        // This is a special case. If any listener updates we need to ensure
        // that the "current" props pointer gets updated so we need a commit
        // to update this element.
        updatePayload = [];
      }
    } else {
      // For any other property we always add it to the queue and then we
      // filter it out using the whitelist during the commit.
      (updatePayload = updatePayload || []).push(propKey, nextProp);
    }
  }
  if (styleUpdates) {
    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
  }
  return updatePayload;
}

// Apply the diff.
function updateProperties$1(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
  // Update checked *before* name.
  // In the middle of an update, it is possible to have multiple checked.
  // When a checked radio tries to change name, browser makes another radio's checked false.
  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {
    updateChecked(domElement, nextRawProps);
  }

  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
  var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
  // Apply the diff.
  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);

  // TODO: Ensure that an update gets scheduled if any of the special props
  // changed.
  switch (tag) {
    case 'input':
      // Update the wrapper around inputs *after* updating props. This has to
      // happen after `updateDOMProperties`. Otherwise HTML5 input validations
      // raise warnings and prevent the new value from being assigned.
      updateWrapper(domElement, nextRawProps);
      break;
    case 'textarea':
      updateWrapper$1(domElement, nextRawProps);
      break;
    case 'select':
      // <select> value update needs to occur after <option> children
      // reconciliation
      postUpdateWrapper(domElement, nextRawProps);
      break;
  }
}

function diffHydratedProperties$1(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
  {
    var suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;
    var isCustomComponentTag = isCustomComponent(tag, rawProps);
    validatePropertiesInDevelopment(tag, rawProps);
    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');
      didWarnShadyDOM = true;
    }
  }

  // TODO: Make sure that we check isMounted before firing any of these events.
  switch (tag) {
    case 'iframe':
    case 'object':
      trapBubbledEvent('topLoad', 'load', domElement);
      break;
    case 'video':
    case 'audio':
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          trapBubbledEvent(event, mediaEvents[event], domElement);
        }
      }
      break;
    case 'source':
      trapBubbledEvent('topError', 'error', domElement);
      break;
    case 'img':
    case 'image':
      trapBubbledEvent('topError', 'error', domElement);
      trapBubbledEvent('topLoad', 'load', domElement);
      break;
    case 'form':
      trapBubbledEvent('topReset', 'reset', domElement);
      trapBubbledEvent('topSubmit', 'submit', domElement);
      break;
    case 'details':
      trapBubbledEvent('topToggle', 'toggle', domElement);
      break;
    case 'input':
      initWrapperState(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'option':
      validateProps(domElement, rawProps);
      break;
    case 'select':
      initWrapperState$1(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
  }

  assertValidProps(tag, rawProps, getStack);

  {
    var extraAttributeNames = new Set();
    var attributes = domElement.attributes;
    for (var i = 0; i < attributes.length; i++) {
      var name = attributes[i].name.toLowerCase();
      switch (name) {
        // Built-in SSR attribute is whitelisted
        case 'data-reactroot':
          break;
        // Controlled attributes are not validated
        // TODO: Only ignore them on controlled tags.
        case 'value':
          break;
        case 'checked':
          break;
        case 'selected':
          break;
        default:
          // Intentionally use the original name.
          // See discussion in https://github.com/facebook/react/pull/10676.
          extraAttributeNames.add(attributes[i].name);
      }
    }
  }

  var updatePayload = null;
  for (var propKey in rawProps) {
    if (!rawProps.hasOwnProperty(propKey)) {
      continue;
    }
    var nextProp = rawProps[propKey];
    if (propKey === CHILDREN) {
      // For text content children we compare against textContent. This
      // might match additional HTML that is hidden when we read it using
      // textContent. E.g. "foo" will match "f<span>oo</span>" but that still
      // satisfies our requirement. Our requirement is not to produce perfect
      // HTML and attributes. Ideally we should preserve structure but it's
      // ok not to if the visible content is still enough to indicate what
      // even listeners these nodes might be wired up to.
      // TODO: Warn if there is more than a single textNode as a child.
      // TODO: Should we use domElement.firstChild.nodeValue to compare?
      if (typeof nextProp === 'string') {
        if (domElement.textContent !== nextProp) {
          if (true && !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }
          updatePayload = [CHILDREN, nextProp];
        }
      } else if (typeof nextProp === 'number') {
        if (domElement.textContent !== '' + nextProp) {
          if (true && !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }
          updatePayload = [CHILDREN, '' + nextProp];
        }
      }
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
    } else {
      // Validate that the properties correspond to their expected values.
      var serverValue;
      var propertyInfo;
      if (suppressHydrationWarning) {
        // Don't bother comparing. We're ignoring all these warnings.
      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 ||
      // Controlled attributes are not validated
      // TODO: Only ignore them on controlled tags.
      propKey === 'value' || propKey === 'checked' || propKey === 'selected') {
        // Noop
      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
        var rawHtml = nextProp ? nextProp[HTML] || '' : '';
        var serverHTML = domElement.innerHTML;
        var expectedHTML = normalizeHTML(domElement, rawHtml);
        if (expectedHTML !== serverHTML) {
          warnForPropDifference(propKey, serverHTML, expectedHTML);
        }
      } else if (propKey === STYLE) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames['delete'](propKey);
        var expectedStyle = createDangerousStringForStyles(nextProp);
        serverValue = domElement.getAttribute('style');
        if (expectedStyle !== serverValue) {
          warnForPropDifference(propKey, serverValue, expectedStyle);
        }
      } else if (isCustomComponentTag) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames['delete'](propKey.toLowerCase());
        serverValue = getValueForAttribute(domElement, propKey, nextProp);

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      } else if (shouldSetAttribute(propKey, nextProp)) {
        if (propertyInfo = getPropertyInfo(propKey)) {
          // $FlowFixMe - Should be inferred as not undefined.
          extraAttributeNames['delete'](propertyInfo.attributeName);
          serverValue = getValueForProperty(domElement, propKey, nextProp);
        } else {
          var ownNamespace = parentNamespace;
          if (ownNamespace === HTML_NAMESPACE) {
            ownNamespace = getIntrinsicNamespace(tag);
          }
          if (ownNamespace === HTML_NAMESPACE) {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames['delete'](propKey.toLowerCase());
          } else {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames['delete'](propKey);
          }
          serverValue = getValueForAttribute(domElement, propKey, nextProp);
        }

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      }
    }
  }

  {
    // $FlowFixMe - Should be inferred as not undefined.
    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
      // $FlowFixMe - Should be inferred as not undefined.
      warnForExtraAttributes(extraAttributeNames);
    }
  }

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps);
      break;
    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement, rawProps);
      break;
    case 'select':
    case 'option':
      // For input and textarea we current always set the value property at
      // post mount to force it to diverge from attributes. However, for
      // option and select we don't quite do the same thing and select
      // is not resilient to the DOM state changing so we don't do that here.
      // TODO: Consider not doing this for input and textarea.
      break;
    default:
      if (typeof rawProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }

  return updatePayload;
}

function diffHydratedText$1(textNode, text) {
  var isDifferent = textNode.nodeValue !== text;
  return isDifferent;
}

function warnForUnmatchedText$1(textNode, text) {
  {
    warnForTextDifference(textNode.nodeValue, text);
  }
}

function warnForDeletedHydratableElement$1(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
  }
}

function warnForDeletedHydratableText$1(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
  }
}

function warnForInsertedHydratedElement$1(parentNode, tag, props) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());
  }
}

function warnForInsertedHydratedText$1(parentNode, text) {
  {
    if (text === '') {
      // We expect to insert empty text nodes since they're not represented in
      // the HTML.
      // TODO: Remove this special case if we can just avoid inserting empty
      // text nodes.
      return;
    }
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
  }
}

function restoreControlledState(domElement, tag, props) {
  switch (tag) {
    case 'input':
      restoreControlledState$1(domElement, props);
      return;
    case 'textarea':
      restoreControlledState$3(domElement, props);
      return;
    case 'select':
      restoreControlledState$2(domElement, props);
      return;
  }
}

var ReactDOMFiberComponent = Object.freeze({
	createElement: createElement$1,
	createTextNode: createTextNode$1,
	setInitialProperties: setInitialProperties$1,
	diffProperties: diffProperties$1,
	updateProperties: updateProperties$1,
	diffHydratedProperties: diffHydratedProperties$1,
	diffHydratedText: diffHydratedText$1,
	warnForUnmatchedText: warnForUnmatchedText$1,
	warnForDeletedHydratableElement: warnForDeletedHydratableElement$1,
	warnForDeletedHydratableText: warnForDeletedHydratableText$1,
	warnForInsertedHydratedElement: warnForInsertedHydratedElement$1,
	warnForInsertedHydratedText: warnForInsertedHydratedText$1,
	restoreControlledState: restoreControlledState
});

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$6 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var validateDOMNesting = emptyFunction;

{
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    current: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo$1 = function (oldInfo, tag, instance) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
      case '#document':
        return tag === 'html';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':
      case 'pre':
      case 'listing':
      case 'table':
      case 'hr':
      case 'xmp':
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childText, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null');
      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var invalidParentOrAncestor = invalidParent || invalidAncestor;
    if (!invalidParentOrAncestor) {
      return;
    }

    var ancestorTag = invalidParentOrAncestor.tag;
    var addendum = getCurrentFiberStackAddendum$6();

    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;
    if (didWarn[warnKey]) {
      return;
    }
    didWarn[warnKey] = true;

    var tagDisplayName = childTag;
    var whitespaceInfo = '';
    if (childTag === '#text') {
      if (/\S/.test(childText)) {
        tagDisplayName = 'Text nodes';
      } else {
        tagDisplayName = 'Whitespace text nodes';
        whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
      }
    } else {
      tagDisplayName = '<' + childTag + '>';
    }

    if (invalidParent) {
      var info = '';
      if (ancestorTag === 'table' && childTag === 'tr') {
        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
      }
      warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);
    } else {
      warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);
    }
  };

  // TODO: turn this into a named export
  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo$1;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

var validateDOMNesting$1 = validateDOMNesting;

// TODO: direct imports like some-package/src/* are bad. Fix me.
var createElement = createElement$1;
var createTextNode = createTextNode$1;
var setInitialProperties = setInitialProperties$1;
var diffProperties = diffProperties$1;
var updateProperties = updateProperties$1;
var diffHydratedProperties = diffHydratedProperties$1;
var diffHydratedText = diffHydratedText$1;
var warnForUnmatchedText = warnForUnmatchedText$1;
var warnForDeletedHydratableElement = warnForDeletedHydratableElement$1;
var warnForDeletedHydratableText = warnForDeletedHydratableText$1;
var warnForInsertedHydratedElement = warnForInsertedHydratedElement$1;
var warnForInsertedHydratedText = warnForInsertedHydratedText$1;
var updatedAncestorInfo = validateDOMNesting$1.updatedAncestorInfo;
var precacheFiberNode = precacheFiberNode$1;
var updateFiberProps = updateFiberProps$1;


{
  var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
  if (typeof Map !== 'function' || Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {
    warning(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');
  }
}

injection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);

var eventsEnabled = null;
var selectionInformation = null;

/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));
}

function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOCUMENT_NODE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function shouldHydrateDueToLegacyHeuristic(container) {
  var rootElement = getReactRootElementInContainer(container);
  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
}

function shouldAutoFocusHostComponent(type, props) {
  switch (type) {
    case 'button':
    case 'input':
    case 'select':
    case 'textarea':
      return !!props.autoFocus;
  }
  return false;
}

var DOMRenderer = reactReconciler({
  getRootHostContext: function (rootContainerInstance) {
    var type = void 0;
    var namespace = void 0;
    var nodeType = rootContainerInstance.nodeType;
    switch (nodeType) {
      case DOCUMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE:
        {
          type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';
          var root = rootContainerInstance.documentElement;
          namespace = root ? root.namespaceURI : getChildNamespace(null, '');
          break;
        }
      default:
        {
          var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
          var ownNamespace = container.namespaceURI || null;
          type = container.tagName;
          namespace = getChildNamespace(ownNamespace, type);
          break;
        }
    }
    {
      var validatedTag = type.toLowerCase();
      var _ancestorInfo = updatedAncestorInfo(null, validatedTag, null);
      return { namespace: namespace, ancestorInfo: _ancestorInfo };
    }
    return namespace;
  },
  getChildHostContext: function (parentHostContext, type) {
    {
      var parentHostContextDev = parentHostContext;
      var _namespace = getChildNamespace(parentHostContextDev.namespace, type);
      var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type, null);
      return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };
    }
    var parentNamespace = parentHostContext;
    return getChildNamespace(parentNamespace, type);
  },
  getPublicInstance: function (instance) {
    return instance;
  },
  prepareForCommit: function () {
    eventsEnabled = isEnabled();
    selectionInformation = getSelectionInformation();
    setEnabled(false);
  },
  resetAfterCommit: function () {
    restoreSelection(selectionInformation);
    selectionInformation = null;
    setEnabled(eventsEnabled);
    eventsEnabled = null;
  },
  createInstance: function (type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
    var parentNamespace = void 0;
    {
      // TODO: take namespace into account when validating.
      var hostContextDev = hostContext;
      validateDOMNesting$1(type, null, hostContextDev.ancestorInfo);
      if (typeof props.children === 'string' || typeof props.children === 'number') {
        var string = '' + props.children;
        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);
        validateDOMNesting$1(null, string, ownAncestorInfo);
      }
      parentNamespace = hostContextDev.namespace;
    }
    var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
    precacheFiberNode(internalInstanceHandle, domElement);
    updateFiberProps(domElement, props);
    return domElement;
  },
  appendInitialChild: function (parentInstance, child) {
    parentInstance.appendChild(child);
  },
  finalizeInitialChildren: function (domElement, type, props, rootContainerInstance) {
    setInitialProperties(domElement, type, props, rootContainerInstance);
    return shouldAutoFocusHostComponent(type, props);
  },
  prepareUpdate: function (domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
    {
      var hostContextDev = hostContext;
      if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {
        var string = '' + newProps.children;
        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);
        validateDOMNesting$1(null, string, ownAncestorInfo);
      }
    }
    return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);
  },
  shouldSetTextContent: function (type, props) {
    return type === 'textarea' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && typeof props.dangerouslySetInnerHTML.__html === 'string';
  },
  shouldDeprioritizeSubtree: function (type, props) {
    return !!props.hidden;
  },
  createTextInstance: function (text, rootContainerInstance, hostContext, internalInstanceHandle) {
    {
      var hostContextDev = hostContext;
      validateDOMNesting$1(null, text, hostContextDev.ancestorInfo);
    }
    var textNode = createTextNode(text, rootContainerInstance);
    precacheFiberNode(internalInstanceHandle, textNode);
    return textNode;
  },


  now: now,

  mutation: {
    commitMount: function (domElement, type, newProps, internalInstanceHandle) {
      domElement.focus();
    },
    commitUpdate: function (domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
      // Update the props handle so that we know which props are the ones with
      // with current event handlers.
      updateFiberProps(domElement, newProps);
      // Apply the diff to the DOM node.
      updateProperties(domElement, updatePayload, type, oldProps, newProps);
    },
    resetTextContent: function (domElement) {
      domElement.textContent = '';
    },
    commitTextUpdate: function (textInstance, oldText, newText) {
      textInstance.nodeValue = newText;
    },
    appendChild: function (parentInstance, child) {
      parentInstance.appendChild(child);
    },
    appendChildToContainer: function (container, child) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.insertBefore(child, container);
      } else {
        container.appendChild(child);
      }
    },
    insertBefore: function (parentInstance, child, beforeChild) {
      parentInstance.insertBefore(child, beforeChild);
    },
    insertInContainerBefore: function (container, child, beforeChild) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.insertBefore(child, beforeChild);
      } else {
        container.insertBefore(child, beforeChild);
      }
    },
    removeChild: function (parentInstance, child) {
      parentInstance.removeChild(child);
    },
    removeChildFromContainer: function (container, child) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.removeChild(child);
      } else {
        container.removeChild(child);
      }
    }
  },

  hydration: {
    canHydrateInstance: function (instance, type, props) {
      if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
        return null;
      }
      // This has now been refined to an element node.
      return instance;
    },
    canHydrateTextInstance: function (instance, text) {
      if (text === '' || instance.nodeType !== TEXT_NODE) {
        // Empty strings are not parsed by HTML so there won't be a correct match here.
        return null;
      }
      // This has now been refined to a text node.
      return instance;
    },
    getNextHydratableSibling: function (instance) {
      var node = instance.nextSibling;
      // Skip non-hydratable nodes.
      while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {
        node = node.nextSibling;
      }
      return node;
    },
    getFirstHydratableChild: function (parentInstance) {
      var next = parentInstance.firstChild;
      // Skip non-hydratable nodes.
      while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {
        next = next.nextSibling;
      }
      return next;
    },
    hydrateInstance: function (instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
      precacheFiberNode(internalInstanceHandle, instance);
      // TODO: Possibly defer this until the commit phase where all the events
      // get attached.
      updateFiberProps(instance, props);
      var parentNamespace = void 0;
      {
        var hostContextDev = hostContext;
        parentNamespace = hostContextDev.namespace;
      }
      return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);
    },
    hydrateTextInstance: function (textInstance, text, internalInstanceHandle) {
      precacheFiberNode(internalInstanceHandle, textInstance);
      return diffHydratedText(textInstance, text);
    },
    didNotMatchHydratedContainerTextInstance: function (parentContainer, textInstance, text) {
      {
        warnForUnmatchedText(textInstance, text);
      }
    },
    didNotMatchHydratedTextInstance: function (parentType, parentProps, parentInstance, textInstance, text) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForUnmatchedText(textInstance, text);
      }
    },
    didNotHydrateContainerInstance: function (parentContainer, instance) {
      {
        if (instance.nodeType === 1) {
          warnForDeletedHydratableElement(parentContainer, instance);
        } else {
          warnForDeletedHydratableText(parentContainer, instance);
        }
      }
    },
    didNotHydrateInstance: function (parentType, parentProps, parentInstance, instance) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        if (instance.nodeType === 1) {
          warnForDeletedHydratableElement(parentInstance, instance);
        } else {
          warnForDeletedHydratableText(parentInstance, instance);
        }
      }
    },
    didNotFindHydratableContainerInstance: function (parentContainer, type, props) {
      {
        warnForInsertedHydratedElement(parentContainer, type, props);
      }
    },
    didNotFindHydratableContainerTextInstance: function (parentContainer, text) {
      {
        warnForInsertedHydratedText(parentContainer, text);
      }
    },
    didNotFindHydratableInstance: function (parentType, parentProps, parentInstance, type, props) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForInsertedHydratedElement(parentInstance, type, props);
      }
    },
    didNotFindHydratableTextInstance: function (parentType, parentProps, parentInstance, text) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForInsertedHydratedText(parentInstance, text);
      }
    }
  },

  scheduleDeferredCallback: rIC,
  cancelDeferredCallback: cIC,

  useSyncScheduling: !enableAsyncSchedulingByDefaultInReactDOM
});

injection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);

var warnedAboutHydrateAPI = false;

function renderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;

  {
    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
      var hostInstance = DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);
      if (hostInstance) {
        warning(hostInstance.parentNode === container, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');
      }
    }

    var isRootRenderedBySomeReact = !!container._reactRootContainer;
    var rootEl = getReactRootElementInContainer(container);
    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));

    warning(!hasNonRootReactChild || isRootRenderedBySomeReact, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');

    warning(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');
  }

  var root = container._reactRootContainer;
  if (!root) {
    var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
    // First clear any existing content.
    if (!shouldHydrate) {
      var warned = false;
      var rootSibling = void 0;
      while (rootSibling = container.lastChild) {
        {
          if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
            warned = true;
            warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');
          }
        }
        container.removeChild(rootSibling);
      }
    }
    {
      if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
        warnedAboutHydrateAPI = true;
        lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');
      }
    }
    var newRoot = DOMRenderer.createContainer(container, shouldHydrate);
    root = container._reactRootContainer = newRoot;
    // Initial mount should not be batched.
    DOMRenderer.unbatchedUpdates(function () {
      DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);
    });
  } else {
    DOMRenderer.updateContainer(children, root, parentComponent, callback);
  }
  return DOMRenderer.getPublicRootInstance(root);
}

function createPortal(children, container) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;
  // TODO: pass ReactDOM portal implementation as third argument
  return createPortal$1(children, container, null, key);
}

function ReactRoot(container, hydrate) {
  var root = DOMRenderer.createContainer(container, hydrate);
  this._reactRootContainer = root;
}
ReactRoot.prototype.render = function (children, callback) {
  var root = this._reactRootContainer;
  DOMRenderer.updateContainer(children, root, null, callback);
};
ReactRoot.prototype.unmount = function (callback) {
  var root = this._reactRootContainer;
  DOMRenderer.updateContainer(null, root, null, callback);
};

var ReactDOM = {
  createPortal: createPortal,

  findDOMNode: function (componentOrElement) {
    {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
        warning(warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner) || 'A component');
        owner.stateNode._warnedAboutRefsInRender = true;
      }
    }
    if (componentOrElement == null) {
      return null;
    }
    if (componentOrElement.nodeType === ELEMENT_NODE) {
      return componentOrElement;
    }

    var inst = get(componentOrElement);
    if (inst) {
      return DOMRenderer.findHostInstance(inst);
    }

    if (typeof componentOrElement.render === 'function') {
      invariant(false, 'Unable to find node on an unmounted component.');
    } else {
      invariant(false, 'Element appears to be neither ReactComponent nor DOMNode. Keys: %s', Object.keys(componentOrElement));
    }
  },
  hydrate: function (element, container, callback) {
    // TODO: throw or warn if we couldn't hydrate?
    return renderSubtreeIntoContainer(null, element, container, true, callback);
  },
  render: function (element, container, callback) {
    return renderSubtreeIntoContainer(null, element, container, false, callback);
  },
  unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {
    !(parentComponent != null && has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;
    return renderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
  },
  unmountComponentAtNode: function (container) {
    !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;

    if (container._reactRootContainer) {
      {
        var rootEl = getReactRootElementInContainer(container);
        var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);
        warning(!renderedByDifferentReact, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.');
      }

      // Unmount should not be batched.
      DOMRenderer.unbatchedUpdates(function () {
        renderSubtreeIntoContainer(null, null, container, false, function () {
          container._reactRootContainer = null;
        });
      });
      // If you call unmountComponentAtNode twice in quick succession, you'll
      // get `true` twice. That's probably fine?
      return true;
    } else {
      {
        var _rootEl = getReactRootElementInContainer(container);
        var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));

        // Check if the container itself is a React root node.
        var isContainerReactRoot = container.nodeType === 1 && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;

        warning(!hasNonRootReactChild, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');
      }

      return false;
    }
  },


  // Temporary alias since we already shipped React 16 RC with it.
  // TODO: remove in React 17.
  unstable_createPortal: createPortal,

  unstable_batchedUpdates: batchedUpdates,

  unstable_deferredUpdates: DOMRenderer.deferredUpdates,

  flushSync: DOMRenderer.flushSync,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    // For TapEventPlugin which is popular in open source
    EventPluginHub: EventPluginHub,
    // Used by test-utils
    EventPluginRegistry: EventPluginRegistry,
    EventPropagators: EventPropagators,
    ReactControlledComponent: ReactControlledComponent,
    ReactDOMComponentTree: ReactDOMComponentTree,
    ReactDOMEventListener: ReactDOMEventListener
  }
};

if (enableCreateRoot) {
  ReactDOM.createRoot = function createRoot(container, options) {
    var hydrate = options != null && options.hydrate === true;
    return new ReactRoot(container, hydrate);
  };
}

var foundDevTools = DOMRenderer.injectIntoDevTools({
  findFiberByHostInstance: getClosestInstanceFromNode,
  bundleType: 1,
  version: ReactVersion,
  rendererPackageName: 'react-dom'
});

{
  if (!foundDevTools && ExecutionEnvironment.canUseDOM && window.top === window.self) {
    // If we're in Chrome or Firefox, provide a download link if not installed.
    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
      var protocol = window.location.protocol;
      // Don't warn in exotic cases like chrome-extension://.
      if (/^(https?|file):$/.test(protocol)) {
        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');
      }
    }
  }
}



var ReactDOM$2 = Object.freeze({
	default: ReactDOM
});

var ReactDOM$3 = ( ReactDOM$2 && ReactDOM ) || ReactDOM$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactDom = ReactDOM$3['default'] ? ReactDOM$3['default'] : ReactDOM$3;

module.exports = reactDom;
  })();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react-dom.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
var aa=__webpack_require__(0),l=__webpack_require__(29),B=__webpack_require__(7),C=__webpack_require__(4),ba=__webpack_require__(28),da=__webpack_require__(32),ea=__webpack_require__(33),fa=__webpack_require__(30),ia=__webpack_require__(31),D=__webpack_require__(9);
function E(a){for(var b=arguments.length-1,c="Minified React error #"+a+"; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d"+a,d=0;d<b;d++)c+="\x26args[]\x3d"+encodeURIComponent(arguments[d+1]);b=Error(c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name="Invariant Violation";b.framesToPop=1;throw b;}aa?void 0:E("227");
var oa={children:!0,dangerouslySetInnerHTML:!0,defaultValue:!0,defaultChecked:!0,innerHTML:!0,suppressContentEditableWarning:!0,suppressHydrationWarning:!0,style:!0};function pa(a,b){return(a&b)===b}
var ta={MUST_USE_PROPERTY:1,HAS_BOOLEAN_VALUE:4,HAS_NUMERIC_VALUE:8,HAS_POSITIVE_NUMERIC_VALUE:24,HAS_OVERLOADED_BOOLEAN_VALUE:32,HAS_STRING_BOOLEAN_VALUE:64,injectDOMPropertyConfig:function(a){var b=ta,c=a.Properties||{},d=a.DOMAttributeNamespaces||{},e=a.DOMAttributeNames||{};a=a.DOMMutationMethods||{};for(var f in c){ua.hasOwnProperty(f)?E("48",f):void 0;var g=f.toLowerCase(),h=c[f];g={attributeName:g,attributeNamespace:null,propertyName:f,mutationMethod:null,mustUseProperty:pa(h,b.MUST_USE_PROPERTY),
hasBooleanValue:pa(h,b.HAS_BOOLEAN_VALUE),hasNumericValue:pa(h,b.HAS_NUMERIC_VALUE),hasPositiveNumericValue:pa(h,b.HAS_POSITIVE_NUMERIC_VALUE),hasOverloadedBooleanValue:pa(h,b.HAS_OVERLOADED_BOOLEAN_VALUE),hasStringBooleanValue:pa(h,b.HAS_STRING_BOOLEAN_VALUE)};1>=g.hasBooleanValue+g.hasNumericValue+g.hasOverloadedBooleanValue?void 0:E("50",f);e.hasOwnProperty(f)&&(g.attributeName=e[f]);d.hasOwnProperty(f)&&(g.attributeNamespace=d[f]);a.hasOwnProperty(f)&&(g.mutationMethod=a[f]);ua[f]=g}}},ua={};
function va(a,b){if(oa.hasOwnProperty(a)||2<a.length&&("o"===a[0]||"O"===a[0])&&("n"===a[1]||"N"===a[1]))return!1;if(null===b)return!0;switch(typeof b){case "boolean":return oa.hasOwnProperty(a)?a=!0:(b=wa(a))?a=b.hasBooleanValue||b.hasStringBooleanValue||b.hasOverloadedBooleanValue:(a=a.toLowerCase().slice(0,5),a="data-"===a||"aria-"===a),a;case "undefined":case "number":case "string":case "object":return!0;default:return!1}}function wa(a){return ua.hasOwnProperty(a)?ua[a]:null}
var xa=ta,ya=xa.MUST_USE_PROPERTY,K=xa.HAS_BOOLEAN_VALUE,za=xa.HAS_NUMERIC_VALUE,Aa=xa.HAS_POSITIVE_NUMERIC_VALUE,Ba=xa.HAS_OVERLOADED_BOOLEAN_VALUE,Ca=xa.HAS_STRING_BOOLEAN_VALUE,Da={Properties:{allowFullScreen:K,async:K,autoFocus:K,autoPlay:K,capture:Ba,checked:ya|K,cols:Aa,contentEditable:Ca,controls:K,"default":K,defer:K,disabled:K,download:Ba,draggable:Ca,formNoValidate:K,hidden:K,loop:K,multiple:ya|K,muted:ya|K,noValidate:K,open:K,playsInline:K,readOnly:K,required:K,reversed:K,rows:Aa,rowSpan:za,
scoped:K,seamless:K,selected:ya|K,size:Aa,start:za,span:Aa,spellCheck:Ca,style:0,tabIndex:0,itemScope:K,acceptCharset:0,className:0,htmlFor:0,httpEquiv:0,value:Ca},DOMAttributeNames:{acceptCharset:"accept-charset",className:"class",htmlFor:"for",httpEquiv:"http-equiv"},DOMMutationMethods:{value:function(a,b){if(null==b)return a.removeAttribute("value");"number"!==a.type||!1===a.hasAttribute("value")?a.setAttribute("value",""+b):a.validity&&!a.validity.badInput&&a.ownerDocument.activeElement!==a&&
a.setAttribute("value",""+b)}}},Ea=xa.HAS_STRING_BOOLEAN_VALUE,M={xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace"},Ga={Properties:{autoReverse:Ea,externalResourcesRequired:Ea,preserveAlpha:Ea},DOMAttributeNames:{autoReverse:"autoReverse",externalResourcesRequired:"externalResourcesRequired",preserveAlpha:"preserveAlpha"},DOMAttributeNamespaces:{xlinkActuate:M.xlink,xlinkArcrole:M.xlink,xlinkHref:M.xlink,xlinkRole:M.xlink,xlinkShow:M.xlink,xlinkTitle:M.xlink,xlinkType:M.xlink,
xmlBase:M.xml,xmlLang:M.xml,xmlSpace:M.xml}},Ha=/[\-\:]([a-z])/g;function Ia(a){return a[1].toUpperCase()}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode x-height xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xmlns:xlink xml:lang xml:space".split(" ").forEach(function(a){var b=a.replace(Ha,
Ia);Ga.Properties[b]=0;Ga.DOMAttributeNames[b]=a});xa.injectDOMPropertyConfig(Da);xa.injectDOMPropertyConfig(Ga);
var P={_caughtError:null,_hasCaughtError:!1,_rethrowError:null,_hasRethrowError:!1,injection:{injectErrorUtils:function(a){"function"!==typeof a.invokeGuardedCallback?E("197"):void 0;Ja=a.invokeGuardedCallback}},invokeGuardedCallback:function(a,b,c,d,e,f,g,h,k){Ja.apply(P,arguments)},invokeGuardedCallbackAndCatchFirstError:function(a,b,c,d,e,f,g,h,k){P.invokeGuardedCallback.apply(this,arguments);if(P.hasCaughtError()){var q=P.clearCaughtError();P._hasRethrowError||(P._hasRethrowError=!0,P._rethrowError=
q)}},rethrowCaughtError:function(){return Ka.apply(P,arguments)},hasCaughtError:function(){return P._hasCaughtError},clearCaughtError:function(){if(P._hasCaughtError){var a=P._caughtError;P._caughtError=null;P._hasCaughtError=!1;return a}E("198")}};function Ja(a,b,c,d,e,f,g,h,k){P._hasCaughtError=!1;P._caughtError=null;var q=Array.prototype.slice.call(arguments,3);try{b.apply(c,q)}catch(v){P._caughtError=v,P._hasCaughtError=!0}}
function Ka(){if(P._hasRethrowError){var a=P._rethrowError;P._rethrowError=null;P._hasRethrowError=!1;throw a;}}var La=null,Ma={};
function Na(){if(La)for(var a in Ma){var b=Ma[a],c=La.indexOf(a);-1<c?void 0:E("96",a);if(!Oa[c]){b.extractEvents?void 0:E("97",a);Oa[c]=b;c=b.eventTypes;for(var d in c){var e=void 0;var f=c[d],g=b,h=d;Pa.hasOwnProperty(h)?E("99",h):void 0;Pa[h]=f;var k=f.phasedRegistrationNames;if(k){for(e in k)k.hasOwnProperty(e)&&Qa(k[e],g,h);e=!0}else f.registrationName?(Qa(f.registrationName,g,h),e=!0):e=!1;e?void 0:E("98",d,a)}}}}
function Qa(a,b,c){Ra[a]?E("100",a):void 0;Ra[a]=b;Sa[a]=b.eventTypes[c].dependencies}var Oa=[],Pa={},Ra={},Sa={};function Ta(a){La?E("101"):void 0;La=Array.prototype.slice.call(a);Na()}function Ua(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];Ma.hasOwnProperty(c)&&Ma[c]===d||(Ma[c]?E("102",c):void 0,Ma[c]=d,b=!0)}b&&Na()}
var Va=Object.freeze({plugins:Oa,eventNameDispatchConfigs:Pa,registrationNameModules:Ra,registrationNameDependencies:Sa,possibleRegistrationNames:null,injectEventPluginOrder:Ta,injectEventPluginsByName:Ua}),Wa=null,Xa=null,Ya=null;function Za(a,b,c,d){b=a.type||"unknown-event";a.currentTarget=Ya(d);P.invokeGuardedCallbackAndCatchFirstError(b,c,void 0,a);a.currentTarget=null}
function $a(a,b){null==b?E("30"):void 0;if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function ab(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}var bb=null;
function cb(a,b){if(a){var c=a._dispatchListeners,d=a._dispatchInstances;if(Array.isArray(c))for(var e=0;e<c.length&&!a.isPropagationStopped();e++)Za(a,b,c[e],d[e]);else c&&Za(a,b,c,d);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}}function db(a){return cb(a,!0)}function gb(a){return cb(a,!1)}var hb={injectEventPluginOrder:Ta,injectEventPluginsByName:Ua};
function ib(a,b){var c=a.stateNode;if(!c)return null;var d=Wa(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;c&&"function"!==typeof c?E("231",b,typeof c):void 0;
return c}function jb(a,b,c,d){for(var e,f=0;f<Oa.length;f++){var g=Oa[f];g&&(g=g.extractEvents(a,b,c,d))&&(e=$a(e,g))}return e}function kb(a){a&&(bb=$a(bb,a))}function lb(a){var b=bb;bb=null;b&&(a?ab(b,db):ab(b,gb),bb?E("95"):void 0,P.rethrowCaughtError())}var mb=Object.freeze({injection:hb,getListener:ib,extractEvents:jb,enqueueEvents:kb,processEventQueue:lb}),nb=Math.random().toString(36).slice(2),Q="__reactInternalInstance$"+nb,ob="__reactEventHandlers$"+nb;
function pb(a){if(a[Q])return a[Q];for(var b=[];!a[Q];)if(b.push(a),a.parentNode)a=a.parentNode;else return null;var c=void 0,d=a[Q];if(5===d.tag||6===d.tag)return d;for(;a&&(d=a[Q]);a=b.pop())c=d;return c}function qb(a){if(5===a.tag||6===a.tag)return a.stateNode;E("33")}function rb(a){return a[ob]||null}
var sb=Object.freeze({precacheFiberNode:function(a,b){b[Q]=a},getClosestInstanceFromNode:pb,getInstanceFromNode:function(a){a=a[Q];return!a||5!==a.tag&&6!==a.tag?null:a},getNodeFromInstance:qb,getFiberCurrentPropsFromNode:rb,updateFiberProps:function(a,b){a[ob]=b}});function tb(a){do a=a["return"];while(a&&5!==a.tag);return a?a:null}function ub(a,b,c){for(var d=[];a;)d.push(a),a=tb(a);for(a=d.length;0<a--;)b(d[a],"captured",c);for(a=0;a<d.length;a++)b(d[a],"bubbled",c)}
function vb(a,b,c){if(b=ib(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=$a(c._dispatchListeners,b),c._dispatchInstances=$a(c._dispatchInstances,a)}function wb(a){a&&a.dispatchConfig.phasedRegistrationNames&&ub(a._targetInst,vb,a)}function xb(a){if(a&&a.dispatchConfig.phasedRegistrationNames){var b=a._targetInst;b=b?tb(b):null;ub(b,vb,a)}}
function yb(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=ib(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=$a(c._dispatchListeners,b),c._dispatchInstances=$a(c._dispatchInstances,a))}function zb(a){a&&a.dispatchConfig.registrationName&&yb(a._targetInst,null,a)}function Ab(a){ab(a,wb)}
function Bb(a,b,c,d){if(c&&d)a:{var e=c;for(var f=d,g=0,h=e;h;h=tb(h))g++;h=0;for(var k=f;k;k=tb(k))h++;for(;0<g-h;)e=tb(e),g--;for(;0<h-g;)f=tb(f),h--;for(;g--;){if(e===f||e===f.alternate)break a;e=tb(e);f=tb(f)}e=null}else e=null;f=e;for(e=[];c&&c!==f;){g=c.alternate;if(null!==g&&g===f)break;e.push(c);c=tb(c)}for(c=[];d&&d!==f;){g=d.alternate;if(null!==g&&g===f)break;c.push(d);d=tb(d)}for(d=0;d<e.length;d++)yb(e[d],"bubbled",a);for(a=c.length;0<a--;)yb(c[a],"captured",b)}
var Cb=Object.freeze({accumulateTwoPhaseDispatches:Ab,accumulateTwoPhaseDispatchesSkipTarget:function(a){ab(a,xb)},accumulateEnterLeaveDispatches:Bb,accumulateDirectDispatches:function(a){ab(a,zb)}}),Db=null;function Eb(){!Db&&l.canUseDOM&&(Db="textContent"in document.documentElement?"textContent":"innerText");return Db}var S={_root:null,_startText:null,_fallbackText:null};
function Fb(){if(S._fallbackText)return S._fallbackText;var a,b=S._startText,c=b.length,d,e=Gb(),f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);S._fallbackText=e.slice(a,1<d?1-d:void 0);return S._fallbackText}function Gb(){return"value"in S._root?S._root.value:S._root[Eb()]}
var Hb="dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances".split(" "),Ib={type:null,target:null,currentTarget:C.thatReturnsNull,eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null};
function T(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?C.thatReturnsTrue:C.thatReturnsFalse;this.isPropagationStopped=C.thatReturnsFalse;return this}
B(T.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=C.thatReturnsTrue)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=C.thatReturnsTrue)},persist:function(){this.isPersistent=C.thatReturnsTrue},isPersistent:C.thatReturnsFalse,
destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;for(a=0;a<Hb.length;a++)this[Hb[a]]=null}});T.Interface=Ib;T.augmentClass=function(a,b){function c(){}c.prototype=this.prototype;var d=new c;B(d,a.prototype);a.prototype=d;a.prototype.constructor=a;a.Interface=B({},this.Interface,b);a.augmentClass=this.augmentClass;Jb(a)};Jb(T);function Kb(a,b,c,d){if(this.eventPool.length){var e=this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}
function Lb(a){a instanceof this?void 0:E("223");a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function Jb(a){a.eventPool=[];a.getPooled=Kb;a.release=Lb}function Mb(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Mb,{data:null});function Nb(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Nb,{data:null});var Pb=[9,13,27,32],Vb=l.canUseDOM&&"CompositionEvent"in window,Wb=null;l.canUseDOM&&"documentMode"in document&&(Wb=document.documentMode);var Xb;
if(Xb=l.canUseDOM&&"TextEvent"in window&&!Wb){var Yb=window.opera;Xb=!("object"===typeof Yb&&"function"===typeof Yb.version&&12>=parseInt(Yb.version(),10))}
var Zb=Xb,$b=l.canUseDOM&&(!Vb||Wb&&8<Wb&&11>=Wb),ac=String.fromCharCode(32),bc={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["topCompositionEnd","topKeyPress","topTextInput","topPaste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"topBlur topCompositionEnd topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",
captured:"onCompositionStartCapture"},dependencies:"topBlur topCompositionStart topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"topBlur topCompositionUpdate topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")}},cc=!1;
function dc(a,b){switch(a){case "topKeyUp":return-1!==Pb.indexOf(b.keyCode);case "topKeyDown":return 229!==b.keyCode;case "topKeyPress":case "topMouseDown":case "topBlur":return!0;default:return!1}}function ec(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var fc=!1;function gc(a,b){switch(a){case "topCompositionEnd":return ec(b);case "topKeyPress":if(32!==b.which)return null;cc=!0;return ac;case "topTextInput":return a=b.data,a===ac&&cc?null:a;default:return null}}
function hc(a,b){if(fc)return"topCompositionEnd"===a||!Vb&&dc(a,b)?(a=Fb(),S._root=null,S._startText=null,S._fallbackText=null,fc=!1,a):null;switch(a){case "topPaste":return null;case "topKeyPress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "topCompositionEnd":return $b?null:b.data;default:return null}}
var ic={eventTypes:bc,extractEvents:function(a,b,c,d){var e;if(Vb)b:{switch(a){case "topCompositionStart":var f=bc.compositionStart;break b;case "topCompositionEnd":f=bc.compositionEnd;break b;case "topCompositionUpdate":f=bc.compositionUpdate;break b}f=void 0}else fc?dc(a,c)&&(f=bc.compositionEnd):"topKeyDown"===a&&229===c.keyCode&&(f=bc.compositionStart);f?($b&&(fc||f!==bc.compositionStart?f===bc.compositionEnd&&fc&&(e=Fb()):(S._root=d,S._startText=Gb(),fc=!0)),f=Mb.getPooled(f,b,c,d),e?f.data=
e:(e=ec(c),null!==e&&(f.data=e)),Ab(f),e=f):e=null;(a=Zb?gc(a,c):hc(a,c))?(b=Nb.getPooled(bc.beforeInput,b,c,d),b.data=a,Ab(b)):b=null;return[e,b]}},jc=null,kc=null,lc=null;function mc(a){if(a=Xa(a)){jc&&"function"===typeof jc.restoreControlledState?void 0:E("194");var b=Wa(a.stateNode);jc.restoreControlledState(a.stateNode,a.type,b)}}var nc={injectFiberControlledHostComponent:function(a){jc=a}};function oc(a){kc?lc?lc.push(a):lc=[a]:kc=a}
function pc(){if(kc){var a=kc,b=lc;lc=kc=null;mc(a);if(b)for(a=0;a<b.length;a++)mc(b[a])}}var qc=Object.freeze({injection:nc,enqueueStateRestore:oc,restoreStateIfNeeded:pc});function rc(a,b){return a(b)}var sc=!1;function tc(a,b){if(sc)return rc(a,b);sc=!0;try{return rc(a,b)}finally{sc=!1,pc()}}var uc={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};
function vc(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!uc[a.type]:"textarea"===b?!0:!1}function wc(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var xc;l.canUseDOM&&(xc=document.implementation&&document.implementation.hasFeature&&!0!==document.implementation.hasFeature("",""));
function yc(a,b){if(!l.canUseDOM||b&&!("addEventListener"in document))return!1;b="on"+a;var c=b in document;c||(c=document.createElement("div"),c.setAttribute(b,"return;"),c="function"===typeof c[b]);!c&&xc&&"wheel"===a&&(c=document.implementation.hasFeature("Events.wheel","3.0"));return c}function zc(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
function Ac(a){var b=zc(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"function"===typeof c.get&&"function"===typeof c.set)return Object.defineProperty(a,b,{enumerable:c.enumerable,configurable:!0,get:function(){return c.get.call(this)},set:function(a){d=""+a;c.set.call(this,a)}}),{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}
function Bc(a){a._valueTracker||(a._valueTracker=Ac(a))}function Cc(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=zc(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}var Dc={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"topBlur topChange topClick topFocus topInput topKeyDown topKeyUp topSelectionChange".split(" ")}};
function Ec(a,b,c){a=T.getPooled(Dc.change,a,b,c);a.type="change";oc(c);Ab(a);return a}var Fc=null,Gc=null;function Hc(a){kb(a);lb(!1)}function Ic(a){var b=qb(a);if(Cc(b))return a}function Jc(a,b){if("topChange"===a)return b}var Kc=!1;l.canUseDOM&&(Kc=yc("input")&&(!document.documentMode||9<document.documentMode));function Lc(){Fc&&(Fc.detachEvent("onpropertychange",Mc),Gc=Fc=null)}function Mc(a){"value"===a.propertyName&&Ic(Gc)&&(a=Ec(Gc,a,wc(a)),tc(Hc,a))}
function Nc(a,b,c){"topFocus"===a?(Lc(),Fc=b,Gc=c,Fc.attachEvent("onpropertychange",Mc)):"topBlur"===a&&Lc()}function Oc(a){if("topSelectionChange"===a||"topKeyUp"===a||"topKeyDown"===a)return Ic(Gc)}function Pc(a,b){if("topClick"===a)return Ic(b)}function $c(a,b){if("topInput"===a||"topChange"===a)return Ic(b)}
var ad={eventTypes:Dc,_isInputEventSupported:Kc,extractEvents:function(a,b,c,d){var e=b?qb(b):window,f=e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Jc;else if(vc(e))if(Kc)g=$c;else{g=Oc;var h=Nc}else f=e.nodeName,!f||"input"!==f.toLowerCase()||"checkbox"!==e.type&&"radio"!==e.type||(g=Pc);if(g&&(g=g(a,b)))return Ec(g,c,d);h&&h(a,e,b);"topBlur"===a&&null!=b&&(a=b._wrapperState||e._wrapperState)&&a.controlled&&"number"===e.type&&(a=""+e.value,e.getAttribute("value")!==
a&&e.setAttribute("value",a))}};function bd(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(bd,{view:null,detail:null});var cd={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function dd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=cd[a])?!!b[a]:!1}function ed(){return dd}function fd(a,b,c,d){return T.call(this,a,b,c,d)}
bd.augmentClass(fd,{screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:ed,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)}});
var gd={mouseEnter:{registrationName:"onMouseEnter",dependencies:["topMouseOut","topMouseOver"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["topMouseOut","topMouseOver"]}},hd={eventTypes:gd,extractEvents:function(a,b,c,d){if("topMouseOver"===a&&(c.relatedTarget||c.fromElement)||"topMouseOut"!==a&&"topMouseOver"!==a)return null;var e=d.window===d?d:(e=d.ownerDocument)?e.defaultView||e.parentWindow:window;"topMouseOut"===a?(a=b,b=(b=c.relatedTarget||c.toElement)?pb(b):null):a=null;if(a===
b)return null;var f=null==a?e:qb(a);e=null==b?e:qb(b);var g=fd.getPooled(gd.mouseLeave,a,c,d);g.type="mouseleave";g.target=f;g.relatedTarget=e;c=fd.getPooled(gd.mouseEnter,b,c,d);c.type="mouseenter";c.target=e;c.relatedTarget=f;Bb(g,c,a,b);return[g,c]}},id=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;function jd(a){a=a.type;return"string"===typeof a?a:"function"===typeof a?a.displayName||a.name:null}
function kd(a){var b=a;if(a.alternate)for(;b["return"];)b=b["return"];else{if(0!==(b.effectTag&2))return 1;for(;b["return"];)if(b=b["return"],0!==(b.effectTag&2))return 1}return 3===b.tag?2:3}function ld(a){return(a=a._reactInternalFiber)?2===kd(a):!1}function md(a){2!==kd(a)?E("188"):void 0}
function nd(a){var b=a.alternate;if(!b)return b=kd(a),3===b?E("188"):void 0,1===b?null:a;for(var c=a,d=b;;){var e=c["return"],f=e?e.alternate:null;if(!e||!f)break;if(e.child===f.child){for(var g=e.child;g;){if(g===c)return md(e),a;if(g===d)return md(e),b;g=g.sibling}E("188")}if(c["return"]!==d["return"])c=e,d=f;else{g=!1;for(var h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}g?
void 0:E("189")}}c.alternate!==d?E("190"):void 0}3!==c.tag?E("188"):void 0;return c.stateNode.current===c?a:b}function od(a){a=nd(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child["return"]=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b["return"]||b["return"]===a)return null;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}}return null}
function pd(a){a=nd(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child&&4!==b.tag)b.child["return"]=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b["return"]||b["return"]===a)return null;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}}return null}var qd=[];
function rd(a){var b=a.targetInst;do{if(!b){a.ancestors.push(b);break}var c;for(c=b;c["return"];)c=c["return"];c=3!==c.tag?null:c.stateNode.containerInfo;if(!c)break;a.ancestors.push(b);b=pb(c)}while(b);for(c=0;c<a.ancestors.length;c++)b=a.ancestors[c],sd(a.topLevelType,b,a.nativeEvent,wc(a.nativeEvent))}var td=!0,sd=void 0;function ud(a){td=!!a}function U(a,b,c){return c?ba.listen(c,b,vd.bind(null,a)):null}function wd(a,b,c){return c?ba.capture(c,b,vd.bind(null,a)):null}
function vd(a,b){if(td){var c=wc(b);c=pb(c);null===c||"number"!==typeof c.tag||2===kd(c)||(c=null);if(qd.length){var d=qd.pop();d.topLevelType=a;d.nativeEvent=b;d.targetInst=c;a=d}else a={topLevelType:a,nativeEvent:b,targetInst:c,ancestors:[]};try{tc(rd,a)}finally{a.topLevelType=null,a.nativeEvent=null,a.targetInst=null,a.ancestors.length=0,10>qd.length&&qd.push(a)}}}
var xd=Object.freeze({get _enabled(){return td},get _handleTopLevel(){return sd},setHandleTopLevel:function(a){sd=a},setEnabled:ud,isEnabled:function(){return td},trapBubbledEvent:U,trapCapturedEvent:wd,dispatchEvent:vd});function yd(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;c["ms"+a]="MS"+b;c["O"+a]="o"+b.toLowerCase();return c}
var zd={animationend:yd("Animation","AnimationEnd"),animationiteration:yd("Animation","AnimationIteration"),animationstart:yd("Animation","AnimationStart"),transitionend:yd("Transition","TransitionEnd")},Ad={},Bd={};l.canUseDOM&&(Bd=document.createElement("div").style,"AnimationEvent"in window||(delete zd.animationend.animation,delete zd.animationiteration.animation,delete zd.animationstart.animation),"TransitionEvent"in window||delete zd.transitionend.transition);
function Cd(a){if(Ad[a])return Ad[a];if(!zd[a])return a;var b=zd[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Bd)return Ad[a]=b[c];return""}
var Dd={topAbort:"abort",topAnimationEnd:Cd("animationend")||"animationend",topAnimationIteration:Cd("animationiteration")||"animationiteration",topAnimationStart:Cd("animationstart")||"animationstart",topBlur:"blur",topCancel:"cancel",topCanPlay:"canplay",topCanPlayThrough:"canplaythrough",topChange:"change",topClick:"click",topClose:"close",topCompositionEnd:"compositionend",topCompositionStart:"compositionstart",topCompositionUpdate:"compositionupdate",topContextMenu:"contextmenu",topCopy:"copy",
topCut:"cut",topDoubleClick:"dblclick",topDrag:"drag",topDragEnd:"dragend",topDragEnter:"dragenter",topDragExit:"dragexit",topDragLeave:"dragleave",topDragOver:"dragover",topDragStart:"dragstart",topDrop:"drop",topDurationChange:"durationchange",topEmptied:"emptied",topEncrypted:"encrypted",topEnded:"ended",topError:"error",topFocus:"focus",topInput:"input",topKeyDown:"keydown",topKeyPress:"keypress",topKeyUp:"keyup",topLoadedData:"loadeddata",topLoad:"load",topLoadedMetadata:"loadedmetadata",topLoadStart:"loadstart",
topMouseDown:"mousedown",topMouseMove:"mousemove",topMouseOut:"mouseout",topMouseOver:"mouseover",topMouseUp:"mouseup",topPaste:"paste",topPause:"pause",topPlay:"play",topPlaying:"playing",topProgress:"progress",topRateChange:"ratechange",topScroll:"scroll",topSeeked:"seeked",topSeeking:"seeking",topSelectionChange:"selectionchange",topStalled:"stalled",topSuspend:"suspend",topTextInput:"textInput",topTimeUpdate:"timeupdate",topToggle:"toggle",topTouchCancel:"touchcancel",topTouchEnd:"touchend",topTouchMove:"touchmove",
topTouchStart:"touchstart",topTransitionEnd:Cd("transitionend")||"transitionend",topVolumeChange:"volumechange",topWaiting:"waiting",topWheel:"wheel"},Ed={},Fd=0,Gd="_reactListenersID"+(""+Math.random()).slice(2);function Hd(a){Object.prototype.hasOwnProperty.call(a,Gd)||(a[Gd]=Fd++,Ed[a[Gd]]={});return Ed[a[Gd]]}function Id(a){for(;a&&a.firstChild;)a=a.firstChild;return a}
function Jd(a,b){var c=Id(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Id(c)}}function Kd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&"text"===a.type||"textarea"===b||"true"===a.contentEditable)}
var Ld=l.canUseDOM&&"documentMode"in document&&11>=document.documentMode,Md={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},dependencies:"topBlur topContextMenu topFocus topKeyDown topKeyUp topMouseDown topMouseUp topSelectionChange".split(" ")}},Nd=null,Od=null,Pd=null,Qd=!1;
function Rd(a,b){if(Qd||null==Nd||Nd!==da())return null;var c=Nd;"selectionStart"in c&&Kd(c)?c={start:c.selectionStart,end:c.selectionEnd}:window.getSelection?(c=window.getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset}):c=void 0;return Pd&&ea(Pd,c)?null:(Pd=c,a=T.getPooled(Md.select,Od,a,b),a.type="select",a.target=Nd,Ab(a),a)}
var Sd={eventTypes:Md,extractEvents:function(a,b,c,d){var e=d.window===d?d.document:9===d.nodeType?d:d.ownerDocument,f;if(!(f=!e)){a:{e=Hd(e);f=Sa.onSelect;for(var g=0;g<f.length;g++){var h=f[g];if(!e.hasOwnProperty(h)||!e[h]){e=!1;break a}}e=!0}f=!e}if(f)return null;e=b?qb(b):window;switch(a){case "topFocus":if(vc(e)||"true"===e.contentEditable)Nd=e,Od=b,Pd=null;break;case "topBlur":Pd=Od=Nd=null;break;case "topMouseDown":Qd=!0;break;case "topContextMenu":case "topMouseUp":return Qd=!1,Rd(c,d);case "topSelectionChange":if(Ld)break;
case "topKeyDown":case "topKeyUp":return Rd(c,d)}return null}};function Td(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Td,{animationName:null,elapsedTime:null,pseudoElement:null});function Ud(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Ud,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}});function Vd(a,b,c,d){return T.call(this,a,b,c,d)}bd.augmentClass(Vd,{relatedTarget:null});
function Wd(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;return 32<=a||13===a?a:0}
var Xd={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Yd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",
116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"};function Zd(a,b,c,d){return T.call(this,a,b,c,d)}
bd.augmentClass(Zd,{key:function(a){if(a.key){var b=Xd[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Wd(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Yd[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:ed,charCode:function(a){return"keypress"===a.type?Wd(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Wd(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}});function $d(a,b,c,d){return T.call(this,a,b,c,d)}fd.augmentClass($d,{dataTransfer:null});function ae(a,b,c,d){return T.call(this,a,b,c,d)}bd.augmentClass(ae,{touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:ed});function be(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(be,{propertyName:null,elapsedTime:null,pseudoElement:null});
function ce(a,b,c,d){return T.call(this,a,b,c,d)}fd.augmentClass(ce,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:null,deltaMode:null});var de={},ee={};
"abort animationEnd animationIteration animationStart blur cancel canPlay canPlayThrough click close contextMenu copy cut doubleClick drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error focus input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing progress rateChange reset scroll seeked seeking stalled submit suspend timeUpdate toggle touchCancel touchEnd touchMove touchStart transitionEnd volumeChange waiting wheel".split(" ").forEach(function(a){var b=a[0].toUpperCase()+
a.slice(1),c="on"+b;b="top"+b;c={phasedRegistrationNames:{bubbled:c,captured:c+"Capture"},dependencies:[b]};de[a]=c;ee[b]=c});
var fe={eventTypes:de,extractEvents:function(a,b,c,d){var e=ee[a];if(!e)return null;switch(a){case "topKeyPress":if(0===Wd(c))return null;case "topKeyDown":case "topKeyUp":a=Zd;break;case "topBlur":case "topFocus":a=Vd;break;case "topClick":if(2===c.button)return null;case "topDoubleClick":case "topMouseDown":case "topMouseMove":case "topMouseUp":case "topMouseOut":case "topMouseOver":case "topContextMenu":a=fd;break;case "topDrag":case "topDragEnd":case "topDragEnter":case "topDragExit":case "topDragLeave":case "topDragOver":case "topDragStart":case "topDrop":a=
$d;break;case "topTouchCancel":case "topTouchEnd":case "topTouchMove":case "topTouchStart":a=ae;break;case "topAnimationEnd":case "topAnimationIteration":case "topAnimationStart":a=Td;break;case "topTransitionEnd":a=be;break;case "topScroll":a=bd;break;case "topWheel":a=ce;break;case "topCopy":case "topCut":case "topPaste":a=Ud;break;default:a=T}b=a.getPooled(e,b,c,d);Ab(b);return b}};sd=function(a,b,c,d){a=jb(a,b,c,d);kb(a);lb(!1)};hb.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
Wa=sb.getFiberCurrentPropsFromNode;Xa=sb.getInstanceFromNode;Ya=sb.getNodeFromInstance;hb.injectEventPluginsByName({SimpleEventPlugin:fe,EnterLeaveEventPlugin:hd,ChangeEventPlugin:ad,SelectEventPlugin:Sd,BeforeInputEventPlugin:ic});var ge=[],he=-1;function V(a){0>he||(a.current=ge[he],ge[he]=null,he--)}function W(a,b){he++;ge[he]=a.current;a.current=b}new Set;var ie={current:D},X={current:!1},je=D;function ke(a){return le(a)?je:ie.current}
function me(a,b){var c=a.type.contextTypes;if(!c)return D;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function le(a){return 2===a.tag&&null!=a.type.childContextTypes}function ne(a){le(a)&&(V(X,a),V(ie,a))}
function oe(a,b,c){null!=ie.cursor?E("168"):void 0;W(ie,b,a);W(X,c,a)}function pe(a,b){var c=a.stateNode,d=a.type.childContextTypes;if("function"!==typeof c.getChildContext)return b;c=c.getChildContext();for(var e in c)e in d?void 0:E("108",jd(a)||"Unknown",e);return B({},b,c)}function qe(a){if(!le(a))return!1;var b=a.stateNode;b=b&&b.__reactInternalMemoizedMergedChildContext||D;je=ie.current;W(ie,b,a);W(X,X.current,a);return!0}
function re(a,b){var c=a.stateNode;c?void 0:E("169");if(b){var d=pe(a,je);c.__reactInternalMemoizedMergedChildContext=d;V(X,a);V(ie,a);W(ie,d,a)}else V(X,a);W(X,b,a)}
function Y(a,b,c){this.tag=a;this.key=b;this.stateNode=this.type=null;this.sibling=this.child=this["return"]=null;this.index=0;this.memoizedState=this.updateQueue=this.memoizedProps=this.pendingProps=this.ref=null;this.internalContextTag=c;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.expirationTime=0;this.alternate=null}
function se(a,b,c){var d=a.alternate;null===d?(d=new Y(a.tag,a.key,a.internalContextTag),d.type=a.type,d.stateNode=a.stateNode,d.alternate=a,a.alternate=d):(d.effectTag=0,d.nextEffect=null,d.firstEffect=null,d.lastEffect=null);d.expirationTime=c;d.pendingProps=b;d.child=a.child;d.memoizedProps=a.memoizedProps;d.memoizedState=a.memoizedState;d.updateQueue=a.updateQueue;d.sibling=a.sibling;d.index=a.index;d.ref=a.ref;return d}
function te(a,b,c){var d=void 0,e=a.type,f=a.key;"function"===typeof e?(d=e.prototype&&e.prototype.isReactComponent?new Y(2,f,b):new Y(0,f,b),d.type=e,d.pendingProps=a.props):"string"===typeof e?(d=new Y(5,f,b),d.type=e,d.pendingProps=a.props):"object"===typeof e&&null!==e&&"number"===typeof e.tag?(d=e,d.pendingProps=a.props):E("130",null==e?e:typeof e,"");d.expirationTime=c;return d}function ue(a,b,c,d){b=new Y(10,d,b);b.pendingProps=a;b.expirationTime=c;return b}
function ve(a,b,c){b=new Y(6,null,b);b.pendingProps=a;b.expirationTime=c;return b}function we(a,b,c){b=new Y(7,a.key,b);b.type=a.handler;b.pendingProps=a;b.expirationTime=c;return b}function xe(a,b,c){a=new Y(9,null,b);a.expirationTime=c;return a}function ye(a,b,c){b=new Y(4,a.key,b);b.pendingProps=a.children||[];b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}var ze=null,Ae=null;
function Be(a){return function(b){try{return a(b)}catch(c){}}}function Ce(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=b.inject(a);ze=Be(function(a){return b.onCommitFiberRoot(c,a)});Ae=Be(function(a){return b.onCommitFiberUnmount(c,a)})}catch(d){}return!0}function De(a){"function"===typeof ze&&ze(a)}function Ee(a){"function"===typeof Ae&&Ae(a)}
function Fe(a){return{baseState:a,expirationTime:0,first:null,last:null,callbackList:null,hasForceUpdate:!1,isInitialized:!1}}function Ge(a,b){null===a.last?a.first=a.last=b:(a.last.next=b,a.last=b);if(0===a.expirationTime||a.expirationTime>b.expirationTime)a.expirationTime=b.expirationTime}
function He(a,b){var c=a.alternate,d=a.updateQueue;null===d&&(d=a.updateQueue=Fe(null));null!==c?(a=c.updateQueue,null===a&&(a=c.updateQueue=Fe(null))):a=null;a=a!==d?a:null;null===a?Ge(d,b):null===d.last||null===a.last?(Ge(d,b),Ge(a,b)):(Ge(d,b),a.last=b)}function Ie(a,b,c,d){a=a.partialState;return"function"===typeof a?a.call(b,c,d):a}
function Je(a,b,c,d,e,f){null!==a&&a.updateQueue===c&&(c=b.updateQueue={baseState:c.baseState,expirationTime:c.expirationTime,first:c.first,last:c.last,isInitialized:c.isInitialized,callbackList:null,hasForceUpdate:!1});c.expirationTime=0;c.isInitialized?a=c.baseState:(a=c.baseState=b.memoizedState,c.isInitialized=!0);for(var g=!0,h=c.first,k=!1;null!==h;){var q=h.expirationTime;if(q>f){var v=c.expirationTime;if(0===v||v>q)c.expirationTime=q;k||(k=!0,c.baseState=a)}else{k||(c.first=h.next,null===
c.first&&(c.last=null));if(h.isReplace)a=Ie(h,d,a,e),g=!0;else if(q=Ie(h,d,a,e))a=g?B({},a,q):B(a,q),g=!1;h.isForced&&(c.hasForceUpdate=!0);null!==h.callback&&(q=c.callbackList,null===q&&(q=c.callbackList=[]),q.push(h))}h=h.next}null!==c.callbackList?b.effectTag|=32:null!==c.first||c.hasForceUpdate||(b.updateQueue=null);k||(c.baseState=a);return a}
function Ke(a,b){var c=a.callbackList;if(null!==c)for(a.callbackList=null,a=0;a<c.length;a++){var d=c[a],e=d.callback;d.callback=null;"function"!==typeof e?E("191",e):void 0;e.call(b)}}
function Le(a,b,c,d){function e(a,b){b.updater=f;a.stateNode=b;b._reactInternalFiber=a}var f={isMounted:ld,enqueueSetState:function(c,d,e){c=c._reactInternalFiber;e=void 0===e?null:e;var g=b(c);He(c,{expirationTime:g,partialState:d,callback:e,isReplace:!1,isForced:!1,nextCallback:null,next:null});a(c,g)},enqueueReplaceState:function(c,d,e){c=c._reactInternalFiber;e=void 0===e?null:e;var g=b(c);He(c,{expirationTime:g,partialState:d,callback:e,isReplace:!0,isForced:!1,nextCallback:null,next:null});
a(c,g)},enqueueForceUpdate:function(c,d){c=c._reactInternalFiber;d=void 0===d?null:d;var e=b(c);He(c,{expirationTime:e,partialState:null,callback:d,isReplace:!1,isForced:!0,nextCallback:null,next:null});a(c,e)}};return{adoptClassInstance:e,constructClassInstance:function(a,b){var c=a.type,d=ke(a),f=2===a.tag&&null!=a.type.contextTypes,g=f?me(a,d):D;b=new c(b,g);e(a,b);f&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=d,a.__reactInternalMemoizedMaskedChildContext=g);return b},mountClassInstance:function(a,
b){var c=a.alternate,d=a.stateNode,e=d.state||null,g=a.pendingProps;g?void 0:E("158");var h=ke(a);d.props=g;d.state=a.memoizedState=e;d.refs=D;d.context=me(a,h);null!=a.type&&null!=a.type.prototype&&!0===a.type.prototype.unstable_isAsyncReactComponent&&(a.internalContextTag|=1);"function"===typeof d.componentWillMount&&(e=d.state,d.componentWillMount(),e!==d.state&&f.enqueueReplaceState(d,d.state,null),e=a.updateQueue,null!==e&&(d.state=Je(c,a,e,d,g,b)));"function"===typeof d.componentDidMount&&(a.effectTag|=
4)},updateClassInstance:function(a,b,e){var g=b.stateNode;g.props=b.memoizedProps;g.state=b.memoizedState;var h=b.memoizedProps,k=b.pendingProps;k||(k=h,null==k?E("159"):void 0);var u=g.context,z=ke(b);z=me(b,z);"function"!==typeof g.componentWillReceiveProps||h===k&&u===z||(u=g.state,g.componentWillReceiveProps(k,z),g.state!==u&&f.enqueueReplaceState(g,g.state,null));u=b.memoizedState;e=null!==b.updateQueue?Je(a,b,b.updateQueue,g,k,e):u;if(!(h!==k||u!==e||X.current||null!==b.updateQueue&&b.updateQueue.hasForceUpdate))return"function"!==
typeof g.componentDidUpdate||h===a.memoizedProps&&u===a.memoizedState||(b.effectTag|=4),!1;var G=k;if(null===h||null!==b.updateQueue&&b.updateQueue.hasForceUpdate)G=!0;else{var I=b.stateNode,L=b.type;G="function"===typeof I.shouldComponentUpdate?I.shouldComponentUpdate(G,e,z):L.prototype&&L.prototype.isPureReactComponent?!ea(h,G)||!ea(u,e):!0}G?("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(k,e,z),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4)):("function"!==typeof g.componentDidUpdate||
h===a.memoizedProps&&u===a.memoizedState||(b.effectTag|=4),c(b,k),d(b,e));g.props=k;g.state=e;g.context=z;return G}}}var Qe="function"===typeof Symbol&&Symbol["for"],Re=Qe?Symbol["for"]("react.element"):60103,Se=Qe?Symbol["for"]("react.call"):60104,Te=Qe?Symbol["for"]("react.return"):60105,Ue=Qe?Symbol["for"]("react.portal"):60106,Ve=Qe?Symbol["for"]("react.fragment"):60107,We="function"===typeof Symbol&&Symbol.iterator;
function Xe(a){if(null===a||"undefined"===typeof a)return null;a=We&&a[We]||a["@@iterator"];return"function"===typeof a?a:null}var Ye=Array.isArray;
function Ze(a,b){var c=b.ref;if(null!==c&&"function"!==typeof c){if(b._owner){b=b._owner;var d=void 0;b&&(2!==b.tag?E("110"):void 0,d=b.stateNode);d?void 0:E("147",c);var e=""+c;if(null!==a&&null!==a.ref&&a.ref._stringRef===e)return a.ref;a=function(a){var b=d.refs===D?d.refs={}:d.refs;null===a?delete b[e]:b[e]=a};a._stringRef=e;return a}"string"!==typeof c?E("148"):void 0;b._owner?void 0:E("149",c)}return c}
function $e(a,b){"textarea"!==a.type&&E("31","[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,"")}
function af(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b,c){a=se(a,b,c);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=
2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=ve(c,a.internalContextTag,d),b["return"]=a,b;b=e(b,c,d);b["return"]=a;return b}function k(a,b,c,d){if(null!==b&&b.type===c.type)return d=e(b,c.props,d),d.ref=Ze(b,c),d["return"]=a,d;d=te(c,a.internalContextTag,d);d.ref=Ze(b,c);d["return"]=a;return d}function q(a,b,c,d){if(null===b||7!==b.tag)return b=we(c,a.internalContextTag,d),b["return"]=a,b;b=e(b,c,d);
b["return"]=a;return b}function v(a,b,c,d){if(null===b||9!==b.tag)return b=xe(c,a.internalContextTag,d),b.type=c.value,b["return"]=a,b;b=e(b,null,d);b.type=c.value;b["return"]=a;return b}function y(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=ye(c,a.internalContextTag,d),b["return"]=a,b;b=e(b,c.children||[],d);b["return"]=a;return b}function u(a,b,c,d,f){if(null===b||10!==b.tag)return b=ue(c,a.internalContextTag,
d,f),b["return"]=a,b;b=e(b,c,d);b["return"]=a;return b}function z(a,b,c){if("string"===typeof b||"number"===typeof b)return b=ve(""+b,a.internalContextTag,c),b["return"]=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case Re:if(b.type===Ve)return b=ue(b.props.children,a.internalContextTag,c,b.key),b["return"]=a,b;c=te(b,a.internalContextTag,c);c.ref=Ze(null,b);c["return"]=a;return c;case Se:return b=we(b,a.internalContextTag,c),b["return"]=a,b;case Te:return c=xe(b,a.internalContextTag,
c),c.type=b.value,c["return"]=a,c;case Ue:return b=ye(b,a.internalContextTag,c),b["return"]=a,b}if(Ye(b)||Xe(b))return b=ue(b,a.internalContextTag,c,null),b["return"]=a,b;$e(a,b)}return null}function G(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Re:return c.key===e?c.type===Ve?u(a,b,c.props.children,d,e):k(a,b,c,d):null;case Se:return c.key===e?q(a,b,c,d):null;case Te:return null===
e?v(a,b,c,d):null;case Ue:return c.key===e?y(a,b,c,d):null}if(Ye(c)||Xe(c))return null!==e?null:u(a,b,c,d,null);$e(a,c)}return null}function I(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Re:return a=a.get(null===d.key?c:d.key)||null,d.type===Ve?u(b,a,d.props.children,e,d.key):k(b,a,d,e);case Se:return a=a.get(null===d.key?c:d.key)||null,q(b,a,d,e);case Te:return a=a.get(c)||null,v(b,a,d,e);case Ue:return a=
a.get(null===d.key?c:d.key)||null,y(b,a,d,e)}if(Ye(d)||Xe(d))return a=a.get(c)||null,u(b,a,d,e,null);$e(b,d)}return null}function L(e,g,m,A){for(var h=null,r=null,n=g,w=g=0,k=null;null!==n&&w<m.length;w++){n.index>w?(k=n,n=null):k=n.sibling;var x=G(e,n,m[w],A);if(null===x){null===n&&(n=k);break}a&&n&&null===x.alternate&&b(e,n);g=f(x,g,w);null===r?h=x:r.sibling=x;r=x;n=k}if(w===m.length)return c(e,n),h;if(null===n){for(;w<m.length;w++)if(n=z(e,m[w],A))g=f(n,g,w),null===r?h=n:r.sibling=n,r=n;return h}for(n=
d(e,n);w<m.length;w++)if(k=I(n,e,w,m[w],A)){if(a&&null!==k.alternate)n["delete"](null===k.key?w:k.key);g=f(k,g,w);null===r?h=k:r.sibling=k;r=k}a&&n.forEach(function(a){return b(e,a)});return h}function N(e,g,m,A){var h=Xe(m);"function"!==typeof h?E("150"):void 0;m=h.call(m);null==m?E("151"):void 0;for(var r=h=null,n=g,w=g=0,k=null,x=m.next();null!==n&&!x.done;w++,x=m.next()){n.index>w?(k=n,n=null):k=n.sibling;var J=G(e,n,x.value,A);if(null===J){n||(n=k);break}a&&n&&null===J.alternate&&b(e,n);g=f(J,
g,w);null===r?h=J:r.sibling=J;r=J;n=k}if(x.done)return c(e,n),h;if(null===n){for(;!x.done;w++,x=m.next())x=z(e,x.value,A),null!==x&&(g=f(x,g,w),null===r?h=x:r.sibling=x,r=x);return h}for(n=d(e,n);!x.done;w++,x=m.next())if(x=I(n,e,w,x.value,A),null!==x){if(a&&null!==x.alternate)n["delete"](null===x.key?w:x.key);g=f(x,g,w);null===r?h=x:r.sibling=x;r=x}a&&n.forEach(function(a){return b(e,a)});return h}return function(a,d,f,h){"object"===typeof f&&null!==f&&f.type===Ve&&null===f.key&&(f=f.props.children);
var m="object"===typeof f&&null!==f;if(m)switch(f.$$typeof){case Re:a:{var r=f.key;for(m=d;null!==m;){if(m.key===r)if(10===m.tag?f.type===Ve:m.type===f.type){c(a,m.sibling);d=e(m,f.type===Ve?f.props.children:f.props,h);d.ref=Ze(m,f);d["return"]=a;a=d;break a}else{c(a,m);break}else b(a,m);m=m.sibling}f.type===Ve?(d=ue(f.props.children,a.internalContextTag,h,f.key),d["return"]=a,a=d):(h=te(f,a.internalContextTag,h),h.ref=Ze(d,f),h["return"]=a,a=h)}return g(a);case Se:a:{for(m=f.key;null!==d;){if(d.key===
m)if(7===d.tag){c(a,d.sibling);d=e(d,f,h);d["return"]=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=we(f,a.internalContextTag,h);d["return"]=a;a=d}return g(a);case Te:a:{if(null!==d)if(9===d.tag){c(a,d.sibling);d=e(d,null,h);d.type=f.value;d["return"]=a;a=d;break a}else c(a,d);d=xe(f,a.internalContextTag,h);d.type=f.value;d["return"]=a;a=d}return g(a);case Ue:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===
f.implementation){c(a,d.sibling);d=e(d,f.children||[],h);d["return"]=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=ye(f,a.internalContextTag,h);d["return"]=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f,h)):(c(a,d),d=ve(f,a.internalContextTag,h)),d["return"]=a,a=d,g(a);if(Ye(f))return L(a,d,f,h);if(Xe(f))return N(a,d,f,h);m&&$e(a,f);if("undefined"===typeof f)switch(a.tag){case 2:case 1:h=a.type,E("152",h.displayName||
h.name||"Component")}return c(a,d)}}var bf=af(!0),cf=af(!1);
function df(a,b,c,d,e){function f(a,b,c){var d=b.expirationTime;b.child=null===a?cf(b,null,c,d):bf(b,a.child,c,d)}function g(a,b){var c=b.ref;null===c||a&&a.ref===c||(b.effectTag|=128)}function h(a,b,c,d){g(a,b);if(!c)return d&&re(b,!1),q(a,b);c=b.stateNode;id.current=b;var e=c.render();b.effectTag|=1;f(a,b,e);b.memoizedState=c.state;b.memoizedProps=c.props;d&&re(b,!0);return b.child}function k(a){var b=a.stateNode;b.pendingContext?oe(a,b.pendingContext,b.pendingContext!==b.context):b.context&&oe(a,
b.context,!1);I(a,b.containerInfo)}function q(a,b){null!==a&&b.child!==a.child?E("153"):void 0;if(null!==b.child){a=b.child;var c=se(a,a.pendingProps,a.expirationTime);b.child=c;for(c["return"]=b;null!==a.sibling;)a=a.sibling,c=c.sibling=se(a,a.pendingProps,a.expirationTime),c["return"]=b;c.sibling=null}return b.child}function v(a,b){switch(b.tag){case 3:k(b);break;case 2:qe(b);break;case 4:I(b,b.stateNode.containerInfo)}return null}var y=a.shouldSetTextContent,u=a.useSyncScheduling,z=a.shouldDeprioritizeSubtree,
G=b.pushHostContext,I=b.pushHostContainer,L=c.enterHydrationState,N=c.resetHydrationState,J=c.tryToClaimNextHydratableInstance;a=Le(d,e,function(a,b){a.memoizedProps=b},function(a,b){a.memoizedState=b});var w=a.adoptClassInstance,m=a.constructClassInstance,A=a.mountClassInstance,Ob=a.updateClassInstance;return{beginWork:function(a,b,c){if(0===b.expirationTime||b.expirationTime>c)return v(a,b);switch(b.tag){case 0:null!==a?E("155"):void 0;var d=b.type,e=b.pendingProps,r=ke(b);r=me(b,r);d=d(e,r);b.effectTag|=
1;"object"===typeof d&&null!==d&&"function"===typeof d.render?(b.tag=2,e=qe(b),w(b,d),A(b,c),b=h(a,b,!0,e)):(b.tag=1,f(a,b,d),b.memoizedProps=e,b=b.child);return b;case 1:a:{e=b.type;c=b.pendingProps;d=b.memoizedProps;if(X.current)null===c&&(c=d);else if(null===c||d===c){b=q(a,b);break a}d=ke(b);d=me(b,d);e=e(c,d);b.effectTag|=1;f(a,b,e);b.memoizedProps=c;b=b.child}return b;case 2:return e=qe(b),d=void 0,null===a?b.stateNode?E("153"):(m(b,b.pendingProps),A(b,c),d=!0):d=Ob(a,b,c),h(a,b,d,e);case 3:return k(b),
e=b.updateQueue,null!==e?(d=b.memoizedState,e=Je(a,b,e,null,null,c),d===e?(N(),b=q(a,b)):(d=e.element,r=b.stateNode,(null===a||null===a.child)&&r.hydrate&&L(b)?(b.effectTag|=2,b.child=cf(b,null,d,c)):(N(),f(a,b,d)),b.memoizedState=e,b=b.child)):(N(),b=q(a,b)),b;case 5:G(b);null===a&&J(b);e=b.type;var n=b.memoizedProps;d=b.pendingProps;null===d&&(d=n,null===d?E("154"):void 0);r=null!==a?a.memoizedProps:null;X.current||null!==d&&n!==d?(n=d.children,y(e,d)?n=null:r&&y(e,r)&&(b.effectTag|=16),g(a,b),
2147483647!==c&&!u&&z(e,d)?(b.expirationTime=2147483647,b=null):(f(a,b,n),b.memoizedProps=d,b=b.child)):b=q(a,b);return b;case 6:return null===a&&J(b),a=b.pendingProps,null===a&&(a=b.memoizedProps),b.memoizedProps=a,null;case 8:b.tag=7;case 7:e=b.pendingProps;if(X.current)null===e&&(e=a&&a.memoizedProps,null===e?E("154"):void 0);else if(null===e||b.memoizedProps===e)e=b.memoizedProps;d=e.children;b.stateNode=null===a?cf(b,b.stateNode,d,c):bf(b,b.stateNode,d,c);b.memoizedProps=e;return b.stateNode;
case 9:return null;case 4:a:{I(b,b.stateNode.containerInfo);e=b.pendingProps;if(X.current)null===e&&(e=a&&a.memoizedProps,null==e?E("154"):void 0);else if(null===e||b.memoizedProps===e){b=q(a,b);break a}null===a?b.child=bf(b,null,e,c):f(a,b,e);b.memoizedProps=e;b=b.child}return b;case 10:a:{c=b.pendingProps;if(X.current)null===c&&(c=b.memoizedProps);else if(null===c||b.memoizedProps===c){b=q(a,b);break a}f(a,b,c);b.memoizedProps=c;b=b.child}return b;default:E("156")}},beginFailedWork:function(a,b,
c){switch(b.tag){case 2:qe(b);break;case 3:k(b);break;default:E("157")}b.effectTag|=64;null===a?b.child=null:b.child!==a.child&&(b.child=a.child);if(0===b.expirationTime||b.expirationTime>c)return v(a,b);b.firstEffect=null;b.lastEffect=null;b.child=null===a?cf(b,null,null,c):bf(b,a.child,null,c);2===b.tag&&(a=b.stateNode,b.memoizedProps=a.props,b.memoizedState=a.state);return b.child}}}
function ef(a,b,c){function d(a){a.effectTag|=4}var e=a.createInstance,f=a.createTextInstance,g=a.appendInitialChild,h=a.finalizeInitialChildren,k=a.prepareUpdate,q=a.persistence,v=b.getRootHostContainer,y=b.popHostContext,u=b.getHostContext,z=b.popHostContainer,G=c.prepareToHydrateHostInstance,I=c.prepareToHydrateHostTextInstance,L=c.popHydrationState,N=void 0,J=void 0,w=void 0;a.mutation?(N=function(){},J=function(a,b,c){(b.updateQueue=c)&&d(b)},w=function(a,b,c,e){c!==e&&d(b)}):q?E("235"):E("236");
return{completeWork:function(a,b,c){var m=b.pendingProps;if(null===m)m=b.memoizedProps;else if(2147483647!==b.expirationTime||2147483647===c)b.pendingProps=null;switch(b.tag){case 1:return null;case 2:return ne(b),null;case 3:z(b);V(X,b);V(ie,b);m=b.stateNode;m.pendingContext&&(m.context=m.pendingContext,m.pendingContext=null);if(null===a||null===a.child)L(b),b.effectTag&=-3;N(b);return null;case 5:y(b);c=v();var A=b.type;if(null!==a&&null!=b.stateNode){var p=a.memoizedProps,q=b.stateNode,x=u();q=
k(q,A,p,m,c,x);J(a,b,q,A,p,m,c);a.ref!==b.ref&&(b.effectTag|=128)}else{if(!m)return null===b.stateNode?E("166"):void 0,null;a=u();if(L(b))G(b,c,a)&&d(b);else{a=e(A,m,c,a,b);a:for(p=b.child;null!==p;){if(5===p.tag||6===p.tag)g(a,p.stateNode);else if(4!==p.tag&&null!==p.child){p.child["return"]=p;p=p.child;continue}if(p===b)break;for(;null===p.sibling;){if(null===p["return"]||p["return"]===b)break a;p=p["return"]}p.sibling["return"]=p["return"];p=p.sibling}h(a,A,m,c)&&d(b);b.stateNode=a}null!==b.ref&&
(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)w(a,b,a.memoizedProps,m);else{if("string"!==typeof m)return null===b.stateNode?E("166"):void 0,null;a=v();c=u();L(b)?I(b)&&d(b):b.stateNode=f(m,a,c,b)}return null;case 7:(m=b.memoizedProps)?void 0:E("165");b.tag=8;A=[];a:for((p=b.stateNode)&&(p["return"]=b);null!==p;){if(5===p.tag||6===p.tag||4===p.tag)E("247");else if(9===p.tag)A.push(p.type);else if(null!==p.child){p.child["return"]=p;p=p.child;continue}for(;null===p.sibling;){if(null===
p["return"]||p["return"]===b)break a;p=p["return"]}p.sibling["return"]=p["return"];p=p.sibling}p=m.handler;m=p(m.props,A);b.child=bf(b,null!==a?a.child:null,m,c);return b.child;case 8:return b.tag=7,null;case 9:return null;case 10:return null;case 4:return z(b),N(b),null;case 0:E("167");default:E("156")}}}}
function ff(a,b){function c(a){var c=a.ref;if(null!==c)try{c(null)}catch(A){b(a,A)}}function d(a){"function"===typeof Ee&&Ee(a);switch(a.tag){case 2:c(a);var d=a.stateNode;if("function"===typeof d.componentWillUnmount)try{d.props=a.memoizedProps,d.state=a.memoizedState,d.componentWillUnmount()}catch(A){b(a,A)}break;case 5:c(a);break;case 7:e(a.stateNode);break;case 4:k&&g(a)}}function e(a){for(var b=a;;)if(d(b),null===b.child||k&&4===b.tag){if(b===a)break;for(;null===b.sibling;){if(null===b["return"]||
b["return"]===a)return;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}else b.child["return"]=b,b=b.child}function f(a){return 5===a.tag||3===a.tag||4===a.tag}function g(a){for(var b=a,c=!1,f=void 0,g=void 0;;){if(!c){c=b["return"];a:for(;;){null===c?E("160"):void 0;switch(c.tag){case 5:f=c.stateNode;g=!1;break a;case 3:f=c.stateNode.containerInfo;g=!0;break a;case 4:f=c.stateNode.containerInfo;g=!0;break a}c=c["return"]}c=!0}if(5===b.tag||6===b.tag)e(b),g?J(f,b.stateNode):N(f,b.stateNode);
else if(4===b.tag?f=b.stateNode.containerInfo:d(b),null!==b.child){b.child["return"]=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b["return"]||b["return"]===a)return;b=b["return"];4===b.tag&&(c=!1)}b.sibling["return"]=b["return"];b=b.sibling}}var h=a.getPublicInstance,k=a.mutation;a=a.persistence;k||(a?E("235"):E("236"));var q=k.commitMount,v=k.commitUpdate,y=k.resetTextContent,u=k.commitTextUpdate,z=k.appendChild,G=k.appendChildToContainer,I=k.insertBefore,L=k.insertInContainerBefore,
N=k.removeChild,J=k.removeChildFromContainer;return{commitResetTextContent:function(a){y(a.stateNode)},commitPlacement:function(a){a:{for(var b=a["return"];null!==b;){if(f(b)){var c=b;break a}b=b["return"]}E("160");c=void 0}var d=b=void 0;switch(c.tag){case 5:b=c.stateNode;d=!1;break;case 3:b=c.stateNode.containerInfo;d=!0;break;case 4:b=c.stateNode.containerInfo;d=!0;break;default:E("161")}c.effectTag&16&&(y(b),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c["return"]||f(c["return"])){c=
null;break a}c=c["return"]}c.sibling["return"]=c["return"];for(c=c.sibling;5!==c.tag&&6!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;else c.child["return"]=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}for(var e=a;;){if(5===e.tag||6===e.tag)c?d?L(b,e.stateNode,c):I(b,e.stateNode,c):d?G(b,e.stateNode):z(b,e.stateNode);else if(4!==e.tag&&null!==e.child){e.child["return"]=e;e=e.child;continue}if(e===a)break;for(;null===e.sibling;){if(null===e["return"]||e["return"]===
a)return;e=e["return"]}e.sibling["return"]=e["return"];e=e.sibling}},commitDeletion:function(a){g(a);a["return"]=null;a.child=null;a.alternate&&(a.alternate.child=null,a.alternate["return"]=null)},commitWork:function(a,b){switch(b.tag){case 2:break;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps;a=null!==a?a.memoizedProps:d;var e=b.type,f=b.updateQueue;b.updateQueue=null;null!==f&&v(c,f,e,a,d,b)}break;case 6:null===b.stateNode?E("162"):void 0;c=b.memoizedProps;u(b.stateNode,null!==a?a.memoizedProps:
c,c);break;case 3:break;default:E("163")}},commitLifeCycles:function(a,b){switch(b.tag){case 2:var c=b.stateNode;if(b.effectTag&4)if(null===a)c.props=b.memoizedProps,c.state=b.memoizedState,c.componentDidMount();else{var d=a.memoizedProps;a=a.memoizedState;c.props=b.memoizedProps;c.state=b.memoizedState;c.componentDidUpdate(d,a)}b=b.updateQueue;null!==b&&Ke(b,c);break;case 3:c=b.updateQueue;null!==c&&Ke(c,null!==b.child?b.child.stateNode:null);break;case 5:c=b.stateNode;null===a&&b.effectTag&4&&q(c,
b.type,b.memoizedProps,b);break;case 6:break;case 4:break;default:E("163")}},commitAttachRef:function(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:b(h(c));break;default:b(c)}}},commitDetachRef:function(a){a=a.ref;null!==a&&a(null)}}}var gf={};
function hf(a){function b(a){a===gf?E("174"):void 0;return a}var c=a.getChildHostContext,d=a.getRootHostContext,e={current:gf},f={current:gf},g={current:gf};return{getHostContext:function(){return b(e.current)},getRootHostContainer:function(){return b(g.current)},popHostContainer:function(a){V(e,a);V(f,a);V(g,a)},popHostContext:function(a){f.current===a&&(V(e,a),V(f,a))},pushHostContainer:function(a,b){W(g,b,a);b=d(b);W(f,a,a);W(e,b,a)},pushHostContext:function(a){var d=b(g.current),h=b(e.current);
d=c(h,a.type,d);h!==d&&(W(f,a,a),W(e,d,a))},resetHostContainer:function(){e.current=gf;g.current=gf}}}
function jf(a){function b(a,b){var c=new Y(5,null,0);c.type="DELETED";c.stateNode=b;c["return"]=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function c(a,b){switch(a.tag){case 5:return b=f(b,a.type,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;case 6:return b=g(b,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;default:return!1}}function d(a){for(a=a["return"];null!==a&&5!==a.tag&&3!==a.tag;)a=a["return"];y=a}var e=a.shouldSetTextContent;
a=a.hydration;if(!a)return{enterHydrationState:function(){return!1},resetHydrationState:function(){},tryToClaimNextHydratableInstance:function(){},prepareToHydrateHostInstance:function(){E("175")},prepareToHydrateHostTextInstance:function(){E("176")},popHydrationState:function(){return!1}};var f=a.canHydrateInstance,g=a.canHydrateTextInstance,h=a.getNextHydratableSibling,k=a.getFirstHydratableChild,q=a.hydrateInstance,v=a.hydrateTextInstance,y=null,u=null,z=!1;return{enterHydrationState:function(a){u=
k(a.stateNode.containerInfo);y=a;return z=!0},resetHydrationState:function(){u=y=null;z=!1},tryToClaimNextHydratableInstance:function(a){if(z){var d=u;if(d){if(!c(a,d)){d=h(d);if(!d||!c(a,d)){a.effectTag|=2;z=!1;y=a;return}b(y,u)}y=a;u=k(d)}else a.effectTag|=2,z=!1,y=a}},prepareToHydrateHostInstance:function(a,b,c){b=q(a.stateNode,a.type,a.memoizedProps,b,c,a);a.updateQueue=b;return null!==b?!0:!1},prepareToHydrateHostTextInstance:function(a){return v(a.stateNode,a.memoizedProps,a)},popHydrationState:function(a){if(a!==
y)return!1;if(!z)return d(a),z=!0,!1;var c=a.type;if(5!==a.tag||"head"!==c&&"body"!==c&&!e(c,a.memoizedProps))for(c=u;c;)b(a,c),c=h(c);d(a);u=y?h(a.stateNode):null;return!0}}}
function kf(a){function b(a){Qb=ja=!0;var b=a.stateNode;b.current===a?E("177"):void 0;b.isReadyForCommit=!1;id.current=null;if(1<a.effectTag)if(null!==a.lastEffect){a.lastEffect.nextEffect=a;var c=a.firstEffect}else c=a;else c=a.firstEffect;yg();for(t=c;null!==t;){var d=!1,e=void 0;try{for(;null!==t;){var f=t.effectTag;f&16&&zg(t);if(f&128){var g=t.alternate;null!==g&&Ag(g)}switch(f&-242){case 2:Ne(t);t.effectTag&=-3;break;case 6:Ne(t);t.effectTag&=-3;Oe(t.alternate,t);break;case 4:Oe(t.alternate,
t);break;case 8:Sc=!0,Bg(t),Sc=!1}t=t.nextEffect}}catch(Tc){d=!0,e=Tc}d&&(null===t?E("178"):void 0,h(t,e),null!==t&&(t=t.nextEffect))}Cg();b.current=a;for(t=c;null!==t;){c=!1;d=void 0;try{for(;null!==t;){var k=t.effectTag;k&36&&Dg(t.alternate,t);k&128&&Eg(t);if(k&64)switch(e=t,f=void 0,null!==R&&(f=R.get(e),R["delete"](e),null==f&&null!==e.alternate&&(e=e.alternate,f=R.get(e),R["delete"](e))),null==f?E("184"):void 0,e.tag){case 2:e.stateNode.componentDidCatch(f.error,{componentStack:f.componentStack});
break;case 3:null===ca&&(ca=f.error);break;default:E("157")}var Qc=t.nextEffect;t.nextEffect=null;t=Qc}}catch(Tc){c=!0,d=Tc}c&&(null===t?E("178"):void 0,h(t,d),null!==t&&(t=t.nextEffect))}ja=Qb=!1;"function"===typeof De&&De(a.stateNode);ha&&(ha.forEach(G),ha=null);null!==ca&&(a=ca,ca=null,Ob(a));b=b.current.expirationTime;0===b&&(qa=R=null);return b}function c(a){for(;;){var b=Fg(a.alternate,a,H),c=a["return"],d=a.sibling;var e=a;if(2147483647===H||2147483647!==e.expirationTime){if(2!==e.tag&&3!==
e.tag)var f=0;else f=e.updateQueue,f=null===f?0:f.expirationTime;for(var g=e.child;null!==g;)0!==g.expirationTime&&(0===f||f>g.expirationTime)&&(f=g.expirationTime),g=g.sibling;e.expirationTime=f}if(null!==b)return b;null!==c&&(null===c.firstEffect&&(c.firstEffect=a.firstEffect),null!==a.lastEffect&&(null!==c.lastEffect&&(c.lastEffect.nextEffect=a.firstEffect),c.lastEffect=a.lastEffect),1<a.effectTag&&(null!==c.lastEffect?c.lastEffect.nextEffect=a:c.firstEffect=a,c.lastEffect=a));if(null!==d)return d;
if(null!==c)a=c;else{a.stateNode.isReadyForCommit=!0;break}}return null}function d(a){var b=rg(a.alternate,a,H);null===b&&(b=c(a));id.current=null;return b}function e(a){var b=Gg(a.alternate,a,H);null===b&&(b=c(a));id.current=null;return b}function f(a){if(null!==R){if(!(0===H||H>a))if(H<=Uc)for(;null!==F;)F=k(F)?e(F):d(F);else for(;null!==F&&!A();)F=k(F)?e(F):d(F)}else if(!(0===H||H>a))if(H<=Uc)for(;null!==F;)F=d(F);else for(;null!==F&&!A();)F=d(F)}function g(a,b){ja?E("243"):void 0;ja=!0;a.isReadyForCommit=
!1;if(a!==ra||b!==H||null===F){for(;-1<he;)ge[he]=null,he--;je=D;ie.current=D;X.current=!1;x();ra=a;H=b;F=se(ra.current,null,b)}var c=!1,d=null;try{f(b)}catch(Rc){c=!0,d=Rc}for(;c;){if(eb){ca=d;break}var g=F;if(null===g)eb=!0;else{var k=h(g,d);null===k?E("183"):void 0;if(!eb){try{c=k;d=b;for(k=c;null!==g;){switch(g.tag){case 2:ne(g);break;case 5:qg(g);break;case 3:p(g);break;case 4:p(g)}if(g===k||g.alternate===k)break;g=g["return"]}F=e(c);f(d)}catch(Rc){c=!0;d=Rc;continue}break}}}b=ca;eb=ja=!1;ca=
null;null!==b&&Ob(b);return a.isReadyForCommit?a.current.alternate:null}function h(a,b){var c=id.current=null,d=!1,e=!1,f=null;if(3===a.tag)c=a,q(a)&&(eb=!0);else for(var g=a["return"];null!==g&&null===c;){2===g.tag?"function"===typeof g.stateNode.componentDidCatch&&(d=!0,f=jd(g),c=g,e=!0):3===g.tag&&(c=g);if(q(g)){if(Sc||null!==ha&&(ha.has(g)||null!==g.alternate&&ha.has(g.alternate)))return null;c=null;e=!1}g=g["return"]}if(null!==c){null===qa&&(qa=new Set);qa.add(c);var h="";g=a;do{a:switch(g.tag){case 0:case 1:case 2:case 5:var k=
g._debugOwner,Qc=g._debugSource;var m=jd(g);var n=null;k&&(n=jd(k));k=Qc;m="\n    in "+(m||"Unknown")+(k?" (at "+k.fileName.replace(/^.*[\\\/]/,"")+":"+k.lineNumber+")":n?" (created by "+n+")":"");break a;default:m=""}h+=m;g=g["return"]}while(g);g=h;a=jd(a);null===R&&(R=new Map);b={componentName:a,componentStack:g,error:b,errorBoundary:d?c.stateNode:null,errorBoundaryFound:d,errorBoundaryName:f,willRetry:e};R.set(c,b);try{var p=b.error;p&&p.suppressReactErrorLogging||console.error(p)}catch(Vc){Vc&&
Vc.suppressReactErrorLogging||console.error(Vc)}Qb?(null===ha&&(ha=new Set),ha.add(c)):G(c);return c}null===ca&&(ca=b);return null}function k(a){return null!==R&&(R.has(a)||null!==a.alternate&&R.has(a.alternate))}function q(a){return null!==qa&&(qa.has(a)||null!==a.alternate&&qa.has(a.alternate))}function v(){return 20*(((I()+100)/20|0)+1)}function y(a){return 0!==ka?ka:ja?Qb?1:H:!Hg||a.internalContextTag&1?v():1}function u(a,b){return z(a,b,!1)}function z(a,b){for(;null!==a;){if(0===a.expirationTime||
a.expirationTime>b)a.expirationTime=b;null!==a.alternate&&(0===a.alternate.expirationTime||a.alternate.expirationTime>b)&&(a.alternate.expirationTime=b);if(null===a["return"])if(3===a.tag){var c=a.stateNode;!ja&&c===ra&&b<H&&(F=ra=null,H=0);var d=c,e=b;Rb>Ig&&E("185");if(null===d.nextScheduledRoot)d.remainingExpirationTime=e,null===O?(sa=O=d,d.nextScheduledRoot=d):(O=O.nextScheduledRoot=d,O.nextScheduledRoot=sa);else{var f=d.remainingExpirationTime;if(0===f||e<f)d.remainingExpirationTime=e}Fa||(la?
Sb&&(ma=d,na=1,m(ma,na)):1===e?w(1,null):L(e));!ja&&c===ra&&b<H&&(F=ra=null,H=0)}else break;a=a["return"]}}function G(a){z(a,1,!0)}function I(){return Uc=((Wc()-Pe)/10|0)+2}function L(a){if(0!==Tb){if(a>Tb)return;Jg(Xc)}var b=Wc()-Pe;Tb=a;Xc=Kg(J,{timeout:10*(a-2)-b})}function N(){var a=0,b=null;if(null!==O)for(var c=O,d=sa;null!==d;){var e=d.remainingExpirationTime;if(0===e){null===c||null===O?E("244"):void 0;if(d===d.nextScheduledRoot){sa=O=d.nextScheduledRoot=null;break}else if(d===sa)sa=e=d.nextScheduledRoot,
O.nextScheduledRoot=e,d.nextScheduledRoot=null;else if(d===O){O=c;O.nextScheduledRoot=sa;d.nextScheduledRoot=null;break}else c.nextScheduledRoot=d.nextScheduledRoot,d.nextScheduledRoot=null;d=c.nextScheduledRoot}else{if(0===a||e<a)a=e,b=d;if(d===O)break;c=d;d=d.nextScheduledRoot}}c=ma;null!==c&&c===b?Rb++:Rb=0;ma=b;na=a}function J(a){w(0,a)}function w(a,b){fb=b;for(N();null!==ma&&0!==na&&(0===a||na<=a)&&!Yc;)m(ma,na),N();null!==fb&&(Tb=0,Xc=-1);0!==na&&L(na);fb=null;Yc=!1;Rb=0;if(Ub)throw a=Zc,Zc=
null,Ub=!1,a;}function m(a,c){Fa?E("245"):void 0;Fa=!0;if(c<=I()){var d=a.finishedWork;null!==d?(a.finishedWork=null,a.remainingExpirationTime=b(d)):(a.finishedWork=null,d=g(a,c),null!==d&&(a.remainingExpirationTime=b(d)))}else d=a.finishedWork,null!==d?(a.finishedWork=null,a.remainingExpirationTime=b(d)):(a.finishedWork=null,d=g(a,c),null!==d&&(A()?a.finishedWork=d:a.remainingExpirationTime=b(d)));Fa=!1}function A(){return null===fb||fb.timeRemaining()>Lg?!1:Yc=!0}function Ob(a){null===ma?E("246"):
void 0;ma.remainingExpirationTime=0;Ub||(Ub=!0,Zc=a)}var r=hf(a),n=jf(a),p=r.popHostContainer,qg=r.popHostContext,x=r.resetHostContainer,Me=df(a,r,n,u,y),rg=Me.beginWork,Gg=Me.beginFailedWork,Fg=ef(a,r,n).completeWork;r=ff(a,h);var zg=r.commitResetTextContent,Ne=r.commitPlacement,Bg=r.commitDeletion,Oe=r.commitWork,Dg=r.commitLifeCycles,Eg=r.commitAttachRef,Ag=r.commitDetachRef,Wc=a.now,Kg=a.scheduleDeferredCallback,Jg=a.cancelDeferredCallback,Hg=a.useSyncScheduling,yg=a.prepareForCommit,Cg=a.resetAfterCommit,
Pe=Wc(),Uc=2,ka=0,ja=!1,F=null,ra=null,H=0,t=null,R=null,qa=null,ha=null,ca=null,eb=!1,Qb=!1,Sc=!1,sa=null,O=null,Tb=0,Xc=-1,Fa=!1,ma=null,na=0,Yc=!1,Ub=!1,Zc=null,fb=null,la=!1,Sb=!1,Ig=1E3,Rb=0,Lg=1;return{computeAsyncExpiration:v,computeExpirationForFiber:y,scheduleWork:u,batchedUpdates:function(a,b){var c=la;la=!0;try{return a(b)}finally{(la=c)||Fa||w(1,null)}},unbatchedUpdates:function(a){if(la&&!Sb){Sb=!0;try{return a()}finally{Sb=!1}}return a()},flushSync:function(a){var b=la;la=!0;try{a:{var c=
ka;ka=1;try{var d=a();break a}finally{ka=c}d=void 0}return d}finally{la=b,Fa?E("187"):void 0,w(1,null)}},deferredUpdates:function(a){var b=ka;ka=v();try{return a()}finally{ka=b}}}}
function lf(a){function b(a){a=od(a);return null===a?null:a.stateNode}var c=a.getPublicInstance;a=kf(a);var d=a.computeAsyncExpiration,e=a.computeExpirationForFiber,f=a.scheduleWork;return{createContainer:function(a,b){var c=new Y(3,null,0);a={current:c,containerInfo:a,pendingChildren:null,remainingExpirationTime:0,isReadyForCommit:!1,finishedWork:null,context:null,pendingContext:null,hydrate:b,nextScheduledRoot:null};return c.stateNode=a},updateContainer:function(a,b,c,q){var g=b.current;if(c){c=
c._reactInternalFiber;var h;b:{2===kd(c)&&2===c.tag?void 0:E("170");for(h=c;3!==h.tag;){if(le(h)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}(h=h["return"])?void 0:E("171")}h=h.stateNode.context}c=le(c)?pe(c,h):h}else c=D;null===b.context?b.context=c:b.pendingContext=c;b=q;b=void 0===b?null:b;q=null!=a&&null!=a.type&&null!=a.type.prototype&&!0===a.type.prototype.unstable_isAsyncReactComponent?d():e(g);He(g,{expirationTime:q,partialState:{element:a},callback:b,isReplace:!1,isForced:!1,
nextCallback:null,next:null});f(g,q)},batchedUpdates:a.batchedUpdates,unbatchedUpdates:a.unbatchedUpdates,deferredUpdates:a.deferredUpdates,flushSync:a.flushSync,getPublicRootInstance:function(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return c(a.child.stateNode);default:return a.child.stateNode}},findHostInstance:b,findHostInstanceWithNoPortals:function(a){a=pd(a);return null===a?null:a.stateNode},injectIntoDevTools:function(a){var c=a.findFiberByHostInstance;return Ce(B({},
a,{findHostInstanceByFiber:function(a){return b(a)},findFiberByHostInstance:function(a){return c?c(a):null}}))}}}var mf=Object.freeze({default:lf}),nf=mf&&lf||mf,of=nf["default"]?nf["default"]:nf;function pf(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:Ue,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}var qf="object"===typeof performance&&"function"===typeof performance.now,rf=void 0;rf=qf?function(){return performance.now()}:function(){return Date.now()};
var sf=void 0,tf=void 0;
if(l.canUseDOM)if("function"!==typeof requestIdleCallback||"function"!==typeof cancelIdleCallback){var uf=null,vf=!1,wf=-1,xf=!1,yf=0,zf=33,Af=33,Bf;Bf=qf?{didTimeout:!1,timeRemaining:function(){var a=yf-performance.now();return 0<a?a:0}}:{didTimeout:!1,timeRemaining:function(){var a=yf-Date.now();return 0<a?a:0}};var Cf="__reactIdleCallback$"+Math.random().toString(36).slice(2);window.addEventListener("message",function(a){if(a.source===window&&a.data===Cf){vf=!1;a=rf();if(0>=yf-a)if(-1!==wf&&wf<=
a)Bf.didTimeout=!0;else{xf||(xf=!0,requestAnimationFrame(Df));return}else Bf.didTimeout=!1;wf=-1;a=uf;uf=null;null!==a&&a(Bf)}},!1);var Df=function(a){xf=!1;var b=a-yf+Af;b<Af&&zf<Af?(8>b&&(b=8),Af=b<zf?zf:b):zf=b;yf=a+Af;vf||(vf=!0,window.postMessage(Cf,"*"))};sf=function(a,b){uf=a;null!=b&&"number"===typeof b.timeout&&(wf=rf()+b.timeout);xf||(xf=!0,requestAnimationFrame(Df));return 0};tf=function(){uf=null;vf=!1;wf=-1}}else sf=window.requestIdleCallback,tf=window.cancelIdleCallback;else sf=function(a){return setTimeout(function(){a({timeRemaining:function(){return Infinity}})})},
tf=function(a){clearTimeout(a)};var Ef=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Ff={},Gf={};
function Hf(a){if(Gf.hasOwnProperty(a))return!0;if(Ff.hasOwnProperty(a))return!1;if(Ef.test(a))return Gf[a]=!0;Ff[a]=!0;return!1}
function If(a,b,c){var d=wa(b);if(d&&va(b,c)){var e=d.mutationMethod;e?e(a,c):null==c||d.hasBooleanValue&&!c||d.hasNumericValue&&isNaN(c)||d.hasPositiveNumericValue&&1>c||d.hasOverloadedBooleanValue&&!1===c?Jf(a,b):d.mustUseProperty?a[d.propertyName]=c:(b=d.attributeName,(e=d.attributeNamespace)?a.setAttributeNS(e,b,""+c):d.hasBooleanValue||d.hasOverloadedBooleanValue&&!0===c?a.setAttribute(b,""):a.setAttribute(b,""+c))}else Kf(a,b,va(b,c)?c:null)}
function Kf(a,b,c){Hf(b)&&(null==c?a.removeAttribute(b):a.setAttribute(b,""+c))}function Jf(a,b){var c=wa(b);c?(b=c.mutationMethod)?b(a,void 0):c.mustUseProperty?a[c.propertyName]=c.hasBooleanValue?!1:"":a.removeAttribute(c.attributeName):a.removeAttribute(b)}
function Lf(a,b){var c=b.value,d=b.checked;return B({type:void 0,step:void 0,min:void 0,max:void 0},b,{defaultChecked:void 0,defaultValue:void 0,value:null!=c?c:a._wrapperState.initialValue,checked:null!=d?d:a._wrapperState.initialChecked})}function Mf(a,b){var c=b.defaultValue;a._wrapperState={initialChecked:null!=b.checked?b.checked:b.defaultChecked,initialValue:null!=b.value?b.value:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}
function Nf(a,b){b=b.checked;null!=b&&If(a,"checked",b)}function Of(a,b){Nf(a,b);var c=b.value;if(null!=c)if(0===c&&""===a.value)a.value="0";else if("number"===b.type){if(b=parseFloat(a.value)||0,c!=b||c==b&&a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else null==b.value&&null!=b.defaultValue&&a.defaultValue!==""+b.defaultValue&&(a.defaultValue=""+b.defaultValue),null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}
function Pf(a,b){switch(b.type){case "submit":case "reset":break;case "color":case "date":case "datetime":case "datetime-local":case "month":case "time":case "week":a.value="";a.value=a.defaultValue;break;default:a.value=a.value}b=a.name;""!==b&&(a.name="");a.defaultChecked=!a.defaultChecked;a.defaultChecked=!a.defaultChecked;""!==b&&(a.name=b)}function Qf(a){var b="";aa.Children.forEach(a,function(a){null==a||"string"!==typeof a&&"number"!==typeof a||(b+=a)});return b}
function Rf(a,b){a=B({children:void 0},b);if(b=Qf(b.children))a.children=b;return a}function Sf(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+c;b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}
function Tf(a,b){var c=b.value;a._wrapperState={initialValue:null!=c?c:b.defaultValue,wasMultiple:!!b.multiple}}function Uf(a,b){null!=b.dangerouslySetInnerHTML?E("91"):void 0;return B({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function Vf(a,b){var c=b.value;null==c&&(c=b.defaultValue,b=b.children,null!=b&&(null!=c?E("92"):void 0,Array.isArray(b)&&(1>=b.length?void 0:E("93"),b=b[0]),c=""+b),null==c&&(c=""));a._wrapperState={initialValue:""+c}}
function Wf(a,b){var c=b.value;null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&(a.defaultValue=c));null!=b.defaultValue&&(a.defaultValue=b.defaultValue)}function Xf(a){var b=a.textContent;b===a._wrapperState.initialValue&&(a.value=b)}var Yf={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};
function Zf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function $f(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Zf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
var ag=void 0,bg=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(a.namespaceURI!==Yf.svg||"innerHTML"in a)a.innerHTML=b;else{ag=ag||document.createElement("div");ag.innerHTML="\x3csvg\x3e"+b+"\x3c/svg\x3e";for(b=ag.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});
function cg(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}
var dg={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,
stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},eg=["Webkit","ms","Moz","O"];Object.keys(dg).forEach(function(a){eg.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);dg[b]=dg[a]})});
function fg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--");var e=c;var f=b[c];e=null==f||"boolean"===typeof f||""===f?"":d||"number"!==typeof f||0===f||dg.hasOwnProperty(e)&&dg[e]?(""+f).trim():f+"px";"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var gg=B({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
function hg(a,b,c){b&&(gg[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML?E("137",a,c()):void 0),null!=b.dangerouslySetInnerHTML&&(null!=b.children?E("60"):void 0,"object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML?void 0:E("61")),null!=b.style&&"object"!==typeof b.style?E("62",c()):void 0)}
function ig(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}var jg=Yf.html,kg=C.thatReturns("");
function lg(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Hd(a);b=Sa[b];for(var d=0;d<b.length;d++){var e=b[d];c.hasOwnProperty(e)&&c[e]||("topScroll"===e?wd("topScroll","scroll",a):"topFocus"===e||"topBlur"===e?(wd("topFocus","focus",a),wd("topBlur","blur",a),c.topBlur=!0,c.topFocus=!0):"topCancel"===e?(yc("cancel",!0)&&wd("topCancel","cancel",a),c.topCancel=!0):"topClose"===e?(yc("close",!0)&&wd("topClose","close",a),c.topClose=!0):Dd.hasOwnProperty(e)&&U(e,Dd[e],a),c[e]=!0)}}
var mg={topAbort:"abort",topCanPlay:"canplay",topCanPlayThrough:"canplaythrough",topDurationChange:"durationchange",topEmptied:"emptied",topEncrypted:"encrypted",topEnded:"ended",topError:"error",topLoadedData:"loadeddata",topLoadedMetadata:"loadedmetadata",topLoadStart:"loadstart",topPause:"pause",topPlay:"play",topPlaying:"playing",topProgress:"progress",topRateChange:"ratechange",topSeeked:"seeked",topSeeking:"seeking",topStalled:"stalled",topSuspend:"suspend",topTimeUpdate:"timeupdate",topVolumeChange:"volumechange",
topWaiting:"waiting"};function ng(a,b,c,d){c=9===c.nodeType?c:c.ownerDocument;d===jg&&(d=Zf(a));d===jg?"script"===a?(a=c.createElement("div"),a.innerHTML="\x3cscript\x3e\x3c/script\x3e",a=a.removeChild(a.firstChild)):a="string"===typeof b.is?c.createElement(a,{is:b.is}):c.createElement(a):a=c.createElementNS(d,a);return a}function og(a,b){return(9===b.nodeType?b:b.ownerDocument).createTextNode(a)}
function pg(a,b,c,d){var e=ig(b,c);switch(b){case "iframe":case "object":U("topLoad","load",a);var f=c;break;case "video":case "audio":for(f in mg)mg.hasOwnProperty(f)&&U(f,mg[f],a);f=c;break;case "source":U("topError","error",a);f=c;break;case "img":case "image":U("topError","error",a);U("topLoad","load",a);f=c;break;case "form":U("topReset","reset",a);U("topSubmit","submit",a);f=c;break;case "details":U("topToggle","toggle",a);f=c;break;case "input":Mf(a,c);f=Lf(a,c);U("topInvalid","invalid",a);
lg(d,"onChange");break;case "option":f=Rf(a,c);break;case "select":Tf(a,c);f=B({},c,{value:void 0});U("topInvalid","invalid",a);lg(d,"onChange");break;case "textarea":Vf(a,c);f=Uf(a,c);U("topInvalid","invalid",a);lg(d,"onChange");break;default:f=c}hg(b,f,kg);var g=f,h;for(h in g)if(g.hasOwnProperty(h)){var k=g[h];"style"===h?fg(a,k,kg):"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,null!=k&&bg(a,k)):"children"===h?"string"===typeof k?("textarea"!==b||""!==k)&&cg(a,k):"number"===typeof k&&cg(a,
""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(Ra.hasOwnProperty(h)?null!=k&&lg(d,h):e?Kf(a,h,k):null!=k&&If(a,h,k))}switch(b){case "input":Bc(a);Pf(a,c);break;case "textarea":Bc(a);Xf(a,c);break;case "option":null!=c.value&&a.setAttribute("value",c.value);break;case "select":a.multiple=!!c.multiple;b=c.value;null!=b?Sf(a,!!c.multiple,b,!1):null!=c.defaultValue&&Sf(a,!!c.multiple,c.defaultValue,!0);break;default:"function"===typeof f.onClick&&(a.onclick=
C)}}
function sg(a,b,c,d,e){var f=null;switch(b){case "input":c=Lf(a,c);d=Lf(a,d);f=[];break;case "option":c=Rf(a,c);d=Rf(a,d);f=[];break;case "select":c=B({},c,{value:void 0});d=B({},d,{value:void 0});f=[];break;case "textarea":c=Uf(a,c);d=Uf(a,d);f=[];break;default:"function"!==typeof c.onClick&&"function"===typeof d.onClick&&(a.onclick=C)}hg(b,d,kg);var g,h;a=null;for(g in c)if(!d.hasOwnProperty(g)&&c.hasOwnProperty(g)&&null!=c[g])if("style"===g)for(h in b=c[g],b)b.hasOwnProperty(h)&&(a||(a={}),a[h]=
"");else"dangerouslySetInnerHTML"!==g&&"children"!==g&&"suppressContentEditableWarning"!==g&&"suppressHydrationWarning"!==g&&"autoFocus"!==g&&(Ra.hasOwnProperty(g)?f||(f=[]):(f=f||[]).push(g,null));for(g in d){var k=d[g];b=null!=c?c[g]:void 0;if(d.hasOwnProperty(g)&&k!==b&&(null!=k||null!=b))if("style"===g)if(b){for(h in b)!b.hasOwnProperty(h)||k&&k.hasOwnProperty(h)||(a||(a={}),a[h]="");for(h in k)k.hasOwnProperty(h)&&b[h]!==k[h]&&(a||(a={}),a[h]=k[h])}else a||(f||(f=[]),f.push(g,a)),a=k;else"dangerouslySetInnerHTML"===
g?(k=k?k.__html:void 0,b=b?b.__html:void 0,null!=k&&b!==k&&(f=f||[]).push(g,""+k)):"children"===g?b===k||"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(g,""+k):"suppressContentEditableWarning"!==g&&"suppressHydrationWarning"!==g&&(Ra.hasOwnProperty(g)?(null!=k&&lg(e,g),f||b===k||(f=[])):(f=f||[]).push(g,k))}a&&(f=f||[]).push("style",a);return f}
function tg(a,b,c,d,e){"input"===c&&"radio"===e.type&&null!=e.name&&Nf(a,e);ig(c,d);d=ig(c,e);for(var f=0;f<b.length;f+=2){var g=b[f],h=b[f+1];"style"===g?fg(a,h,kg):"dangerouslySetInnerHTML"===g?bg(a,h):"children"===g?cg(a,h):d?null!=h?Kf(a,g,h):a.removeAttribute(g):null!=h?If(a,g,h):Jf(a,g)}switch(c){case "input":Of(a,e);break;case "textarea":Wf(a,e);break;case "select":a._wrapperState.initialValue=void 0,b=a._wrapperState.wasMultiple,a._wrapperState.wasMultiple=!!e.multiple,c=e.value,null!=c?Sf(a,
!!e.multiple,c,!1):b!==!!e.multiple&&(null!=e.defaultValue?Sf(a,!!e.multiple,e.defaultValue,!0):Sf(a,!!e.multiple,e.multiple?[]:"",!1))}}
function ug(a,b,c,d,e){switch(b){case "iframe":case "object":U("topLoad","load",a);break;case "video":case "audio":for(var f in mg)mg.hasOwnProperty(f)&&U(f,mg[f],a);break;case "source":U("topError","error",a);break;case "img":case "image":U("topError","error",a);U("topLoad","load",a);break;case "form":U("topReset","reset",a);U("topSubmit","submit",a);break;case "details":U("topToggle","toggle",a);break;case "input":Mf(a,c);U("topInvalid","invalid",a);lg(e,"onChange");break;case "select":Tf(a,c);
U("topInvalid","invalid",a);lg(e,"onChange");break;case "textarea":Vf(a,c),U("topInvalid","invalid",a),lg(e,"onChange")}hg(b,c,kg);d=null;for(var g in c)c.hasOwnProperty(g)&&(f=c[g],"children"===g?"string"===typeof f?a.textContent!==f&&(d=["children",f]):"number"===typeof f&&a.textContent!==""+f&&(d=["children",""+f]):Ra.hasOwnProperty(g)&&null!=f&&lg(e,g));switch(b){case "input":Bc(a);Pf(a,c);break;case "textarea":Bc(a);Xf(a,c);break;case "select":case "option":break;default:"function"===typeof c.onClick&&
(a.onclick=C)}return d}function vg(a,b){return a.nodeValue!==b}
var wg=Object.freeze({createElement:ng,createTextNode:og,setInitialProperties:pg,diffProperties:sg,updateProperties:tg,diffHydratedProperties:ug,diffHydratedText:vg,warnForUnmatchedText:function(){},warnForDeletedHydratableElement:function(){},warnForDeletedHydratableText:function(){},warnForInsertedHydratedElement:function(){},warnForInsertedHydratedText:function(){},restoreControlledState:function(a,b,c){switch(b){case "input":Of(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=
c.parentNode;c=c.querySelectorAll("input[name\x3d"+JSON.stringify(""+b)+'][type\x3d"radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=rb(d);e?void 0:E("90");Cc(d);Of(d,e)}}}break;case "textarea":Wf(a,c);break;case "select":b=c.value,null!=b&&Sf(a,!!c.multiple,b,!1)}}});nc.injectFiberControlledHostComponent(wg);var xg=null,Mg=null;function Ng(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}
function Og(a){a=a?9===a.nodeType?a.documentElement:a.firstChild:null;return!(!a||1!==a.nodeType||!a.hasAttribute("data-reactroot"))}
var Z=of({getRootHostContext:function(a){var b=a.nodeType;switch(b){case 9:case 11:a=(a=a.documentElement)?a.namespaceURI:$f(null,"");break;default:b=8===b?a.parentNode:a,a=b.namespaceURI||null,b=b.tagName,a=$f(a,b)}return a},getChildHostContext:function(a,b){return $f(a,b)},getPublicInstance:function(a){return a},prepareForCommit:function(){xg=td;var a=da();if(Kd(a)){if("selectionStart"in a)var b={start:a.selectionStart,end:a.selectionEnd};else a:{var c=window.getSelection&&window.getSelection();
if(c&&0!==c.rangeCount){b=c.anchorNode;var d=c.anchorOffset,e=c.focusNode;c=c.focusOffset;try{b.nodeType,e.nodeType}catch(z){b=null;break a}var f=0,g=-1,h=-1,k=0,q=0,v=a,y=null;b:for(;;){for(var u;;){v!==b||0!==d&&3!==v.nodeType||(g=f+d);v!==e||0!==c&&3!==v.nodeType||(h=f+c);3===v.nodeType&&(f+=v.nodeValue.length);if(null===(u=v.firstChild))break;y=v;v=u}for(;;){if(v===a)break b;y===b&&++k===d&&(g=f);y===e&&++q===c&&(h=f);if(null!==(u=v.nextSibling))break;v=y;y=v.parentNode}v=u}b=-1===g||-1===h?null:
{start:g,end:h}}else b=null}b=b||{start:0,end:0}}else b=null;Mg={focusedElem:a,selectionRange:b};ud(!1)},resetAfterCommit:function(){var a=Mg,b=da(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&fa(document.documentElement,c)){if(Kd(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(window.getSelection){b=window.getSelection();var e=c[Eb()].length;a=Math.min(d.start,e);d=void 0===d.end?a:Math.min(d.end,e);!b.extend&&a>
d&&(e=d,d=a,a=e);e=Jd(c,a);var f=Jd(c,d);if(e&&f&&(1!==b.rangeCount||b.anchorNode!==e.node||b.anchorOffset!==e.offset||b.focusNode!==f.node||b.focusOffset!==f.offset)){var g=document.createRange();g.setStart(e.node,e.offset);b.removeAllRanges();a>d?(b.addRange(g),b.extend(f.node,f.offset)):(g.setEnd(f.node,f.offset),b.addRange(g))}}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});ia(c);for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=
a.top}Mg=null;ud(xg);xg=null},createInstance:function(a,b,c,d,e){a=ng(a,b,c,d);a[Q]=e;a[ob]=b;return a},appendInitialChild:function(a,b){a.appendChild(b)},finalizeInitialChildren:function(a,b,c,d){pg(a,b,c,d);a:{switch(b){case "button":case "input":case "select":case "textarea":a=!!c.autoFocus;break a}a=!1}return a},prepareUpdate:function(a,b,c,d,e){return sg(a,b,c,d,e)},shouldSetTextContent:function(a,b){return"textarea"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===
typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&"string"===typeof b.dangerouslySetInnerHTML.__html},shouldDeprioritizeSubtree:function(a,b){return!!b.hidden},createTextInstance:function(a,b,c,d){a=og(a,b);a[Q]=d;return a},now:rf,mutation:{commitMount:function(a){a.focus()},commitUpdate:function(a,b,c,d,e){a[ob]=e;tg(a,b,c,d,e)},resetTextContent:function(a){a.textContent=""},commitTextUpdate:function(a,b,c){a.nodeValue=c},appendChild:function(a,b){a.appendChild(b)},appendChildToContainer:function(a,
b){8===a.nodeType?a.parentNode.insertBefore(b,a):a.appendChild(b)},insertBefore:function(a,b,c){a.insertBefore(b,c)},insertInContainerBefore:function(a,b,c){8===a.nodeType?a.parentNode.insertBefore(b,c):a.insertBefore(b,c)},removeChild:function(a,b){a.removeChild(b)},removeChildFromContainer:function(a,b){8===a.nodeType?a.parentNode.removeChild(b):a.removeChild(b)}},hydration:{canHydrateInstance:function(a,b){return 1!==a.nodeType||b.toLowerCase()!==a.nodeName.toLowerCase()?null:a},canHydrateTextInstance:function(a,
b){return""===b||3!==a.nodeType?null:a},getNextHydratableSibling:function(a){for(a=a.nextSibling;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a},getFirstHydratableChild:function(a){for(a=a.firstChild;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a},hydrateInstance:function(a,b,c,d,e,f){a[Q]=f;a[ob]=c;return ug(a,b,c,e,d)},hydrateTextInstance:function(a,b,c){a[Q]=c;return vg(a,b)},didNotMatchHydratedContainerTextInstance:function(){},didNotMatchHydratedTextInstance:function(){},
didNotHydrateContainerInstance:function(){},didNotHydrateInstance:function(){},didNotFindHydratableContainerInstance:function(){},didNotFindHydratableContainerTextInstance:function(){},didNotFindHydratableInstance:function(){},didNotFindHydratableTextInstance:function(){}},scheduleDeferredCallback:sf,cancelDeferredCallback:tf,useSyncScheduling:!0});rc=Z.batchedUpdates;
function Pg(a,b,c,d,e){Ng(c)?void 0:E("200");var f=c._reactRootContainer;if(f)Z.updateContainer(b,f,a,e);else{d=d||Og(c);if(!d)for(f=void 0;f=c.lastChild;)c.removeChild(f);var g=Z.createContainer(c,d);f=c._reactRootContainer=g;Z.unbatchedUpdates(function(){Z.updateContainer(b,g,a,e)})}return Z.getPublicRootInstance(f)}function Qg(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;Ng(b)?void 0:E("200");return pf(a,b,null,c)}
function Rg(a,b){this._reactRootContainer=Z.createContainer(a,b)}Rg.prototype.render=function(a,b){Z.updateContainer(a,this._reactRootContainer,null,b)};Rg.prototype.unmount=function(a){Z.updateContainer(null,this._reactRootContainer,null,a)};
var Sg={createPortal:Qg,findDOMNode:function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(b)return Z.findHostInstance(b);"function"===typeof a.render?E("188"):E("213",Object.keys(a))},hydrate:function(a,b,c){return Pg(null,a,b,!0,c)},render:function(a,b,c){return Pg(null,a,b,!1,c)},unstable_renderSubtreeIntoContainer:function(a,b,c,d){null==a||void 0===a._reactInternalFiber?E("38"):void 0;return Pg(a,b,c,!1,d)},unmountComponentAtNode:function(a){Ng(a)?void 0:
E("40");return a._reactRootContainer?(Z.unbatchedUpdates(function(){Pg(null,null,a,!1,function(){a._reactRootContainer=null})}),!0):!1},unstable_createPortal:Qg,unstable_batchedUpdates:tc,unstable_deferredUpdates:Z.deferredUpdates,flushSync:Z.flushSync,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{EventPluginHub:mb,EventPluginRegistry:Va,EventPropagators:Cb,ReactControlledComponent:qc,ReactDOMComponentTree:sb,ReactDOMEventListener:xd}};
Z.injectIntoDevTools({findFiberByHostInstance:pb,bundleType:0,version:"16.2.0",rendererPackageName:"react-dom"});var Tg=Object.freeze({default:Sg}),Ug=Tg&&Sg||Tg;module.exports=Ug["default"]?Ug["default"]:Ug;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(0), __webpack_require__(135));
	else if(typeof define === 'function' && define.amd)
		define(["react", "highcharts/highstock"], factory);
	else if(typeof exports === 'object')
		exports["ReactHighstock"] = factory(require("react"), require("highcharts/highstock"));
	else
		root["ReactHighstock"] = factory(root["React"], root["Highcharts"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_23__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 25);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(2);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_5__;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var _assign = __webpack_require__(6);

var emptyObject = __webpack_require__(9);
var _invariant = __webpack_require__(1);

if (process.env.NODE_ENV !== 'production') {
  var warning = __webpack_require__(3);
}

var MIXINS_KEY = 'mixins';

// Helper function to allow the creation of anonymous functions which do not
// have .name set to the name of the variable being assigned to.
function identity(fn) {
  return fn;
}

var ReactPropTypeLocationNames;
if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
} else {
  ReactPropTypeLocationNames = {};
}

function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
  /**
   * Policies that describe methods in `ReactClassInterface`.
   */

  var injectedMixins = [];

  /**
   * Composite components are higher-level components that compose other composite
   * or host components.
   *
   * To create a new type of `ReactClass`, pass a specification of
   * your new class to `React.createClass`. The only requirement of your class
   * specification is that you implement a `render` method.
   *
   *   var MyComponent = React.createClass({
   *     render: function() {
   *       return <div>Hello World</div>;
   *     }
   *   });
   *
   * The class specification supports a specific protocol of methods that have
   * special meaning (e.g. `render`). See `ReactClassInterface` for
   * more the comprehensive protocol. Any other properties and methods in the
   * class specification will be available on the prototype.
   *
   * @interface ReactClassInterface
   * @internal
   */
  var ReactClassInterface = {
    /**
     * An array of Mixin objects to include when defining your component.
     *
     * @type {array}
     * @optional
     */
    mixins: 'DEFINE_MANY',

    /**
     * An object containing properties and methods that should be defined on
     * the component's constructor instead of its prototype (static methods).
     *
     * @type {object}
     * @optional
     */
    statics: 'DEFINE_MANY',

    /**
     * Definition of prop types for this component.
     *
     * @type {object}
     * @optional
     */
    propTypes: 'DEFINE_MANY',

    /**
     * Definition of context types for this component.
     *
     * @type {object}
     * @optional
     */
    contextTypes: 'DEFINE_MANY',

    /**
     * Definition of context types this component sets for its children.
     *
     * @type {object}
     * @optional
     */
    childContextTypes: 'DEFINE_MANY',

    // ==== Definition methods ====

    /**
     * Invoked when the component is mounted. Values in the mapping will be set on
     * `this.props` if that prop is not specified (i.e. using an `in` check).
     *
     * This method is invoked before `getInitialState` and therefore cannot rely
     * on `this.state` or use `this.setState`.
     *
     * @return {object}
     * @optional
     */
    getDefaultProps: 'DEFINE_MANY_MERGED',

    /**
     * Invoked once before the component is mounted. The return value will be used
     * as the initial value of `this.state`.
     *
     *   getInitialState: function() {
     *     return {
     *       isOn: false,
     *       fooBaz: new BazFoo()
     *     }
     *   }
     *
     * @return {object}
     * @optional
     */
    getInitialState: 'DEFINE_MANY_MERGED',

    /**
     * @return {object}
     * @optional
     */
    getChildContext: 'DEFINE_MANY_MERGED',

    /**
     * Uses props from `this.props` and state from `this.state` to render the
     * structure of the component.
     *
     * No guarantees are made about when or how often this method is invoked, so
     * it must not have side effects.
     *
     *   render: function() {
     *     var name = this.props.name;
     *     return <div>Hello, {name}!</div>;
     *   }
     *
     * @return {ReactComponent}
     * @required
     */
    render: 'DEFINE_ONCE',

    // ==== Delegate methods ====

    /**
     * Invoked when the component is initially created and about to be mounted.
     * This may have side effects, but any external subscriptions or data created
     * by this method must be cleaned up in `componentWillUnmount`.
     *
     * @optional
     */
    componentWillMount: 'DEFINE_MANY',

    /**
     * Invoked when the component has been mounted and has a DOM representation.
     * However, there is no guarantee that the DOM node is in the document.
     *
     * Use this as an opportunity to operate on the DOM when the component has
     * been mounted (initialized and rendered) for the first time.
     *
     * @param {DOMElement} rootNode DOM element representing the component.
     * @optional
     */
    componentDidMount: 'DEFINE_MANY',

    /**
     * Invoked before the component receives new props.
     *
     * Use this as an opportunity to react to a prop transition by updating the
     * state using `this.setState`. Current props are accessed via `this.props`.
     *
     *   componentWillReceiveProps: function(nextProps, nextContext) {
     *     this.setState({
     *       likesIncreasing: nextProps.likeCount > this.props.likeCount
     *     });
     *   }
     *
     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
     * transition may cause a state change, but the opposite is not true. If you
     * need it, you are probably looking for `componentWillUpdate`.
     *
     * @param {object} nextProps
     * @optional
     */
    componentWillReceiveProps: 'DEFINE_MANY',

    /**
     * Invoked while deciding if the component should be updated as a result of
     * receiving new props, state and/or context.
     *
     * Use this as an opportunity to `return false` when you're certain that the
     * transition to the new props/state/context will not require a component
     * update.
     *
     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
     *     return !equal(nextProps, this.props) ||
     *       !equal(nextState, this.state) ||
     *       !equal(nextContext, this.context);
     *   }
     *
     * @param {object} nextProps
     * @param {?object} nextState
     * @param {?object} nextContext
     * @return {boolean} True if the component should update.
     * @optional
     */
    shouldComponentUpdate: 'DEFINE_ONCE',

    /**
     * Invoked when the component is about to update due to a transition from
     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
     * and `nextContext`.
     *
     * Use this as an opportunity to perform preparation before an update occurs.
     *
     * NOTE: You **cannot** use `this.setState()` in this method.
     *
     * @param {object} nextProps
     * @param {?object} nextState
     * @param {?object} nextContext
     * @param {ReactReconcileTransaction} transaction
     * @optional
     */
    componentWillUpdate: 'DEFINE_MANY',

    /**
     * Invoked when the component's DOM representation has been updated.
     *
     * Use this as an opportunity to operate on the DOM when the component has
     * been updated.
     *
     * @param {object} prevProps
     * @param {?object} prevState
     * @param {?object} prevContext
     * @param {DOMElement} rootNode DOM element representing the component.
     * @optional
     */
    componentDidUpdate: 'DEFINE_MANY',

    /**
     * Invoked when the component is about to be removed from its parent and have
     * its DOM representation destroyed.
     *
     * Use this as an opportunity to deallocate any external resources.
     *
     * NOTE: There is no `componentDidUnmount` since your component will have been
     * destroyed by that point.
     *
     * @optional
     */
    componentWillUnmount: 'DEFINE_MANY',

    // ==== Advanced methods ====

    /**
     * Updates the component's currently mounted DOM representation.
     *
     * By default, this implements React's rendering and reconciliation algorithm.
     * Sophisticated clients may wish to override this.
     *
     * @param {ReactReconcileTransaction} transaction
     * @internal
     * @overridable
     */
    updateComponent: 'OVERRIDE_BASE'
  };

  /**
   * Mapping from class specification keys to special processing functions.
   *
   * Although these are declared like instance properties in the specification
   * when defining classes using `React.createClass`, they are actually static
   * and are accessible on the constructor instead of the prototype. Despite
   * being static, they must be defined outside of the "statics" key under
   * which all other static methods are defined.
   */
  var RESERVED_SPEC_KEYS = {
    displayName: function(Constructor, displayName) {
      Constructor.displayName = displayName;
    },
    mixins: function(Constructor, mixins) {
      if (mixins) {
        for (var i = 0; i < mixins.length; i++) {
          mixSpecIntoComponent(Constructor, mixins[i]);
        }
      }
    },
    childContextTypes: function(Constructor, childContextTypes) {
      if (process.env.NODE_ENV !== 'production') {
        validateTypeDef(Constructor, childContextTypes, 'childContext');
      }
      Constructor.childContextTypes = _assign(
        {},
        Constructor.childContextTypes,
        childContextTypes
      );
    },
    contextTypes: function(Constructor, contextTypes) {
      if (process.env.NODE_ENV !== 'production') {
        validateTypeDef(Constructor, contextTypes, 'context');
      }
      Constructor.contextTypes = _assign(
        {},
        Constructor.contextTypes,
        contextTypes
      );
    },
    /**
     * Special case getDefaultProps which should move into statics but requires
     * automatic merging.
     */
    getDefaultProps: function(Constructor, getDefaultProps) {
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps = createMergedResultFunction(
          Constructor.getDefaultProps,
          getDefaultProps
        );
      } else {
        Constructor.getDefaultProps = getDefaultProps;
      }
    },
    propTypes: function(Constructor, propTypes) {
      if (process.env.NODE_ENV !== 'production') {
        validateTypeDef(Constructor, propTypes, 'prop');
      }
      Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
    },
    statics: function(Constructor, statics) {
      mixStaticSpecIntoComponent(Constructor, statics);
    },
    autobind: function() {}
  };

  function validateTypeDef(Constructor, typeDef, location) {
    for (var propName in typeDef) {
      if (typeDef.hasOwnProperty(propName)) {
        // use a warning instead of an _invariant so components
        // don't show up in prod but only in __DEV__
        if (process.env.NODE_ENV !== 'production') {
          warning(
            typeof typeDef[propName] === 'function',
            '%s: %s type `%s` is invalid; it must be a function, usually from ' +
              'React.PropTypes.',
            Constructor.displayName || 'ReactClass',
            ReactPropTypeLocationNames[location],
            propName
          );
        }
      }
    }
  }

  function validateMethodOverride(isAlreadyDefined, name) {
    var specPolicy = ReactClassInterface.hasOwnProperty(name)
      ? ReactClassInterface[name]
      : null;

    // Disallow overriding of base class methods unless explicitly allowed.
    if (ReactClassMixin.hasOwnProperty(name)) {
      _invariant(
        specPolicy === 'OVERRIDE_BASE',
        'ReactClassInterface: You are attempting to override ' +
          '`%s` from your class specification. Ensure that your method names ' +
          'do not overlap with React methods.',
        name
      );
    }

    // Disallow defining methods more than once unless explicitly allowed.
    if (isAlreadyDefined) {
      _invariant(
        specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED',
        'ReactClassInterface: You are attempting to define ' +
          '`%s` on your component more than once. This conflict may be due ' +
          'to a mixin.',
        name
      );
    }
  }

  /**
   * Mixin helper which handles policy validation and reserved
   * specification keys when building React classes.
   */
  function mixSpecIntoComponent(Constructor, spec) {
    if (!spec) {
      if (process.env.NODE_ENV !== 'production') {
        var typeofSpec = typeof spec;
        var isMixinValid = typeofSpec === 'object' && spec !== null;

        if (process.env.NODE_ENV !== 'production') {
          warning(
            isMixinValid,
            "%s: You're attempting to include a mixin that is either null " +
              'or not an object. Check the mixins included by the component, ' +
              'as well as any mixins they include themselves. ' +
              'Expected object but got %s.',
            Constructor.displayName || 'ReactClass',
            spec === null ? null : typeofSpec
          );
        }
      }

      return;
    }

    _invariant(
      typeof spec !== 'function',
      "ReactClass: You're attempting to " +
        'use a component class or function as a mixin. Instead, just use a ' +
        'regular object.'
    );
    _invariant(
      !isValidElement(spec),
      "ReactClass: You're attempting to " +
        'use a component as a mixin. Instead, just use a regular object.'
    );

    var proto = Constructor.prototype;
    var autoBindPairs = proto.__reactAutoBindPairs;

    // By handling mixins before any other properties, we ensure the same
    // chaining order is applied to methods with DEFINE_MANY policy, whether
    // mixins are listed before or after these methods in the spec.
    if (spec.hasOwnProperty(MIXINS_KEY)) {
      RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
    }

    for (var name in spec) {
      if (!spec.hasOwnProperty(name)) {
        continue;
      }

      if (name === MIXINS_KEY) {
        // We have already handled mixins in a special case above.
        continue;
      }

      var property = spec[name];
      var isAlreadyDefined = proto.hasOwnProperty(name);
      validateMethodOverride(isAlreadyDefined, name);

      if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
        RESERVED_SPEC_KEYS[name](Constructor, property);
      } else {
        // Setup methods on prototype:
        // The following member methods should not be automatically bound:
        // 1. Expected ReactClass methods (in the "interface").
        // 2. Overridden methods (that were mixed in).
        var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
        var isFunction = typeof property === 'function';
        var shouldAutoBind =
          isFunction &&
          !isReactClassMethod &&
          !isAlreadyDefined &&
          spec.autobind !== false;

        if (shouldAutoBind) {
          autoBindPairs.push(name, property);
          proto[name] = property;
        } else {
          if (isAlreadyDefined) {
            var specPolicy = ReactClassInterface[name];

            // These cases should already be caught by validateMethodOverride.
            _invariant(
              isReactClassMethod &&
                (specPolicy === 'DEFINE_MANY_MERGED' ||
                  specPolicy === 'DEFINE_MANY'),
              'ReactClass: Unexpected spec policy %s for key %s ' +
                'when mixing in component specs.',
              specPolicy,
              name
            );

            // For methods which are defined more than once, call the existing
            // methods before calling the new property, merging if appropriate.
            if (specPolicy === 'DEFINE_MANY_MERGED') {
              proto[name] = createMergedResultFunction(proto[name], property);
            } else if (specPolicy === 'DEFINE_MANY') {
              proto[name] = createChainedFunction(proto[name], property);
            }
          } else {
            proto[name] = property;
            if (process.env.NODE_ENV !== 'production') {
              // Add verbose displayName to the function, which helps when looking
              // at profiling tools.
              if (typeof property === 'function' && spec.displayName) {
                proto[name].displayName = spec.displayName + '_' + name;
              }
            }
          }
        }
      }
    }
  }

  function mixStaticSpecIntoComponent(Constructor, statics) {
    if (!statics) {
      return;
    }
    for (var name in statics) {
      var property = statics[name];
      if (!statics.hasOwnProperty(name)) {
        continue;
      }

      var isReserved = name in RESERVED_SPEC_KEYS;
      _invariant(
        !isReserved,
        'ReactClass: You are attempting to define a reserved ' +
          'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' +
          'as an instance property instead; it will still be accessible on the ' +
          'constructor.',
        name
      );

      var isInherited = name in Constructor;
      _invariant(
        !isInherited,
        'ReactClass: You are attempting to define ' +
          '`%s` on your component more than once. This conflict may be ' +
          'due to a mixin.',
        name
      );
      Constructor[name] = property;
    }
  }

  /**
   * Merge two objects, but throw if both contain the same key.
   *
   * @param {object} one The first object, which is mutated.
   * @param {object} two The second object
   * @return {object} one after it has been mutated to contain everything in two.
   */
  function mergeIntoWithNoDuplicateKeys(one, two) {
    _invariant(
      one && two && typeof one === 'object' && typeof two === 'object',
      'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.'
    );

    for (var key in two) {
      if (two.hasOwnProperty(key)) {
        _invariant(
          one[key] === undefined,
          'mergeIntoWithNoDuplicateKeys(): ' +
            'Tried to merge two objects with the same key: `%s`. This conflict ' +
            'may be due to a mixin; in particular, this may be caused by two ' +
            'getInitialState() or getDefaultProps() methods returning objects ' +
            'with clashing keys.',
          key
        );
        one[key] = two[key];
      }
    }
    return one;
  }

  /**
   * Creates a function that invokes two functions and merges their return values.
   *
   * @param {function} one Function to invoke first.
   * @param {function} two Function to invoke second.
   * @return {function} Function that invokes the two argument functions.
   * @private
   */
  function createMergedResultFunction(one, two) {
    return function mergedResult() {
      var a = one.apply(this, arguments);
      var b = two.apply(this, arguments);
      if (a == null) {
        return b;
      } else if (b == null) {
        return a;
      }
      var c = {};
      mergeIntoWithNoDuplicateKeys(c, a);
      mergeIntoWithNoDuplicateKeys(c, b);
      return c;
    };
  }

  /**
   * Creates a function that invokes two functions and ignores their return vales.
   *
   * @param {function} one Function to invoke first.
   * @param {function} two Function to invoke second.
   * @return {function} Function that invokes the two argument functions.
   * @private
   */
  function createChainedFunction(one, two) {
    return function chainedFunction() {
      one.apply(this, arguments);
      two.apply(this, arguments);
    };
  }

  /**
   * Binds a method to the component.
   *
   * @param {object} component Component whose method is going to be bound.
   * @param {function} method Method to be bound.
   * @return {function} The bound method.
   */
  function bindAutoBindMethod(component, method) {
    var boundMethod = method.bind(component);
    if (process.env.NODE_ENV !== 'production') {
      boundMethod.__reactBoundContext = component;
      boundMethod.__reactBoundMethod = method;
      boundMethod.__reactBoundArguments = null;
      var componentName = component.constructor.displayName;
      var _bind = boundMethod.bind;
      boundMethod.bind = function(newThis) {
        for (
          var _len = arguments.length,
            args = Array(_len > 1 ? _len - 1 : 0),
            _key = 1;
          _key < _len;
          _key++
        ) {
          args[_key - 1] = arguments[_key];
        }

        // User is trying to bind() an autobound method; we effectively will
        // ignore the value of "this" that the user is trying to use, so
        // let's warn.
        if (newThis !== component && newThis !== null) {
          if (process.env.NODE_ENV !== 'production') {
            warning(
              false,
              'bind(): React component methods may only be bound to the ' +
                'component instance. See %s',
              componentName
            );
          }
        } else if (!args.length) {
          if (process.env.NODE_ENV !== 'production') {
            warning(
              false,
              'bind(): You are binding a component method to the component. ' +
                'React does this for you automatically in a high-performance ' +
                'way, so you can safely remove this call. See %s',
              componentName
            );
          }
          return boundMethod;
        }
        var reboundMethod = _bind.apply(boundMethod, arguments);
        reboundMethod.__reactBoundContext = component;
        reboundMethod.__reactBoundMethod = method;
        reboundMethod.__reactBoundArguments = args;
        return reboundMethod;
      };
    }
    return boundMethod;
  }

  /**
   * Binds all auto-bound methods in a component.
   *
   * @param {object} component Component whose method is going to be bound.
   */
  function bindAutoBindMethods(component) {
    var pairs = component.__reactAutoBindPairs;
    for (var i = 0; i < pairs.length; i += 2) {
      var autoBindKey = pairs[i];
      var method = pairs[i + 1];
      component[autoBindKey] = bindAutoBindMethod(component, method);
    }
  }

  var IsMountedPreMixin = {
    componentDidMount: function() {
      this.__isMounted = true;
    }
  };

  var IsMountedPostMixin = {
    componentWillUnmount: function() {
      this.__isMounted = false;
    }
  };

  /**
   * Add more to the ReactClass base class. These are all legacy features and
   * therefore not already part of the modern ReactComponent.
   */
  var ReactClassMixin = {
    /**
     * TODO: This will be deprecated because state should always keep a consistent
     * type signature and the only use case for this, is to avoid that.
     */
    replaceState: function(newState, callback) {
      this.updater.enqueueReplaceState(this, newState, callback);
    },

    /**
     * Checks whether or not this composite component is mounted.
     * @return {boolean} True if mounted, false otherwise.
     * @protected
     * @final
     */
    isMounted: function() {
      if (process.env.NODE_ENV !== 'production') {
        warning(
          this.__didWarnIsMounted,
          '%s: isMounted is deprecated. Instead, make sure to clean up ' +
            'subscriptions and pending requests in componentWillUnmount to ' +
            'prevent memory leaks.',
          (this.constructor && this.constructor.displayName) ||
            this.name ||
            'Component'
        );
        this.__didWarnIsMounted = true;
      }
      return !!this.__isMounted;
    }
  };

  var ReactClassComponent = function() {};
  _assign(
    ReactClassComponent.prototype,
    ReactComponent.prototype,
    ReactClassMixin
  );

  /**
   * Creates a composite component class given a class specification.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  function createClass(spec) {
    // To keep our warnings more understandable, we'll use a little hack here to
    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
    // unnecessarily identify a class without displayName as 'Constructor'.
    var Constructor = identity(function(props, context, updater) {
      // This constructor gets overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if (process.env.NODE_ENV !== 'production') {
        warning(
          this instanceof Constructor,
          'Something is calling a React component directly. Use a factory or ' +
            'JSX instead. See: https://fb.me/react-legacyfactory'
        );
      }

      // Wire up auto-binding
      if (this.__reactAutoBindPairs.length) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if (process.env.NODE_ENV !== 'production') {
        // We allow auto-mocks to proceed as if they're returning null.
        if (
          initialState === undefined &&
          this.getInitialState._isMockFunction
        ) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      _invariant(
        typeof initialState === 'object' && !Array.isArray(initialState),
        '%s.getInitialState(): must return an object or null',
        Constructor.displayName || 'ReactCompositeComponent'
      );

      this.state = initialState;
    });
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, IsMountedPreMixin);
    mixSpecIntoComponent(Constructor, spec);
    mixSpecIntoComponent(Constructor, IsMountedPostMixin);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if (process.env.NODE_ENV !== 'production') {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    _invariant(
      Constructor.prototype.render,
      'createClass(...): Class specification must implement a `render` method.'
    );

    if (process.env.NODE_ENV !== 'production') {
      warning(
        !Constructor.prototype.componentShouldUpdate,
        '%s has a method called ' +
          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +
          'The name is phrased as a question because the function is ' +
          'expected to return a value.',
        spec.displayName || 'A component'
      );
      warning(
        !Constructor.prototype.componentWillRecieveProps,
        '%s has a method called ' +
          'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',
        spec.displayName || 'A component'
      );
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  }

  return createClass;
}

module.exports = factory;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var React = __webpack_require__(5);
var factory = __webpack_require__(7);

if (typeof React === 'undefined') {
  throw Error(
    'create-react-class could not find the React object. If you are using script tags, ' +
      'make sure that React is being loaded before create-react-class.'
  );
}

// Hack to grab NoopUpdateQueue from isomorphic React
var ReactNoopUpdateQueue = new React.Component().updater;

module.exports = factory(
  React.Component,
  React.isValidElement,
  ReactNoopUpdateQueue
);


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var React = __webpack_require__(5);
var createReactClass = __webpack_require__(8);
var PropTypes = __webpack_require__(14);
var win = typeof global === 'undefined' ? window : global;

module.exports = function (chartType, Highcharts) {
  var displayName = 'Highcharts' + chartType;
  var result = createReactClass({
    displayName: displayName,

    propTypes: {
      config: PropTypes.object,
      isPureConfig: PropTypes.bool,
      neverReflow: PropTypes.bool,
      callback: PropTypes.func,
      domProps: PropTypes.object
    },
    getDefaultProps: function getDefaultProps() {
      return {
        callback: function callback() {},
        domProps: {}
      };
    },
    setChartRef: function setChartRef(chartRef) {
      this.chartRef = chartRef;
    },
    renderChart: function renderChart(config) {
      var _this = this;

      if (!config) {
        throw new Error('Config must be specified for the ' + displayName + ' component');
      }
      var chartConfig = config.chart;
      this.chart = new Highcharts[chartType](_extends({}, config, {
        chart: _extends({}, chartConfig, {
          renderTo: this.chartRef
        })
      }), this.props.callback);

      if (!this.props.neverReflow) {
        win && win.requestAnimationFrame && requestAnimationFrame(function () {
          _this.chart && _this.chart.options && _this.chart.reflow();
        });
      }
    },

    shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
      if (nextProps.neverReflow || nextProps.isPureConfig && this.props.config === nextProps.config) {
        return true;
      }
      this.renderChart(nextProps.config);
      return false;
    },


    getChart: function getChart() {
      if (!this.chart) {
        throw new Error('getChart() should not be called before the component is mounted');
      }
      return this.chart;
    },

    componentDidMount: function componentDidMount() {
      this.renderChart(this.props.config);
    },

    componentWillUnmount: function componentWillUnmount() {
      this.chart.destroy();
    },


    render: function render() {
      return React.createElement('div', _extends({ ref: this.setChartRef }, this.props.domProps));
    }
  });

  result.Highcharts = Highcharts;
  result.withHighcharts = function (Highcharts) {
    return module.exports(chartType, Highcharts);
  };
  return result;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(1);
  var warning = __webpack_require__(3);
  var ReactPropTypesSecret = __webpack_require__(4);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(2);
var invariant = __webpack_require__(1);
var ReactPropTypesSecret = __webpack_require__(4);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(2);
var invariant = __webpack_require__(1);
var warning = __webpack_require__(3);
var assign = __webpack_require__(6);

var ReactPropTypesSecret = __webpack_require__(4);
var checkPropTypes = __webpack_require__(11);

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(
            false,
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            warning(
              false,
              'You are manually calling a React.PropTypes validation ' +
              'function for the `%s` prop on `%s`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
              propFullName,
              componentName
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(
          false,
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received %s at index %s.',
          getPostfixForTypeWarning(checker),
          i
        );
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(13)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(12)();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 15 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(10)('StockChart', __webpack_require__(23));

/***/ }),
/* 21 */,
/* 22 */,
/* 23 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_23__;

/***/ }),
/* 24 */,
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(20);


/***/ })
/******/ ]);
});

/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_PropTypes__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_warning__ = __webpack_require__(18);
/* harmony export (immutable) */ __webpack_exports__["b"] = createProvider;
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var didWarnAboutReceivingStore = false;
function warnAboutReceivingStore() {
  if (didWarnAboutReceivingStore) {
    return;
  }
  didWarnAboutReceivingStore = true;

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_warning__["a" /* default */])('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
}

function createProvider() {
  var _Provider$childContex;

  var storeKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'store';
  var subKey = arguments[1];

  var subscriptionKey = subKey || storeKey + 'Subscription';

  var Provider = function (_Component) {
    _inherits(Provider, _Component);

    Provider.prototype.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[storeKey] = this[storeKey], _ref[subscriptionKey] = null, _ref;
    };

    function Provider(props, context) {
      _classCallCheck(this, Provider);

      var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

      _this[storeKey] = props.store;
      return _this;
    }

    Provider.prototype.render = function render() {
      return __WEBPACK_IMPORTED_MODULE_0_react__["Children"].only(this.props.children);
    };

    return Provider;
  }(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]);

  if (process.env.NODE_ENV !== 'production') {
    Provider.prototype.componentWillReceiveProps = function (nextProps) {
      if (this[storeKey] !== nextProps.store) {
        warnAboutReceivingStore();
      }
    };
  }

  Provider.propTypes = {
    store: __WEBPACK_IMPORTED_MODULE_2__utils_PropTypes__["a" /* storeShape */].isRequired,
    children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.element.isRequired
  };
  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[storeKey] = __WEBPACK_IMPORTED_MODULE_2__utils_PropTypes__["a" /* storeShape */].isRequired, _Provider$childContex[subscriptionKey] = __WEBPACK_IMPORTED_MODULE_2__utils_PropTypes__["b" /* subscriptionShape */], _Provider$childContex);

  return Provider;
}

/* harmony default export */ __webpack_exports__["a"] = (createProvider());
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(1)))

/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_connectAdvanced__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_shallowEqual__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mapDispatchToProps__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mapStateToProps__ = __webpack_require__(155);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__mergeProps__ = __webpack_require__(156);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__selectorFactory__ = __webpack_require__(157);
/* unused harmony export createConnect */
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }








/*
  connect is a facade over connectAdvanced. It turns its args into a compatible
  selectorFactory, which has the signature:

    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps
  
  connect passes its args to connectAdvanced as options, which will in turn pass them to
  selectorFactory each time a Connect component instance is instantiated or hot reloaded.

  selectorFactory returns a final props selector from its mapStateToProps,
  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
  mergePropsFactories, and pure args.

  The resulting final props selector is called by the Connect component instance whenever
  it receives new props or store state.
 */

function match(arg, factories, name) {
  for (var i = factories.length - 1; i >= 0; i--) {
    var result = factories[i](arg);
    if (result) return result;
  }

  return function (dispatch, options) {
    throw new Error('Invalid value of type ' + typeof arg + ' for ' + name + ' argument when connecting component ' + options.wrappedComponentName + '.');
  };
}

function strictEqual(a, b) {
  return a === b;
}

// createConnect with default args builds the 'official' connect behavior. Calling it with
// different options opens up some testing and extensibility scenarios
function createConnect() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$connectHOC = _ref.connectHOC,
      connectHOC = _ref$connectHOC === undefined ? __WEBPACK_IMPORTED_MODULE_0__components_connectAdvanced__["a" /* default */] : _ref$connectHOC,
      _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
      mapStateToPropsFactories = _ref$mapStateToPropsF === undefined ? __WEBPACK_IMPORTED_MODULE_3__mapStateToProps__["a" /* default */] : _ref$mapStateToPropsF,
      _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
      mapDispatchToPropsFactories = _ref$mapDispatchToPro === undefined ? __WEBPACK_IMPORTED_MODULE_2__mapDispatchToProps__["a" /* default */] : _ref$mapDispatchToPro,
      _ref$mergePropsFactor = _ref.mergePropsFactories,
      mergePropsFactories = _ref$mergePropsFactor === undefined ? __WEBPACK_IMPORTED_MODULE_4__mergeProps__["a" /* default */] : _ref$mergePropsFactor,
      _ref$selectorFactory = _ref.selectorFactory,
      selectorFactory = _ref$selectorFactory === undefined ? __WEBPACK_IMPORTED_MODULE_5__selectorFactory__["a" /* default */] : _ref$selectorFactory;

  return function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
    var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        _ref2$pure = _ref2.pure,
        pure = _ref2$pure === undefined ? true : _ref2$pure,
        _ref2$areStatesEqual = _ref2.areStatesEqual,
        areStatesEqual = _ref2$areStatesEqual === undefined ? strictEqual : _ref2$areStatesEqual,
        _ref2$areOwnPropsEqua = _ref2.areOwnPropsEqual,
        areOwnPropsEqual = _ref2$areOwnPropsEqua === undefined ? __WEBPACK_IMPORTED_MODULE_1__utils_shallowEqual__["a" /* default */] : _ref2$areOwnPropsEqua,
        _ref2$areStatePropsEq = _ref2.areStatePropsEqual,
        areStatePropsEqual = _ref2$areStatePropsEq === undefined ? __WEBPACK_IMPORTED_MODULE_1__utils_shallowEqual__["a" /* default */] : _ref2$areStatePropsEq,
        _ref2$areMergedPropsE = _ref2.areMergedPropsEqual,
        areMergedPropsEqual = _ref2$areMergedPropsE === undefined ? __WEBPACK_IMPORTED_MODULE_1__utils_shallowEqual__["a" /* default */] : _ref2$areMergedPropsE,
        extraOptions = _objectWithoutProperties(_ref2, ['pure', 'areStatesEqual', 'areOwnPropsEqual', 'areStatePropsEqual', 'areMergedPropsEqual']);

    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
    var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');

    return connectHOC(selectorFactory, _extends({
      // used in error messages
      methodName: 'connect',

      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: function getDisplayName(name) {
        return 'Connect(' + name + ')';
      },

      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),

      // passed through to selectorFactory
      initMapStateToProps: initMapStateToProps,
      initMapDispatchToProps: initMapDispatchToProps,
      initMergeProps: initMergeProps,
      pure: pure,
      areStatesEqual: areStatesEqual,
      areOwnPropsEqual: areOwnPropsEqual,
      areStatePropsEqual: areStatePropsEqual,
      areMergedPropsEqual: areMergedPropsEqual

    }, extraOptions));
  };
}

/* harmony default export */ __webpack_exports__["a"] = (createConnect());

/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_redux__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__wrapMapToProps__ = __webpack_require__(38);
/* unused harmony export whenMapDispatchToPropsIsFunction */
/* unused harmony export whenMapDispatchToPropsIsMissing */
/* unused harmony export whenMapDispatchToPropsIsObject */



function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
  return typeof mapDispatchToProps === 'function' ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__wrapMapToProps__["a" /* wrapMapToPropsFunc */])(mapDispatchToProps, 'mapDispatchToProps') : undefined;
}

function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
  return !mapDispatchToProps ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__wrapMapToProps__["b" /* wrapMapToPropsConstant */])(function (dispatch) {
    return { dispatch: dispatch };
  }) : undefined;
}

function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__wrapMapToProps__["b" /* wrapMapToPropsConstant */])(function (dispatch) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_redux__["bindActionCreators"])(mapDispatchToProps, dispatch);
  }) : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = ([whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject]);

/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__wrapMapToProps__ = __webpack_require__(38);
/* unused harmony export whenMapStateToPropsIsFunction */
/* unused harmony export whenMapStateToPropsIsMissing */


function whenMapStateToPropsIsFunction(mapStateToProps) {
  return typeof mapStateToProps === 'function' ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__wrapMapToProps__["a" /* wrapMapToPropsFunc */])(mapStateToProps, 'mapStateToProps') : undefined;
}

function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__wrapMapToProps__["b" /* wrapMapToPropsConstant */])(function () {
    return {};
  }) : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = ([whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing]);

/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_verifyPlainObject__ = __webpack_require__(40);
/* unused harmony export defaultMergeProps */
/* unused harmony export wrapMergePropsFunc */
/* unused harmony export whenMergePropsIsFunction */
/* unused harmony export whenMergePropsIsOmitted */
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };



function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return _extends({}, ownProps, stateProps, dispatchProps);
}

function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, _ref) {
    var displayName = _ref.displayName,
        pure = _ref.pure,
        areMergedPropsEqual = _ref.areMergedPropsEqual;

    var hasRunOnce = false;
    var mergedProps = void 0;

    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);

      if (hasRunOnce) {
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;

        if (process.env.NODE_ENV !== 'production') __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_verifyPlainObject__["a" /* default */])(mergedProps, displayName, 'mergeProps');
      }

      return mergedProps;
    };
  };
}

function whenMergePropsIsFunction(mergeProps) {
  return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
}

function whenMergePropsIsOmitted(mergeProps) {
  return !mergeProps ? function () {
    return defaultMergeProps;
  } : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = ([whenMergePropsIsFunction, whenMergePropsIsOmitted]);
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(1)))

/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__verifySubselectors__ = __webpack_require__(158);
/* unused harmony export impureFinalPropsSelectorFactory */
/* unused harmony export pureFinalPropsSelectorFactory */
/* harmony export (immutable) */ __webpack_exports__["a"] = finalPropsSelectorFactory;
function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }



function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
  };
}

function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
  var areStatesEqual = _ref.areStatesEqual,
      areOwnPropsEqual = _ref.areOwnPropsEqual,
      areStatePropsEqual = _ref.areStatePropsEqual;

  var hasRunAtLeastOnce = false;
  var state = void 0;
  var ownProps = void 0;
  var stateProps = void 0;
  var dispatchProps = void 0;
  var mergedProps = void 0;

  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }

  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);

    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);

    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewState() {
    var nextStateProps = mapStateToProps(state, ownProps);
    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;

    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);

    return mergedProps;
  }

  function handleSubsequentCalls(nextState, nextOwnProps) {
    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    var stateChanged = !areStatesEqual(nextState, state);
    state = nextState;
    ownProps = nextOwnProps;

    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
    if (propsChanged) return handleNewProps();
    if (stateChanged) return handleNewState();
    return mergedProps;
  }

  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}

// TODO: Add more comments

// If pure is true, the selector returned by selectorFactory will memoize its results,
// allowing connectAdvanced's shouldComponentUpdate to return false if final
// props have not changed. If false, the selector will always return a new
// object and shouldComponentUpdate will always return true.

function finalPropsSelectorFactory(dispatch, _ref2) {
  var initMapStateToProps = _ref2.initMapStateToProps,
      initMapDispatchToProps = _ref2.initMapDispatchToProps,
      initMergeProps = _ref2.initMergeProps,
      options = _objectWithoutProperties(_ref2, ['initMapStateToProps', 'initMapDispatchToProps', 'initMergeProps']);

  var mapStateToProps = initMapStateToProps(dispatch, options);
  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
  var mergeProps = initMergeProps(dispatch, options);

  if (process.env.NODE_ENV !== 'production') {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__verifySubselectors__["a" /* default */])(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName);
  }

  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;

  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(1)))

/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_warning__ = __webpack_require__(18);
/* harmony export (immutable) */ __webpack_exports__["a"] = verifySubselectors;


function verify(selector, methodName, displayName) {
  if (!selector) {
    throw new Error('Unexpected value for ' + methodName + ' in ' + displayName + '.');
  } else if (methodName === 'mapStateToProps' || methodName === 'mapDispatchToProps') {
    if (!selector.hasOwnProperty('dependsOnOwnProps')) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_warning__["a" /* default */])('The selector for ' + methodName + ' of ' + displayName + ' did not specify a value for dependsOnOwnProps.');
    }
  }
}

function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {
  verify(mapStateToProps, 'mapStateToProps', displayName);
  verify(mapDispatchToProps, 'mapDispatchToProps', displayName);
  verify(mergeProps, 'mergeProps', displayName);
}

/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Subscription; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// encapsulates the subscription logic for connecting a component to the redux store, as
// well as nesting subscriptions of descendant components, so that we can ensure the
// ancestor components re-render before descendants

var CLEARED = null;
var nullListeners = {
  notify: function notify() {}
};

function createListenerCollection() {
  // the current/next pattern is copied from redux's createStore code.
  // TODO: refactor+expose that code to be reusable here?
  var current = [];
  var next = [];

  return {
    clear: function clear() {
      next = CLEARED;
      current = CLEARED;
    },
    notify: function notify() {
      var listeners = current = next;
      for (var i = 0; i < listeners.length; i++) {
        listeners[i]();
      }
    },
    get: function get() {
      return next;
    },
    subscribe: function subscribe(listener) {
      var isSubscribed = true;
      if (next === current) next = current.slice();
      next.push(listener);

      return function unsubscribe() {
        if (!isSubscribed || current === CLEARED) return;
        isSubscribed = false;

        if (next === current) next = current.slice();
        next.splice(next.indexOf(listener), 1);
      };
    }
  };
}

var Subscription = function () {
  function Subscription(store, parentSub, onStateChange) {
    _classCallCheck(this, Subscription);

    this.store = store;
    this.parentSub = parentSub;
    this.onStateChange = onStateChange;
    this.unsubscribe = null;
    this.listeners = nullListeners;
  }

  Subscription.prototype.addNestedSub = function addNestedSub(listener) {
    this.trySubscribe();
    return this.listeners.subscribe(listener);
  };

  Subscription.prototype.notifyNestedSubs = function notifyNestedSubs() {
    this.listeners.notify();
  };

  Subscription.prototype.isSubscribed = function isSubscribed() {
    return Boolean(this.unsubscribe);
  };

  Subscription.prototype.trySubscribe = function trySubscribe() {
    if (!this.unsubscribe) {
      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange);

      this.listeners = createListenerCollection();
    }
  };

  Subscription.prototype.tryUnsubscribe = function tryUnsubscribe() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
      this.listeners.clear();
      this.listeners = nullListeners;
    }
  };

  return Subscription;
}();



/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = shallowEqual;
var hasOwn = Object.prototype.hasOwnProperty;

function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function shallowEqual(objA, objB) {
  if (is(objA, objB)) return true;

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) return false;

  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0
 * react.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (process.env.NODE_ENV !== "production") {
  (function() {
'use strict';

var _assign = __webpack_require__(7);
var emptyObject = __webpack_require__(9);
var invariant = __webpack_require__(6);
var warning = __webpack_require__(10);
var emptyFunction = __webpack_require__(4);
var checkPropTypes = __webpack_require__(16);

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.2.0';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol['for'];

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable === 'undefined') {
    return null;
  }
  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }
  return null;
}

/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var constructor = publicInstance.constructor;
    var componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';
    var warningKey = componentName + '.' + callerName;
    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }
    warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

/**
 * Base class helpers for the updating state of a component.
 */
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
Component.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
        return undefined;
      }
    });
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

/**
 * Base class helpers for the updating state of a component.
 */
function PureComponent(props, context, updater) {
  // Duplicated from Component.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

function ComponentDummy() {}
ComponentDummy.prototype = Component.prototype;
var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent;
// Avoid an extra prototype jump for these methods.
_assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = true;

function AsyncComponent(props, context, updater) {
  // Duplicated from Component.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

var asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();
asyncComponentPrototype.constructor = AsyncComponent;
// Avoid an extra prototype jump for these methods.
_assign(asyncComponentPrototype, Component.prototype);
asyncComponentPrototype.unstable_isAsyncReactComponent = true;
asyncComponentPrototype.render = function () {
  return this.props.children;
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var hasOwnProperty = Object.prototype.hasOwnProperty;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown;
var specialPropRefWarningShown;

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    });
    // self and source are DEV only properties.
    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    });
    // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.
    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */
function createElement(type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}

/**
 * Return a function that produces ReactElements of a given type.
 * See https://reactjs.org/docs/react-api.html#createfactory
 */


function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
}

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */
function cloneElement(element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}

/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var ReactDebugCurrentFrame = {};

{
  // Component that is being worked on
  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var impl = ReactDebugCurrentFrame.getCurrentStack;
    if (impl) {
      return impl();
    }
    return null;
  };
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */
function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

var POOL_SIZE = 10;
var traverseContextPool = [];
function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
  if (traverseContextPool.length) {
    var traverseContext = traverseContextPool.pop();
    traverseContext.result = mapResult;
    traverseContext.keyPrefix = keyPrefix;
    traverseContext.func = mapFunction;
    traverseContext.context = mapContext;
    traverseContext.count = 0;
    return traverseContext;
  } else {
    return {
      result: mapResult,
      keyPrefix: keyPrefix,
      func: mapFunction,
      context: mapContext,
      count: 0
    };
  }
}

function releaseTraverseContext(traverseContext) {
  traverseContext.result = null;
  traverseContext.keyPrefix = null;
  traverseContext.func = null;
  traverseContext.context = null;
  traverseContext.count = 0;
  if (traverseContextPool.length < POOL_SIZE) {
    traverseContextPool.push(traverseContext);
  }
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;
      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_CALL_TYPE:
          case REACT_RETURN_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }
    }
  }

  if (invokeCallback) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (typeof iteratorFn === 'function') {
      {
        // Warn about using Maps as children
        if (iteratorFn === children.entries) {
          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum());
          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(children);
      var step;
      var ii = 0;
      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getComponentKey(child, ii++);
        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
      }
    } else if (type === 'object') {
      var addendum = '';
      {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
      }
      var childrenString = '' + children;
      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof component === 'object' && component !== null && component.key != null) {
    // Explicit key
    return escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  releaseTraverseContext(traverseContext);
}

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  releaseTraverseContext(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
  return children;
}

var describeComponentFrame = function (name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
};

function getComponentName(fiber) {
  var type = fiber.type;

  if (typeof type === 'string') {
    return type;
  }
  if (typeof type === 'function') {
    return type.displayName || type.name;
  }
  return null;
}

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

{
  var currentlyValidatingElement = null;

  var propTypesMisspellWarningShown = false;

  var getDisplayName = function (element) {
    if (element == null) {
      return '#empty';
    } else if (typeof element === 'string' || typeof element === 'number') {
      return '#text';
    } else if (typeof element.type === 'string') {
      return element.type;
    } else if (element.type === REACT_FRAGMENT_TYPE) {
      return 'React.Fragment';
    } else {
      return element.type.displayName || element.type.name || 'Unknown';
    }
  };

  var getStackAddendum = function () {
    var stack = '';
    if (currentlyValidatingElement) {
      var name = getDisplayName(currentlyValidatingElement);
      var owner = currentlyValidatingElement._owner;
      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
    }
    stack += ReactDebugCurrentFrame.getStackAddendum() || '';
    return stack;
  };

  var VALID_FRAGMENT_PROPS = new Map([['children', true], ['key', true]]);
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current);
    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }
  return '';
}

function getSourceInfoErrorAddendum(elementProps) {
  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
    var source = elementProps.__source;
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = '\n\nCheck the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';
  }

  currentlyValidatingElement = element;
  {
    warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
  }
  currentlyValidatingElement = null;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  var propTypes = componentClass.propTypes;
  if (propTypes) {
    currentlyValidatingElement = element;
    checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);
    currentlyValidatingElement = null;
  } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {
    propTypesMisspellWarningShown = true;
    warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
  }
}

/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */
function validateFragmentProps(fragment) {
  currentlyValidatingElement = fragment;

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      if (!VALID_FRAGMENT_PROPS.has(key)) {
        warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());
        break;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (fragment.ref !== null) {
    warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());
  }

  currentlyValidatingElement = null;
}

function createElementWithValidation(type, props, children) {
  var validType = typeof type === 'string' || typeof type === 'function' || typeof type === 'symbol' || typeof type === 'number';
  // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.
  if (!validType) {
    var info = '';
    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendum(props);
    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    info += getStackAddendum() || '';

    warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info);
  }

  var element = createElement.apply(this, arguments);

  // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.
  if (element == null) {
    return element;
  }

  // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)
  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (typeof type === 'symbol' && type === REACT_FRAGMENT_TYPE) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}

function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  // Legacy hook TODO: Warn if this is accessed
  validatedFactory.type = type;

  {
    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}

function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);
  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }
  validatePropTypes(newElement);
  return newElement;
}

var React = {
  Children: {
    map: mapChildren,
    forEach: forEachChildren,
    count: countChildren,
    toArray: toArray,
    only: onlyChild
  },

  Component: Component,
  PureComponent: PureComponent,
  unstable_AsyncComponent: AsyncComponent,

  Fragment: REACT_FRAGMENT_TYPE,

  createElement: createElementWithValidation,
  cloneElement: cloneElementWithValidation,
  createFactory: createFactoryWithValidation,
  isValidElement: isValidElement,

  version: ReactVersion,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    ReactCurrentOwner: ReactCurrentOwner,
    // Used by renderers to avoid bundling object-assign twice in UMD bundles:
    assign: _assign
  }
};

{
  _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
    // These should not be included in production.
    ReactDebugCurrentFrame: ReactDebugCurrentFrame,
    // Shim for React DOM 16.0.0 which still destructured (but not used) this.
    // TODO: remove in React 17.0.
    ReactComponentTreeHook: {}
  });
}



var React$2 = Object.freeze({
	default: React
});

var React$3 = ( React$2 && React ) || React$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var react = React$3['default'] ? React$3['default'] : React$3;

module.exports = react;
  })();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var m=__webpack_require__(7),n=__webpack_require__(9),p=__webpack_require__(4),q="function"===typeof Symbol&&Symbol["for"],r=q?Symbol["for"]("react.element"):60103,t=q?Symbol["for"]("react.call"):60104,u=q?Symbol["for"]("react.return"):60105,v=q?Symbol["for"]("react.portal"):60106,w=q?Symbol["for"]("react.fragment"):60107,x="function"===typeof Symbol&&Symbol.iterator;
function y(a){for(var b=arguments.length-1,e="Minified React error #"+a+"; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d"+a,c=0;c<b;c++)e+="\x26args[]\x3d"+encodeURIComponent(arguments[c+1]);b=Error(e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name="Invariant Violation";b.framesToPop=1;throw b;}
var z={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}};function A(a,b,e){this.props=a;this.context=b;this.refs=n;this.updater=e||z}A.prototype.isReactComponent={};A.prototype.setState=function(a,b){"object"!==typeof a&&"function"!==typeof a&&null!=a?y("85"):void 0;this.updater.enqueueSetState(this,a,b,"setState")};A.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};
function B(a,b,e){this.props=a;this.context=b;this.refs=n;this.updater=e||z}function C(){}C.prototype=A.prototype;var D=B.prototype=new C;D.constructor=B;m(D,A.prototype);D.isPureReactComponent=!0;function E(a,b,e){this.props=a;this.context=b;this.refs=n;this.updater=e||z}var F=E.prototype=new C;F.constructor=E;m(F,A.prototype);F.unstable_isAsyncReactComponent=!0;F.render=function(){return this.props.children};var G={current:null},H=Object.prototype.hasOwnProperty,I={key:!0,ref:!0,__self:!0,__source:!0};
function J(a,b,e){var c,d={},g=null,k=null;if(null!=b)for(c in void 0!==b.ref&&(k=b.ref),void 0!==b.key&&(g=""+b.key),b)H.call(b,c)&&!I.hasOwnProperty(c)&&(d[c]=b[c]);var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){for(var h=Array(f),l=0;l<f;l++)h[l]=arguments[l+2];d.children=h}if(a&&a.defaultProps)for(c in f=a.defaultProps,f)void 0===d[c]&&(d[c]=f[c]);return{$$typeof:r,type:a,key:g,ref:k,props:d,_owner:G.current}}function K(a){return"object"===typeof a&&null!==a&&a.$$typeof===r}
function escape(a){var b={"\x3d":"\x3d0",":":"\x3d2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var L=/\/+/g,M=[];function N(a,b,e,c){if(M.length){var d=M.pop();d.result=a;d.keyPrefix=b;d.func=e;d.context=c;d.count=0;return d}return{result:a,keyPrefix:b,func:e,context:c,count:0}}function O(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>M.length&&M.push(a)}
function P(a,b,e,c){var d=typeof a;if("undefined"===d||"boolean"===d)a=null;var g=!1;if(null===a)g=!0;else switch(d){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case r:case t:case u:case v:g=!0}}if(g)return e(c,a,""===b?"."+Q(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var k=0;k<a.length;k++){d=a[k];var f=b+Q(d,k);g+=P(d,f,e,c)}else if(null===a||"undefined"===typeof a?f=null:(f=x&&a[x]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=
f.call(a),k=0;!(d=a.next()).done;)d=d.value,f=b+Q(d,k++),g+=P(d,f,e,c);else"object"===d&&(e=""+a,y("31","[object Object]"===e?"object with keys {"+Object.keys(a).join(", ")+"}":e,""));return g}function Q(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function R(a,b){a.func.call(a.context,b,a.count++)}
function S(a,b,e){var c=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?T(a,c,e,p.thatReturnsArgument):null!=a&&(K(a)&&(b=d+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(L,"$\x26/")+"/")+e,a={$$typeof:r,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}),c.push(a))}function T(a,b,e,c,d){var g="";null!=e&&(g=(""+e).replace(L,"$\x26/")+"/");b=N(b,g,c,d);null==a||P(a,"",S,b);O(b)}
var U={Children:{map:function(a,b,e){if(null==a)return a;var c=[];T(a,c,null,b,e);return c},forEach:function(a,b,e){if(null==a)return a;b=N(null,null,b,e);null==a||P(a,"",R,b);O(b)},count:function(a){return null==a?0:P(a,"",p.thatReturnsNull,null)},toArray:function(a){var b=[];T(a,b,null,p.thatReturnsArgument);return b},only:function(a){K(a)?void 0:y("143");return a}},Component:A,PureComponent:B,unstable_AsyncComponent:E,Fragment:w,createElement:J,cloneElement:function(a,b,e){var c=m({},a.props),
d=a.key,g=a.ref,k=a._owner;if(null!=b){void 0!==b.ref&&(g=b.ref,k=G.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var f=a.type.defaultProps;for(h in b)H.call(b,h)&&!I.hasOwnProperty(h)&&(c[h]=void 0===b[h]&&void 0!==f?f[h]:b[h])}var h=arguments.length-2;if(1===h)c.children=e;else if(1<h){f=Array(h);for(var l=0;l<h;l++)f[l]=arguments[l+2];c.children=f}return{$$typeof:r,type:a.type,key:d,ref:g,props:c,_owner:k}},createFactory:function(a){var b=J.bind(null,a);b.type=a;return b},
isValidElement:K,version:"16.2.0",__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentOwner:G,assign:m}},V=Object.freeze({default:U}),W=V&&U||V;module.exports=W["default"]?W["default"]:W;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.printBuffer = printBuffer;

var _helpers = __webpack_require__(41);

var _diff = __webpack_require__(165);

var _diff2 = _interopRequireDefault(_diff);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Get log level string based on supplied params
 *
 * @param {string | function | object} level - console[level]
 * @param {object} action - selected action
 * @param {array} payload - selected payload
 * @param {string} type - log entry type
 *
 * @returns {string} level
 */
function getLogLevel(level, action, payload, type) {
  switch (typeof level === 'undefined' ? 'undefined' : _typeof(level)) {
    case 'object':
      return typeof level[type] === 'function' ? level[type].apply(level, _toConsumableArray(payload)) : level[type];
    case 'function':
      return level(action);
    default:
      return level;
  }
}

function defaultTitleFormatter(options) {
  var timestamp = options.timestamp,
      duration = options.duration;


  return function (action, time, took) {
    var parts = ['action'];

    parts.push('%c' + String(action.type));
    if (timestamp) parts.push('%c@ ' + time);
    if (duration) parts.push('%c(in ' + took.toFixed(2) + ' ms)');

    return parts.join(' ');
  };
}

function printBuffer(buffer, options) {
  var logger = options.logger,
      actionTransformer = options.actionTransformer,
      _options$titleFormatt = options.titleFormatter,
      titleFormatter = _options$titleFormatt === undefined ? defaultTitleFormatter(options) : _options$titleFormatt,
      collapsed = options.collapsed,
      colors = options.colors,
      level = options.level,
      diff = options.diff;


  buffer.forEach(function (logEntry, key) {
    var started = logEntry.started,
        startedTime = logEntry.startedTime,
        action = logEntry.action,
        prevState = logEntry.prevState,
        error = logEntry.error;
    var took = logEntry.took,
        nextState = logEntry.nextState;

    var nextEntry = buffer[key + 1];

    if (nextEntry) {
      nextState = nextEntry.prevState;
      took = nextEntry.started - started;
    }

    // Message
    var formattedAction = actionTransformer(action);
    var isCollapsed = typeof collapsed === 'function' ? collapsed(function () {
      return nextState;
    }, action, logEntry) : collapsed;

    var formattedTime = (0, _helpers.formatTime)(startedTime);
    var titleCSS = colors.title ? 'color: ' + colors.title(formattedAction) + ';' : '';
    var headerCSS = ['color: gray; font-weight: lighter;'];
    headerCSS.push(titleCSS);
    if (options.timestamp) headerCSS.push('color: gray; font-weight: lighter;');
    if (options.duration) headerCSS.push('color: gray; font-weight: lighter;');
    var title = titleFormatter(formattedAction, formattedTime, took);

    // Render
    try {
      if (isCollapsed) {
        if (colors.title) logger.groupCollapsed.apply(logger, ['%c ' + title].concat(headerCSS));else logger.groupCollapsed(title);
      } else {
        if (colors.title) logger.group.apply(logger, ['%c ' + title].concat(headerCSS));else logger.group(title);
      }
    } catch (e) {
      logger.log(title);
    }

    var prevStateLevel = getLogLevel(level, formattedAction, [prevState], 'prevState');
    var actionLevel = getLogLevel(level, formattedAction, [formattedAction], 'action');
    var errorLevel = getLogLevel(level, formattedAction, [error, prevState], 'error');
    var nextStateLevel = getLogLevel(level, formattedAction, [nextState], 'nextState');

    if (prevStateLevel) {
      if (colors.prevState) logger[prevStateLevel]('%c prev state', 'color: ' + colors.prevState(prevState) + '; font-weight: bold', prevState);else logger[prevStateLevel]('prev state', prevState);
    }

    if (actionLevel) {
      if (colors.action) logger[actionLevel]('%c action    ', 'color: ' + colors.action(formattedAction) + '; font-weight: bold', formattedAction);else logger[actionLevel]('action    ', formattedAction);
    }

    if (error && errorLevel) {
      if (colors.error) logger[errorLevel]('%c error     ', 'color: ' + colors.error(error, prevState) + '; font-weight: bold;', error);else logger[errorLevel]('error     ', error);
    }

    if (nextStateLevel) {
      if (colors.nextState) logger[nextStateLevel]('%c next state', 'color: ' + colors.nextState(nextState) + '; font-weight: bold', nextState);else logger[nextStateLevel]('next state', nextState);
    }

    if (diff) {
      (0, _diff2.default)(prevState, nextState, logger, isCollapsed);
    }

    try {
      logger.groupEnd();
    } catch (e) {
      logger.log('\u2014\u2014 log end \u2014\u2014');
    }
  });
}

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  level: "log",
  logger: console,
  logErrors: true,
  collapsed: undefined,
  predicate: undefined,
  duration: false,
  timestamp: true,
  stateTransformer: function stateTransformer(state) {
    return state;
  },
  actionTransformer: function actionTransformer(action) {
    return action;
  },
  errorTransformer: function errorTransformer(error) {
    return error;
  },
  colors: {
    title: function title() {
      return "inherit";
    },
    prevState: function prevState() {
      return "#9E9E9E";
    },
    action: function action() {
      return "#03A9F4";
    },
    nextState: function nextState() {
      return "#4CAF50";
    },
    error: function error() {
      return "#F20404";
    }
  },
  diff: false,
  diffPredicate: undefined,

  // Deprecated options
  transformer: undefined
};
module.exports = exports["default"];

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = diffLogger;

var _deepDiff = __webpack_require__(126);

var _deepDiff2 = _interopRequireDefault(_deepDiff);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// https://github.com/flitbit/diff#differences
var dictionary = {
  'E': {
    color: '#2196F3',
    text: 'CHANGED:'
  },
  'N': {
    color: '#4CAF50',
    text: 'ADDED:'
  },
  'D': {
    color: '#F44336',
    text: 'DELETED:'
  },
  'A': {
    color: '#2196F3',
    text: 'ARRAY:'
  }
};

function style(kind) {
  return 'color: ' + dictionary[kind].color + '; font-weight: bold';
}

function render(diff) {
  var kind = diff.kind,
      path = diff.path,
      lhs = diff.lhs,
      rhs = diff.rhs,
      index = diff.index,
      item = diff.item;


  switch (kind) {
    case 'E':
      return [path.join('.'), lhs, '\u2192', rhs];
    case 'N':
      return [path.join('.'), rhs];
    case 'D':
      return [path.join('.')];
    case 'A':
      return [path.join('.') + '[' + index + ']', item];
    default:
      return [];
  }
}

function diffLogger(prevState, newState, logger, isCollapsed) {
  var diff = (0, _deepDiff2.default)(prevState, newState);

  try {
    if (isCollapsed) {
      logger.groupCollapsed('diff');
    } else {
      logger.group('diff');
    }
  } catch (e) {
    logger.log('diff');
  }

  if (diff) {
    diff.forEach(function (elem) {
      var kind = elem.kind;

      var output = render(elem);

      logger.log.apply(logger, ['%c ' + dictionary[kind].text, style(kind)].concat(_toConsumableArray(output)));
    });
  } else {
    logger.log('\u2014\u2014 no diff \u2014\u2014');
  }

  try {
    logger.groupEnd();
  } catch (e) {
    logger.log('\u2014\u2014 diff end \u2014\u2014 ');
  }
}
module.exports = exports['default'];

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logger = exports.defaults = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _core = __webpack_require__(163);

var _helpers = __webpack_require__(41);

var _defaults = __webpack_require__(164);

var _defaults2 = _interopRequireDefault(_defaults);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates logger with following options
 *
 * @namespace
 * @param {object} options - options for logger
 * @param {string | function | object} options.level - console[level]
 * @param {boolean} options.duration - print duration of each action?
 * @param {boolean} options.timestamp - print timestamp with each action?
 * @param {object} options.colors - custom colors
 * @param {object} options.logger - implementation of the `console` API
 * @param {boolean} options.logErrors - should errors in action execution be caught, logged, and re-thrown?
 * @param {boolean} options.collapsed - is group collapsed?
 * @param {boolean} options.predicate - condition which resolves logger behavior
 * @param {function} options.stateTransformer - transform state before print
 * @param {function} options.actionTransformer - transform action before print
 * @param {function} options.errorTransformer - transform error before print
 *
 * @returns {function} logger middleware
 */
function createLogger() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var loggerOptions = _extends({}, _defaults2.default, options);

  var logger = loggerOptions.logger,
      transformer = loggerOptions.transformer,
      stateTransformer = loggerOptions.stateTransformer,
      errorTransformer = loggerOptions.errorTransformer,
      predicate = loggerOptions.predicate,
      logErrors = loggerOptions.logErrors,
      diffPredicate = loggerOptions.diffPredicate;

  // Return if 'console' object is not defined

  if (typeof logger === 'undefined') {
    return function () {
      return function (next) {
        return function (action) {
          return next(action);
        };
      };
    };
  }

  if (transformer) {
    console.error('Option \'transformer\' is deprecated, use \'stateTransformer\' instead!'); // eslint-disable-line no-console
  }

  // Detect if 'createLogger' was passed directly to 'applyMiddleware'.
  if (options.getState && options.dispatch) {
    // eslint-disable-next-line no-console
    console.error('[redux-logger] redux-logger not installed. Make sure to pass logger instance as middleware:\n\n// Logger with default options\nimport { logger } from \'redux-logger\'\nconst store = createStore(\n  reducer,\n  applyMiddleware(logger)\n)\n\n\n// Or you can create your own logger with custom options http://bit.ly/redux-logger-options\nimport createLogger from \'redux-logger\'\n\nconst logger = createLogger({\n  // ...options\n});\n\nconst store = createStore(\n  reducer,\n  applyMiddleware(logger)\n)\n');

    return function () {
      return function (next) {
        return function (action) {
          return next(action);
        };
      };
    };
  }

  var logBuffer = [];

  return function (_ref) {
    var getState = _ref.getState;
    return function (next) {
      return function (action) {
        // Exit early if predicate function returns 'false'
        if (typeof predicate === 'function' && !predicate(getState, action)) {
          return next(action);
        }

        var logEntry = {};
        logBuffer.push(logEntry);

        logEntry.started = _helpers.timer.now();
        logEntry.startedTime = new Date();
        logEntry.prevState = stateTransformer(getState());
        logEntry.action = action;

        var returnedValue = void 0;
        if (logErrors) {
          try {
            returnedValue = next(action);
          } catch (e) {
            logEntry.error = errorTransformer(e);
          }
        } else {
          returnedValue = next(action);
        }

        logEntry.took = _helpers.timer.now() - logEntry.started;
        logEntry.nextState = stateTransformer(getState());

        var diff = loggerOptions.diff && typeof diffPredicate === 'function' ? diffPredicate(getState, action) : loggerOptions.diff;

        (0, _core.printBuffer)(logBuffer, _extends({}, loggerOptions, { diff: diff }));
        logBuffer.length = 0;

        if (logEntry.error) throw logEntry.error;
        return returnedValue;
      };
    };
  };
}

var defaultLogger = createLogger();

exports.defaults = _defaults2.default;
exports.logger = defaultLogger;
exports.default = createLogger;
module.exports = exports['default'];


/***/ }),
/* 167 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__compose__ = __webpack_require__(42);
/* harmony export (immutable) */ __webpack_exports__["a"] = applyMiddleware;
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };



/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function (reducer, preloadedState, enhancer) {
      var store = createStore(reducer, preloadedState, enhancer);
      var _dispatch = store.dispatch;
      var chain = [];

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch(action) {
          return _dispatch(action);
        }
      };
      chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = __WEBPACK_IMPORTED_MODULE_0__compose__["a" /* default */].apply(undefined, chain)(store.dispatch);

      return _extends({}, store, {
        dispatch: _dispatch
      });
    };
  };
}

/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = bindActionCreators;
function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(undefined, arguments));
  };
}

/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass a single function as the first argument,
 * and get a function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
  }

  var keys = Object.keys(actionCreators);
  var boundActionCreators = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}

/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__createStore__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash_es_isPlainObject__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_warning__ = __webpack_require__(44);
/* harmony export (immutable) */ __webpack_exports__["a"] = combineReducers;




function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === __WEBPACK_IMPORTED_MODULE_0__createStore__["b" /* ActionTypes */].INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_lodash_es_isPlainObject__["a" /* default */])(inputState)) {
    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });

  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });

  if (unexpectedKeys.length > 0) {
    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, { type: __WEBPACK_IMPORTED_MODULE_0__createStore__["b" /* ActionTypes */].INIT });

    if (typeof initialState === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');
    }

    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
    if (typeof reducer(undefined, { type: type }) === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + __WEBPACK_IMPORTED_MODULE_0__createStore__["b" /* ActionTypes */].INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');
    }
  });
}

/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (process.env.NODE_ENV !== 'production') {
      if (typeof reducers[key] === 'undefined') {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_warning__["a" /* default */])('No reducer provided for key "' + key + '"');
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);

  var unexpectedKeyCache = void 0;
  if (process.env.NODE_ENV !== 'production') {
    unexpectedKeyCache = {};
  }

  var shapeAssertionError = void 0;
  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var action = arguments[1];

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (process.env.NODE_ENV !== 'production') {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_warning__["a" /* default */])(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};
    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(_key, action);
        throw new Error(errorMessage);
      }
      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    return hasChanged ? nextState : state;
  };
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(1)))

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(171);


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = __webpack_require__(172);

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root; /* global window */


if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11), __webpack_require__(174)(module)))

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};

/***/ }),
/* 173 */
/***/ (function(module, exports) {


exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};


/***/ }),
/* 174 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var window = __webpack_require__(134)
var isFunction = __webpack_require__(34)
var parseHeaders = __webpack_require__(146)
var xtend = __webpack_require__(176)

module.exports = createXHR
createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest

forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback)
        options.method = method.toUpperCase()
        return _createXHR(options)
    }
})

function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
        iterator(array[i])
    }
}

function isEmpty(obj){
    for(var i in obj){
        if(obj.hasOwnProperty(i)) return false
    }
    return true
}

function initParams(uri, options, callback) {
    var params = uri

    if (isFunction(options)) {
        callback = options
        if (typeof uri === "string") {
            params = {uri:uri}
        }
    } else {
        params = xtend(options, {uri: uri})
    }

    params.callback = callback
    return params
}

function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback)
    return _createXHR(options)
}

function _createXHR(options) {
    if(typeof options.callback === "undefined"){
        throw new Error("callback argument missing")
    }

    var called = false
    var callback = function cbOnce(err, response, body){
        if(!called){
            called = true
            options.callback(err, response, body)
        }
    }

    function readystatechange() {
        if (xhr.readyState === 4) {
            setTimeout(loadFunc, 0)
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else {
            body = xhr.responseText || getXml(xhr)
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
        }
        evt.statusCode = 0
        return callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return
        var status
        clearTimeout(timeoutTimer)
        if(options.useXDR && xhr.status===undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200
        } else {
            status = (xhr.status === 1223 ? 204 : xhr.status)
        }
        var response = failureResponse
        var err = null

        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        return callback(err, response, response.body)
    }

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest()
        }else{
            xhr = new createXHR.XMLHttpRequest()
        }
    }

    var key
    var aborted
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer
    var failureResponse = {
        body: undefined,
        headers: {},
        statusCode: 0,
        method: method,
        url: uri,
        rawRequest: xhr
    }

    if ("json" in options && options.json !== false) {
        isJson = true
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
            body = JSON.stringify(options.json === true ? body : options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.onabort = function(){
        aborted = true;
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync, options.username, options.password)
    //has to be after open
    if(!sync) {
        xhr.withCredentials = !!options.withCredentials
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            if (aborted) return
            aborted = true//IE9 may still call readystatechange
            xhr.abort("timeout")
            var e = new Error("XMLHttpRequest timeout")
            e.code = "ETIMEDOUT"
            errorFunc(e)
        }, options.timeout )
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }

    if ("beforeSend" in options &&
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    // Microsoft Edge browser sends "undefined" when send is called with undefined value.
    // XMLHttpRequest spec says to pass null as body to indicate no body
    // See https://github.com/naugtur/xhr/issues/100.
    xhr.send(body || null)

    return xhr


}

function getXml(xhr) {
    if (xhr.responseType === "document") {
        return xhr.responseXML
    }
    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror"
    if (xhr.responseType === "" && !firefoxBugTakenEffect) {
        return xhr.responseXML
    }

    return null
}

function noop() {}


/***/ }),
/* 176 */
/***/ (function(module, exports) {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMGU4MzViMjcxNTIyMjM3NDA5ZGIiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2QzLXRpbWUvc3JjL2ludGVydmFsLmpzIiwid2VicGFjazovLy8uL34vZDMtdGltZS9zcmMvZHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb21wb25lbnRzL2NhbnZhcy9jdHhjb21wb25lbnRzL2N0eENvbnRleHRTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvY29uc3RhbnRzL2Rhc2hib2FyZC5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvZGF0YS9kYXRhc291cmNlLmpzIiwid2VicGFjazovLy8uL34vZDNmYy1yYW5kb20tZGF0YS9idWlsZC9kM2ZjLXJhbmRvbS1kYXRhLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL34vcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9lcy91dGlscy93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL2NvbnN0YW50cy93aWRnZXRzLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb250YWluZXJzL2dyYXBoX3RlbXAuanN4Iiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb250YWluZXJzL21hcC5qc3giLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL2NvbnRhaW5lcnMvcmVhbHRpbWUuanN4Iiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb250YWluZXJzL3RvcG5hdi5qc3giLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL2hlbHBlcnMvbWF0aGZ1bmNzLmpzIiwid2VicGFjazovLy8uL34vZDMtcmFuZG9tL3NyYy9pcndpbkhhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kMy1yYW5kb20vc3JjL25vcm1hbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2ZvY3VzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9pcy1mdW5jdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vcHJvcC10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2VzL2NvbXBvbmVudHMvY29ubmVjdEFkdmFuY2VkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvZXMvY29ubmVjdC93cmFwTWFwVG9Qcm9wcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2VzL3V0aWxzL1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2VzL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vcmVkdXgtbG9nZ2VyL2xpYi9oZWxwZXJzLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvZXMvY29tcG9zZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2VzL2NyZWF0ZVN0b3JlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvZXMvdXRpbHMvd2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvTGF5b3V0LmpzeCIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvc3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL2NvbXBvbmVudHMvY2FudmFzL2NhcmRjdHguanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL2NvbXBvbmVudHMvY2FudmFzL2Nsb2NrLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb21wb25lbnRzL2NhbnZhcy9jdHhDaGFydC5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvY29tcG9uZW50cy9jYW52YXMvY3R4Z3JhcGhzLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb21wb25lbnRzL2NhbnZhcy9kZXBvc2l0YW10LmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb21wb25lbnRzL2NhbnZhcy9wb3NpdGlvblRpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL2NvbXBvbmVudHMvY2FudmFzL3NwcmVhZENUWC5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvY29tcG9uZW50cy9jYW52YXMvdHJlbmRsaW5lQ1RYLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb21wb25lbnRzL2Rhc2hib2FyZC9jaGFydF9jb250YWluZXIuanN4Iiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb21wb25lbnRzL2Rhc2hib2FyZC9oaXN0b3J5L2luZm9saS5qc3giLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL2NvbXBvbmVudHMvZGFzaGJvYXJkL2hpc3RvcnkvcG9zaXRpb252aWV3LmpzeCIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvY29tcG9uZW50cy9kYXNoYm9hcmQvaGlzdG9yeS9zdGF0c3RpbGVzLmpzeCIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvY29tcG9uZW50cy9kYXNoYm9hcmQvbGl2ZWdyYXBoL2Fza19iaWRfb3ZlcnZpZXcuanN4Iiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb21wb25lbnRzL2Rhc2hib2FyZC9saXZlZ3JhcGgvYnV5c2VsbC5qc3giLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL2NvbXBvbmVudHMvZGFzaGJvYXJkL2xpdmVncmFwaC9jYW52YXNjaGFydC5qc3giLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL2NvbXBvbmVudHMvZGFzaGJvYXJkL2xpdmV0aWNrZXJzLmpzeCIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvY29tcG9uZW50cy9kYXNoYm9hcmQvb3B0aW9ucy9hY3RpdmVzcHJlYWRzLmpzeCIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvY29tcG9uZW50cy9kYXNoYm9hcmQvb3B0aW9ucy9wb3NpdGlvblRpbGVzLmpzeCIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvY29tcG9uZW50cy9kYXNoYm9hcmQvb3B0aW9ucy93YXRjaGVkc3ByZWFkcy5qc3giLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL2NvbXBvbmVudHMvZGFzaGJvYXJkL3NpZGVvcHRpb25zLmpzeCIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvY29tcG9uZW50cy9kYXNoYm9hcmQvdHJhbnNhY3Rpb25saXN0LmpzeCIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvY29tcG9uZW50cy9kYXNoYm9hcmQvd2lkZ2V0YmxvY2suanN4Iiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb21wb25lbnRzL2Rhc2hib2FyZC93aWRnZXRzL2NoYXJ0d2lkZ2V0LmpzeCIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvY29tcG9uZW50cy9kYXNoYm9hcmQvd2lkZ2V0cy9mdWxsd2lkZ2V0LmpzeCIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvY29tcG9uZW50cy9kYXNoYm9hcmQvd2lkZ2V0cy9taW5pZ3JhcGguanN4Iiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb21wb25lbnRzL2Rhc2hib2FyZC93aWRnZXRzL3Byb2dyZXNzYmFycy5qc3giLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL2NvbXBvbmVudHMvZGFzaGJvYXJkL3dpZGdldHMvdGFibGUuanN4Iiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb21wb25lbnRzL2xvYWRlcnMvbG9hZGJhcnMuanN4Iiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb21wb25lbnRzL2xvYWRlcnMvc3BpbmxvYWQuanN4Iiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb21wb25lbnRzL21pY3JvL2xpc3RzL2ZvcmV4bGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvY29tcG9uZW50cy9taWNyby9saXN0cy9zb2NrbGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvY29tcG9uZW50cy9taWNyby9saXZlc3RhcnQuanN4Iiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb21wb25lbnRzL21pY3JvL3RpY2tlcnMvdGlja2NhcmQuanN4Iiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb21wb25lbnRzL21pY3JvL3RpY2tlcnMvdGlja2Vydmlldy5qc3giLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL2NvbXBvbmVudHMvbWljcm8vdGltZWludGVydmFscy5qc3giLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL2NvbXBvbmVudHMvc3ZnL3N0YXQuanN4Iiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb21wb25lbnRzL3N2Zy9zdGF0U1ZHLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb25zdGFudHMvcm91dGVzLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb25zdGFudHMvdHJhZGVzLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9jb25zdGFudHMvdHJhbnNhY3Rpb25zLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9kYXRhL2NvdW50cmllcy5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvZGF0YS9mb3JleF9zeW1ib2xfcGFpcnMuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL2RhdGEvZ29zeW1ib2xzLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9kYXRhL2dvd2Vic29ja2V0LmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9kYXRhL2luZGljYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL2RhdGEvc3RvY2tzLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9oZWxwZXJzL2dyYXBoX2NvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL2hlbHBlcnMvZ3JhcGhfaGVscGVyL2NoYXJ0cy5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvaGVscGVycy9ncmFwaF9oZWxwZXIvZGF0YV90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL2hlbHBlcnMvZ3JhcGhfaGVscGVyL2dyYXBoY29uZmlncy5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvcmVkdWNlcnMvZGFzaGJvYXJkUmVkdWNlci5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvcmVkdWNlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL3JlZHVjZXJzL3JvdXRlUmVkdWNlci5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvanMvcmVkdWNlcnMvdHJhZGVSZWR1Y2VyLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9qcy9yZWR1Y2Vycy90cmFuc2FjdGlvblJlZHVjZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL3JlZHVjZXJzL3dpZGdldFJlZHVjZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kMy1yYW5kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9kMy1yYW5kb20vc3JjL2JhdGVzLmpzIiwid2VicGFjazovLy8uL34vZDMtcmFuZG9tL3NyYy9leHBvbmVudGlhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2QzLXJhbmRvbS9zcmMvbG9nTm9ybWFsLmpzIiwid2VicGFjazovLy8uL34vZDMtcmFuZG9tL3NyYy91bmlmb3JtLmpzIiwid2VicGFjazovLy8uL34vZDMtdGltZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2QzLXRpbWUvc3JjL2RheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2QzLXRpbWUvc3JjL2hvdXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kMy10aW1lL3NyYy9taWxsaXNlY29uZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2QzLXRpbWUvc3JjL21pbnV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2QzLXRpbWUvc3JjL21vbnRoLmpzIiwid2VicGFjazovLy8uL34vZDMtdGltZS9zcmMvc2Vjb25kLmpzIiwid2VicGFjazovLy8uL34vZDMtdGltZS9zcmMvdXRjRGF5LmpzIiwid2VicGFjazovLy8uL34vZDMtdGltZS9zcmMvdXRjSG91ci5qcyIsIndlYnBhY2s6Ly8vLi9+L2QzLXRpbWUvc3JjL3V0Y01pbnV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2QzLXRpbWUvc3JjL3V0Y01vbnRoLmpzIiwid2VicGFjazovLy8uL34vZDMtdGltZS9zcmMvdXRjV2Vlay5qcyIsIndlYnBhY2s6Ly8vLi9+L2QzLXRpbWUvc3JjL3V0Y1llYXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kMy10aW1lL3NyYy93ZWVrLmpzIiwid2VicGFjazovLy8uL34vZDMtdGltZS9zcmMveWVhci5qcyIsIndlYnBhY2s6Ly8vLi9+L2QzZmMtcmViaW5kL2J1aWxkL2QzZmMtcmViaW5kLmpzIiwid2VicGFjazovLy8uL34vZGVlcC1kaWZmL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvY2FtZWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2h5cGhlbmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2lzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2lzVGV4dE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mb3ItZWFjaC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2dsb2JhbC93aW5kb3cuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaWdoY2hhcnRzL2hpZ2hzdG9jay5qcyIsIndlYnBhY2s6Ly8vLi9+L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vaW52YXJpYW50L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gtZXMvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gtZXMvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC1lcy9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC1lcy9fcm9vdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZS1oZWFkZXJzL3BhcnNlLWhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtaGlnaGNoYXJ0cy9SZWFjdEhpZ2hzdG9jay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2VzL2NvbXBvbmVudHMvUHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L2Nvbm5lY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L21hcERpc3BhdGNoVG9Qcm9wcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWFwU3RhdGVUb1Byb3BzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tZXJnZVByb3BzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9zZWxlY3RvckZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3ZlcmlmeVN1YnNlbGVjdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2VzL3V0aWxzL1N1YnNjcmlwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2VzL3V0aWxzL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4LWxvZ2dlci9saWIvY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4LWxvZ2dlci9saWIvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC1sb2dnZXIvbGliL2RpZmYuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC1sb2dnZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvZXMvYXBwbHlNaWRkbGV3YXJlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvZXMvYmluZEFjdGlvbkNyZWF0b3JzLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvZXMvY29tYmluZVJlZHVjZXJzLmpzIiwid2VicGFjazovLy8uL34vc3ltYm9sLW9ic2VydmFibGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvcG9ueWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi90cmltL2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi94aHIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi94dGVuZC9pbW11dGFibGUuanMiXSwibmFtZXMiOlsiQ2FudmFzMkRDb250ZXh0IiwiY2FudmFzIiwiY29udGV4dCIsImN0eCIsImdldENvbnRleHQiLCJwcm90b3R5cGUiLCJhcmMiLCJzZXR1cCIsImNhbGwiLCJtZXRob2RzIiwiZ2V0dGVyTWV0aG9kcyIsInByb3BlcnRpZXMiLCJtIiwibWV0aG9kIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJwIiwicHJvcCIsInZhbHVlIiwidW5kZWZpbmVkIiwiQUREX0NIQVJUIiwiQ0xPU0VfQ0hBUlQiLCJDSEFSVF9TVEFURV9VUERBVEUiLCJXQVRDSEVEX1BPU0lUSU9OUyIsIkZFRURfU1RBUlQiLCJPUFRTX1ZJRVciLCJTV0lUQ0hfSU5ESUNFUyIsIlRPR0dMRV9DSEFSVF9NRU5VIiwiQ09OTkVDVElPTl9MT1NUIiwiQ09OTkVDVEVEIiwiREFUQVNPVVJDRSIsImluc3RhbmNlTmFtZSIsImdldFJlYWxUaW1lWEhSIiwiY2IiLCJ4aHJHZXQiLCJnZXRMaXN0VHlwZVhIUiIsInBhcmFtIiwiY29uc29sZSIsImxvZyIsInJvdXRlIiwiZ2V0SW5kaWNhdG9yWEhSIiwiY291bnRyeSIsImdldE1hcmtldERhdGFYSFIiLCJzeW1ib2wiLCJ0b1VwcGVyQ2FzZSIsInRoZVVSTCIsInJlcXVlc3QiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJvbmxvYWQiLCJzdGF0dXMiLCJyZXNwIiwicmVzcG9uc2VUZXh0IiwiSlNPTiIsInBhcnNlIiwib25lcnJvciIsInNlbmQiLCJkYXRhIiwiYm9keSIsInN0cmluZ2lmeSIsInVyaSIsImhlYWRlcnMiLCJlcnIiLCJXSURHRVRfRFJPUCIsIldJREdFVF9EUkFHR0VEIiwiR09UX01FU1NBR0UiLCJHT1RfREFUQSIsIkdyYXBoIiwiUHVyZUNvbXBvbmVudCIsIk1hcCIsInByb3BzIiwiZ290RGF0YSIsInRoZURhdGEiLCJzZWMxIiwic2VjMiIsInJlZHVjZSIsIm9iIiwiaXRtIiwiaSIsInQiLCJkdGEiLCJyZWZzIiwicmVnaW9uU2VsZWN0Iiwic2V0U3RhdGUiLCJkYXRhQmxvYiIsImdldERhdGFDYWxsIiwiZGJTb3VyY2UiLCJjb3VudHJ5Q2hhbmdlIiwiZSIsImV4IiwidGFyZ2V0IiwiY29udGluZW50Q2hhbmdlIiwiY29udGluZW50IiwiZ2V0SW5kaWNhdG9yIiwiY250cnkiLCJjb3VudHJ5U2VsZWN0Iiwic3RhdGUiLCJjb3VudHJ5T3B0cyIsIm1hcCIsImlpIiwiQ2xvY2siLCJyZXF1aXJlIiwic2VsZWN0Iiwic3RvcmUiLCJydCIsInRyYWRlcyIsInRybiIsInRyYW5zYWN0aW9ucyIsIlJlYWxUaW1lIiwid2JDbG9zZWQiLCJldmVudCIsImRpc3BhdGNoIiwidHlwZSIsInBheWxvYWQiLCJjb25uZWN0ZWQiLCJkZXBvc2l0Q2hhbmdlZCIsImFtdCIsImRlcG9zaXQiLCJuZXdBbW91bnQiLCJNYXRoIiwicm91bmQiLCJ3aW5kb3ciLCJzaG93RGlmZiIsImFkZENoYXJ0TWVudSIsImNoYXJ0QWRkT3BlbiIsImNsb3NlQ3J0IiwiY2hydFN5bSIsImNoYXJ0TGlzdCIsInRvdGFsQ2hhcnRzIiwic3RhdGVVcGRhdGVzIiwiZmlsdGVyIiwic3ltYiIsInBsYXRmb3JtVmlldyIsInN3aXRjaEluZGljZXMiLCJpbmRleFR5cGUiLCJhbHJlYWR5U2VsZWN0ZWQiLCJzZXRTcHJlYWRSZWYiLCJzcHJlYWRDbnRybCIsInNwcmVhZFJlZiIsIm9wdFZpZXciLCJkYXNodmlldyIsIm9wdHNDb21wb25lbnQiLCJ0cmFkVmlld0NsYXNzIiwic2V0dGluZyIsImN1cnJlbnRDbGFzcyIsImluVmlldyIsIm91dFZpZXciLCJzZXREYXNoYm9hcmRMYXlvdXQiLCJvdXRPZlZpZXciLCJjYXJkQ3R4IiwicmVuZGVyQ2hhcnRzIiwiU3ZnQ0IiLCJpblZpZXdCb29sIiwiYmFja0luVmlldyIsImxpdmVGZWVkU3RhcnRlZCIsInN5bWJGZWVkIiwic2VyaWVzV2F0Y2giLCJwdXNoIiwiYWRkQnV0dG9uIiwiYWRkTmV3Q2hhcnQiLCJpbmRleCIsImNoYXJ0UG9zaXRpb25zIiwiY2hhcnRTdGF0ZXMiLCJrZXl5IiwicG9zaXRpb24iLCJ0b3RhbCIsImN1cnJlbnQiLCJtb2RhbE9wZW4iLCJkYXRhTGVuZ3RoIiwib25TdGFydCIsIm9wdHNPcGVuIiwiY2hhcnRUeXBlIiwibWFpblN5bWJvbCIsImNhbGxQdXQiLCJjb25jYXQiLCJuZXdTZXQiLCJyZW5kZXJDYW52YXNDaGFydHMiLCJjaGFydCIsImxlbmd0aCIsIm5ld1BvcyIsInBhc3NDVFhjb25zdHJ1Y3RvciIsImNhbnZhc1BsYWNlZCIsIm5ld1N5bWIiLCJ0cmFkZVBvc3Rpb25zIiwiT2JqZWN0IiwiYXNzaWduIiwidHJhZGVFeHBpcmVkIiwicG9zIiwicGFzdFRyYWRlcyIsImN1cnJlbnRQb3MiLCJ0b3RhbFJldiIsInRvZGF5VG90YWxOZXQiLCJud1BudCIsImdldExhdGVzdFBvaW50IiwiZGlmZiIsInVuaXRQcmljZSIsInF0eSIsIm5ld05ldCIsIm5ld0Rlb3Bvc2l0IiwibmV3Q3JudFBvcyIsImN0eGlkIiwicHN0VFJEIiwidm9sdW1lIiwiZGF0ZSIsIkRhdGUiLCJ0b0RhdGVTdHJpbmciLCJzaG9ydCIsInByaWNlc3RhcnQiLCJwcmljZWVuZCIsInByb2ZpdCIsInBvc0NUWGNudHJsIiwiY3R4Q2hhcnQiLCJwb3NFeHBpcmVkIiwidXBEYXRlIiwid2Vla2x5VHJhZGVDb3VudCIsInRvZGF5VHJhZGVDb3VudCIsIm5ld0N1cnJlbnRQb3MiLCJwb3NJZCIsImFkZE5ld1BvcyIsInNldFRpbWVvdXQiLCJ0aW1lIiwiY2FudmFzT3V0Iiwic2h1dGRvd24iLCJjb21wb25lbnREaWRNb3VudCIsIm9ub3BlbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbiIsImRldGFpbHMiLCJvbmNsb3NlIiwicmVhZHlTdGF0ZSIsInNlbGVjdFVsIiwidGRDbGFzcyIsIm9ubGluZVN0YXR1cyIsImJsb2NrU3RhcnQiLCJibG9ja2VkIiwiVG9wTmF2IiwiZ29TdGF0ZSIsInBhdGgiLCJjaGVja1BhdGgiLCJ0aGVDbGFzcyIsInBhdGhOYW1lIiwiTWF0aEZ1bmNzIiwiZ2V0RGlnaXRMZW4iLCJudW0iLCJhYnMiLCJMT0cxMEUiLCJuaWNlRmxvYXRzIiwicmVzIiwidG9GaXhlZCIsIl9hcHBseUxpc3RlbmVyIiwiaGlzdEZ1bmMiLCJoaXN0b3J5IiwicnYiLCJFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJyb3V0ZXMiLCJMYXlvdXQiLCJwdXNoU3RhdGUiLCJvbnBvcHN0YXRlIiwibmV3UGF0aCIsIlVybCIsImNvbXAiLCJyb3V0ZUNvbXBvbmVudHMiLCJ0b3BOYXYiLCJldmVudEhhbmRsZXIiLCJ0aGlzU2NvcGUiLCJwcCIsIkNvbXBvbmVudCIsImNvbXBvc2VkU3RvcmUiLCJhcmVhQ2hhcnRDb25maWciLCJheGlzWCIsInZhbHVlRm9ybWF0U3RyaW5nIiwidGlja0xlbmd0aCIsIm1hcmdpbiIsImxpbmVUaGlja25lc3MiLCJheGlzWSIsImdyaWRUaGlja25lc3MiLCJpbmNsdWRlWmVybyIsImdyaWRDb2xvciIsImludGVyYWN0aXZpdHlFbmFibGVkIiwiYmFja2dyb3VuZENvbG9yIiwid2lkdGgiLCJoZWlnaHQiLCJhbmltYXRpb25FbmFibGVkIiwibWFya2VyVHlwZSIsImdlbmVyYXRlRGF0YSIsInByIiwic3RhcnREYXRlIiwic3RhcnRQcmljZSIsIngiLCJ5IiwiY2xvc2UiLCJDYXJkQ3R4IiwiY2FsbEFsbCIsImNoYXJ0VmlldyIsImNvbmZpZyIsInByaWNlU2VlZCIsImZpbGxPcGFjaXR5IiwibGluZUNvbG9yIiwiY29sb3IiLCJkYXRhUG9pbnRzIiwicmVuZGVyIiwiQ2FudmFzSlMiLCJDaGFydCIsInByaWNlIiwidXBkYXRlIiwibmV3UG50Iiwic2hpZnQiLCJhc2tCaWQiLCJ1cFRyaWFuZ2xlIiwicHJuQ2huZyIsImJlZ2luUGF0aCIsInN0cm9rZVN0eWxlIiwiZmlsbFN0eWxlIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlIiwiZmlsbCIsImZvbnQiLCJ0ZXh0QWxpZ24iLCJmaWxsVGV4dCIsImRvd25UcmlhbmdsZSIsInBlcmNlbnRDaGFuZ2UiLCJsYXN0IiwiU3RyaW5nIiwic2xpY2UiLCJyZW5kZXJDaGFuZ2UiLCJwdXQiLCJjbGVhclJlY3QiLCJmbG9vciIsImNlaWwiLCJzZXRDYXJkIiwiY2FyZElkIiwiYyIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJwb2ludFN0cmVhbSIsInN0cmVhbSIsIm5leHQiLCJzdGFydCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImhpZ2giLCJsb3ciLCJzdGFydExvb3AiLCJiaW5kIiwidGhpc0NhcmQiLCJmb3JFYWNoIiwidE8iLCJyYW5kb20iLCJnZXRWaWV3IiwiY2xvY2siLCJjaGVja1RpbWUiLCJ0aW1lciIsImN0eElkIiwic3RhcnRUaW1lIiwidG9kYXkiLCJoIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwicyIsImdldFNlY29uZHMiLCJ0bSIsInNldENsb2NrIiwibW9kdWxlIiwiZXhwb3J0cyIsInRyZW5kTGluZUNyZWF0ZSIsImxpbmVEYXRhVHJhbnNmb3JtIiwibG4iLCJvaGxjRGF0YVRyYW5zZm9ybSIsIkN0eENvbnRyb2xsZXIiLCJDdHhDaHJ0Iiwic3ltYmwiLCJjaGFydFNldHRpbmdzIiwiY1QiLCJzZXRUeXBlIiwidHlwZXMiLCJkYXRhRnVsbCIsImxhc3RYdmFsIiwiVHJlbmRMaW5lIiwiZnVsbERhdGFQb2ludHMiLCJhWCIsImxhYmVsRm9udFNpemUiLCJhWSIsIm1pbmltdW0iLCJzZXRBeE1pbk1heCIsIm1heGltdW0iLCJnZXRUaW1lIiwic2V0QmFjayIsInNldEF4TWluTWF4MiIsImxlbiIsInZpZXdwb3J0TWluaW11bSIsInZpZXdwb3J0TWF4aW11bSIsImNoYXJ0Q29uZmlncyIsImFyZWEiLCJtYXJrZXJTaXplIiwiY3Vyc29yIiwiYXhpc1lUeXBlIiwibGluZSIsIm9obGMiLCJyaXNpbmdDb2xvciIsImNhbmRsZXN0aWNrIiwibWFrZVNlcmllcyIsImNoYXJ0Q29uZmlnIiwic2VyaWVzIiwidGl0bGUiLCJ0ZXh0IiwiZm9udENvbG9yIiwiZm9udFNpemUiLCJ2ZXJ0aWNhbEFsaWduIiwiaG9yaXpvbnRhbEFsaWduIiwidG9vbFRpcCIsImVuYWJsZWQiLCJheGlzWTIiLCJzZXRUcmVuZExpbmVDQiIsImxpbmVTaGlmdCIsImNhbGxQdXRMaW5lcyIsInJlY3RCc2V0Q29sb3IiLCJtb2RpZnlTZXJpZXMiLCJ0eUNoYW5nZSIsInNsaWNlVG8iLCJhMSIsImxpbmVDaGFydHMiLCJwb2ludCIsInhWYWwiLCJsbkNvbG9yIiwibGFzdFZhbCIsIm1pbiIsIm9obGNDaGFydHMiLCJsYXN0UG9pbnQiLCJkYXRhU3RyZWFtIiwiY2hhbmdlUmVjdENvbG9yIiwidXNlU29saWRzIiwicmVjdEJzZXQiLCJhZGRTZXJpZXMiLCJzeW0iLCJnZXRUcmVuZExpbmVDbnRybCIsInRpbWVzdGFtcCIsInJlbW92ZVNlcmllcyIsImdldENoYXJ0VHlwZSIsImNoYW5nZURhdGFMZW5ndGgiLCJDdHhDaGFydCIsIm1ha2VHcmFwaCIsImNoYXJ0SWQiLCJhbmltYXRpb25EdXJhdGlvbiIsInJlbmRlckNoYXJ0IiwibmV3RGF0YSIsInRvdGFsQW1vdW50Q3R4IiwiY2FzaCIsInN0YXJ0QW10IiwiY3R4RmlsbCIsInVuaXQiLCJvZ1ZhbHVlIiwibmV3VmFsdWUiLCJ2YWx1ZXMiLCJvZ0NQWSIsIm5ld1ZsIiwiQ3VycmVudFBvc2l0aW9ucyIsInBlcmNlbnRDaG5nZSIsInNpZ24iLCJnZXRUaW1lTGVmdCIsImQiLCJwYXJzZUludCIsInJlbmRlckFycm93IiwidXBBcnJvdyIsInN0YXJ0VGltZXIiLCJkdXJhdGlvbiIsInByYyIsImNoYW5nZSIsInRpbWVMZWZ0IiwiUG9zdGlvblRpbGUiLCJleHBpcmVUaW1lIiwic2V0VGltZXIiLCJub3dUaW1lIiwic2V0VGlsZSIsIlBvc2l0aW9uVGlsZXMiLCJzZWVkcyIsInNwcmVhZENUWCIsIlRpY2tlcnMiLCJhY3RpdmVTeW1ib2xzIiwiaGFzUmVuZGVyZWQiLCJjdHhIZWlnaHQiLCJjYW5SZW5kZXIiLCJ0eXBlU2V0dGluZyIsImN1cnJlbnRUaWNrcyIsInR3b0RlYyIsInZhbCIsInJlbmRlclJvdyIsImF0UG9zIiwiYXNrIiwiYmlkIiwidGV4dFBvcyIsImNvbG9yTnBlcmNlbnQiLCJmaWxsUmVjdCIsInJlbmRlckxpdmUiLCJzeW1JdG0iLCJjYWxsUm91bmQiLCJyZW5kZXJTcHJlYWQiLCJyZW5kZXJVbml0IiwidG9wUG9zIiwidXRUaWNrIiwibmV3VGlja2VyIiwicmVuZGVyRGVsYXkiLCJhdERleCIsInRpY2tTeW1iIiwiY3VycmVudFBvaW50IiwidGlja0luZGV4IiwibG9nRGF0YSIsInRoaXNJbmRleCIsImdlbmVyYXRvciIsInAxcyIsInAycyIsImxhc3Rwb2ludCIsImFza1ZvbCIsImJpZFZvbCIsInN0YXJ0cG9pbnQiLCJwMSIsImJpZFZsIiwic2VlZFNwcmVhZCIsInNwcmVhZEludGVyZmFjZSIsInRwIiwidHJlbmRMaW5lMiIsImNvbnRhaW5lciIsInF1ZXJ5U2VsZWN0b3IiLCJjbGllbnRIZWlnaHQiLCJjbGllbnRXaWR0aCIsInRoZVdpZCIsInRoZUhlaWdodCIsInRoZVkiLCJnbG9iYWxBbHBoYSIsImxpbmVXaWR0aCIsInRyZW5kTGluZSIsImN0eDIiLCJ0cmVuZExpbmVDb2xvciIsIm9wZW5Qb3MiLCJMaW5lU2hpZnQiLCJjbG9zZVBhdGgiLCJDYWxsUHV0TGluZXMiLCJjb252ZXJ0ZXIiLCJ0aGVDb2xvciIsInNldExpbmVEYXNoIiwic3RhbXAiLCJuZXdDb2xvciIsIkNoYXJ0Q29udGFpbmVyIiwiY2hhcnRRbnR5IiwiY29udGFpbmVyQ2xhc3NOYW1lIiwiY2hpbGRyZW4iLCJwZXJjZW50Q2hhbmdlMiIsImFycm93IiwicHJuY3QiLCJyZXR1cm5MaUNsYXNzIiwiYW5pbWF0ZSIsImFjdGl2ZSIsIkluZm9MaSIsIndoZW5DbGlja2VkIiwiY2xpY2tlZCIsImFkZFN0eWxlIiwibGlDbGFzcyIsImFuaSIsInBlcmNlbnRhZ2UiLCJhbmltYXRpb24iLCJwb3N0aXZlQ2hhbmdlIiwibmVnYXRpdmVDaGFuZ2UiLCJQb3NpdGlvblZpZXciLCJjdXJyZW50UHJvZml0IiwiR3JhcGhDb250cm9sbGVyIiwidXBkYXRlUG9zUHJvcHMiLCJjcmVhdGVDaGFydHMiLCJ1cGRhdGVDaGFydHMiLCJzdmcxIiwicGx1c1ZhbHVlIiwiYnVmZmVyIiwiZG9tRWxlbSIsImZpbGxDaGFuZ2UiLCJsYXN0VmFsdWUiLCJuYW1lIiwic3ZnMiIsInN2ZzMiLCJzdmc0Iiwic3ZnNSIsIlN0YXRUaWxlcyIsInRyYWRlUHJvcHMiLCJBc2tCaWRPdmVydmlldyIsInZhbEluZGV4IiwidGltZUV4cGlyZXMiLCJpc251bGwiLCJwb3NWYWx1ZSIsIkNhbGxQdXQiLCJ0b2dnbGVNZW51QmlkIiwidGltZVNldCIsIm1haW5TeW0iLCJxbnR5IiwiYmlkT3BlbiIsImFza09wZW4iLCJ0aW1lTWVudU9wZW4iLCJ0b2dnbGVNZW51QXNrIiwic2V0UG9zVGltZSIsInBvc1NldCIsImJpZE9yQXNrIiwicG9zTnVtIiwiZXhwaXJlcyIsIm5vdyIsInRvU3RyaW5nIiwiY2xvc2VNb2RhbCIsImJpZEJ0bkNsYXNzIiwicHV0QnRuQ2xhc3MiLCJtZW51U2V0IiwicGx1c01pbnVzIiwiYnRuUHRucHVzaCIsImJvb2wiLCJidG4iLCJtZW51dHlwZSIsImNsb2NrQ3R4IiwidGltZXJJZCIsImNhbGNUaW1lRXhwaXJlcyIsImNoYXJ0T3B0cyIsIkNhbnZhc0NoYXJ0IiwiZGlzcGF0Y2hDaGFuZ2UiLCJjaGFydFN5bWJvbCIsInRvZ2dsZU1vZGFsIiwidG9nZ2xlU2V0cyIsImRlcENoZyIsImhpZGVVTCIsImxpdmVVcGRhdGUiLCJjaGFydFR5cGVTZWwiLCJjbGFzc05hbWUiLCJwYXJlbnRFbGVtZW50IiwiZGF0YXNldCIsImNsb3NlQ2hhcnQiLCJmZWVkRXhpdCIsImNsQ3R4IiwiZGF0YVNvdXJjZSIsImZlZWRXYXRjaCIsInN5bWJDaGFydCIsIndoZW5Nb3VudGVkIiwiY2hhcnRUeXBlTGlzIiwiY2xOYW1lIiwibGwiLCJMaXZlVGlja2VycyIsImNhcmRQb3N0aW9uQ2xpY2siLCJpbmQiLCJsZWZ0Q2FyZCIsImhvdmVyZWRDYXJkIiwidXBkYXRlVmlld2VkIiwiY2FyZGxpc3QiLCJ3aGVuRHJvcCIsImNhcmRTeW1ib2wiLCJhcHBseU91dEFuaSIsImRyYWdnZWRDYXJkIiwidmlld2VkVGlja2VyIiwiY2FyZERyYWdTdGFydCIsImRyYWdPdmVyQ2FyZCIsInNpZGVFbnRlciIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwic2lkZUxlYXZlIiwiZHJhZ0xlZnRDYXJkIiwib25EcmFnT3ZlciIsInNpZGVEcm9wIiwiZHJvcEhhbmRsZSIsImRyYWdnZWRTeW1iIiwiY2FyZGxzdCIsIm9iYiIsImRyYWdFbnRlciIsImNhcmREcm9wcGVkIiwiZHJhZ0xlYXZlIiwidGlja0NhcmRzIiwiQWN0aXZlU3ByZWFkcyIsIkNUWHNwcmVhZCIsInRyYWNrZWRCaWRzIiwib25WaWV3IiwiY2FsbENUIiwiUG9zaXRpb25UaWxlIiwicG9zVGlsZUNUWCIsIldhdGNoZWRTcHJlYWRzIiwiY3VycmVudEJsb2NrcyIsImFjdGl2ZVBvc0xpc3QiLCJwb3NDVFgiLCJTaWRlT3B0aW9ucyIsIm9wdGlvblZpZXciLCJpdG1WaWV3IiwiVHJhbnNhY3Rpb25MaXN0IiwicG9zdGlvbkNsaWNrIiwiZmlyc3RDbGFzcyIsImFjdGl2ZUluZGV4IiwicGFzdFRyYWRlTGlzdCIsIndpZGdldHMiLCJXaWRnZXRCbG9jayIsInVwZGF0ZVdpZGdldCIsImdldE1lc3NhZ2UiLCJtZXNzIiwid2lkIiwibmV3V2FpdCIsIndpZGdldE51bSIsImRyYWdnZWRXaWRnZXQiLCJzdGF0ZUNvcHkiLCJXaWRnZXRMaXN0IiwiaGFuZGxlRHJhZ0V2Iiwid2lkZ2V0IiwibmVlZHNVcGRhdGUiLCJuZWVkc1VwZGF0ZUtleSIsInJlc3VsdHMiLCJjb250ZW50Iiwia2V5cyIsInJvd1RvcFN0eWxlIiwicm93QnRtU3R5bGUiLCJ3aWRnZXQxIiwid2lkZ2V0MiIsIndpZGdldDMiLCJ3aWRnZXQ0Iiwic2hvd24iLCJjbFR5cGUiLCJSZWFjdEhpZ2hzdG9jayIsIkNoYXJ0V2lkZ2V0IiwibnVsbERhdGEiLCJkYXRhR2VuIiwiZ3JhcGhUeXBlIiwiZGF0YVRyYW5zZm9ybSIsImNvbnRlbnREYXRhIiwiRnVsbFdpZGdldCIsImhhbmRsZURyYWciLCJ3aGVuRHJhZyIsIndkIiwicGFzc01lc3NhZ2UiLCJtcyIsImdyYXBoIiwiY2hhcnRpZCIsInRhYmxlIiwiZ3JhcGhqcyIsInByb2dyZXNzIiwiY2FuZHJhZyIsImtpbmQiLCJNaW5pR3JhcGgiLCJQcm9ncmVzc0JhcnMiLCJ3aWR0aDY2Iiwid2lkdGg0NSIsIndpZHRoMjUiLCJ3aWR0aDMiLCJ3aWR0aDEiLCJUYWJsZSIsIkxvYWRCYXJzIiwiTG9hZENvbm5lY3QiLCJGb3JleExpc3QiLCJleGNoYW5nZUNoYW5nZSIsImV4Y2hhbmdlIiwiaGFuZGxlU3RhcnQiLCJzdGFydENoYXJ0IiwiZmVlZFN5bWJvbCIsInVzZWQiLCJpblVzZSIsIlJlZ0V4cCIsImpvaW4iLCJsaXN0IiwidGVzdCIsIlN0b2NrTGlzdCIsImV4Y2hhbmdlT3B0cyIsImNoYW5nZUV4Y2hhbmdlIiwiTGl2ZVN0YXJ0IiwiVGlja0NhcmQiLCJkcmFnU3RhcnQiLCJtb3VzZVVwIiwiY2FyZENUWCIsImFwcGx5T3V0IiwiVGlja2VyVmlldyIsInRpbWVVbml0Iiwic2V0SW5kZXgiLCJkaXNwbGF5Q2xhc3MiLCJUaW1lSW50ZXJ2YWxzIiwidGltZUxpc3QiLCJjYWxjWCIsIm51bWJlciIsImFuaW1hdGVTdGF0IiwiU3RhdCIsInN2ZyIsInN2Z0lkIiwidGhlU1ZHIiwic2V0UmVmIiwiY2xhc3NUeXBlIiwiZmlsbENvbG9yIiwic3RhdFNWR3MiLCJTdmdDYWxsQmFja3MiLCJzaG91bGRBbmltYXRlIiwic3ZnUmVwZWF0Iiwic3ZnRWxtIiwiZmlsbENobmciLCJzZXRBdHRyaWJ1dGUiLCJ0ZXh0Q29udGVudCIsIm51bVN0cmluZyIsInh4Iiwic3ZnQW5pbWF0ZSIsInN2Z09iIiwiaW5jIiwic3ViIiwiY3VTVkciLCJORVdfUEFUSCIsIkZFVENIX1RSQURFUyIsIkZFVENIX1RSQURFU19SRUpFQ1RFRCIsIkZFVENIX1RSQURFU19GVUxGSUxMRUQiLCJERVBPU0lUX0NIQU5HRSIsIkFERF9UUkFERSIsIlRSQURFX0NPTVBMRVRFIiwiQUREX01PTkVZIiwiQ291bnRyaWVzIiwiQU1FUklDQSIsIkVVUk9QRSIsIkFGUklDQSIsIkFTSUEiLCJmb3JleFN5bWJvbFBhaXJzIiwic3RvY2tTeW1icyIsInNvcnQiLCJueXNlIiwiZXhjaGFuZ2VTeW1icyIsInVzZWRJdG1zIiwibmFzZGFxT3B0aW9ucyIsInN5bWJzIiwibnlzZU9wdGlvbnMiLCJOQVNEQVEiLCJOWVNFIiwidXJsQmFzZSIsIk9wZW5XZWJzb2NrZXQiLCJ0aGVTb2NrZXRVcmwiLCJsb2NhdGlvbiIsInByb3RvY29sIiwiU09DS0VUIiwiV2ViU29ja2V0Iiwid2F0Y2hlZEZlZWRzIiwiY2FsbGJhY2siLCJvbm1lc3NhZ2UiLCJJbmRpY2F0b3JzIiwibmFzU3ltYnMiLCJueXNlU3ltYnMiLCJuYXNkYXFPcHRzIiwibnlzZU9wdHMiLCJleGNoYW5nZU9wdGlvbnMiLCJhc2tCaWRWb2x1bWUiLCJ2MSIsInYyIiwibWF4IiwicG9zUHJvcHMiLCJkb251dENoYXJ0IiwibWFrZUNoYXJ0IiwicmF0aW9EYXRhIiwiYmFja2dyb3VuZCIsIm1zQW5pIiwiY29tYm9DaGFydCIsIm1ha2VDb21ib0NoYXJ0IiwiYVltaW4iLCJsZWdlbmRUZXh0IiwiZ2VuRGF0YSIsInZpZXdDbnRybCIsImdldFJhbmRvbURhdGEiLCJzZWVkRGF0ZSIsImRvbnV0Q29uZmlnIiwibGVnZW5kIiwic3RhcnRBbmdsZSIsImNvbHVtbkNvbmZpZyIsInJhbmdlQXJlYUNvbmZpZyIsInBsYWluTXVsdGlTZXJpZXMiLCJzZXR0aW5ncyIsInZvbHVtZUFuZFJhbmdlIiwidGhlTWluIiwidGhlTWF4IiwicG9pbnRzIiwicmFuZ2UiLCJjb2xDb2xvciIsImNvbHVtbiIsImNvbHVtbnMiLCJtaW5NYXgiLCJraW5kQ29uZmlnIiwidGhlSWQiLCJ0aGVTZXR0aW5ncyIsInRoZUNvbmZpZyIsIm5ld2RhdGEiLCJkYXRhU2V0cyIsImNoYXJ0TWFrZXIiLCJjYW5kbGVTdGljayIsInNwbGluZSIsImNvbHVtbnJhbmdlIiwiaGlnaHQiLCJzdGVwIiwiY2FuZGxlc3RpY2tDb25maWciLCJyYW5nZVNlbGVjdG9yIiwic2VsZWN0ZWQiLCJkYXRhR3JvdXBpbmciLCJ1bml0cyIsIm9obGNDb25maWciLCJhbGlnblRpY2tzIiwiY29sdW1uUmFuZ2VDb25maWciLCJsaW5lQ29uZmlnIiwidG9vbHRpcCIsInZhbHVlRGVjaW1hbHMiLCJhcmVhQ29uZmlnIiwic3RlcENvbmZpZyIsInNwbGluZUNvbmZpZyIsInN0YWNrQ29sdW1uQ29uZmlnIiwieEF4aXMiLCJjYXRlZ29yaWVzIiwieUF4aXMiLCJzdGFja0xhYmVscyIsInN0eWxlIiwiZm9udFdlaWdodCIsImhlYWRlckZvcm1hdCIsInBvaW50Rm9ybWF0IiwiYWxpZ24iLCJmbG9hdGluZyIsImJvcmRlckNvbG9yIiwiYm9yZGVyV2lkdGgiLCJzaGFkb3ciLCJwbG90T3B0aW9ucyIsInN0YWNraW5nIiwiZGF0YUxhYmVscyIsInRleHRTaGFkb3ciLCJtdWx0aUNvbmZpZyIsInNlcmllc09wdGlvbnMiLCJsYWJlbHMiLCJmb3JtYXR0ZXIiLCJwbG90TGluZXMiLCJjb21wYXJlIiwiZ3JhcGhDb25maWdzIiwibXVsdGljb25maWciLCJyb290IiwicmVkdWNlciIsImlubml0aWFsU3RhdGUiLCJhY3Rpb24iLCJDaGFuZ2VVcmwiLCJ1cmwiLCJvYmoiLCJUaXRsZSIsImFsbFBhdGhzIiwiYWxsVGl0bGVzIiwicGF0aFJlZHVjZXIiLCJwYXRoSVMiLCJxIiwiZ2V0VG9wTmF2IiwiaW5pdGlhbFBhdGgiLCJwYXRobmFtZSIsIm5ldFBvc1RyYWRlcyIsInRvdGFsVm9sdW1lIiwibmV0TmVnVHJhZGVzIiwibW9uZXlBdmFsaWFibGUiLCJmZXRjaGluZyIsImZldGNoZWQiLCJlcnJvciIsImR5bmFtaWMiLCJyb3dUb3AiLCJjb21wcyIsInJvd0J0bSIsIm92ZXJXaWRnZXQiLCJjb2xUeXBlIiwiaG9sZFR5cGUiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJC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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7O0FBRTVELENBQUM7Ozs7Ozs7Ozs7O0FDaFBEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFF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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7OztBQ2hTQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7O0FDbEVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7Ozs7O0FDYkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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b0M7O0FBRXBDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7Ozs7Ozs7Ozs7O0FDZEE7QUFDcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOzs7Ozs7Ozs7O0FDaEJBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekJBO0FBQ3VCOztBQUV2QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOzs7Ozs7Ozs7O0FDZEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOzs7Ozs7Ozs7OztBQ2RBO0FBQ3VCOztBQUV2QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOzs7Ozs7Ozs7OztBQ2RBO0FBQ29COztBQUVwQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOzs7Ozs7Ozs7OztBQ2RBO0FBQ3FCOztBQUVyQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOzs7Ozs7Ozs7OztBQ2RBO0FBQ3VCOztBQUV2QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOzs7Ozs7Ozs7O0FDZEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNkQTtBQUNxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUM1QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekJBO0FBQ3FDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQzVCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOzs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxDQUFDLDRCQUE0Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGFBQWE7QUFDcEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsdUZBQXVGLGFBQWE7QUFDcEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQsZ0VBQWdFO0FBQzdIOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsNEZBQTRGLGFBQWE7QUFDekc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRSxnRUFBZ0U7QUFDM0k7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0EseUVBQXlFLGFBQWE7QUFDdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQ7QUFDQSx5RUFBeUUsYUFBYTtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7O0FBRTVELENBQUM7Ozs7Ozs7OENDNUpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQUE7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxRQUFRO0FBQ3RGO0FBQ0EsNkVBQTZFLFFBQVE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2QkFBNkI7QUFDN0IsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEI7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQzdoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QixhQUFhLEVBQUU7QUFDZixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QixhQUFhLEVBQUU7QUFDZixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLHNCQUFzQjs7QUFFdEI7QUFDQSxrQkFBa0I7QUFDbEIsZUFBZTtBQUNmLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2IsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsaUJBQWlCLGtDQUFrQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsaUJBQWlCLEVBQUU7QUFDckMseUJBQXlCLHdCQUF3QixFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFdBQVc7QUFDdEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlOztBQUVmO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0tBQWtLLHlDQUF5QztBQUMzTTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0RBQWtEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHlDQUF5QztBQUN6QyxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4TUFBOE07QUFDOU07QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQsbUJBQW1CO0FBQ2hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzRkFBc0YsYUFBYTtBQUNuRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsZUFBZTtBQUMzRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEIsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4S0FBOEssWUFBWTtBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVMQUF1TCwrQkFBK0I7QUFDdE47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrSkFBK0osaUJBQWlCO0FBQ2hMLE9BQU87QUFDUCwrSkFBK0osaUJBQWlCLHdEQUF3RCxtQkFBbUIsZ0JBQWdCLDhCQUE4QjtBQUN6UztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBJQUEwSSxtQkFBbUIsZ0JBQWdCLDhCQUE4QjtBQUMzTSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0RBQXNELGVBQWU7QUFDckUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakMsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7O0FDamllQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsY0FBYyw0REFBNEQsb0ZBQW9GLElBQUksMkRBQTJELDRIQUE0SCw2QkFBNkIsZ0JBQWdCLFNBQVM7QUFDL1ksUUFBUSw4SkFBOEosaUJBQWlCO0FBQ3ZMLFFBQVEsMExBQTBMLDJCQUEyQiwrQkFBK0IsMkJBQTJCLDJCQUEyQixnQkFBZ0Isc0NBQXNDLDZCQUE2QixHQUFHO0FBQ3hZLHNRQUFzUSxvRkFBb0YsNENBQTRDLGlEQUFpRCw2Q0FBNkMsVUFBVTtBQUM5ZSxpQkFBaUIsaUdBQWlHLHFCQUFxQixpQkFBaUIsZ01BQWdNLG9FQUFvRSxrQkFBa0IsZUFBZTtBQUM3Yix3TEFBd0wsWUFBWTtBQUNwTSxtS0FBbUssb0JBQW9CLHNGQUFzRixxQkFBcUIsb0JBQW9CLDZDQUE2QztBQUNuVywrQkFBK0IsbUNBQW1DLGdGQUFnRixLQUFLLFlBQVksNkRBQTZELG9CQUFvQiw4R0FBOEcseUJBQXlCO0FBQzNYLDRDQUE0QyxxQkFBcUIsZUFBZTtBQUNoRix5c0NBQXlzQztBQUN6c0MsSUFBSSxtQkFBbUIsMEJBQTBCLEVBQUUsK0JBQStCO0FBQ2xGLE9BQU8sdUZBQXVGLDZCQUE2Qiw0REFBNEQsNEJBQTRCLG1EQUFtRCxzQkFBc0IscUVBQXFFLDhDQUE4Qyx1QkFBdUIsMkJBQTJCO0FBQ2pjLElBQUksK0JBQStCLDZCQUE2QiwyQkFBMkIseUJBQXlCLDZCQUE2QixzQkFBc0IscUJBQXFCLG9CQUFvQixxQkFBcUIsU0FBUyxXQUFXLCtCQUErQixxQkFBcUIsb0JBQW9CLDhDQUE4QyxJQUFJLGFBQWEsU0FBUztBQUN6WSxjQUFjLHVCQUF1QixzQkFBc0IscUJBQXFCLHNCQUFzQixVQUFVO0FBQ2hILGNBQWMsdUJBQXVCLDRCQUE0QixzQkFBc0IsV0FBVyxpQ0FBaUMsUUFBUSxlQUFlLGdCQUFnQixhQUFhLG1CQUFtQixzQ0FBc0MsUUFBUSxnQ0FBZ0MsTUFBTSw2Q0FBNkMsS0FBSywrREFBK0Q7QUFDL1ksbUJBQW1CLHdCQUF3QixRQUFRLG1DQUFtQyxlQUFlLE1BQU0sT0FBTyxlQUFlLG1CQUFtQixpQ0FBaUMsS0FBSyxlQUFlLFdBQVcsbUNBQW1DLFdBQVcsd0VBQXdFO0FBQzFVLHNCQUFzQix1TEFBdUwsMEJBQTBCLHFCQUFxQiwwQkFBMEIsc0JBQXNCLHdEQUF3RDtBQUNwVyxpQkFBaUIsdUJBQXVCLG9CQUFvQixxQkFBcUIsK0NBQStDLFVBQVUsU0FBUyw0Q0FBNEMsbUJBQW1CLCtDQUErQztBQUNqUSxpQkFBaUIsTUFBTSxrREFBa0QsZ0NBQWdDLHNDQUFzQyxzQkFBc0Isb0JBQW9CLDBCQUEwQiwwQkFBMEIsNENBQTRDLGVBQWUsZ0JBQWdCLGVBQWUsZ0JBQWdCLFFBQVE7QUFDL1YsaUJBQWlCLGtCQUFrQixrQkFBa0IsWUFBWSxrQkFBa0IsT0FBTyxZQUFZLGtUQUFrVCxLQUFLLFFBQVEsYUFBYSxpQkFBaUI7QUFDbmMsU0FBUyxxQkFBcUIsY0FBYyxZQUFZLEtBQUssWUFBWSw2Q0FBNkMsU0FBUyxlQUFlLGlCQUFpQixlQUFlLFNBQVMsUUFBUSxrRUFBa0Usc0JBQXNCLG1GQUFtRjtBQUMxVyxlQUFlLG9CQUFvQixhQUFhLE1BQU0sMENBQTBDLGlCQUFpQixvQkFBb0IsaUNBQWlDLEtBQUssWUFBWSxjQUFjLFNBQVMsZUFBZSwyQ0FBMkMsUUFBUSxlQUFlO0FBQy9SLHNCQUFzQixnQ0FBZ0MsT0FBTywrREFBK0QsT0FBTyxzQ0FBc0MsdUZBQXVGLFNBQVMsRUFBRSxlQUFlLGlCQUFpQixvQkFBb0IsZ0JBQWdCLG1CQUFtQixhQUFhLEVBQUUsbUJBQW1CLGVBQWUsTUFBTSxzQkFBc0IsUUFBUSxXQUFXO0FBQ2xjLG1CQUFtQix1SkFBdUosZUFBZSxvRUFBb0UsZUFBZSxnREFBZ0Qsb0JBQW9CLGVBQWU7QUFDL1YsbUJBQW1CLHdMQUF3TCxlQUFlLCtEQUErRCxlQUFlO0FBQ3hTLHFCQUFxQixXQUFXLFFBQVEsb0JBQW9CLEVBQUUsWUFBWSxJQUFJLFlBQVksRUFBRSxZQUFZLEtBQUssTUFBTSxhQUFhLEtBQUssTUFBTSxhQUFhLEtBQUssSUFBSSxFQUFFLGtDQUFrQyxRQUFRLFFBQVEsT0FBTyxZQUFZLElBQUksU0FBUyxTQUFTLEVBQUUsY0FBYyx5QkFBeUIsVUFBVSxRQUFRLFNBQVMsU0FBUyxFQUFFLGNBQWMseUJBQXlCLFVBQVUsUUFBUSxRQUFRLFdBQVcseUJBQXlCLGVBQWUsTUFBTTtBQUN2YyxzQkFBc0IsbUZBQW1GLFNBQVMsMEVBQTBFLFVBQVUsVUFBVSxjQUFjLDBGQUEwRixVQUFVLE9BQU87QUFDelUsY0FBYywwQ0FBMEMsb0RBQW9ELFFBQVEsaUJBQWlCLEtBQUssVUFBVSxRQUFRLHNCQUFzQixLQUFLLDBDQUEwQyx1QkFBdUIsY0FBYztBQUN0USw2SUFBNkkseUhBQXlILCtCQUErQjtBQUNyUyxvQkFBb0Isc0JBQXNCLG1CQUFtQixtQkFBbUIsNkJBQTZCLG9HQUFvRyw4SEFBOEgsNkNBQTZDO0FBQzVYLGVBQWUsMEJBQTBCLHlCQUF5Qix1QkFBdUIsd0lBQXdJLDRCQUE0Qix1QkFBdUIsOElBQThJLG9CQUFvQixvQ0FBb0M7QUFDMWQsc0JBQXNCLG1DQUFtQyx3QkFBd0IsUUFBUSxZQUFZLHNCQUFzQixFQUFFLGVBQWUsNkJBQTZCLGNBQWMsMkJBQTJCLFlBQVksaUJBQWlCLGNBQWMsMEJBQTBCLGdCQUFnQixtQkFBbUIsaUNBQWlDLE9BQU8sTUFBTSxxQkFBcUIsMEJBQTBCLDJCQUEyQixxQkFBcUIsU0FBUztBQUNoZCxlQUFlLGtDQUFrQyxlQUFlLGlEQUFpRCxlQUFlLGVBQWUsZUFBZSxhQUFhLHFCQUFxQiw0QkFBNEIsbUJBQW1CLFVBQVUsRUFBRSxxQkFBcUIsNEJBQTRCLG1CQUFtQixVQUFVLEVBQUUsd0VBQXdFLG1FQUFtRTtBQUN0ZCw4Q0FBOEMsb0JBQW9CO0FBQ2xFLGlGQUFpRixhQUFhLHlCQUF5Qix3REFBd0QsNEVBQTRFLGlCQUFpQix5QkFBeUIsOERBQThELGtHQUFrRyxtQkFBbUIseUJBQXlCO0FBQ2pmLHFDQUFxQyxvR0FBb0csb0JBQW9CLHlCQUF5QixvRUFBb0Usc0dBQXNHO0FBQ2hXLGlCQUFpQixVQUFVLGlEQUFpRCx5Q0FBeUMsK0RBQStELGtCQUFrQixlQUFlLFdBQVcsa0RBQWtELFVBQVUsaUJBQWlCLFVBQVUsc0NBQXNDLCtDQUErQyxNQUFNLFVBQVUsc0RBQXNEO0FBQ2xkLGlCQUFpQiw0SEFBNEgsVUFBVSw0QkFBNEIsOEVBQThFLHlDQUF5QywrQ0FBK0MsWUFBWSwrQ0FBK0M7QUFDcFosUUFBUSw4Q0FBOEMsTUFBTSxTQUFTLFVBQVUscURBQXFELFFBQVEsNkNBQTZDLFFBQVEsbURBQW1ELFFBQVEsU0FBUyxrR0FBa0c7QUFDdlcsbURBQW1ELG9GQUFvRixhQUFhLHlCQUF5QixlQUFlLFlBQVksa0VBQWtFLHNCQUFzQixpREFBaUQsUUFBUSwrQ0FBK0MsT0FBTyxlQUFlO0FBQzlaLGNBQWMsT0FBTyxjQUFjLFdBQVcsTUFBTSxhQUFhLFdBQVcsY0FBYyxzQkFBc0IsNERBQTRELEVBQUUsaUJBQWlCLFlBQVksVUFBVSxpQkFBaUIscUJBQXFCLE1BQU0sSUFBSSxlQUFlLFFBQVEsWUFBWSxRQUFRO0FBQ2hULGVBQWUsOENBQThDLG9EQUFvRCxlQUFlLGlDQUFpQyx5REFBeUQscUNBQXFDLE9BQU87QUFDdFEsaUJBQWlCLDhEQUE4RCxTQUFTLG9CQUFvQiw2REFBNkQsK0JBQStCLGtGQUFrRixTQUFTLGVBQWUsYUFBYTtBQUMvVCxlQUFlLHFHQUFxRyxnSEFBZ0gsdURBQXVELHdCQUF3QixpQkFBaUIsT0FBTyxvQkFBb0IsR0FBRyxvQkFBb0IsU0FBUyxzQkFBc0IsT0FBTyx5QkFBeUIscUJBQXFCO0FBQzFjLGVBQWUseUNBQXlDLGVBQWUsZUFBZSxzQkFBc0IsZUFBZSxtQkFBbUIsU0FBUyw4Q0FBOEMsSUFBSSxtQ0FBbUMsUUFBUSxRQUFRLHlCQUF5Qiw4Q0FBOEM7QUFDblUsbUJBQW1CLCtCQUErQixnQkFBZ0IsTUFBTSxNQUFNLFNBQVMsb0JBQW9CLGVBQWUsTUFBTSxPQUFPLGVBQWUsWUFBWSxrQkFBa0IsaUJBQWlCLDRCQUE0QixVQUFVLGlGQUFpRixjQUFjLHVEQUF1RCxlQUFlO0FBQ2haLG1CQUFtQiwwRkFBMEYsZUFBZSw0RUFBNEUsaUJBQWlCLCtCQUErQixpQkFBaUI7QUFDelEsUUFBUSx3RUFBd0UsNERBQTRELHVEQUF1RCx5QkFBeUIsS0FBSyxLQUFLLFNBQVMsK0ZBQStGLGtDQUFrQyxZQUFZO0FBQzVYLGdDQUFnQyxxQkFBcUIsNEJBQTRCLG1CQUFtQixzQkFBc0IsRUFBRSxRQUFRLGdFQUFnRSxlQUFlLHVCQUF1QixvRUFBb0UsY0FBYyxVQUFVLHFCQUFxQjtBQUMzVixvQkFBb0IscU1BQXFNLGtGQUFrRjtBQUMzUyxRQUFRLFlBQVksNEVBQTRFLGFBQWEsNkVBQTZFLEtBQUssOENBQThDLDJHQUEyRyw4RUFBOEUsNkVBQTZFO0FBQ25mLGNBQWMsc0JBQXNCLGtCQUFrQix3Q0FBd0Msb0JBQW9CLFdBQVcsa0JBQWtCLG9DQUFvQyxvQkFBb0IsV0FBVyxrQkFBa0IsWUFBWSxhQUFhLDRFQUE0RSxlQUFlLFNBQVM7QUFDalcsZUFBZSxRQUFRLG9CQUFvQixZQUFZLGVBQWUsS0FBSyxnQ0FBZ0MsS0FBSyxZQUFZLCtDQUErQyxxQkFBcUIsZUFBZSw2Q0FBNkMsZUFBZTtBQUMzUSxlQUFlLGtCQUFrQix3REFBd0QsaUJBQWlCLEVBQUUsdUNBQXVDLGdCQUFnQixzQkFBc0Isa0JBQWtCLEVBQUUsRUFBRSx3QkFBd0Isd0JBQXdCLFlBQVksU0FBUyxxQ0FBcUMsS0FBSyxLQUFLLGtCQUFrQixFQUFFLEVBQUUsVUFBVSxLQUFLLElBQUksSUFBSSxNQUFNLFVBQVUsS0FBSyxJQUFJLElBQUksTUFBTSxZQUFZLE9BQU8sY0FBYyxFQUFFLEVBQUUsVUFBVSxLQUFLLElBQUksSUFBSSxNQUFNLFVBQVUsS0FBSyxJQUFJLElBQUksTUFBTSxZQUFZO0FBQzlmLGlCQUFpQixnQ0FBZ0MsMEJBQTBCLG1DQUFtQyxlQUFlLFFBQVEsa0JBQWtCLGFBQWEsRUFBRSxpQ0FBaUMseUNBQXlDLEtBQUssZUFBZSxLQUFLLFdBQVcsRUFBRSw2Q0FBNkMsY0FBYyxnQ0FBZ0MsYUFBYTtBQUM5WCxlQUFlLFFBQVEsa0JBQWtCLGFBQWEsRUFBRSxpQ0FBaUMsb0RBQW9ELEtBQUssZUFBZSxLQUFLLFdBQVcsRUFBRSw2Q0FBNkMsY0FBYyxnQ0FBZ0MsYUFBYSxZQUFZO0FBQ3ZTLGVBQWUsbUJBQW1CLEdBQUcsT0FBTyxvQkFBb0IsTUFBTSxNQUFNLFFBQVEsWUFBWSxlQUFlLDJDQUEyQyxZQUFZLG9CQUFvQixRQUFRLFNBQVMsUUFBUSxxQkFBcUIsMEVBQTBFLG9CQUFvQixlQUFlLE9BQU8sa0JBQWtCLDZDQUE2QyxtQkFBbUI7QUFDOWEsaUJBQWlCLE9BQU8sWUFBWSxRQUFRLHVEQUF1RCxjQUFjLGVBQWUsaUJBQWlCLGdCQUFnQixlQUFlLElBQUksUUFBUSx3REFBd0QsSUFBSSxTQUFTLFFBQVE7QUFDelEsc0JBQXNCLGVBQWUsVUFBVSx1QkFBdUIsVUFBVSwrQkFBK0IsS0FBSyxvQ0FBb0MsVUFBVSwwREFBMEQsRUFBRSxpQkFBaUIsU0FBUyxtQ0FBbUMseUJBQXlCLG1CQUFtQixpQkFBaUIsNkJBQTZCO0FBQ3JYLFFBQVEsbU1BQW1NLE1BQU0sT0FBTztBQUN4TixlQUFlLHNCQUFzQixtQkFBbUIsY0FBYyw2REFBNkQ7QUFDbkksUUFBUTtBQUNSO0FBQ0E7QUFDQSxzSkFBc0osTUFBTSx5REFBeUQsZUFBZSxvRUFBb0UsRUFBRSxpQkFBaUIsZUFBZSxLQUFLLGdCQUFnQixnQkFBZ0I7QUFDL1csaUJBQWlCLFlBQVksSUFBSSxVQUFVLEVBQUUsRUFBRSxtQkFBbUIseUJBQXlCLHFCQUFxQixtQkFBbUIsSUFBSSxHQUFHLEtBQUssRUFBRSxFQUFFLGtCQUFrQixnQkFBZ0IsUUFBUSxlQUFlLFNBQVMsU0FBUyxlQUFlLDhDQUE4QztBQUMzUiw2RUFBNkUsUUFBUSx5QkFBeUIsOENBQThDLDJIQUEySDtBQUN2UixpQkFBaUIsdUNBQXVDLFNBQVMsK0JBQStCLDBDQUEwQyxpREFBaUQsb0dBQW9HLFdBQVc7QUFDMVMsUUFBUSw4Q0FBOEMsaUVBQWlFLFlBQVksR0FBRyxRQUFRLGNBQWMsWUFBWSxXQUFXLEtBQUssV0FBVyxnQ0FBZ0MsS0FBSyxTQUFTLEtBQUssS0FBSyxpQkFBaUIsaUJBQWlCLFVBQVUsdUVBQXVFLE1BQU0sNkJBQTZCLE1BQU0sMEJBQTBCLE1BQU0sNkRBQTZEO0FBQ3BmLGlEQUFpRCxjQUFjLHFCQUFxQiw0QkFBNEIsbUJBQW1CLHVEQUF1RCxFQUFFLHFCQUFxQiw0QkFBNEIsbUJBQW1CLDBCQUEwQixnRUFBZ0UsRUFBRSxxQkFBcUIsNEJBQTRCLG9CQUFvQixtQkFBbUI7QUFDcGIsZUFBZSxnQkFBZ0Isd0RBQXdEO0FBQ3ZGLFFBQVEsMk1BQTJNLEtBQUs7QUFDeE4sc0hBQXNILHFCQUFxQjtBQUMzSSxvQkFBb0IsZ0JBQWdCLFVBQVUsdUJBQXVCLCtCQUErQixnSkFBZ0osb0lBQW9JLGtDQUFrQyxxQkFBcUIsdURBQXVELG1CQUFtQjtBQUN6ZiwrREFBK0QsRUFBRSxxQkFBcUIsNEJBQTRCLG9CQUFvQixrQkFBa0IsRUFBRSxxQkFBcUIsNEJBQTRCLG9CQUFvQiw0SEFBNEgsRUFBRSxxQkFBcUIsNEJBQTRCLG1CQUFtQixzREFBc0Q7QUFDdmQscUJBQXFCLDRCQUE0QixvQkFBb0IsbUJBQW1CLCtEQUErRCxvQkFBb0IsOEZBQThGLDRCQUE0QixFQUFFLFNBQVM7QUFDaFQsNmxCQUE2bEI7QUFDN2xCLG9CQUFvQixVQUFVLEdBQUcseUJBQXlCLCtCQUErQixtQkFBbUIsUUFBUSxRQUFRO0FBQzVILFFBQVEsOENBQThDLFlBQVksa0JBQWtCLFVBQVUsNENBQTRDLHVDQUF1QyxNQUFNLG9DQUFvQyxNQUFNLDRDQUE0QyxrSkFBa0osTUFBTTtBQUNyYSxHQUFHLE1BQU0sdUZBQXVGLE1BQU0sa0ZBQWtGLE1BQU0sNkJBQTZCLE1BQU0sc0JBQXNCLE1BQU0scUJBQXFCLE1BQU0sa0RBQWtELE1BQU0sWUFBWSx1QkFBdUIsTUFBTSxXQUFXLHFCQUFxQixjQUFjLE1BQU0sUUFBUTtBQUNyYixtQ0FBbUMsMEJBQTBCLDBCQUEwQiw2QkFBNkIsa0hBQWtILEVBQUUsZ0JBQWdCLGNBQWMsMENBQTBDLGdCQUFnQixLQUFLLGlCQUFpQixZQUFZLFFBQVEsUUFBUSxVQUFVLElBQUksV0FBVyxNQUFNLGVBQWU7QUFDaGEsaUJBQWlCLDBCQUEwQixlQUFlLGtCQUFrQiwyR0FBMkcsUUFBUSxHQUFHLHFCQUFxQixpSEFBaUgsU0FBUyxlQUFlLGlEQUFpRCxlQUFlO0FBQ2hhLG1CQUFtQixnQ0FBZ0MsVUFBVSxTQUFTLGlCQUFpQiw2Q0FBNkMsa0RBQWtELHNCQUFzQix5REFBeUQsV0FBVyxNQUFNLGVBQWUsbUJBQW1CLGtCQUFrQixvREFBb0QsY0FBYyxVQUFVLGlCQUFpQjtBQUN2YSxpQkFBaUIsa0JBQWtCLGtCQUFrQixNQUFNLGVBQWUsOENBQThDLE9BQU8sUUFBUSxVQUFVLFlBQVk7QUFDN0osa0JBQWtCLFdBQVcsV0FBVyw4QkFBOEIsNENBQTRDLGFBQWEsdUZBQXVGLDBCQUEwQixpQkFBaUIsc0RBQXNELHNCQUFzQjtBQUM3VSxtQkFBbUIsa0JBQWtCLDhMQUE4TCxtQkFBbUIsaUJBQWlCLGdCQUFnQixnQ0FBZ0MsZ0NBQWdDLDRCQUE0QixvQkFBb0IsZ0JBQWdCLFlBQVk7QUFDbmEsbUJBQW1CLDhCQUE4QixzVEFBc1QsbUJBQW1CLFNBQVMscUJBQXFCLGdCQUFnQixpQkFBaUIsbUJBQW1CO0FBQzVjLG1CQUFtQixrQkFBa0IsaUJBQWlCLG1CQUFtQixTQUFTLG1CQUFtQixtQkFBbUIsaUJBQWlCLGlCQUFpQixtQkFBbUIsU0FBUyxtQkFBbUIsa0JBQWtCLG1CQUFtQixTQUFTLG1CQUFtQixtQkFBbUIsOEJBQThCLG1CQUFtQixhQUFhLG9GQUFvRixTQUFTO0FBQ3hiLGVBQWUsbUJBQW1CLElBQUksWUFBWSxZQUFZLGVBQWUsZ0VBQWdFLHFDQUFxQywyQ0FBMkMsSUFBSSxrQkFBa0Isa0JBQWtCLGdDQUFnQyxFQUFFLGtCQUFrQixtQ0FBbUMsRUFBRSxVQUFVLFNBQVMsZUFBZSw4QkFBOEIsZUFBZTtBQUM3YSxlQUFlLE9BQU8sd0dBQXdHLGlCQUFpQix3REFBd0Q7QUFDdk0saUJBQWlCLGtDQUFrQyxxQ0FBcUMsdUVBQXVFLGVBQWUsbUZBQW1GLHFCQUFxQixpQkFBaUI7QUFDdlMseUJBQXlCLCtDQUErQyxrSkFBa0osRUFBRSxtQkFBbUIsaUZBQWlGLDRCQUE0QixTQUFTLEVBQUUsdUJBQXVCLFFBQVEsdUJBQXVCLGlDQUFpQyx3QkFBd0IsS0FBSztBQUMzZCx3QkFBd0Isa0NBQWtDLDhCQUE4QixrQkFBa0Isa0NBQWtDLGdGQUFnRixTQUFTLDZGQUE2RixtQkFBbUI7QUFDclYsaUJBQWlCLHFCQUFxQix3Q0FBd0MsV0FBVyxLQUFLLHdCQUF3QixnQkFBZ0Isd0NBQXdDO0FBQzlLLHFCQUFxQixnQkFBZ0IsWUFBWSxjQUFjLHdCQUF3QixPQUFPLDZDQUE2Qyx3QkFBd0Isb0JBQW9CLFdBQVcsTUFBTSxnR0FBZ0csRUFBRSxPQUFPLHFDQUFxQyx3QkFBd0Isb0JBQW9CLFdBQVcsTUFBTSxnR0FBZ0c7QUFDbmYsT0FBTyxrQ0FBa0Msd0JBQXdCLG9CQUFvQixXQUFXLE1BQU0sbUdBQW1HLEVBQUUsU0FBUyxPQUFPLDBEQUEwRCwwRUFBMEUsYUFBYSxPQUFPLGlIQUFpSCxTQUFTO0FBQzdlLEdBQUcsaUVBQWlFLGtCQUFrQixZQUFZLFVBQVUsMEJBQTBCLFNBQVMsa0JBQWtCLHNIQUFzSCxvTEFBb0w7QUFDM2MsR0FBRyxxQ0FBcUMsa0JBQWtCLHdCQUF3Qix3QkFBd0IsdUNBQXVDLGlDQUFpQyx3QkFBd0IsVUFBVSwrSkFBK0osa0JBQWtCLHFEQUFxRDtBQUMxYiwyRkFBMkYsUUFBUSxxRUFBcUUsS0FBSywyQkFBMkIsaUpBQWlKO0FBQ3pWLDBFQUEwRSxVQUFVLFVBQVUsWUFBWSxXQUFXO0FBQ3JILGVBQWUsZ0RBQWdELDZCQUE2QixtQ0FBbUM7QUFDL0gsaUJBQWlCLFlBQVksb0NBQW9DLGFBQWEsV0FBVyxhQUFhLDZDQUE2QyxvQkFBb0IsV0FBVyw2REFBNkQsY0FBYywwQkFBMEIsUUFBUSw2QkFBNkIsZUFBZSxTQUFTLG9DQUFvQywyQkFBMkI7QUFDblosaUJBQWlCLHFHQUFxRyw4QkFBOEI7QUFDcEosZUFBZSxnQkFBZ0IsTUFBTSxtQkFBbUIsc0VBQXNFLGtCQUFrQixlQUFlLGdCQUFnQixrQkFBa0IsS0FBSyxTQUFTLG9CQUFvQixZQUFZLGdCQUFnQixjQUFjLFNBQVMsMERBQTBELFNBQVMsa0JBQWtCLFlBQVksVUFBVSxlQUFlLFNBQVMsa0JBQWtCLFVBQVUsZUFBZSxjQUFjO0FBQ2xkLE9BQU8sY0FBYyxTQUFTLGNBQWMsdUNBQXVDLFNBQVMsb0JBQW9CLDZFQUE2RSxXQUFXLGNBQWMsU0FBUyxvQkFBb0IsbUZBQW1GLCtCQUErQixjQUFjLGNBQWMsU0FBUyxvQkFBb0IsNkVBQTZFO0FBQzNlLGNBQWMsU0FBUyxvQkFBb0IsNEZBQTRGLGNBQWMsZUFBZSxjQUFjLFNBQVMsb0JBQW9CLHlLQUF5Syx3QkFBd0IsY0FBYyxTQUFTLHNCQUFzQjtBQUM3YixxQkFBcUIsV0FBVyxjQUFjLFNBQVMsa0JBQWtCLHFHQUFxRyxrQ0FBa0MsbUJBQW1CLGtHQUFrRywrQkFBK0IsaUJBQWlCLGNBQWMsU0FBUyw4REFBOEQ7QUFDMWMsa0NBQWtDLDhEQUE4RCwyRUFBMkUsUUFBUSxZQUFZLG9CQUFvQiwwQkFBMEIsK0VBQStFLGtDQUFrQyxtQkFBbUIsaUZBQWlGLHlDQUF5QztBQUMzZSxrQkFBa0IseUNBQXlDLHFEQUFxRCxRQUFRLFlBQVksc0JBQXNCLGtGQUFrRixrQ0FBa0MsbUJBQW1CLDBHQUEwRyw4REFBOEQsMkNBQTJDO0FBQ3BmLDZDQUE2Qyx3REFBd0QsUUFBUSxZQUFZLG9CQUFvQix1Q0FBdUMscUJBQXFCLEtBQUssbUNBQW1DLG9CQUFvQixhQUFhLGdCQUFnQixNQUFNLGlDQUFpQyxXQUFXLHlCQUF5QixJQUFJLElBQUksZ0NBQWdDLGFBQWEsS0FBSyxXQUFXLDZEQUE2RCxTQUFTO0FBQ3hmLE9BQU8sV0FBVywwQkFBMEIsMkRBQTJELFdBQVcseUJBQXlCLElBQUkseUJBQXlCLGNBQWMsRUFBRSxTQUFTLG9CQUFvQixZQUFZLHNDQUFzQyxZQUFZLHdCQUF3Qiw2Q0FBNkMsa0JBQWtCLGdCQUFnQixtQ0FBbUMsdUJBQXVCLGFBQWEsU0FBUyxNQUFNLGlDQUFpQztBQUNqZixLQUFLLHlCQUF5QixJQUFJLElBQUksMEJBQTBCLGFBQWEsS0FBSyxRQUFRLG9GQUFvRixTQUFTLGFBQWEsUUFBUSxpREFBaUQsMkRBQTJELFdBQVcseUJBQXlCLElBQUkseUJBQXlCLGNBQWMsRUFBRSxTQUFTLHlCQUF5QjtBQUMzYSxvQ0FBb0Msd0JBQXdCLFdBQVcsWUFBWSxRQUFRLFNBQVMsRUFBRSx3REFBd0QsZUFBZSw4Q0FBOEMsY0FBYyxjQUFjLElBQUksUUFBUSxLQUFLLE9BQU8sTUFBTSxZQUFZLFlBQVkscUpBQXFKLFlBQVksV0FBVyxZQUFZLFNBQVMsRUFBRTtBQUNoZixnQkFBZ0IsZUFBZSxXQUFXLGNBQWMsSUFBSSxRQUFRLEtBQUssT0FBTyxNQUFNLFlBQVksWUFBWSwrQkFBK0IsY0FBYyxJQUFJLFlBQVksV0FBVywwQkFBMEIsZUFBZSxjQUFjLGVBQWUsY0FBYyxJQUFJLFFBQVEsWUFBWSwrQkFBK0IsZUFBZSxjQUFjLElBQUksWUFBWSxXQUFXLFlBQVksU0FBUyxFQUFFO0FBQ2haLGtCQUFrQixlQUFlLHdCQUF3QixjQUFjLElBQUksUUFBUSxLQUFLLE9BQU8sTUFBTSxZQUFZLFlBQVksK0JBQStCLGNBQWMsSUFBSSxZQUFZLHlLQUF5SywyQkFBMkIsMkJBQTJCLFdBQVcsd0NBQXdDO0FBQzVjLHFCQUFxQixlQUFlO0FBQ3BDLHVCQUF1QixrQkFBa0IsdUJBQXVCLGtEQUFrRCxnQkFBZ0IsWUFBWSwyQ0FBMkMsb0JBQW9CLE9BQU8sZ0NBQWdDLGNBQWMsYUFBYSxpQkFBaUIsZUFBZSxTQUFTLHdCQUF3Qix3QkFBd0IsWUFBWSxlQUFlLGNBQWMsa0JBQWtCO0FBQ25hLGNBQWMscUJBQXFCLGdCQUFnQiw0Q0FBNEMsbUJBQW1CLFVBQVUsNENBQTRDLFVBQVUsa0JBQWtCLGlCQUFpQiw2RUFBNkUsZUFBZSxlQUFlLGdCQUFnQixjQUFjLFlBQVksTUFBTSxhQUFhLE1BQU0sc0NBQXNDLFlBQVk7QUFDcmIsK0hBQStILHVCQUF1QixrQkFBa0IsZUFBZSxrQkFBa0IsRUFBRSxzR0FBc0csT0FBTywwQkFBMEIsMERBQTBELGNBQWMsZ0NBQWdDLHNDQUFzQyxVQUFVLFNBQVM7QUFDbmYsRUFBRSx5SkFBeUosU0FBUyxVQUFVLFNBQVMsaUJBQWlCLGtCQUFrQiw2QkFBNkIseUJBQXlCLFNBQVMsUUFBUSxRQUFRLFVBQVUsU0FBUyxlQUFlLFNBQVMsa0JBQWtCLFVBQVUsU0FBUyxzSEFBc0g7QUFDL2Usc1FBQXNRLFlBQVksZUFBZSxTQUFTLHNCQUFzQixpQkFBaUIseUNBQXlDLGdDQUFnQztBQUMxWixpSEFBaUgsU0FBUyxtR0FBbUcsZUFBZSx3QkFBd0IsdUVBQXVFLHdEQUF3RCxhQUFhLGlFQUFpRSxrQkFBa0I7QUFDbmUsbUJBQW1CLFVBQVUsK0JBQStCLGlCQUFpQixzRUFBc0UsdUNBQXVDLFNBQVMsUUFBUSx5Q0FBeUMsa0JBQWtCLFVBQVUsU0FBUyxXQUFXLGlCQUFpQiwyQ0FBMkMsdUNBQXVDLFNBQVMsUUFBUSxTQUFTLGtCQUFrQixVQUFVLFNBQVMsa0JBQWtCO0FBQ3hkLEdBQUcsY0FBYyxhQUFhLE1BQU0sWUFBWSxNQUFNLGlCQUFpQixnQkFBZ0IsMkRBQTJELDBEQUEwRCxtQkFBbUIsa0JBQWtCLHdEQUF3RCwyRUFBMkU7QUFDcFgsbUJBQW1CLGNBQWMsZUFBZSw4VUFBOFUsMEJBQTBCLG1CQUFtQix3QkFBd0IscUJBQXFCLFlBQVk7QUFDcGUsT0FBTyw2QkFBNkIscUJBQXFCLDhCQUE4QiwwRUFBMEUsY0FBYyxtQkFBbUIseUJBQXlCLFlBQVksT0FBTyxRQUFRLGNBQWMscUVBQXFFLGlEQUFpRCxLQUFLLFlBQVksWUFBWSxNQUFNLGFBQWEsZ0NBQWdDLDBDQUEwQztBQUNwZixlQUFlLGlCQUFpQixrQ0FBa0MsS0FBSyxxREFBcUQsTUFBTSx1QkFBdUIsS0FBSyxlQUFlLGdCQUFnQixTQUFTLEVBQUUseUNBQXlDLG1DQUFtQyxvQkFBb0IsVUFBVSxTQUFTLGVBQWUsS0FBSyxpQkFBaUIsRUFBRSwrQ0FBK0MsY0FBYyxnQ0FBZ0MsWUFBWSxpQkFBaUIsY0FBYztBQUMxZSxtQkFBbUIsWUFBWSx3REFBd0QsS0FBSyxzRUFBc0UsTUFBTSxNQUFNLHVDQUF1QyxZQUFZLDJDQUEyQyxRQUFRLEtBQUssdUNBQXVDLFNBQVMsRUFBRSw0Q0FBNEMsaUNBQWlDLHdCQUF3QixvQkFBb0IsVUFBVSxTQUFTLEtBQUssaUJBQWlCLEVBQUU7QUFDL2UscUNBQXFDLGNBQWMsZ0NBQWdDLFlBQVksWUFBWSxlQUFlLHdDQUF3QyxlQUFlLDJCQUEyQixtQkFBbUIsb0JBQW9CLDZCQUE2QixnQkFBZ0I7QUFDaFMsaUJBQWlCLGNBQWMsWUFBWSxnQkFBZ0IsUUFBUSxTQUFTLFFBQVEsY0FBYyw4QkFBOEIsY0FBYyxZQUFZLGtCQUFrQixrREFBa0QseUVBQXlFLFNBQVMsT0FBTyxNQUFNLFlBQVksTUFBTSxzQkFBc0IsTUFBTSxnQkFBZ0IsY0FBYyxhQUFhLHVDQUF1QyxlQUFlLEtBQUssaUJBQWlCLEVBQUU7QUFDcGUsdUJBQXVCLGNBQWMsZ0NBQWdDLFlBQVksbUNBQW1DLGNBQWMsdUNBQXVDLGNBQWMsb0NBQW9DLEVBQUUsT0FBTyxjQUFjLFFBQVEsRUFBRSx5QkFBeUIsY0FBYyxxQkFBcUIsS0FBSyxRQUFRLG1DQUFtQyxLQUFLLFFBQVEsbUNBQW1DLEtBQUssUUFBUSxjQUFjLEtBQUs7QUFDeGIsbUVBQW1FLG9CQUFvQixVQUFVLFNBQVMsZUFBZSxLQUFLLGlCQUFpQixFQUFFLDhDQUE4QyxjQUFjLGtCQUFrQixnQ0FBZ0MsYUFBYSx1Q0FBdUMsZ0JBQWdCLHlCQUF5QjtBQUM1Viw2Q0FBNkMsT0FBTyxtQ0FBbUMsZUFBZSw2QkFBNkIsR0FBRyxzQkFBc0IsU0FBUyxFQUFFLFNBQVMsUUFBUSxRQUFRLGNBQWMsU0FBUyxTQUFTLGVBQWUsY0FBYyxxQkFBcUIsS0FBSyxNQUFNLG1DQUFtQyxLQUFLLE1BQU0sbUNBQW1DLEtBQUssTUFBTSxpQkFBaUIsd0NBQXdDLGFBQWEsRUFBRSxLQUFLLGlCQUFpQixFQUFFLHVDQUF1QztBQUNoZ0IsS0FBSyxRQUFRLGNBQWMsZ0NBQWdDLGdCQUFnQixxQkFBcUIsRUFBRSw0QkFBNEIsd0NBQXdDLG1DQUFtQyxxQkFBcUIsY0FBYyxTQUFTLGFBQWEsRUFBRSxzR0FBc0csbUNBQW1DLG9CQUFvQixVQUFVLFNBQVMsZUFBZSxLQUFLLGlCQUFpQixFQUFFO0FBQzNkLFNBQVMsY0FBYyxnQ0FBZ0MsYUFBYSw0QkFBNEIsS0FBSyxpQkFBaUIsYUFBYSxpRUFBaUUsMEJBQTBCLGNBQWMsYUFBYSx5QkFBeUIsWUFBWSxzQkFBc0IsNkJBQTZCLDZCQUE2QixtQkFBbUIseUJBQXlCLE1BQU0sMENBQTBDLGtCQUFrQjtBQUM1ZCxLQUFLLE1BQU0sYUFBYSxrQkFBa0IsZ0NBQWdDLGNBQWMseUJBQXlCLG1HQUFtRyxLQUFLLHNCQUFzQixrQkFBa0Isd0JBQXdCLHdCQUF3QiwwQkFBMEIsZ0JBQWdCLGtCQUFrQixNQUFNLHVCQUF1QixzREFBc0QsTUFBTSxxQkFBcUI7QUFDM2QsMEJBQTBCLE1BQU0sYUFBYSxhQUFhLGtCQUFrQiw2QkFBNkIsWUFBWSxhQUFhLGtCQUFrQixjQUFjLGVBQWUsTUFBTSxlQUFlLDZCQUE2QixRQUFRLG9CQUFvQjtBQUMvUCxlQUFlLGNBQWMsdUJBQXVCLFNBQVMsc0RBQXNELFdBQVcsSUFBSSxXQUFXLElBQUksWUFBWSxPQUFPLDBCQUEwQixvQkFBb0IsaUNBQWlDLG9CQUFvQiw4QkFBOEIsT0FBTyxPQUFPLE9BQU8sNEJBQTRCLCtCQUErQixpQ0FBaUMsU0FBUyxPQUFPLFNBQVMsU0FBUyw2QkFBNkI7QUFDcmQsZ0JBQWdCLDJCQUEyQiwrQkFBK0IsYUFBYTtBQUN2RixlQUFlLGdCQUFnQixzQkFBc0IsaUJBQWlCLGNBQWMsY0FBYyxjQUFjLDRGQUE0RixnQkFBZ0IsY0FBYywwRUFBMEUsbUVBQW1FLGtCQUFrQixjQUFjLGtCQUFrQiwrQkFBK0IsZUFBZSxJQUFJO0FBQzNkLGNBQWMsYUFBYSwrQkFBK0IsU0FBUyxpQ0FBaUMsOENBQThDLHlDQUF5QyxTQUFTLDZDQUE2QyxTQUFTLDhCQUE4QixXQUFXLDhLQUE4SyxPQUFPLGdDQUFnQztBQUN4Ziw2QkFBNkIsSUFBSSxZQUFZLGdDQUFnQyxTQUFTLEtBQUssOENBQThDLE1BQU0sUUFBUSxNQUFNLFlBQVksT0FBTyxnQkFBZ0IsZUFBZSxLQUFLLElBQUksT0FBTyxPQUFPLElBQUksT0FBTyw4QkFBOEIsOENBQThDLDhDQUE4QyxnQkFBZ0Isc0JBQXNCLDhDQUE4Qyx3Q0FBd0MsK0JBQStCO0FBQ3RnQixXQUFXLDBCQUEwQixhQUFhLG9FQUFvRSxFQUFFLGVBQWUsS0FBSyx3QkFBd0I7QUFDcEssZUFBZSxjQUFjLFNBQVMsa0JBQWtCLDhCQUE4QixzQkFBc0IsZ0JBQWdCLHlDQUF5QywwQkFBMEIsb0JBQW9CLFNBQVMscUJBQXFCLEtBQUssUUFBUSxTQUFTLEVBQUUsa0JBQWtCLElBQUksS0FBSyxTQUFTLEVBQUUsa0JBQWtCLFlBQVksVUFBVSxrQkFBa0IsZ0JBQWdCLGVBQWUsYUFBYSxnQkFBZ0IsTUFBTSxhQUFhLGdCQUFnQixrQkFBa0IsTUFBTTtBQUNoZSxHQUFHLE1BQU0seUJBQXlCLGdCQUFnQixVQUFVLFVBQVUsZ0VBQWdFLEtBQUssWUFBWSxRQUFRLFNBQVMsRUFBRSxLQUFLLFNBQVMsSUFBSSxLQUFLLFNBQVMsRUFBRSxrQkFBa0Isd0JBQXdCLGFBQWEsd0tBQXdLLDhDQUE4QyxnQ0FBZ0M7QUFDemYsTUFBTSwrQkFBK0IsTUFBTSxpQkFBaUIsb0JBQW9CLGtCQUFrQixNQUFNLFVBQVUsVUFBVSxnRUFBZ0UsU0FBUyx3Q0FBd0MsNEJBQTRCLGdDQUFnQywyQkFBMkIsbUJBQW1CLFNBQVMsY0FBYyxNQUFNLEVBQUUsb0RBQW9ELFFBQVEsa0RBQWtEO0FBQ3BlLGNBQWMsbURBQW1ELGtCQUFrQixTQUFTLHFGQUFxRixtQkFBbUIscUJBQXFCLDRRQUE0UTtBQUNyZSxnQkFBZ0IsS0FBSyxnQ0FBZ0MsT0FBTyxZQUFZLGNBQWMsMEJBQTBCLG1CQUFtQixnQkFBZ0IsU0FBUyxjQUFjLDBCQUEwQixtQkFBbUIsZ0JBQWdCLFNBQVMsY0FBYyxhQUFhLCtCQUErQixTQUFTLGtCQUFrQixVQUFVLGVBQWUsa0JBQWtCLG9DQUFvQyxTQUFTLFFBQVEsVUFBVSxlQUFlLFFBQVEsZ0JBQWdCLG1CQUFtQixNQUFNO0FBQy9lLEdBQUcsNEJBQTRCLEtBQUssTUFBTSxrQkFBa0IsS0FBSyxhQUFhLGFBQWEsSUFBSSxLQUFLLElBQUksd0JBQXdCLGdCQUFnQixJQUFJLEtBQUssVUFBVSxVQUFVLEtBQUssRUFBRSxFQUFFLE9BQU8sS0FBSyxNQUFNLFFBQVEsa0JBQWtCLEtBQUssYUFBYSx5QkFBeUIsUUFBUSxJQUFJLElBQUksSUFBSSxRQUFRLFNBQVMsRUFBRSxjQUFjLGFBQWEsTUFBTSxhQUFhLE1BQU0sWUFBWSxNQUFNLFlBQVksZ0NBQWdDLGNBQWMsT0FBTyxLQUFLLFVBQVUsS0FBSyxLQUFLLFNBQVMsUUFBUSxLQUFLLFNBQVM7QUFDbmYsS0FBSyxnQkFBZ0IsbURBQW1ELGdCQUFnQix1Q0FBdUMsK0JBQStCLDJCQUEyQixtQkFBbUIsRUFBRSxzR0FBc0csU0FBUyxtRkFBbUYsT0FBTyxLQUFLLGNBQWMsYUFBYSx3QkFBd0IsVUFBVSxTQUFTLElBQUksR0FBRyxnQkFBZ0I7QUFDemYsZ0NBQWdDLFlBQVksV0FBVyxhQUFhLEtBQUssNEhBQTRILFFBQVEsYUFBYSxLQUFLLGNBQWMsU0FBUyxJQUFJLFFBQVEsc0JBQXNCLEdBQUcsZ0lBQWdJLFdBQVcsSUFBSSxjQUFjLGlEQUFpRCxVQUFVO0FBQ25mLGdEQUFnRCw0Q0FBNEMsU0FBUyxrQkFBa0IsWUFBWSxjQUFjLG9FQUFvRSxjQUFjLHVFQUF1RSxhQUFhLCtCQUErQixjQUFjLDZEQUE2RCxnQkFBZ0IsaUJBQWlCLGdCQUFnQixLQUFLLFNBQVMsRUFBRTtBQUNsZSxzQ0FBc0MsbUhBQW1ILG9DQUFvQyxrQkFBa0Isa0NBQWtDLFlBQVksZ0JBQWdCLG1KQUFtSixLQUFLLGdDQUFnQywwQ0FBMEM7QUFDL2UsK0NBQStDLGtDQUFrQyxXQUFXLGVBQWUsY0FBYyxVQUFVLGFBQWEsNkJBQTZCLGNBQWMsV0FBVyxlQUFlLE9BQU8sY0FBYyxLQUFLLFNBQVMsbUJBQW1CLEVBQUUsYUFBYSxlQUFlLDZCQUE2QixTQUFTLEVBQUUsZ0NBQWdDLFVBQVUsbUNBQW1DLDRCQUE0Qiw4QkFBOEIsTUFBTTtBQUM5ZCwrQ0FBK0MsZUFBZSxJQUFJLHVCQUF1Qix5QkFBeUIsTUFBTSxzRUFBc0Usc0JBQXNCLEtBQUssc0JBQXNCLGVBQWUsSUFBSSx1QkFBdUIsS0FBSywwQkFBMEIsS0FBSyxLQUFLLGNBQWMsT0FBTyxnQkFBZ0IsS0FBSyxRQUFRLHVDQUF1QyxjQUFjLHdCQUF3QixjQUFjLFFBQVEsTUFBTSxLQUFLO0FBQ2xlLGNBQWMsZ0JBQWdCLG1CQUFtQixNQUFNLFdBQVcscUJBQXFCLHdJQUF3SSxtTEFBbUwsTUFBTSxhQUFhLGlEQUFpRCxlQUFlO0FBQ3JlLE9BQU8sNkJBQTZCLGlCQUFpQixxS0FBcUssVUFBVTtBQUNwTyx5TUFBeU0sT0FBTyxpR0FBaUcsU0FBUyxNQUFNLElBQUksWUFBWSxRQUFRLHVCQUF1Qiw4QkFBOEIsWUFBWSxNQUFNLElBQUksV0FBVyxRQUFRLE9BQU8sV0FBVyx1QkFBdUIsU0FBUyxNQUFNLElBQUksR0FBRztBQUNyZixHQUFHLEtBQUssSUFBSSxVQUFVLFFBQVEsUUFBUSxLQUFLLFNBQVMsU0FBUyxRQUFRLG1DQUFtQyw2QkFBNkIsU0FBUyxPQUFPLElBQUksV0FBVyxRQUFRO0FBQzVLLGVBQWUsY0FBYyxRQUFRLGlDQUFpQywwQkFBMEIsUUFBUSw4RUFBOEUsT0FBTyw4QkFBOEIsc0JBQXNCLEdBQUcsa0xBQWtMLHFCQUFxQixtQ0FBbUMsZ0JBQWdCLE1BQU07QUFDcGYsc0JBQXNCLE1BQU0sR0FBRyxxQ0FBcUMsUUFBUSxVQUFVLEVBQUUsVUFBVSx3REFBd0QsUUFBUSxnQ0FBZ0Msc0JBQXNCLGtCQUFrQixTQUFTLGdEQUFnRCxJQUFJLG9CQUFvQiwrR0FBK0csTUFBTSwrQkFBK0IsVUFBVTtBQUN6ZCw0QkFBNEIsRUFBRSxPQUFPLCtKQUErSixZQUFZLHdCQUF3QixvQkFBb0IsbUNBQW1DLGtDQUFrQyw4REFBOEQsUUFBUSxpQ0FBaUMsZ0NBQWdDLGdDQUFnQyxjQUFjO0FBQ3RmLEdBQUcsb0NBQW9DLFlBQVkscUNBQXFDLG9CQUFvQixLQUFLLHNCQUFzQixXQUFXLGtEQUFrRCxtQkFBbUIsa0VBQWtFLE9BQU8sK0VBQStFLG9GQUFvRixpQkFBaUIseUJBQXlCLFlBQVk7QUFDemY7QUFDQSxtR0FBbUcsa0RBQWtELE9BQU8sdUNBQXVDLDJCQUEyQixnQkFBZ0IsRUFBRSx1Q0FBdUMsb0JBQW9CLGlCQUFpQixrRUFBa0UsOENBQThDLG1DQUFtQyxNQUFNLE9BQU87QUFDNWQsbUJBQW1CLEtBQUssc0NBQXNDLE9BQU8sc0JBQXNCLE1BQU0sS0FBSyxRQUFRLGlCQUFpQixLQUFLLG1CQUFtQixNQUFNLGNBQWMsMkNBQTJDLFFBQVEsd0NBQXdDLGlCQUFpQixLQUFLLDBEQUEwRCxzQ0FBc0MsVUFBVSxjQUFjLFFBQVEsTUFBTSxPQUFPLGdFQUFnRSxvQkFBb0IsNkJBQTZCLEdBQUcseUJBQXlCLGlCQUFpQixFQUFFLEVBQUU7QUFDM2tCLGVBQWUsaUJBQWlCLDBXQUEwVztBQUMxWSxlQUFlLGlDQUFpQyxpQ0FBaUMsOEJBQThCLFNBQVM7QUFDeEgsbUJBQW1CLFlBQVksZUFBZSx1QkFBdUIsbVdBQW1XO0FBQ3hhLG1CQUFtQiw2REFBNkQsaUJBQWlCLFlBQVk7QUFDN0csaUJBQWlCLDBCQUEwQixVQUFVLDhDQUE4QyxJQUFJLHdJQUF3SSxFQUFFLGlCQUFpQixxQkFBcUIsaUJBQWlCO0FBQ3hTLGlCQUFpQixZQUFZLDJCQUEyQixpQkFBaUIsUUFBUSxjQUFjLDhDQUE4QywyQkFBMkIsZ0VBQWdFLG9DQUFvQztBQUM1USxpQkFBaUIsZUFBZSxpQ0FBaUMsK0dBQStHLHVCQUF1QixNQUFNLHdCQUF3QixTQUFTLG9CQUFvQixtQ0FBbUMsbUNBQW1DLG1CQUFtQixlQUFlLFNBQVMsa0NBQWtDLDBEQUEwRCxFQUFFO0FBQ2pkLGlCQUFpQixLQUFLLGdCQUFnQixJQUFJLGlDQUFpQyxTQUFTLHFCQUFxQixZQUFZLE1BQU0sS0FBSyxZQUFZLFdBQVcsbUJBQW1CLFFBQVEsV0FBVyw0R0FBNEcsS0FBSyxPQUFPLE9BQU8sUUFBUSxXQUFXLEtBQUssbUJBQW1CLGlCQUFpQiw2QkFBNkIsT0FBTyxrQ0FBa0M7QUFDOWIsaUJBQWlCLGNBQWMsaUJBQWlCLGdFQUFnRSxpQkFBaUIsK0NBQStDLFdBQVcsSUFBSSwwRUFBMEUsRUFBRSxpQkFBaUIsY0FBYyx3SkFBd0osaUJBQWlCO0FBQ25kLGlCQUFpQixjQUFjLG9GQUFvRixzREFBc0QsZUFBZSxvQkFBb0IsOENBQThDLFFBQVE7QUFDbFEsZUFBZSxVQUFVLDhDQUE4Qyx1REFBdUQsOENBQThDLGlCQUFpQjtBQUM3TCw2QkFBNkIsa0ZBQWtGLHlDQUF5QyxrQkFBa0IsRUFBRSxHQUFHLGVBQWUsMERBQTBELEtBQUsscUNBQXFDLDRDQUE0QyxvQkFBb0IsYUFBYSw2QkFBNkIsS0FBSyxhQUFhLDhCQUE4QjtBQUM1YixpQkFBaUIsTUFBTSxtQkFBbUIsdUNBQXVDLGNBQWMsUUFBUTtBQUN2RyxRQUFRO0FBQ1IsMEdBQTBHLDhCQUE4QixvQ0FBb0MsdUJBQXVCLDZDQUE2QyxZQUFZLEVBQUU7QUFDOVAsaUJBQWlCLFVBQVUsdUNBQXVDLDBCQUEwQixRQUFRLFdBQVcsMkhBQTJILDRCQUE0Qiw2QkFBNkIsVUFBVSxZQUFZLEVBQUUseUhBQXlIO0FBQ3BiLG1CQUFtQjtBQUNuQixpQkFBaUIsb0RBQW9ELFVBQVUsa0xBQWtMLGtCQUFrQjtBQUNuUixpQkFBaUIsb0RBQW9ELFlBQVksUUFBUSxZQUFZLFdBQVcsS0FBSyxXQUFXO0FBQ2hJLFFBQVE7QUFDUixzQkFBc0IscUJBQXFCLG1DQUFtQyxrQkFBa0IscUtBQXFLLFFBQVEsOENBQThDLFNBQVMsaUJBQWlCO0FBQ3JWLHFCQUFxQixjQUFjLFVBQVUsa0RBQWtELFFBQVEsTUFBTSx5RUFBeUUsSUFBSSxNQUFNLHNDQUFzQyxJQUFJLE1BQU0sZ0RBQWdELHNCQUFzQixJQUFJLE1BQU0sb0NBQW9DLDBCQUEwQixJQUFJLE1BQU0seUNBQXlDLElBQUksTUFBTSxxQkFBcUIsVUFBVTtBQUMxZCxpQkFBaUIsTUFBTSx3QkFBd0IsTUFBTSxzQkFBc0IsTUFBTSxJQUFJLGFBQWEsRUFBRSw0QkFBNEIsaUJBQWlCLE1BQU0sd0JBQXdCLFVBQVUsNEJBQTRCLGlCQUFpQixNQUFNLFlBQVksV0FBVyxVQUFVLG1DQUFtQyxXQUFXO0FBQzNULG9LQUFvSyxVQUFVLG1CQUFtQixRQUFRLE1BQU0sc0JBQXNCLFFBQVEsTUFBTSw2REFBNkQsTUFBTSxzQ0FBc0MsVUFBVSwyRkFBMkYsTUFBTTtBQUN2YztBQUNBLHVCQUF1QixXQUFXLFVBQVUsdUJBQXVCLFVBQVUsS0FBSyxNQUFNLHdCQUF3QixVQUFVLEtBQUssTUFBTSxvQkFBb0IsSUFBSSxhQUFhLEVBQUUsTUFBTSxJQUFJLGFBQWEsRUFBRSxLQUFLLE1BQU0sMEJBQTBCLFVBQVUsS0FBSyxNQUFNLG9GQUFvRixXQUFXLFFBQVEsT0FBTyxtSUFBbUk7QUFDaGYsSUFBSSxrTUFBa00sWUFBWSxXQUFXLHNCQUFzQix1RUFBdUUsa0VBQWtFLFdBQVcsc0RBQXNELGFBQWEsb0NBQW9DO0FBQzllLCtUQUErVCw2QkFBNkI7QUFDNVYsdUJBQXVCLHFEQUFxRCxRQUFRLFVBQVUsWUFBWSxXQUFXLE1BQU0sb0JBQW9CLHVKQUF1SixVQUFVLHFCQUFxQixNQUFNLHdCQUF3QixNQUFNO0FBQ3pXO0FBQ0EsdUJBQXVCLFVBQVUsa0RBQWtELE1BQU0sNkVBQTZFLE1BQU0sc0NBQXNDLE1BQU0sZ0RBQWdELHNCQUFzQixNQUFNLG9DQUFvQywwQkFBMEIsTUFBTSx5Q0FBeUMsTUFBTSxxQkFBcUIsNEJBQTRCLGlCQUFpQixNQUFNO0FBQy9kLDRCQUE0QixpQkFBaUIsTUFBTSxxRUFBcUUsV0FBVyxPQUFPLDhOQUE4TixVQUFVLG1CQUFtQixRQUFRLE1BQU0sc0JBQXNCLFFBQVEsTUFBTSxrQ0FBa0M7QUFDemQsY0FBYyxTQUFTLGlCQUFpQjtBQUN4QyxzQkFBc0IsZ0xBQWdMLDZDQUE2QywwQ0FBMEMsNENBQTRDLHlDQUF5Qyx3Q0FBd0MsVUFBVSxxQkFBcUIsU0FBUyw4QkFBOEIsUUFBUSxhQUFhO0FBQ3JmLGFBQWEsaUZBQWlGLFFBQVEsV0FBVyxLQUFLLFdBQVcsMkJBQTJCLFlBQVksaUJBQWlCLE1BQU0sVUFBVSxNQUFNLHdCQUF3QixNQUFNLDJEQUEyRCxFQUFFLDBDQUEwQyxvQkFBb0IsZUFBZTtBQUN2WCxlQUFlLHVEQUF1RDtBQUN0RSxVQUFVLCtCQUErQixpQkFBaUIsVUFBVSxrRUFBa0UsTUFBTSw0RUFBNEUsU0FBUyxtQ0FBbUMsZUFBZSwrQkFBK0IsU0FBUyw2QkFBNkIsTUFBTSxXQUFXLFVBQVUsK0JBQStCLDJDQUEyQyxRQUFRO0FBQ3JjLHdCQUF3QixlQUFlLG1DQUFtQyxnQkFBZ0IsSUFBSSxzQkFBc0IsU0FBUyxPQUFPLFFBQVEscUNBQXFDLFFBQVEsRUFBRSxXQUFXLEVBQUUsc0NBQXNDLHNDQUFzQyx3Q0FBd0MsaUNBQWlDLElBQUksSUFBSSxNQUFNLEVBQUUsaUJBQWlCLHNCQUFzQixzQkFBc0Isa0NBQWtDLElBQUksZUFBZSxJQUFJO0FBQ25lLENBQUMsZUFBZSxZQUFZLE1BQU0sZUFBZSxZQUFZLElBQUksZ0NBQWdDLE9BQU8sNkJBQTZCLG1EQUFtRCwwQ0FBMEMsa0lBQWtJLDZCQUE2Qix3QkFBd0IscUJBQXFCLHNCQUFzQixxQ0FBcUM7QUFDemUsaUJBQWlCLFVBQVUsY0FBYywrSEFBK0gsNkJBQTZCLDRCQUE0QixvQkFBb0IseUZBQXlGLEtBQUssUUFBUSxlQUFlLHlCQUF5Qiw0Q0FBNEMsRUFBRSxNQUFNLFFBQVEsV0FBVztBQUMxYyxNQUFNLFFBQVEsT0FBTyxRQUFRLG9DQUFvQyxjQUFjLE9BQU8sUUFBUSxTQUFTLGtDQUFrQyxpQkFBaUIsMkNBQTJDLFlBQVksR0FBRyxVQUFVLHlFQUF5RSxRQUFRLEtBQUssU0FBUyxtQ0FBbUMscUJBQXFCLG9DQUFvQztBQUN6Wix1SEFBdUgseUNBQXlDLGlCQUFpQixzQ0FBc0MsVUFBVSxPQUFPLFNBQVMsa0JBQWtCLHdCQUF3QixVQUFVLGtDQUFrQyxRQUFRLGNBQWMsOEJBQThCLGlCQUFpQixrQ0FBa0MsY0FBYywyQkFBMkIsaUJBQWlCO0FBQ3hlLEdBQUcsK0RBQStELDhCQUE4QixvQkFBb0IseUNBQXlDLGtFQUFrRSwyQkFBMkIsaUJBQWlCLHdDQUF3Qyw2REFBNkQsWUFBWSxpQ0FBaUMseUVBQXlFO0FBQ3RlLEdBQUcsb0NBQW9DLHNDQUFzQyxvQkFBb0Isa0NBQWtDLGlCQUFpQixTQUFTLHFDQUFxQyxtQkFBbUIsa0NBQWtDLGlCQUFpQixTQUFTLHVDQUF1QyxPQUFPLFFBQVEscUJBQXFCLHFDQUFxQyxPQUFPLGVBQWUsc0RBQXNELDZDQUE2QztBQUMxZiwyQ0FBMkMsbUNBQW1DLG1EQUFtRCx1REFBdUQsMENBQTBDLCtDQUErQyw0RUFBNEUsRUFBRTtBQUMvVix1QkFBdUIsc0JBQXNCLDRCQUE0QixnQ0FBZ0MsS0FBSyxXQUFXLG1CQUFtQixjQUFjLGtCQUFrQiw2QkFBNkIsMEJBQTBCLDhCQUE4QiwyQkFBMkIsRUFBRSxrQ0FBa0MsaUJBQWlCLGtFQUFrRSxzQkFBc0I7QUFDemEsaUJBQWlCLGdEQUFnRCxrQ0FBa0Msc0RBQXNELGlDQUFpQztBQUMxTCxRQUFRLHdDQUF3Qyx1QkFBdUIsMkJBQTJCLDRCQUE0QixrQ0FBa0MsOERBQThELHlCQUF5Qix5QkFBeUIsd0JBQXdCLHlCQUF5Qix1REFBdUQsdURBQXVELHNCQUFzQixvQ0FBb0M7QUFDemUsUUFBUSw0REFBNEQsNkJBQTZCLDJCQUEyQixFQUFFLFNBQVMsMEtBQTBLO0FBQ2pULHNCQUFzQix5RkFBeUYsRUFBRSxzQkFBc0IsV0FBVyxnQkFBZ0I7Ozs7Ozs7QUNwT2xLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxjQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQixFQUFFO0FBQy9ELHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsK0RBQStEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOzs7QUFHdEMsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qjs7QUFF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QUEwQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkJBQTZCO0FBQzdCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGdDQUFnQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsZ0NBQWdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUIsT0FBTztBQUNQO0FBQ0E7O0FBRUEsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7OztBQUdBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxDQUFDLEU7Ozs7Ozs7Ozs7Ozs7QUM5ekVEO0FBQUEsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosaURBQWlELGFBQWEsdUZBQXVGLEVBQUUsdUZBQXVGOztBQUU5TywwQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU5YztBQUM5QjtBQUN3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBOztBQUVBLDJFOzs7Ozs7Ozs7Ozs7OztBQ3ZFQTtBQUFBLG1EQUFtRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWU7O0FBRTlQLDhDQUE4QyxpQkFBaUIscUJBQXFCLG9DQUFvQyw2REFBNkQsb0JBQW9CLEVBQUUsZUFBZTs7QUFFMU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSwwRTs7Ozs7Ozs7Ozs7O0FDdEc2QjtBQUN3Qjs7QUFFckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSw4Sjs7Ozs7Ozs7OztBQ25CcUQ7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsd0g7Ozs7Ozs7Ozs7O0FDWkE7QUFBQSxtREFBbUQsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELDJCQUEyQixFQUFFLEVBQUUsRUFBRSxlQUFlOztBQUU5UDs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLDhHOzs7Ozs7Ozs7OztBQzVDQTtBQUFBLDhDQUE4QyxpQkFBaUIscUJBQXFCLG9DQUFvQyw2REFBNkQsb0JBQW9CLEVBQUUsZUFBZTs7QUFFMU47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEM7Ozs7Ozs7Ozs7QUNyR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7O0FDaEJBO0FBQUEsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdko7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7OztBQ3pGRDtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQzs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0ZBQXNGLGFBQWE7QUFDbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLGVBQWU7QUFDM0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLE9BQU87QUFDcEIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDLFNBQVM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDaFBBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiJidW5kbGUubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA5OCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgMGU4MzViMjcxNTIyMjM3NDA5ZGIiLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdDAgPSBuZXcgRGF0ZSxcbiAgICB0MSA9IG5ldyBEYXRlO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBuZXdJbnRlcnZhbChmbG9vcmksIG9mZnNldGksIGNvdW50LCBmaWVsZCkge1xuXG4gIGZ1bmN0aW9uIGludGVydmFsKGRhdGUpIHtcbiAgICByZXR1cm4gZmxvb3JpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSkpLCBkYXRlO1xuICB9XG5cbiAgaW50ZXJ2YWwuZmxvb3IgPSBpbnRlcnZhbDtcblxuICBpbnRlcnZhbC5jZWlsID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKGRhdGUgLSAxKSksIG9mZnNldGkoZGF0ZSwgMSksIGZsb29yaShkYXRlKSwgZGF0ZTtcbiAgfTtcblxuICBpbnRlcnZhbC5yb3VuZCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICB2YXIgZDAgPSBpbnRlcnZhbChkYXRlKSxcbiAgICAgICAgZDEgPSBpbnRlcnZhbC5jZWlsKGRhdGUpO1xuICAgIHJldHVybiBkYXRlIC0gZDAgPCBkMSAtIGRhdGUgPyBkMCA6IGQxO1xuICB9O1xuXG4gIGludGVydmFsLm9mZnNldCA9IGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICByZXR1cm4gb2Zmc2V0aShkYXRlID0gbmV3IERhdGUoK2RhdGUpLCBzdGVwID09IG51bGwgPyAxIDogTWF0aC5mbG9vcihzdGVwKSksIGRhdGU7XG4gIH07XG5cbiAgaW50ZXJ2YWwucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIHZhciByYW5nZSA9IFtdO1xuICAgIHN0YXJ0ID0gaW50ZXJ2YWwuY2VpbChzdGFydCk7XG4gICAgc3RlcCA9IHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApO1xuICAgIGlmICghKHN0YXJ0IDwgc3RvcCkgfHwgIShzdGVwID4gMCkpIHJldHVybiByYW5nZTsgLy8gYWxzbyBoYW5kbGVzIEludmFsaWQgRGF0ZVxuICAgIGRvIHJhbmdlLnB1c2gobmV3IERhdGUoK3N0YXJ0KSk7IHdoaWxlIChvZmZzZXRpKHN0YXJ0LCBzdGVwKSwgZmxvb3JpKHN0YXJ0KSwgc3RhcnQgPCBzdG9wKVxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICBpbnRlcnZhbC5maWx0ZXIgPSBmdW5jdGlvbih0ZXN0KSB7XG4gICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIGlmIChkYXRlID49IGRhdGUpIHdoaWxlIChmbG9vcmkoZGF0ZSksICF0ZXN0KGRhdGUpKSBkYXRlLnNldFRpbWUoZGF0ZSAtIDEpO1xuICAgIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgIGlmIChkYXRlID49IGRhdGUpIHdoaWxlICgtLXN0ZXAgPj0gMCkgd2hpbGUgKG9mZnNldGkoZGF0ZSwgMSksICF0ZXN0KGRhdGUpKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG4gICAgfSk7XG4gIH07XG5cbiAgaWYgKGNvdW50KSB7XG4gICAgaW50ZXJ2YWwuY291bnQgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICB0MC5zZXRUaW1lKCtzdGFydCksIHQxLnNldFRpbWUoK2VuZCk7XG4gICAgICBmbG9vcmkodDApLCBmbG9vcmkodDEpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY291bnQodDAsIHQxKSk7XG4gICAgfTtcblxuICAgIGludGVydmFsLmV2ZXJ5ID0gZnVuY3Rpb24oc3RlcCkge1xuICAgICAgc3RlcCA9IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgICByZXR1cm4gIWlzRmluaXRlKHN0ZXApIHx8ICEoc3RlcCA+IDApID8gbnVsbFxuICAgICAgICAgIDogIShzdGVwID4gMSkgPyBpbnRlcnZhbFxuICAgICAgICAgIDogaW50ZXJ2YWwuZmlsdGVyKGZpZWxkXG4gICAgICAgICAgICAgID8gZnVuY3Rpb24oZCkgeyByZXR1cm4gZmllbGQoZCkgJSBzdGVwID09PSAwOyB9XG4gICAgICAgICAgICAgIDogZnVuY3Rpb24oZCkgeyByZXR1cm4gaW50ZXJ2YWwuY291bnQoMCwgZCkgJSBzdGVwID09PSAwOyB9KTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGludGVydmFsO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2QzLXRpbWUvc3JjL2ludGVydmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCB2YXIgZHVyYXRpb25TZWNvbmQgPSAxZTM7XG5leHBvcnQgdmFyIGR1cmF0aW9uTWludXRlID0gNmU0O1xuZXhwb3J0IHZhciBkdXJhdGlvbkhvdXIgPSAzNmU1O1xuZXhwb3J0IHZhciBkdXJhdGlvbkRheSA9IDg2NGU1O1xuZXhwb3J0IHZhciBkdXJhdGlvbldlZWsgPSA2MDQ4ZTU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZDMtdGltZS9zcmMvZHVyYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gQ2FudmFzMkRDb250ZXh0KGNhbnZhcykge1xuICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENhbnZhczJEQ29udGV4dCkpIHtcbiAgICAgIHJldHVybiBuZXcgQ2FudmFzMkRDb250ZXh0KGNhbnZhcyk7XG4gICB9XG4gICB0aGlzLmNvbnRleHQgPSB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgaWYgKCFDYW52YXMyRENvbnRleHQucHJvdG90eXBlLmFyYykge1xuICAgICAgQ2FudmFzMkRDb250ZXh0LnNldHVwLmNhbGwodGhpcywgdGhpcy5jdHgpO1xuICAgfVxufVxuQ2FudmFzMkRDb250ZXh0LnNldHVwID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBtZXRob2RzID0gWydhcmMnLCdhcmNUbycsJ2JlZ2luUGF0aCcsJ2JlemllckN1cnZlVG8nLCdjbGVhclJlY3QnLCdjbGlwJyxcbiAgICdjbG9zZVBhdGgnLCdkcmF3SW1hZ2UnLCdmaWxsJywnZmlsbFJlY3QnLCdmaWxsVGV4dCcsJ2xpbmVUbycsJ21vdmVUbycsXG4gICAncXVhZHJhdGljQ3VydmVUbycsJ3JlY3QnLCdyZXN0b3JlJywncm90YXRlJywnc2F2ZScsJ3NjYWxlJywnc2V0VHJhbnNmb3JtJyxcbiAgICdzdHJva2UnLCdzdHJva2VSZWN0Jywnc3Ryb2tlVGV4dCcsJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSddO1xuXG4gY29uc3QgZ2V0dGVyTWV0aG9kcyA9IFsnY3JlYXRlUGF0dGVybicsJ2RyYXdGb2N1c1JpbmcnLCdpc1BvaW50SW5QYXRoJyxcbiAgICdtZWFzdXJlVGV4dCcsICdjcmVhdGVJbWFnZURhdGEnLCdjcmVhdGVMaW5lYXJHcmFkaWVudCcsXG4gICAnY3JlYXRlUmFkaWFsR3JhZGllbnQnLCAnZ2V0SW1hZ2VEYXRhJywncHV0SW1hZ2VEYXRhJ1xuIF07XG5cbiBjb25zdCBwcm9wZXJ0aWVzID0gWydjYW52YXMnLCdmaWxsU3R5bGUnLCdmb250JywnZ2xvYmFsQWxwaGEnLCdnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24nLFxuICAgJ2xpbmVDYXAnLCdsaW5lSm9pbicsJ2xpbmVXaWR0aCcsJ21pdGVyTGltaXQnLCdzaGFkb3dPZmZzZXRYJywnc2hhZG93T2Zmc2V0WScsXG4gICAnc2hhZG93Qmx1cicsJ3NoYWRvd0NvbG9yJywnc3Ryb2tlU3R5bGUnLCd0ZXh0QWxpZ24nLCd0ZXh0QmFzZWxpbmUnXTtcblxuICAgZm9yIChsZXQgbSBvZiBtZXRob2RzKSB7XG4gICAgICBsZXQgbWV0aG9kID0gbTtcbiAgICAgIENhbnZhczJEQ29udGV4dC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIHRoaXMuY3R4W21ldGhvZF0uYXBwbHkodGhpcy5jdHgsIGFyZ3VtZW50cyk7XG4gICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICB9XG5cbiAgIGZvciAobGV0IG0gb2YgZ2V0dGVyTWV0aG9kcykge1xuICAgICAgbGV0IG1ldGhvZCA9IG07XG4gICAgICBDYW52YXMyRENvbnRleHQucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5jdHhbbWV0aG9kXS5hcHBseSh0aGlzLmN0eCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICB9XG5cbiAgIGZvciAobGV0IHAgb2YgcHJvcGVydGllcykge1xuICAgICAgbGV0IHByb3AgPSBwO1xuICAgICAgQ2FudmFzMkRDb250ZXh0LnByb3RvdHlwZVtwcm9wXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdHhbcHJvcF07XG4gICAgICAgICB0aGlzLmN0eFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IENhbnZhczJEQ29udGV4dDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9jb21wb25lbnRzL2NhbnZhcy9jdHhjb21wb25lbnRzL2N0eENvbnRleHRTZXQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZianMvbGliL2ludmFyaWFudC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L29iamVjdC1hc3NpZ24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFByb3ZpZGVyLCB7IGNyZWF0ZVByb3ZpZGVyIH0gZnJvbSAnLi9jb21wb25lbnRzL1Byb3ZpZGVyJztcbmltcG9ydCBjb25uZWN0QWR2YW5jZWQgZnJvbSAnLi9jb21wb25lbnRzL2Nvbm5lY3RBZHZhbmNlZCc7XG5pbXBvcnQgY29ubmVjdCBmcm9tICcuL2Nvbm5lY3QvY29ubmVjdCc7XG5cbmV4cG9ydCB7IFByb3ZpZGVyLCBjcmVhdGVQcm92aWRlciwgY29ubmVjdEFkdmFuY2VkLCBjb25uZWN0IH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LXJlZHV4L2VzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9mYmpzL2xpYi9lbXB0eU9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9mYmpzL2xpYi93YXJuaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IEFERF9DSEFSVCA9ICdBRERfQ0hBUlQnXG5jb25zdCBDTE9TRV9DSEFSVCA9ICdDTE9TRV9DSEFSVCdcbmNvbnN0IENIQVJUX1NUQVRFX1VQREFURSA9ICdDSEFSVF9TVEFURV9VUERBVEUnXG5jb25zdCBXQVRDSEVEX1BPU0lUSU9OUyA9ICdXQVRDSEVEX1BPU0lUSU9OUydcbmNvbnN0IEZFRURfU1RBUlQgPSAnRkVFRF9TVEFSVCdcbmNvbnN0IE9QVFNfVklFVyA9ICdPUFRTX1ZJRVcnXG5jb25zdCBTV0lUQ0hfSU5ESUNFUyA9ICdTV0lUQ0hfSU5ESUNFUydcbmNvbnN0IFRPR0dMRV9DSEFSVF9NRU5VID0gJ1RPR0dMRV9DSEFSVF9NRU5VJ1xuY29uc3QgQ09OTkVDVElPTl9MT1NUID0gJ0NPTk5FQ1RJT05fTE9TVCdcbmNvbnN0IENPTk5FQ1RFRCA9ICdDT05ORUNURUQnXG5cbmV4cG9ydCB7XG4gIEFERF9DSEFSVCxcbiAgQ0xPU0VfQ0hBUlQsXG4gIENIQVJUX1NUQVRFX1VQREFURSxcbiAgV0FUQ0hFRF9QT1NJVElPTlMsXG4gIEZFRURfU1RBUlQsXG4gIE9QVFNfVklFVyxcbiAgU1dJVENIX0lORElDRVMsXG4gIFRPR0dMRV9DSEFSVF9NRU5VLFxuICBDT05ORUNUSU9OX0xPU1QsXG4gIENPTk5FQ1RFRFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL2NvbnN0YW50cy9kYXNoYm9hcmQuanMiLCJpbXBvcnQgeGhyIGZyb20gJ3hocic7XG5cbmNsYXNzIERBVEFTT1VSQ0Uge1xuICBjb25zdHJ1Y3RvcihpbnN0YW5jZU5hbWUgPSAnRGVmYXVsdCcpIHtcbiAgICB0aGlzLmluc3RhbmNlTmFtZSA9IGluc3RhbmNlTmFtZTtcbiAgfVxuICB4aHJHZXQocm91dGUsIGNiKSB7XG4gICAgY29uc3QgdGhlVVJMID0gJy94aHJzLycgKyByb3V0ZTtcblxuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHRoZVVSTCwgdHJ1ZSk7XG4gICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPj0gMjAwICYmIHJlcXVlc3Quc3RhdHVzIDwgNDAwKSB7XG4gICAgICAgIGNvbnN0IHJlc3AgPSByZXF1ZXN0LnJlc3BvbnNlVGV4dDtcbiAgICAgICAgY2IoSlNPTi5wYXJzZShyZXNwKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygndGhpbmdzIGhhcHBlbmVkJyk7XG4gICAgfTtcbiAgICByZXF1ZXN0LnNlbmQoKTtcblxuICB9XG4gIHhoclBvc3Qocm91dGUsIGRhdGEsIGNiKSB7XG4gICAgY29uc3QgdGhlVVJMID0gJy94aHJzLycgKyByb3V0ZTtcbiAgICB4aHIoe1xuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICB1cmk6IHRoZVVSTCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgfVxuICAgIH0sIChlcnIsIHJlc3AsIGJvZHkpID0+IGNiKEpTT04ucGFyc2UoYm9keSkpKVxuICB9O1xuXG4gIGdldFJlYWxUaW1lWEhSID0gKGNiKSA9PiB7XG4gICAgdGhpcy54aHJHZXQoJ2dldHVzZXJzJywgY2IpO1xuICB9XG4gIGdldExpc3RUeXBlWEhSID0gKHBhcmFtLCBjYikgPT4ge1xuICAgIGNvbnNvbGUubG9nKCd1c2VkIHNvY2tldHMgZm9yIGdldExpc3RUeXBlJyk7XG4gICAgY29uc3Qgcm91dGUgPSAnbGlzdHBhcmFtcy8nICsgcGFyYW07XG4gICAgdGhpcy54aHJHZXQocm91dGUsIGNiKTtcbiAgfVxuXG4gIGdldEluZGljYXRvclhIUiA9IChjb3VudHJ5LCBjYikgPT4ge1xuICAgIGNvbnN0IHJvdXRlID0gJ2luZGljYXRvci8nICsgY291bnRyeTtcbiAgICB0aGlzLnhockdldChyb3V0ZSwgY2IpO1xuICB9XG4gIGdldE1hcmtldERhdGFYSFIgPSAoc3ltYm9sLCBjYikgPT4ge1xuICAgIGNvbnN0IHJvdXRlID0gJ21hcmtldGRhdGEvJyArIHN5bWJvbC50b1VwcGVyQ2FzZSgpO1xuICAgIHRoaXMueGhyR2V0KHJvdXRlLCBjYik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IERBVEFTT1VSQ0UoJ21haW4nKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9kYXRhL2RhdGFzb3VyY2UuanMiLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnZDMtcmFuZG9tJyksIHJlcXVpcmUoJ2QzZmMtcmViaW5kJyksIHJlcXVpcmUoJ2QzLXRpbWUnKSkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtcmFuZG9tJywgJ2QzZmMtcmViaW5kJywgJ2QzLXRpbWUnXSwgZmFjdG9yeSkgOlxuICAgIChmYWN0b3J5KChnbG9iYWwuZmMgPSBnbG9iYWwuZmMgfHwge30pLGdsb2JhbC5kMyxnbG9iYWwuZmMsZ2xvYmFsLmQzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxkM1JhbmRvbSxkM2ZjUmViaW5kLGQzVGltZSkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBnZW9tZXRyaWNCcm93bmlhbk1vdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGVyaW9kID0gMTtcbiAgICB2YXIgc3RlcHMgPSAyMDtcbiAgICB2YXIgbXUgPSAwLjE7XG4gICAgdmFyIHNpZ21hID0gMC4xO1xuICAgIHZhciByYW5kb21Ob3JtYWwkJDEgPSBkM1JhbmRvbS5yYW5kb21Ob3JtYWwoKTtcblxuICAgIHZhciBnZW9tZXRyaWNCcm93bmlhbk1vdGlvbiA9IGZ1bmN0aW9uIGdlb21ldHJpY0Jyb3duaWFuTW90aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciB0aW1lU3RlcCA9IHBlcmlvZCAvIHN0ZXBzO1xuICAgICAgICB2YXIgcGF0aERhdGEgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ZXBzICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBwYXRoRGF0YS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHZhciBpbmNyZW1lbnQgPSByYW5kb21Ob3JtYWwkJDEoKSAqIE1hdGguc3FydCh0aW1lU3RlcCkgKiBzaWdtYSArIChtdSAtIHNpZ21hICogc2lnbWEgLyAyKSAqIHRpbWVTdGVwO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIE1hdGguZXhwKGluY3JlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aERhdGE7XG4gICAgfTtcblxuICAgIGdlb21ldHJpY0Jyb3duaWFuTW90aW9uLnBlcmlvZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGVyaW9kO1xuICAgICAgICB9XG4gICAgICAgIHBlcmlvZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGdlb21ldHJpY0Jyb3duaWFuTW90aW9uO1xuICAgIH07XG5cbiAgICBnZW9tZXRyaWNCcm93bmlhbk1vdGlvbi5zdGVwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcHM7XG4gICAgICAgIH1cbiAgICAgICAgc3RlcHMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBnZW9tZXRyaWNCcm93bmlhbk1vdGlvbjtcbiAgICB9O1xuXG4gICAgZ2VvbWV0cmljQnJvd25pYW5Nb3Rpb24ubXUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG11O1xuICAgICAgICB9XG4gICAgICAgIG11ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZ2VvbWV0cmljQnJvd25pYW5Nb3Rpb247XG4gICAgfTtcblxuICAgIGdlb21ldHJpY0Jyb3duaWFuTW90aW9uLnNpZ21hID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWdtYTtcbiAgICAgICAgfVxuICAgICAgICBzaWdtYSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGdlb21ldHJpY0Jyb3duaWFuTW90aW9uO1xuICAgIH07XG5cbiAgICBnZW9tZXRyaWNCcm93bmlhbk1vdGlvbi5yYW5kb21Ob3JtYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmRvbU5vcm1hbCQkMTtcbiAgICAgICAgfVxuICAgICAgICByYW5kb21Ob3JtYWwkJDEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBnZW9tZXRyaWNCcm93bmlhbk1vdGlvbjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGdlb21ldHJpY0Jyb3duaWFuTW90aW9uO1xufTtcblxuZnVuY3Rpb24gZnVuY3Rvcih2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSAnZnVuY3Rpb24nID8gdiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfTtcbn1cblxudmFyIGZpbmFuY2lhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhcnREYXRlID0gbmV3IERhdGUoKTtcbiAgICB2YXIgc3RhcnRQcmljZSA9IDEwMDtcbiAgICB2YXIgaW50ZXJ2YWwgPSBkM1RpbWUudGltZURheTtcbiAgICB2YXIgaW50ZXJ2YWxTdGVwID0gMTtcbiAgICB2YXIgdW5pdEludGVydmFsID0gZDNUaW1lLnRpbWVZZWFyO1xuICAgIHZhciB1bml0SW50ZXJ2YWxTdGVwID0gMTtcbiAgICB2YXIgZmlsdGVyID0gbnVsbDtcbiAgICB2YXIgdm9sdW1lID0gZnVuY3Rpb24gdm9sdW1lKCkge1xuICAgICAgICB2YXIgbm9ybWFsID0gZDNSYW5kb20ucmFuZG9tTm9ybWFsKDEsIDAuMSk7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobm9ybWFsKCkgKiAxMDAwKTtcbiAgICB9O1xuICAgIHZhciBnYm0gPSBnZW9tZXRyaWNCcm93bmlhbk1vdGlvbigpO1xuXG4gICAgdmFyIGdldE9mZnNldFBlcmlvZCA9IGZ1bmN0aW9uIGdldE9mZnNldFBlcmlvZChkYXRlKSB7XG4gICAgICAgIHZhciB1bml0TWlsbGlzZWNvbmRzID0gdW5pdEludGVydmFsLm9mZnNldChkYXRlLCB1bml0SW50ZXJ2YWxTdGVwKSAtIGRhdGU7XG4gICAgICAgIHJldHVybiAoaW50ZXJ2YWwub2Zmc2V0KGRhdGUsIGludGVydmFsU3RlcCkgLSBkYXRlKSAvIHVuaXRNaWxsaXNlY29uZHM7XG4gICAgfTtcblxuICAgIHZhciBjYWxjdWxhdGVPSExDID0gZnVuY3Rpb24gY2FsY3VsYXRlT0hMQyhzdGFydCwgcHJpY2UpIHtcbiAgICAgICAgdmFyIHBlcmlvZCA9IGdldE9mZnNldFBlcmlvZChzdGFydCk7XG4gICAgICAgIHZhciBwcmljZXMgPSBnYm0ucGVyaW9kKHBlcmlvZCkocHJpY2UpO1xuICAgICAgICB2YXIgb2hsYyA9IHtcbiAgICAgICAgICAgIGRhdGU6IHN0YXJ0LFxuICAgICAgICAgICAgb3BlbjogcHJpY2VzWzBdLFxuICAgICAgICAgICAgaGlnaDogTWF0aC5tYXguYXBwbHkoTWF0aCwgcHJpY2VzKSxcbiAgICAgICAgICAgIGxvdzogTWF0aC5taW4uYXBwbHkoTWF0aCwgcHJpY2VzKSxcbiAgICAgICAgICAgIGNsb3NlOiBwcmljZXNbZ2JtLnN0ZXBzKCldXG4gICAgICAgIH07XG4gICAgICAgIG9obGMudm9sdW1lID0gdm9sdW1lKG9obGMpO1xuICAgICAgICByZXR1cm4gb2hsYztcbiAgICB9O1xuXG4gICAgdmFyIGdldE5leHREYXR1bSA9IGZ1bmN0aW9uIGdldE5leHREYXR1bShvaGxjKSB7XG4gICAgICAgIHZhciBkYXRlID0gdm9pZCAwLFxuICAgICAgICAgICAgcHJpY2UgPSB2b2lkIDAsXG4gICAgICAgICAgICBmaWx0ZXJlZCA9IHZvaWQgMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZGF0ZSA9IG9obGMgPyBpbnRlcnZhbC5vZmZzZXQob2hsYy5kYXRlLCBpbnRlcnZhbFN0ZXApIDogbmV3IERhdGUoc3RhcnREYXRlLmdldFRpbWUoKSk7XG4gICAgICAgICAgICBwcmljZSA9IG9obGMgPyBvaGxjLmNsb3NlIDogc3RhcnRQcmljZTtcbiAgICAgICAgICAgIG9obGMgPSBjYWxjdWxhdGVPSExDKGRhdGUsIHByaWNlKTtcbiAgICAgICAgICAgIGZpbHRlcmVkID0gZmlsdGVyICYmICFmaWx0ZXIob2hsYyk7XG4gICAgICAgIH0gd2hpbGUgKGZpbHRlcmVkKTtcbiAgICAgICAgcmV0dXJuIG9obGM7XG4gICAgfTtcblxuICAgIHZhciBtYWtlU3RyZWFtID0gZnVuY3Rpb24gbWFrZVN0cmVhbSgpIHtcbiAgICAgICAgdmFyIGxhdGVzdCA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHN0cmVhbSA9IHt9O1xuICAgICAgICBzdHJlYW0ubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvaGxjID0gZ2V0TmV4dERhdHVtKGxhdGVzdCk7XG4gICAgICAgICAgICBsYXRlc3QgPSBvaGxjO1xuICAgICAgICAgICAgcmV0dXJuIG9obGM7XG4gICAgICAgIH07XG4gICAgICAgIHN0cmVhbS50YWtlID0gZnVuY3Rpb24gKG51bVBvaW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmVhbS51bnRpbChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhbnVtUG9pbnRzIHx8IG51bVBvaW50cyA8IDAgfHwgaSA9PT0gbnVtUG9pbnRzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHN0cmVhbS51bnRpbCA9IGZ1bmN0aW9uIChjb21wYXJpc29uKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgICAgIHZhciBvaGxjID0gZ2V0TmV4dERhdHVtKGxhdGVzdCk7XG4gICAgICAgICAgICB2YXIgY29tcGFyZWQgPSBjb21wYXJpc29uICYmICFjb21wYXJpc29uKG9obGMsIGluZGV4KTtcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlZCkge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaChvaGxjKTtcbiAgICAgICAgICAgICAgICBsYXRlc3QgPSBvaGxjO1xuICAgICAgICAgICAgICAgIG9obGMgPSBnZXROZXh0RGF0dW0obGF0ZXN0KTtcbiAgICAgICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIGNvbXBhcmVkID0gY29tcGFyaXNvbiAmJiAhY29tcGFyaXNvbihvaGxjLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9O1xuXG4gICAgdmFyIGZpbmFuY2lhbCA9IGZ1bmN0aW9uIGZpbmFuY2lhbChudW1Qb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTdHJlYW0oKS50YWtlKG51bVBvaW50cyk7XG4gICAgfTtcbiAgICBmaW5hbmNpYWwuc3RyZWFtID0gbWFrZVN0cmVhbTtcbiAgICBmaW5hbmNpYWxbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IG1ha2VTdHJlYW0oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0cmVhbS5uZXh0KCksXG4gICAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZmluYW5jaWFsLnN0YXJ0RGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnREYXRlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0RGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGZpbmFuY2lhbDtcbiAgICB9O1xuICAgIGZpbmFuY2lhbC5zdGFydFByaWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydFByaWNlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0UHJpY2UgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBmaW5hbmNpYWw7XG4gICAgfTtcbiAgICBmaW5hbmNpYWwuaW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIGludGVydmFsID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZmluYW5jaWFsO1xuICAgIH07XG4gICAgZmluYW5jaWFsLmludGVydmFsU3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJ2YWxTdGVwO1xuICAgICAgICB9XG4gICAgICAgIGludGVydmFsU3RlcCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGZpbmFuY2lhbDtcbiAgICB9O1xuICAgIGZpbmFuY2lhbC51bml0SW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuaXRJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICB1bml0SW50ZXJ2YWwgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBmaW5hbmNpYWw7XG4gICAgfTtcbiAgICBmaW5hbmNpYWwudW5pdEludGVydmFsU3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5pdEludGVydmFsU3RlcDtcbiAgICAgICAgfVxuICAgICAgICB1bml0SW50ZXJ2YWxTdGVwID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZmluYW5jaWFsO1xuICAgIH07XG4gICAgZmluYW5jaWFsLmZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIGZpbHRlciA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGZpbmFuY2lhbDtcbiAgICB9O1xuICAgIGZpbmFuY2lhbC52b2x1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHZvbHVtZTtcbiAgICAgICAgfVxuICAgICAgICB2b2x1bWUgPSBmdW5jdG9yKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSk7XG4gICAgICAgIHJldHVybiBmaW5hbmNpYWw7XG4gICAgfTtcblxuICAgIGQzZmNSZWJpbmQucmViaW5kKGZpbmFuY2lhbCwgZ2JtLCAnc3RlcHMnLCAnbXUnLCAnc2lnbWEnKTtcblxuICAgIHJldHVybiBmaW5hbmNpYWw7XG59O1xuXG52YXIgc2tpcFdlZWtlbmRzID0gZnVuY3Rpb24gKGRhdHVtKSB7XG4gICAgdmFyIGRheSA9IGRhdHVtLmRhdGUuZ2V0RGF5KCk7XG4gICAgcmV0dXJuICEoZGF5ID09PSAwIHx8IGRheSA9PT0gNik7XG59O1xuXG5leHBvcnRzLnJhbmRvbUZpbmFuY2lhbCA9IGZpbmFuY2lhbDtcbmV4cG9ydHMucmFuZG9tR2VvbWV0cmljQnJvd25pYW5Nb3Rpb24gPSBnZW9tZXRyaWNCcm93bmlhbk1vdGlvbjtcbmV4cG9ydHMucmFuZG9tU2tpcFdlZWtlbmRzID0gc2tpcFdlZWtlbmRzO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2QzZmMtcmFuZG9tLWRhdGEvYnVpbGQvZDNmYy1yYW5kb20tZGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgZ2V0UHJvdG90eXBlIGZyb20gJy4vX2dldFByb3RvdHlwZS5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1BsYWluT2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC1lcy9pc1BsYWluT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuICB2YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpbnZhcmlhbnQodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ3RoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAlc2AuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0pO1xuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCAlcyB0eXBlOiAlcyVzJywgbG9jYXRpb24sIGVycm9yLm1lc3NhZ2UsIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFByaW50cyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1yZWR1eC9lcy91dGlscy93YXJuaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgY3JlYXRlU3RvcmUgZnJvbSAnLi9jcmVhdGVTdG9yZSc7XG5pbXBvcnQgY29tYmluZVJlZHVjZXJzIGZyb20gJy4vY29tYmluZVJlZHVjZXJzJztcbmltcG9ydCBiaW5kQWN0aW9uQ3JlYXRvcnMgZnJvbSAnLi9iaW5kQWN0aW9uQ3JlYXRvcnMnO1xuaW1wb3J0IGFwcGx5TWlkZGxld2FyZSBmcm9tICcuL2FwcGx5TWlkZGxld2FyZSc7XG5pbXBvcnQgY29tcG9zZSBmcm9tICcuL2NvbXBvc2UnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi91dGlscy93YXJuaW5nJztcblxuLypcbiogVGhpcyBpcyBhIGR1bW15IGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBmdW5jdGlvbiBuYW1lIGhhcyBiZWVuIGFsdGVyZWQgYnkgbWluaWZpY2F0aW9uLlxuKiBJZiB0aGUgZnVuY3Rpb24gaGFzIGJlZW4gbWluaWZpZWQgYW5kIE5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsIHdhcm4gdGhlIHVzZXIuXG4qL1xuZnVuY3Rpb24gaXNDcnVzaGVkKCkge31cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGlzQ3J1c2hlZC5uYW1lID09PSAnc3RyaW5nJyAmJiBpc0NydXNoZWQubmFtZSAhPT0gJ2lzQ3J1c2hlZCcpIHtcbiAgd2FybmluZygnWW91IGFyZSBjdXJyZW50bHkgdXNpbmcgbWluaWZpZWQgY29kZSBvdXRzaWRlIG9mIE5PREVfRU5WID09PSBcXCdwcm9kdWN0aW9uXFwnLiAnICsgJ1RoaXMgbWVhbnMgdGhhdCB5b3UgYXJlIHJ1bm5pbmcgYSBzbG93ZXIgZGV2ZWxvcG1lbnQgYnVpbGQgb2YgUmVkdXguICcgKyAnWW91IGNhbiB1c2UgbG9vc2UtZW52aWZ5IChodHRwczovL2dpdGh1Yi5jb20vemVydG9zaC9sb29zZS1lbnZpZnkpIGZvciBicm93c2VyaWZ5ICcgKyAnb3IgRGVmaW5lUGx1Z2luIGZvciB3ZWJwYWNrIChodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMwMDMwMDMxKSAnICsgJ3RvIGVuc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBjb2RlIGZvciB5b3VyIHByb2R1Y3Rpb24gYnVpbGQuJyk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVN0b3JlLCBjb21iaW5lUmVkdWNlcnMsIGJpbmRBY3Rpb25DcmVhdG9ycywgYXBwbHlNaWRkbGV3YXJlLCBjb21wb3NlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlZHV4L2VzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJjb25zdCBXSURHRVRfRFJPUCA9ICdXSURHRVRfRFJPUCdcbmNvbnN0IFdJREdFVF9EUkFHR0VEID0gJ1dJREdFVF9EUkFHR0VEJ1xuY29uc3QgR09UX01FU1NBR0UgPSAnR09UX01FU1NBR0UnXG5jb25zdCBHT1RfREFUQSA9ICdHT1RfREFUQSdcblxuZXhwb3J0IHtcbiAgV0lER0VUX0RST1AsXG4gIFdJREdFVF9EUkFHR0VELFxuICBHT1RfTUVTU0FHRSxcbiAgR09UX0RBVEFcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9jb25zdGFudHMvd2lkZ2V0cy5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYXBoIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9J2NvbnRhaW5lcic+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPSdjb2wteHMtMTIganVzdC1zby15b3Uta25vdyc+XG4gICAgICAgICAgPHA+Tm90ZTogSSB0ZW1wb3JhcmlseSByZW1vdmVkIHRoZSBoaXN0b3JpY2FsIGdyYXBoIGZvciB0d28gcmVhc29uczwvcD5cbiAgICAgICAgICA8b2w+XG4gICAgICAgICAgICA8bGk+VGhlIG1hcmtldCBkYXRhIEFQSSBmcmVlIHRyaWFsIGV4cGlyZWQoc28gSSBkb24ndCBoYXZlIHVwLXRvLWRhdGUgZGF0YSB0byBkaXNwbGF5KTwvbGk+XG4gICAgICAgICAgICA8bGk+UmVtb3ZpbmcgdGhpcyB3aWxsIGFsbG93IG1lIHRvIGN1dCBvZmYgZ2VuZXJhbGx5IHVudXNlZCBkZXBlbmRlbmNpZXM8L2xpPlxuICAgICAgICAgIDwvb2w+XG4gICAgICAgICAgPHA+XG4gICAgICAgICAgICA8c3Ryb25nPlNvcnJ5ITwvc3Ryb25nPlxuICAgICAgICAgIDwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29udGFpbmVycy9ncmFwaF90ZW1wLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgREFUQVNPVVJDRSBmcm9tICdkYXRhL2RhdGFzb3VyY2UnO1xuaW1wb3J0IENvdW50cmllcyAgZnJvbSAnZGF0YS9jb3VudHJpZXMnO1xuaW1wb3J0IEluZGljYXRvcnMgZnJvbSAnZGF0YS9pbmRpY2F0b3JzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgdGhpcy5kYlNvdXJjZSA9IERBVEFTT1VSQ0U7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgY29udGluZW50OiAnQVNJQScsXG4gICAgICAgICBjb3VudHJ5OiAnQ2hpbmEnLFxuICAgICAgICAgZGF0YUJsb2I6IG51bGxcbiAgICAgIH1cbiAgIH1cbiAgIGdvdERhdGEgPSAoZGF0YSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ2dvdCBpbmRpY2F0b3JzJywgZGF0YSk7XG4gICAgICBsZXQgdGhlRGF0YSA9IHt9O1xuICAgICAgdGhlRGF0YS5zZWMxID0gZGF0YVswXVswXTtcbiAgICAgIHRoZURhdGEuc2VjMiA9IGRhdGFbMV0ucmVkdWNlKChvYiwgaXRtLCBpKSA9PiB7XG4gICAgICAgICBsZXQgdCA9ICdpbmRleF8nICsgaTtcbiAgICAgICAgIG9iW3RdID0gaXRtO1xuICAgICAgICAgcmV0dXJuIG9iO1xuICAgICAgfSwge30pO1xuICAgICAgbGV0IGR0YSA9IEpTT04uc3RyaW5naWZ5KHRoZURhdGEsIHVuZGVmaW5lZCwgMik7XG4gICAgICB0aGlzLnJlZnMucmVnaW9uU2VsZWN0XG4gICAgICB0aGlzLnNldFN0YXRlKHtkYXRhQmxvYjogZHRhfSk7XG5cbiAgIH1cbiAgIGdldERhdGFDYWxsID0gKGNvdW50cnkpID0+IHtcbiAgICAgIHRoaXMuZGJTb3VyY2UuZ2V0SW5kaWNhdG9yWEhSKGNvdW50cnksIHRoaXMuZ290RGF0YSk7XG4gICB9XG4gICBjb3VudHJ5Q2hhbmdlID0gKGUpID0+IHtcbiAgICAgIGxldCBleCA9IGUudGFyZ2V0LnZhbHVlO1xuXG4gICAgICB0aGlzLnNldFN0YXRlKHtjb3VudHJ5OiBleH0pO1xuICAgfVxuICAgY29udGluZW50Q2hhbmdlID0gKGUpID0+IHtcbiAgICAgIGxldCBleCA9IGUudGFyZ2V0LnZhbHVlO1xuXG4gICAgICB0aGlzLnNldFN0YXRlKHtjb250aW5lbnQ6IGV4LCBjb3VudHJ5OiBDb3VudHJpZXNbZXhdWzBdXG4gICAgICB9KTtcbiAgIH1cbiAgIGdldEluZGljYXRvciA9ICgpID0+IHtcbiAgICAgIGxldCBjbnRyeSA9IHRoaXMucmVmcy5jb3VudHJ5U2VsZWN0LnZhbHVlO1xuICAgICAgdGhpcy5nZXREYXRhQ2FsbChjbnRyeSk7XG4gICB9XG4gICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHRoaXMuZ2V0RGF0YUNhbGwoJ2NoaW5hJyk7XG4gICAgICBjb25zb2xlLmxvZygnQ291bnRyaWVzJywgQ291bnRyaWVzKTtcbiAgIH1cbiAgIHJlbmRlcigpIHtcbiAgICAgIGxldCB7Y29udGluZW50LCBjb3VudHJ5LCBkYXRhQmxvYn0gPSB0aGlzLnN0YXRlO1xuICAgICAgbGV0IGNvdW50cnlPcHRzID0gQ291bnRyaWVzW2NvbnRpbmVudF0ubWFwKChjbnRyeSwgaWkpID0+IHtcblxuICAgICAgICAgcmV0dXJuIDxvcHRpb24ga2V5PXtjbnRyeSArICdfJyArIGlpfSB2YWx1ZT17Y250cnl9PntjbnRyeX08L29wdGlvbj47XG5cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgIDxkaXYgaWQ9J21hcENvbnRhaW5lcicgY2xhc3NOYW1lPSdjb250YWluZXInPlxuICAgICAgICAgICAgPGgyPkVjb24gSW5kaWNhdG9yczwvaDI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0ncm93IGNvbC1jZW50ZXItc2VsZSc+XG4gICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nc2VsZWN0LWNvbC1tYXBzJz5cbiAgICAgICAgICAgICAgICAgIDxzdHJvbmc+Q29udGluZW50Ojwvc3Ryb25nPlxuICAgICAgICAgICAgICAgICAgPHNlbGVjdCByZWY9J3JlZ2lvblNlbGVjdCcgY2xhc3NOYW1lPSdzeW1ib2wtcGljayBsaXZlLXN5bScgdmFsdWU9e2NvbnRpbmVudH0gb25DaGFuZ2U9e3RoaXMuY29udGluZW50Q2hhbmdlIH0+XG4gICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGtleT0nQUZSSUNBLUtFWScgdmFsdWU9J0FGUklDQSc+QUZSSUNBPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGtleT0nQU1FUklDQS1LRVknIHZhbHVlPSdBTUVSSUNBJz5BTUVSSUNBPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGtleT0nQVNJQS1LRVknIHZhbHVlPSdBU0lBJz5BU0lBPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGtleT0nQVVTVFJBTElBLUtFWScgdmFsdWU9J0FVU1RSQUxJQSc+QVVTL1BBQ0lGSUM8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24ga2V5PSdFVVJPUEUtS0VZJyB2YWx1ZT0nRVVST1BFJz5FVVJPUEU8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nc2VsZWN0LWNvbC1tYXBzJz5cbiAgICAgICAgICAgICAgICAgIDxzdHJvbmc+Q291bnRyeTo8L3N0cm9uZz5cbiAgICAgICAgICAgICAgICAgIDxzZWxlY3QgcmVmPSdjb3VudHJ5U2VsZWN0JyB2YWx1ZT17Y291bnRyeX0gY2xhc3NOYW1lPSdzeW1ib2wtcGljayBsaXZlLXN5bScgb25DaGFuZ2U9e3RoaXMuY291bnRyeUNoYW5nZSB9PlxuICAgICAgICAgICAgICAgICAgICAge2NvdW50cnlPcHRzfVxuICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J3JvdyB0ZXh0LWNlbnRlcic+XG4gICAgICAgICAgICAgICA8ZGl2IG9uQ2xpY2s9e3RoaXMuZ2V0SW5kaWNhdG9yIH0gY2xhc3NOYW1lPSdiaWctYnV0dCBnZXQtaW5kaWNhdG9ycy1idXR0Jz5HZXQgSW5kaWNhdG9yczwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8cHJlIGNsYXNzTmFtZT0ncm93IGpzb25ibG9iJz5cblx0XHRcdFx0XHR7ZGF0YUJsb2J9XG5cdFx0XHRcdDwvcHJlPlxuICAgICAgICAgPC9kaXY+XG4gICAgICApXG4gICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL2NvbnRhaW5lcnMvbWFwLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge2Nvbm5lY3R9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCBMb2FkQmFycyBmcm9tICdjb21wb25lbnRzL2xvYWRlcnMvbG9hZGJhcnMnO1xuaW1wb3J0IEN0eENoYXJ0IGZyb20gJ2NhbnZhcy9jdHhDaGFydCc7XG5pbXBvcnQgc3ByZWFkQ1RYIGZyb20gJ2NhbnZhcy9zcHJlYWRDVFgnO1xuaW1wb3J0IENhcmRDdHggZnJvbSAnY2FudmFzL2NhcmRjdHgnO1xuY29uc3QgQ2xvY2sgPSByZXF1aXJlKCdjYW52YXMvY2xvY2suanMnKTtcbmltcG9ydCBQb3NpdGlvblRpbGVzIGZyb20gJ2NhbnZhcy9wb3NpdGlvblRpbGUnO1xuaW1wb3J0IHRvdGFsQW1vdW50Q3R4IGZyb20gJ2NhbnZhcy9kZXBvc2l0YW10JztcbmltcG9ydCBHcmFwaENvbnRyb2xsZXIgZnJvbSAnaGVscGVyL2dyYXBoX2NvbnRyb2xsZXInO1xuaW1wb3J0IHN0YXRTVkdzIGZyb20gJ2NvbXBvbmVudHMvc3ZnL3N0YXRTVkcnO1xuaW1wb3J0IERBVEFTT1VSQ0UgZnJvbSAnZGF0YS9kYXRhc291cmNlJztcbmltcG9ydCBPcGVuV2Vic29ja2V0IGZyb20gJ2RhdGEvZ293ZWJzb2NrZXQnO1xuaW1wb3J0IENhbnZhc0NoYXJ0IGZyb20gJ2Rhc2hib2FyZC9saXZlZ3JhcGgvY2FudmFzY2hhcnQnO1xuaW1wb3J0IENoYXJ0Q29udGFpbmVyIGZyb20gJ2Rhc2hib2FyZC9jaGFydF9jb250YWluZXInO1xuaW1wb3J0IExpdmVTdGFydCBmcm9tICdtaWNyby9saXZlc3RhcnQnO1xuaW1wb3J0IExvYWRDb25uZWN0IGZyb20gJ2NvbXBvbmVudHMvbG9hZGVycy9zcGlubG9hZCc7XG5pbXBvcnQgRm9yZXhMaXN0IGZyb20gJ21pY3JvL2xpc3RzL2ZvcmV4bGlzdCc7XG5pbXBvcnQgU3RvY2tMaXN0IGZyb20gJ21pY3JvL2xpc3RzL3NvY2tsaXN0JztcbmltcG9ydCBBY3RpdmVTcHJlYWRzIGZyb20gJ2Rhc2hib2FyZC9vcHRpb25zL2FjdGl2ZXNwcmVhZHMnO1xuaW1wb3J0IFdpZGdldEJsb2NrIGZyb20gJ2Rhc2hib2FyZC93aWRnZXRibG9jayc7XG5pbXBvcnQgU2lkZU9wdGlvbnMgZnJvbSAnZGFzaGJvYXJkL3NpZGVvcHRpb25zJztcbmltcG9ydCBUcmFuc2FjdGlvbkxpc3QgZnJvbSAnZGFzaGJvYXJkL3RyYW5zYWN0aW9ubGlzdCc7XG5pbXBvcnQgTGl2ZVRpY2tlcnMgZnJvbSAnZGFzaGJvYXJkL2xpdmV0aWNrZXJzJztcbmltcG9ydCBXYXRjaGVkU3ByZWFkcyBmcm9tICdkYXNoYm9hcmQvb3B0aW9ucy93YXRjaGVkc3ByZWFkcyc7XG5cbmltcG9ydCB7XG4gICAgQUREX0NIQVJULFxuICAgIENMT1NFX0NIQVJULFxuICAgIENIQVJUX1NUQVRFX1VQREFURSxcbiAgICBGRUVEX1NUQVJULFxuICAgIE9QVFNfVklFVyxcbiAgICBTV0lUQ0hfSU5ESUNFUyxcbiAgICBUT0dHTEVfQ0hBUlRfTUVOVSxcbiAgICBDT05ORUNUSU9OX0xPU1QsXG4gICAgQ09OTkVDVEVEXG59IGZyb20gJ2NvbnN0YW50cy9kYXNoYm9hcmQnXG5cbmZ1bmN0aW9uIHNlbGVjdChzdG9yZSkge1xuICAvLyBIb3cgRGlmZnJlbnQgUmVkdXggc3RvcmVzIGdldCBtYXBwZWQgdG8gcHJvcHNcbiAgcmV0dXJuIHtydDogc3RvcmUucnQsIHRyYWRlczogc3RvcmUudHJhZGVzLCB0cm46IHN0b3JlLnRyYW5zYWN0aW9uc31cbn1cblxuY2xhc3MgUmVhbFRpbWUgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcylcbiAgICB0aGlzLnRyYWRlUG9zdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRiU291cmNlID0gT3BlbldlYnNvY2tldCgpO1xuICAgIHRoaXMuc3ByZWFkUmVmID0gbnVsbDtcbiAgICB0aGlzLlN2Z0NCID0gc3RhdFNWR3MoKTtcbiAgICB0aGlzLmNhcmRDdHggPSBDYXJkQ3R4KCk7XG5cbiAgICB0aGlzLmRiU291cmNlLm9uLmxpdmVGZWVkU3RhcnRlZCA9IChkZXRhaWxzKSA9PiB0aGlzLmxpdmVGZWVkU3RhcnRlZChkZXRhaWxzKTtcbiAgICB0aGlzLmRiU291cmNlLm9uY2xvc2UgPSAoZXZlbnQpID0+IHRoaXMud2JDbG9zZWQoZXZlbnQpO1xuICB9XG4gIHdiQ2xvc2VkID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0Nvbm5lY3Rpb24gQ2xvc2VkJyk7XG4gICAgdGhpcy5wcm9wcy5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiBDT05ORUNUSU9OX0xPU1QsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGNvbm5lY3RlZDogZmFsc2VcbiAgICAgIH1cbiAgICB9KTtcblxuICB9XG4gIGRlcG9zaXRDaGFuZ2VkID0gKGFtdCkgPT4ge1xuICAgIGxldCB7ZGVwb3NpdH0gPSB0aGlzLnByb3BzLnRyYWRlcztcbiAgICBsZXQgbmV3QW1vdW50ID0gZGVwb3NpdCAtIE1hdGgucm91bmQoYW10KTtcbiAgICB3aW5kb3cuc2hvd0RpZmYoZGVwb3NpdCwgbmV3QW1vdW50KTtcbiAgICB0aGlzLnByb3BzLmRpc3BhdGNoKHt0eXBlOiAnREVQT1NJVF9DSEFOR0UnLCBwYXlsb2FkOiBuZXdBbW91bnR9KTtcblxuICB9XG4gIGFkZENoYXJ0TWVudSA9ICgpID0+IHtcbiAgICB0aGlzLnByb3BzLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IFRPR0dMRV9DSEFSVF9NRU5VLFxuICAgICAgcGF5bG9hZDogIXRoaXMucHJvcHMucnQuY2hhcnRBZGRPcGVuXG4gICAgfSlcbiAgfVxuXG4gIGNsb3NlQ3J0ID0gKGNocnRTeW0pID0+IHtcbiAgICBjb25zdCB7Y2hhcnRMaXN0LCB0b3RhbENoYXJ0c30gPSB0aGlzLnByb3BzLnJ0O1xuICAgIGNvbnN0IHN0YXRlVXBkYXRlcyA9IHtcbiAgICAgIGNoYXJ0TGlzdDogY2hhcnRMaXN0LmZpbHRlcigoaXRtLCBpKSA9PiBpdG0uc3ltYiAhPT0gY2hydFN5bSksXG4gICAgICB0b3RhbENoYXJ0czogdG90YWxDaGFydHMgLSAxLFxuICAgICAgcGxhdGZvcm1WaWV3OiAnbGl2ZSBncmFwaHMnXG5cbiAgICB9XG4gICAgdGhpcy5wcm9wcy5kaXNwYXRjaCh7dHlwZTogQ0xPU0VfQ0hBUlQsIHBheWxvYWQ6IHN0YXRlVXBkYXRlc30pXG4gIH1cbiAgc3dpdGNoSW5kaWNlcyA9IChpbmRleFR5cGUsIGFscmVhZHlTZWxlY3RlZCkgPT4gKCkgPT4ge1xuICAgIGlmIChhbHJlYWR5U2VsZWN0ZWQgIT09IHRydWUpIHtcbiAgICAgIHRoaXMucHJvcHMuZGlzcGF0Y2goe3R5cGU6IFNXSVRDSF9JTkRJQ0VTLCBwYXlsb2FkOiBpbmRleFR5cGV9KTtcbiAgICB9XG4gIH1cbiAgc2V0U3ByZWFkUmVmID0gKHNwcmVhZENudHJsKSA9PiB0aGlzLnNwcmVhZFJlZiA9IHNwcmVhZENudHJsO1xuXG4gIG9wdFZpZXcgPSAodHlwZSkgPT4ge1xuICAgIGNvbnN0IGRhc2h2aWV3ID0gdGhpcy5wcm9wcy5ydC5wbGF0Zm9ybVZpZXc7XG4gICAgY29uc3Qge29wdHNDb21wb25lbnQsIHRyYWRWaWV3Q2xhc3N9ID0gdGhpcy5wcm9wcy5ydDtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3ByZWFkcyc6XG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzLnNwcmVhZFJlZi5zZXR0aW5nKHR5cGUpO1xuICAgICAgICAgIGxldCBjdXJyZW50Q2xhc3MgPSBvcHRzQ29tcG9uZW50ID09PSAnY3VycmVudC1iaWRzJyA/ICdoYWxmLXZpZXcnIDogKHRyYWRWaWV3Q2xhc3MgPT09ICdmdWxsLXZpZXcnID8gJ2hhbGYtdmlldycgOiAnZnVsbC12aWV3Jyk7XG4gICAgICAgICAgY3VycmVudENsYXNzID09PSAnaGFsZi12aWV3JyA/IHRoaXMuc3ByZWFkUmVmLmluVmlldygpIDogdGhpcy5zcHJlYWRSZWYub3V0VmlldygpO1xuICAgICAgICAgIFBvc2l0aW9uVGlsZXMub3V0VmlldygpO1xuICAgICAgICAgIHRoaXMuc2V0RGFzaGJvYXJkTGF5b3V0KGN1cnJlbnRDbGFzcywgdHlwZSwgZGFzaHZpZXcpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICBjYXNlICdjdXJyZW50LWJpZHMnIDoge1xuICAgICAgICAgIGxldCBjdXJyZW50Q2xhc3MgPSBvcHRzQ29tcG9uZW50ID09PSAnc3ByZWFkcycgPyAnaGFsZi12aWV3JyA6ICh0cmFkVmlld0NsYXNzID09PSAnZnVsbC12aWV3JyA/ICdoYWxmLXZpZXcnIDogJ2Z1bGwtdmlldycpO1xuICAgICAgICAgIGN1cnJlbnRDbGFzcyA9PT0gJ2hhbGYtdmlldycgPyBQb3NpdGlvblRpbGVzLmluVmlldygpIDogUG9zaXRpb25UaWxlcy5vdXRWaWV3KCk7XG4gICAgICAgICAgdGhpcy5zcHJlYWRSZWYub3V0VmlldygpO1xuICAgICAgICAgIHRoaXMuc2V0RGFzaGJvYXJkTGF5b3V0KGN1cnJlbnRDbGFzcywgdHlwZSwgZGFzaHZpZXcpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICBjYXNlICdwYXN0LXBvcycgOiB7XG4gICAgICAgICAgQ3R4Q2hhcnQub3V0T2ZWaWV3KCk7XG4gICAgICAgICAgQ2xvY2sub3V0VmlldygpO1xuICAgICAgICAgIHRoaXMuY2FyZEN0eC5vdXRWaWV3KCk7XG4gICAgICAgICAgdGhpcy5zcHJlYWRSZWYub3V0VmlldygpO1xuICAgICAgICAgIEdyYXBoQ29udHJvbGxlci5yZW5kZXJDaGFydHMoKTtcbiAgICAgICAgICB0aGlzLlN2Z0NCLmluVmlld0Jvb2wgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuU3ZnQ0IuaW5WaWV3KCk7XG4gICAgICAgICAgdGhpcy5zZXREYXNoYm9hcmRMYXlvdXQoJ2Z1bGwtdmlldycsIHR5cGUsICd0cmFkZSBsaXN0Jyk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2NoYXJ0cycgOiB7XG4gICAgICAgICAgdGhpcy5zcHJlYWRSZWYub3V0VmlldygpO1xuICAgICAgICAgIHRoaXMuY2FyZEN0eC5vdXRWaWV3KCk7XG4gICAgICAgICAgQ2xvY2suaW5WaWV3KCk7XG4gICAgICAgICAgUG9zaXRpb25UaWxlcy5vdXRWaWV3KCk7XG4gICAgICAgICAgQ3R4Q2hhcnQuYmFja0luVmlldygpO1xuICAgICAgICAgIHRoaXMuU3ZnQ0IuaW5WaWV3Qm9vbCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuc2V0RGFzaGJvYXJkTGF5b3V0KCdmdWxsLXZpZXcnLCB0eXBlLCAnbGl2ZSBncmFwaHMnKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbGl2ZSBvcHRpb25zJyA6IHtcbiAgICAgICAgICBDdHhDaGFydC5vdXRPZlZpZXcoKTtcbiAgICAgICAgICBDbG9jay5vdXRWaWV3KCk7XG4gICAgICAgICAgUG9zaXRpb25UaWxlcy5vdXRWaWV3KCk7XG4gICAgICAgICAgdGhpcy5jYXJkQ3R4LmluVmlldygpO1xuICAgICAgICAgIHRoaXMuU3ZnQ0IuaW5WaWV3Qm9vbCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuc3ByZWFkUmVmLm91dFZpZXcoKTtcbiAgICAgICAgICB0aGlzLnNldERhc2hib2FyZExheW91dCgnZnVsbC12aWV3JywgdHlwZSwgJ2xpdmUgb3B0aW9ucycpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICBjYXNlICdvdmVydmlldycgOiB7XG4gICAgICAgICAgQ3R4Q2hhcnQub3V0T2ZWaWV3KCk7XG4gICAgICAgICAgQ2xvY2sub3V0VmlldygpO1xuICAgICAgICAgIFBvc2l0aW9uVGlsZXMub3V0VmlldygpO1xuICAgICAgICAgIHRoaXMuY2FyZEN0eC5vdXRWaWV3KCk7XG4gICAgICAgICAgdGhpcy5zcHJlYWRSZWYub3V0VmlldygpO1xuICAgICAgICAgIHRoaXMuc2V0RGFzaGJvYXJkTGF5b3V0KCdmdWxsLXZpZXcnLCB0eXBlLCAndHJhZGUgaGlzdG9yeScpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG4gICAgdGhpcy5zZXREYXNoYm9hcmRMYXlvdXQoJ2hhbGYtdmlldycsIHR5cGUsIGRhc2h2aWV3KTtcbiAgfVxuICBzZXREYXNoYm9hcmRMYXlvdXQgPSAodHJhZFZpZXdDbGFzcywgb3B0c0NvbXBvbmVudCwgcGxhdGZvcm1WaWV3KSA9PiB0aGlzLnByb3BzLmRpc3BhdGNoKHtcbiAgICB0eXBlOiBPUFRTX1ZJRVcsXG4gICAgcGF5bG9hZDoge1xuICAgICAgdHJhZFZpZXdDbGFzcyxcbiAgICAgIG9wdHNDb21wb25lbnQsXG4gICAgICBwbGF0Zm9ybVZpZXdcbiAgICB9XG4gIH0pXG4gIGxpdmVGZWVkU3RhcnRlZCA9IChzeW1iRmVlZCkgPT4ge1xuICAgIGxldCBzZXJpZXNXYXRjaCA9IHRoaXMucHJvcHMucnQuc2VyaWVzV2F0Y2g7XG4gICAgc2VyaWVzV2F0Y2gucHVzaChzeW1iRmVlZCk7XG4gICAgdGhpcy5wcm9wcy5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiBGRUVEX1NUQVJULFxuICAgICAgcGF5bG9hZDoge1xuICAgICAgICBzZXJpZXNXYXRjaDogc2VyaWVzV2F0Y2gsXG4gICAgICAgIGFkZEJ1dHRvbjogdHJ1ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgfVxuICBhZGROZXdDaGFydCA9IChzeW1iLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHtjaGFydExpc3QsIHRvdGFsQ2hhcnRzLCBjaGFydFBvc2l0aW9ucywgY2hhcnRTdGF0ZXMgfSA9IHRoaXMucHJvcHMucnQ7XG4gICAgY29uc3Qga2V5eSA9IHN5bWIgKyAnX2NhbnZhcyc7XG5cbiAgICBjb25zdCBzdGF0ZVVwZGF0ZXMgPSB7XG4gICAgICBjaGFydFBvc2l0aW9uczoge1xuICAgICAgICAuLi5jaGFydFBvc2l0aW9ucyxcbiAgICAgICAgW3N5bWJdOiB7XG4gICAgICAgICAgdHJhZGVzOiBbXSxcbiAgICAgICAgICBwb3NpdGlvbjoge30sXG4gICAgICAgICAgdG90YWw6IDAuMCxcbiAgICAgICAgICBjdXJyZW50OiBudWxsXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjaGFydFN0YXRlczoge1xuICAgICAgICAuLi5jaGFydFN0YXRlcyxcbiAgICAgICAgW3N5bWJdOiB7XG4gICAgICAgICAgbW9kYWxPcGVuOiBmYWxzZSxcbiAgICAgICAgICBkYXRhTGVuZ3RoOiA1MDAsXG4gICAgICAgICAgb25TdGFydDogdHJ1ZSxcbiAgICAgICAgICBvcHRzT3BlbjogZmFsc2UsXG4gICAgICAgICAgY2hhcnRUeXBlOiAnY2FuZGxlc3RpY2snLFxuICAgICAgICAgIG1haW5TeW1ib2w6IHN5bWIsXG4gICAgICAgICAgY2FsbFB1dDogbnVsbCxcbiAgICAgICAgICBzZXJpZXNXYXRjaDogW11cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNoYXJ0TGlzdDogY2hhcnRMaXN0LmNvbmNhdCh7c3ltYjogc3ltYiwga2V5eToga2V5eX0pLFxuICAgICAgdG90YWxDaGFydHM6IHRvdGFsQ2hhcnRzICsgMSxcbiAgICAgIG9uU3RhcnQ6IGZhbHNlLFxuICAgICAgYWRkQnV0dG9uOiB0cnVlLFxuICAgICAgbmV3U2V0OiBudWxsLFxuICAgICAgY2hhcnRBZGRPcGVuOiBmYWxzZVxuICAgIH1cblxuICAgIHRoaXMucHJvcHMuZGlzcGF0Y2goe3R5cGU6IEFERF9DSEFSVCwgcGF5bG9hZDogc3RhdGVVcGRhdGVzfSlcbiAgfVxuICByZW5kZXJDYW52YXNDaGFydHMgPSAoKSA9PiB0aGlzLnByb3BzLnJ0LmNoYXJ0TGlzdC5tYXAoKGNoYXJ0LCBpLCBjaGFydExpc3QpID0+IChcbiAgICA8Q2hhcnRDb250YWluZXIga2V5PXtjaGFydC5rZXl5fSBjaGFydFFudHk9e2NoYXJ0TGlzdC5sZW5ndGh9IGluZGV4PXtpfT5cbiAgICAgIDxDYW52YXNDaGFydCBuZXdQb3M9e3RoaXMubmV3UG9zfSBkZXBDaGc9e3RoaXMuZGVwb3NpdENoYW5nZWR9IGN0eD17Q3R4Q2hhcnQucGFzc0NUWGNvbnN0cnVjdG9yKCl9IGNsb2NrPXtDbG9ja30gcG9zaXRpb25zPXt0aGlzLnByb3BzLnJ0LmNoYXJ0UG9zaXRpb25zW2NoYXJ0LnN5bWJdfSBkaXNwYXRjaD17dGhpcy5wcm9wcy5kaXNwYXRjaH0gc3RhdGU9e3RoaXMucHJvcHMucnQuY2hhcnRTdGF0ZXNbY2hhcnQuc3ltYl19IGNsQ3R4PXt0aGlzLmNsb3NlQ3J0fSBkYXRhU291cmNlPXt0aGlzLmRiU291cmNlfSBtYWluU3ltPXtjaGFydC5zeW1ifSB3aGVuTW91bnRlZD17dGhpcy5jYW52YXNQbGFjZWR9Lz5cbiAgICA8L0NoYXJ0Q29udGFpbmVyPlxuICApKVxuXG4gIGNhbnZhc1BsYWNlZCA9IChuZXdTeW1iKSA9PiB7XG4gICAgdGhpcy50cmFkZVBvc3Rpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy50cmFkZVBvc3Rpb25zLCBuZXdTeW1iKTtcbiAgfTtcbiAgdHJhZGVFeHBpcmVkID0gKHBvcykgPT4ge1xuICAgIGxldCB7cGFzdFRyYWRlcywgZGVwb3NpdCwgY3VycmVudFBvcywgdG90YWxSZXYsIHRvZGF5VG90YWxOZXR9ID0gdGhpcy5wcm9wcy50cmFkZXM7XG4gICAgbGV0IG53UG50ID0gcG9zLmdldExhdGVzdFBvaW50KCk7XG4gICAgbGV0IGRpZmYgPSAobndQbnQuZGF0YVszXSAtIHBvcy51bml0UHJpY2UpICogcG9zLnF0eTtcbiAgICBsZXQgbmV3TmV0ID0gdG9kYXlUb3RhbE5ldCArIGRpZmY7XG4gICAgbGV0IG5ld0Rlb3Bvc2l0ID0gTWF0aC5yb3VuZChkZXBvc2l0ICsgKG53UG50LmRhdGFbM10gKiBwb3MucXR5KSk7XG4gICAgbGV0IG5ld0NybnRQb3MgPSBjdXJyZW50UG9zLmZpbHRlcigoaXRtKSA9PiBpdG0uY3R4aWQgIT09IHBvcy5jdHhpZCk7XG4gICAgbGV0IHBzdFRSRCA9IFtcbiAgICAgIHtcbiAgICAgICAgcG9zaXRpb246IHBvcy5zeW1iLFxuICAgICAgICB2b2x1bWU6IHBvcy5xdHksXG4gICAgICAgIGRhdGU6IG5ldyBEYXRlKCkudG9EYXRlU3RyaW5nKCksXG4gICAgICAgIHNob3J0OiBwb3MudHlwZSA9PT0gJ1BVVCcsXG4gICAgICAgIHByaWNlc3RhcnQ6IChNYXRoLnJvdW5kKHBvcy51bml0UHJpY2UgKiAxMDApIC8gMTAwKSxcbiAgICAgICAgcHJpY2VlbmQ6IChNYXRoLnJvdW5kKG53UG50LmRhdGFbM10gKiAxMDApIC8gMTAwKSxcbiAgICAgICAgcHJvZml0OiBkaWZmXG4gICAgICB9XG4gICAgXS5jb25jYXQocGFzdFRyYWRlcyk7XG4gICAgbGV0IHBvc0NUWGNudHJsID0gdGhpcy50cmFkZVBvc3Rpb25zW3Bvcy5zeW1iXS5jdHhDaGFydDtcbiAgICBwb3NDVFhjbnRybC5wb3NFeHBpcmVkKHBvcyk7XG4gICAgd2luZG93LnNob3dEaWZmKGRlcG9zaXQsIG5ld0Rlb3Bvc2l0KTtcblxuICAgIHRoaXMuU3ZnQ0IudXBEYXRlKHBzdFRSRCwgKHRvdGFsUmV2ICsgZGlmZikpO1xuICAgIHRoaXMucHJvcHMuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ1RSQURFX0NPTVBMRVRFJyxcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgZGVwb3NpdDogbmV3RGVvcG9zaXQsXG4gICAgICAgIGN1cnJlbnRQb3M6IG5ld0NybnRQb3MsXG4gICAgICAgIHBhc3RUcmFkZXM6IHBzdFRSRCxcbiAgICAgICAgdG9kYXlUb3RhbE5ldDogbmV3TmV0LFxuICAgICAgICB0b3RhbFJldjogdG90YWxSZXYgKyBkaWZmXG4gICAgICB9XG4gICAgfSk7XG5cbiAgfVxuICBuZXdQb3MgPSAocG9zKSA9PiB7XG4gICAgbGV0IHtkZXBvc2l0LCBjdXJyZW50UG9zLCB3ZWVrbHlUcmFkZUNvdW50LCB0b2RheVRyYWRlQ291bnR9ID0gdGhpcy5wcm9wcy50cmFkZXM7XG4gICAgbGV0IG5ld0N1cnJlbnRQb3MgPSBbcG9zXS5jb25jYXQoY3VycmVudFBvcyk7XG4gICAgbGV0IG5ld0Ftb3VudCA9IGRlcG9zaXQgLSBNYXRoLnJvdW5kKHBvcy51bml0UHJpY2UgKiBwb3MucXR5KTtcbiAgICB3aW5kb3cuc2hvd0RpZmYoZGVwb3NpdCwgbmV3QW1vdW50KTtcbiAgICB0aGlzLnRyYWRlUG9zdGlvbnNbcG9zLnN5bWJdLm9wZW5bcG9zLnBvc0lkXSA9IHBvcztcbiAgICBsZXQgcG9zQ1RYY250cmwgPSB0aGlzLnRyYWRlUG9zdGlvbnNbcG9zLnN5bWJdLmN0eENoYXJ0O1xuICAgIHBvc0NUWGNudHJsLmFkZE5ld1Bvcyhwb3MpO1xuICAgIHRoaXMucHJvcHMuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ0FERF9UUkFERScsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGN1cnJlbnRQb3M6IG5ld0N1cnJlbnRQb3MsXG4gICAgICAgIHdlZWtseVRyYWRlQ291bnQ6IHdlZWtseVRyYWRlQ291bnQgKyAxLFxuICAgICAgICB0b2RheVRyYWRlQ291bnQ6IHRvZGF5VHJhZGVDb3VudCArIDEsXG4gICAgICAgIGRlcG9zaXQ6IG5ld0Ftb3VudFxuICAgICAgfVxuICAgIH0pO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy50cmFkZUV4cGlyZWQocG9zKSwgNjAwMDAgKiBwb3MudGltZSk7XG4gIH1cbiAgY2FudmFzT3V0ID0gKCkgPT4gdGhpcy5jdHhDaGFydC5zaHV0ZG93bigpO1xuXG4gIGNvbXBvbmVudERpZE1vdW50ID0gKCkgPT4ge1xuICAgIHRoaXMuZGJTb3VyY2Uub25vcGVuID0gKGV2ZW50KSA9PiB0aGlzLnByb3BzLmRpc3BhdGNoKHt0eXBlOiBDT05ORUNURUR9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgKGUpID0+IHRoaXMucHJvcHMuZGlzcGF0Y2goe3R5cGU6IENPTk5FQ1RFRH0pLCBmYWxzZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCAoZSkgPT4gdGhpcy5wcm9wcy5kaXNwYXRjaCh7dHlwZTogQ09OTkVDVElPTl9MT1NUfSksIGZhbHNlKTtcbiAgICB0b3RhbEFtb3VudEN0eCh0aGlzLnByb3BzLnRyYWRlcy5kZXBvc2l0KTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBpZiAodGhpcy5kYlNvdXJjZS5yZWFkeVN0YXRlID09PSAnT1BFTicpIHtcbiAgICAgIHRoaXMucHJvcHMuZGlzcGF0Y2goe3R5cGU6IENPTk5FQ1RFRH0pO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBvcHRzQ29tcG9uZW50LFxuICAgICAgb25TdGFydCxcbiAgICAgIHBsYXRmb3JtVmlldyxcbiAgICAgIHRyYWRWaWV3Q2xhc3MsXG4gICAgICBhZGRCdXR0b24sXG4gICAgICBjb25uZWN0ZWQsXG4gICAgICBzZXJpZXNXYXRjaCxcbiAgICAgIGNoYXJ0QWRkT3BlbixcbiAgICAgIHNlbGVjdFVsXG4gICAgfSA9IHRoaXMucHJvcHMucnQ7XG4gICAgbGV0IHRkQ2xhc3MgPSB0cmFkVmlld0NsYXNzID09PSAnaGFsZi12aWV3JztcbiAgICBjb25zdCBvbmxpbmVTdGF0dXMgPSBjb25uZWN0ZWQgPyAnQ09OTkVDVEVEJyA6ICdOb3QgQ29ubmVjdGVkJztcbiAgICBsZXQgYmxvY2tTdGFydCA9IG9uU3RhcnQgPyA8TGl2ZVN0YXJ0IHN0YXJ0Q2hhcnQ9e3RoaXMuYWRkTmV3Q2hhcnR9Lz4gOiBudWxsO1xuICAgIGNvbnN0IGJsb2NrZWQgPSB0aGlzLnByb3BzLnJ0LmNvbm5lY3RlZCA/IGJsb2NrU3RhcnQgOiA8TG9hZENvbm5lY3QvPjtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdj5cbiAgICAgICAgPGRpdiBpZD0ncnRUb3BOYXZVSSc+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2Zha2UtbG9nbyc+XG4gICAgICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPSdtYXRlcmlhbC1pY29ucyc+bGFuZ3VhZ2U8L2k+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9J3NwYW4tdHdvJz5cbiAgICAgICAgICAgICAgVHJhZGUgU3R1ZmZcbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YWRkQnV0dG9uID8gJ2FkZC1jaGFydCcgOiAnYWRkLWNoYXJ0IG5vLXNlZS1uby1jbGljayd9IG9uQ2xpY2s9e3RoaXMuYWRkQ2hhcnRNZW51fT5cbiAgICAgICAgICAgIDxpIGNsYXNzTmFtZT0nbWF0ZXJpYWwtaWNvbnMnPmFkZDwvaT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGlkPSdjaGFydEFkT3B0aW9ucycgY2xhc3NOYW1lPXtjaGFydEFkZE9wZW4gPyAnJyA6ICdoaWRlLWVsbSd9PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3RoaXMucHJvcHMucnQudG90YWxDaGFydHMgPj0gNCA/ICdhZGQtY2hhcnQtd2FybicgOiAnaGlkZS1lbG0nfT5cbiAgICAgICAgICAgICAgPGgzPllvdSBjYW4gb25seSBoYXZlIDQgY2hhcnRzIGF0IGEgdGltZSwgc29ycnkhPC9oMz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3RoaXMucHJvcHMucnQudG90YWxDaGFydHMgPCA0ID8gJ2FkZC1jaGFydC1jbnQnIDogJ2hpZGUtZWxtJ30+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdjb2x1bW4tdHdvIHR5cGUtbmF2Jz5cbiAgICAgICAgICAgICAgICA8c3Ryb25nPk1hcmtldDwvc3Ryb25nPlxuICAgICAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICAgIDxsaSBvbkNsaWNrPXt0aGlzLnN3aXRjaEluZGljZXMoJ3N0b2NrcycsIHNlbGVjdFVsID09PSAnc3RvY2tzJyl9IGNsYXNzTmFtZT17c2VsZWN0VWwgPT09ICdzdG9ja3MnID8gJ3NlbGVjdGVkLWxpJyA6ICcnfT5TdG9ja3M8L2xpPlxuICAgICAgICAgICAgICAgICAgPGxpIG9uQ2xpY2s9e3RoaXMuc3dpdGNoSW5kaWNlcygnZm9yZXgnLCBzZWxlY3RVbCA9PT0gJ2ZvcmV4Jyl9IGNsYXNzTmFtZT17c2VsZWN0VWwgPT09ICdmb3JleCcgPyAnc2VsZWN0ZWQtbGknIDogJyd9PkZvcmV4PC9saT5cbiAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlbGVjdFVsID09PSAnc3RvY2tzJyAmJlxuICAgICAgICAgICAgICAgIDxTdG9ja0xpc3QgdXNlZD17c2VyaWVzV2F0Y2h9IHN0YXJ0Q2hhcnQ9e3RoaXMuYWRkTmV3Q2hhcnR9Lz5cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlbGVjdFVsID09PSAnZm9yZXgnICYmXG4gICAgICAgICAgICAgICAgPEZvcmV4TGlzdCB1c2VkPXtzZXJpZXNXYXRjaH0gc3RhcnRDaGFydD17dGhpcy5hZGROZXdDaGFydH0vPlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgaWQ9J2Nvbm5lY3RlZFN0YXRlJz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjb25uZWN0ZWQgPyAnb25saW5lLXN0YXRlIG9ubGluZScgOiAnb25saW5lLXN0YXRlIG9mZmxpbmUnfT48L2Rpdj5cbiAgICAgICAgICAgIDxzcGFuPntvbmxpbmVTdGF0dXN9PC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBpZD0nc2NvcmVQb2ludHMnIGNsYXNzTmFtZT17KHBsYXRmb3JtVmlldyAhPT0gJ3RyYWRlIGhpc3RvcnknICYmICFvblN0YXJ0KSA/ICcnIDogJ2hpZGUtZWxtJ30+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPSdjb3VudCBzcGFuLWdyZWVuIHRvdGFsLWVhcm5pbmdzJz5cbiAgICAgICAgICAgIDxjYW52YXMgaWQ9J3RvdGFsQWNjb3VudCcgaGVpZ2h0PXs0MH0gd2lkdGg9ezEwMH0+PC9jYW52YXM+XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT0nZGVwb3NpdC1zcGFuJz5ERVBPU0lUPC9zcGFuPlxuXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8c2VjdGlvbiBpZD0ncmVhbFRpbWVUaGVtZSc+XG4gICAgICAgICAge2Jsb2NrZWR9XG4gICAgICAgICAgPFNpZGVPcHRpb25zIHBsYXRmb3JtVmlldz17cGxhdGZvcm1WaWV3fSBvcHRzQ29tcG9uZW50PXtvcHRzQ29tcG9uZW50fSB0ZENsYXNzPXt0ZENsYXNzfSBvblN0YXJ0PXtvblN0YXJ0fSBpdG1WaWV3PXt0aGlzLm9wdFZpZXd9Lz5cbiAgICAgICAgICA8c2VjdGlvbiBpZD0nb3B0aW9uc1ZpZXcnIGNsYXNzTmFtZT17b25TdGFydCA/ICdoaWRlLWVsbScgOiAnb2snfT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtvcHRzQ29tcG9uZW50ID09PSAnc3ByZWFkcycgPyAnaW4tdmlldy1vcHRzJyA6ICdoaWRlLWVsbSd9PlxuICAgICAgICAgICAgICA8QWN0aXZlU3ByZWFkcyBzZXRTcHJlYWRSZWY9e3RoaXMuc2V0U3ByZWFkUmVmfSBjYWxsQ1Q9e3NwcmVhZENUWH0gZGF0YVNvdXJjZT17dGhpcy5kYlNvdXJjZX0vPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17b3B0c0NvbXBvbmVudCA9PT0gJ2N1cnJlbnQtYmlkcycgPyAnaW4tdmlldy1vcHRzJyA6ICdoaWRlLWVsbSd9PlxuICAgICAgICAgICAgICA8V2F0Y2hlZFNwcmVhZHMgUG9zaXRpb25UaWxlcz17UG9zaXRpb25UaWxlc30gYWN0aXZlUG9zTGlzdD17dGhpcy5wcm9wcy50cmFkZXMuY3VycmVudFBvc30vPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICAgIDxzZWN0aW9uIGlkPSd0cmFkaW5ncGxhdGZvcm0nIGNsYXNzTmFtZT17b25TdGFydCA/ICdoaWRlLWVsbScgOiB0cmFkVmlld0NsYXNzfT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtwbGF0Zm9ybVZpZXcgPT09ICdsaXZlIGdyYXBocycgPyAnd3JhcC1ibG9jaycgOiAnaGlkZS1lbG0nfT5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMucnQudG90YWxDaGFydHMgPT09IDAgJiZcbiAgICAgICAgICAgICAgICA8TGl2ZVN0YXJ0IHN0YXJ0Q2hhcnQ9e3RoaXMuYWRkTmV3Q2hhcnR9Lz5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHsgdGhpcy5yZW5kZXJDYW52YXNDaGFydHMoKSB9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgaWQ9J2Rhc2hWaWV3JyBjbGFzc05hbWU9e3BsYXRmb3JtVmlldyA9PT0gJ3RyYWRlIGhpc3RvcnknID8gJ3dyYXAtYmxvY2snIDogJ2hpZGUtZWxtJ30+XG4gICAgICAgICAgICAgIDxXaWRnZXRCbG9jayBpblZpZXc9e3BsYXRmb3JtVmlldyA9PT0gJ3RyYWRlIGhpc3RvcnknfS8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtwbGF0Zm9ybVZpZXcgPT09ICd0cmFkZSBsaXN0JyA/ICd3cmFwLWJsb2NrIGhpc3RvcnktbGlzdCcgOiAnaGlkZS1lbG0nfT5cbiAgICAgICAgICAgICAgPFRyYW5zYWN0aW9uTGlzdCBpblZpZXc9e3BsYXRmb3JtVmlldyA9PT0gJ3RyYWRlIGxpc3QnfSBHcmFwaENvbnRyb2xsZXI9e0dyYXBoQ29udHJvbGxlcn0gU3ZnQ0I9e3RoaXMuU3ZnQ0J9IHBhc3RUcmFkZXM9e3RoaXMucHJvcHMudHJhZGVzLnBhc3RUcmFkZXN9Lz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3BsYXRmb3JtVmlldyA9PT0gJ2xpdmUgb3B0aW9ucycgPyAnd3JhcC1ibG9jayBoaXN0b3J5LWxpc3QnIDogJ2hpZGUtZWxtJ30+XG4gICAgICAgICAgICAgIDxMaXZlVGlja2VycyBjYXJkQ3R4PXt0aGlzLmNhcmRDdHh9IGluVmlldz17cGxhdGZvcm1WaWV3ID09PSAnbGl2ZSBvcHRpb25zJ30vPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICA8L3NlY3Rpb24+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3Qoc2VsZWN0KShSZWFsVGltZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29udGFpbmVycy9yZWFsdGltZS5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb3BOYXYgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cbiAgZ29TdGF0ZSA9IChwYXRoKSA9PiAoKSA9PiB7XG4gICAgd2luZG93LmNoZWNrUGF0aChwYXRoKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxuYXYgaWQ9J3RvcE5hdicgY2xhc3NOYW1lPXt0aGlzLnByb3BzLnRoZUNsYXNzfT5cbiAgICAgICAgPHNwYW4gb25DbGljaz17dGhpcy5nb1N0YXRlKCcvaGlzdG9yeScpfSBjbGFzc05hbWU9eyh0aGlzLnByb3BzLnBhdGhOYW1lID09PSAnL2hpc3RvcnknIHx8IHRoaXMucHJvcHMucGF0aE5hbWUgPT09ICcvJykgPyAnYmxvY2tlZC1hdCcgOiAnJ30+SGlzdG9yeTwvc3Bhbj5cbiAgICAgICAgPHNwYW4gb25DbGljaz17dGhpcy5nb1N0YXRlKCcvcmVhbHRpbWUnKX0gY2xhc3NOYW1lPXt0aGlzLnByb3BzLnBhdGhOYW1lID09PSAnL3JlYWx0aW1lJyA/ICdibG9ja2VkLWF0JyA6ICcnfT5SZWFsIFRpbWU8L3NwYW4+XG4gICAgICAgIDxzcGFuIG9uQ2xpY2s9e3RoaXMuZ29TdGF0ZSgnL21hcCcpfSBjbGFzc05hbWU9e3RoaXMucHJvcHMucGF0aE5hbWUgPT09ICcvbWFwJyA/ICdibG9ja2VkLWF0JyA6ICcnfT5NYXAgVGhpbmc8L3NwYW4+XG4gICAgICA8L25hdj5cblxuICAgICk7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29udGFpbmVycy90b3BuYXYuanN4IiwiXG5jb25zdCBNYXRoRnVuY3MgPSB7XG4gICBnZXREaWdpdExlbjogKG51bSkgPT4gKE1hdGgubG9nKE1hdGguYWJzKG51bSkpICogTWF0aC5MT0cxMEUgKyAxIHwgMCksXG4gICBuaWNlRmxvYXRzOiAobnVtKSA9PiB7XG4gICBcdCAgY29uc3QgcmVzID0gbnVtIC8gMTAwMDtcbiAgIFx0ICBpZiAocmVzIDwgMTApe1xuICAgXHQgIFx0cmV0dXJuIG51bS50b0ZpeGVkKDIpO1xuICAgXHQgIH1cbiAgIFx0ICBpZiAocmVzIDwgMTAwKSB7XG4gICBcdCAgXHRyZXR1cm4gKHJlcykudG9GaXhlZCgzKSArICdrJztcbiAgIFx0ICB9XG4gICBcdCAgaWYgKHJlcyA8IDEwMDApe1xuICAgXHQgIFx0cmV0dXJuIChyZXMpLnRvRml4ZWQoMikgKyAnayc7XG4gICBcdCAgfVxuICAgXHQgIGlmIChyZXMgPCAxMDAwMCkge1xuICAgXHQgIFx0cmV0dXJuIChyZXMpLnRvRml4ZWQoMykgKyAnbSc7XG4gICBcdCAgfVxuICAgXHQgICBpZiAocmVzIDwgMTAwMDAwKSB7XG4gICBcdCAgXHRyZXR1cm4gKHJlcykudG9GaXhlZCgyKSArICdtJztcbiAgIFx0ICB9XG4gICBcdCAgcmV0dXJuIG51bTtcbiAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1hdGhGdW5jcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9oZWxwZXJzL21hdGhmdW5jcy5qcyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHN1bSA9IDAsIGkgPSAwOyBpIDwgbjsgKytpKSBzdW0gKz0gTWF0aC5yYW5kb20oKTtcbiAgICByZXR1cm4gc3VtO1xuICB9O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2QzLXJhbmRvbS9zcmMvaXJ3aW5IYWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtdSwgc2lnbWEpIHtcbiAgdmFyIHgsIHI7XG4gIG11ID0gbXUgPT0gbnVsbCA/IDAgOiArbXU7XG4gIHNpZ21hID0gc2lnbWEgPT0gbnVsbCA/IDEgOiArc2lnbWE7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgeTtcblxuICAgIC8vIElmIGF2YWlsYWJsZSwgdXNlIHRoZSBzZWNvbmQgcHJldmlvdXNseS1nZW5lcmF0ZWQgdW5pZm9ybSByYW5kb20uXG4gICAgaWYgKHggIT0gbnVsbCkgeSA9IHgsIHggPSBudWxsO1xuXG4gICAgLy8gT3RoZXJ3aXNlLCBnZW5lcmF0ZSBhIG5ldyB4IGFuZCB5LlxuICAgIGVsc2UgZG8ge1xuICAgICAgeCA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcbiAgICAgIHkgPSBNYXRoLnJhbmRvbSgpICogMiAtIDE7XG4gICAgICByID0geCAqIHggKyB5ICogeTtcbiAgICB9IHdoaWxlICghciB8fCByID4gMSk7XG5cbiAgICByZXR1cm4gbXUgKyBzaWdtYSAqIHkgKiBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhyKSAvIHIpO1xuICB9O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2QzLXJhbmRvbS9zcmMvbm9ybWFsLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFVwc3RyZWFtIHZlcnNpb24gb2YgZXZlbnQgbGlzdGVuZXIuIERvZXMgbm90IHRha2UgaW50byBhY2NvdW50IHNwZWNpZmljXG4gKiBuYXR1cmUgb2YgcGxhdGZvcm0uXG4gKi9cbnZhciBFdmVudExpc3RlbmVyID0ge1xuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBidWJibGUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYXR0YWNoRXZlbnQpIHtcbiAgICAgIHRhcmdldC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGNhcHR1cmU6IGZ1bmN0aW9uIGNhcHR1cmUodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBdHRlbXB0ZWQgdG8gbGlzdGVuIHRvIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2Ugb24gYSAnICsgJ2Jyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBjYXB0dXJlIHBoYXNlLiBZb3VyIGFwcGxpY2F0aW9uICcgKyAnd2lsbCBub3QgcmVjZWl2ZSBzb21lIGV2ZW50cy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZW1wdHlGdW5jdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgcmVnaXN0ZXJEZWZhdWx0OiBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHQoKSB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RlbmVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG4vKipcbiAqIFNpbXBsZSwgbGlnaHR3ZWlnaHQgbW9kdWxlIGFzc2lzdGluZyB3aXRoIHRoZSBkZXRlY3Rpb24gYW5kIGNvbnRleHQgb2ZcbiAqIFdvcmtlci4gSGVscHMgYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFuZCBhbGxvd3MgY29kZSB0byByZWFzb24gYWJvdXRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxuICogYFJlYWN0V29ya2VyYCBkZXBlbmRlbmN5LlxuICovXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XG5cbiAgY2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cbiAgY2FuVXNlV29ya2VyczogdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6IGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxuXG4gIGNhblVzZVZpZXdwb3J0OiBjYW5Vc2VET00gJiYgISF3aW5kb3cuc2NyZWVuLFxuXG4gIGlzSW5Xb3JrZXI6ICFjYW5Vc2VET00gLy8gRm9yIG5vdywgdGhpcyBpcyB0cnVlIC0gbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKCcuL2lzVGV4dE5vZGUnKTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgY29udGFpbnMgb3IgaXMgYW5vdGhlciBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnNOb2RlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9mYmpzL2xpYi9jb250YWluc05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcbiAqL1xuXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xuICAvLyBJRTggY2FuIHRocm93IFwiQ2FuJ3QgbW92ZSBmb2N1cyB0byB0aGUgY29udHJvbCBiZWNhdXNlIGl0IGlzIGludmlzaWJsZSxcbiAgLy8gbm90IGVuYWJsZWQsIG9yIG9mIGEgdHlwZSB0aGF0IGRvZXMgbm90IGFjY2VwdCB0aGUgZm9jdXMuXCIgZm9yIGFsbCBraW5kcyBvZlxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cbiAgdHJ5IHtcbiAgICBub2RlLmZvY3VzKCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9mYmpzL2xpYi9mb2N1c05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gez9ET01Eb2N1bWVudH0gZG9jIERlZmF1bHRzIHRvIGN1cnJlbnQgZG9jdW1lbnQuXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIC8qP0RPTUVsZW1lbnQqL3tcbiAgZG9jID0gZG9jIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuICBpZiAodHlwZW9mIGRvYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2MuYWN0aXZlRWxlbWVudCB8fCBkb2MuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2MuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIFxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gIGlmICh4ID09PSB5KSB7XG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAvLyBBZGRlZCB0aGUgbm9uemVybyB5IGNoZWNrIHRvIG1ha2UgRmxvdyBoYXBweSwgYnV0IGl0IGlzIHJlZHVuZGFudFxuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChpcyhvYmpBLCBvYmpCKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0VxdWFsO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvblxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKGZuKSB7XG4gIHZhciBzdHJpbmcgPSB0b1N0cmluZy5jYWxsKGZuKVxuICByZXR1cm4gc3RyaW5nID09PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8XG4gICAgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiBzdHJpbmcgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB8fFxuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAvLyBJRTggYW5kIGJlbG93XG4gICAgIChmbiA9PT0gd2luZG93LnNldFRpbWVvdXQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuYWxlcnQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuY29uZmlybSB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5wcm9tcHQpKVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pcy1mdW5jdGlvbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLWVzL19TeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgU3ltYm9sLmZvciAmJlxuICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAweGVhYzc7XG5cbiAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9O1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9wLXR5cGVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuaW1wb3J0IGhvaXN0U3RhdGljcyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgeyBDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBTdWJzY3JpcHRpb24gZnJvbSAnLi4vdXRpbHMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IHN0b3JlU2hhcGUsIHN1YnNjcmlwdGlvblNoYXBlIH0gZnJvbSAnLi4vdXRpbHMvUHJvcFR5cGVzJztcblxudmFyIGhvdFJlbG9hZGluZ1ZlcnNpb24gPSAwO1xudmFyIGR1bW15U3RhdGUgPSB7fTtcbmZ1bmN0aW9uIG5vb3AoKSB7fVxuZnVuY3Rpb24gbWFrZVNlbGVjdG9yU3RhdGVmdWwoc291cmNlU2VsZWN0b3IsIHN0b3JlKSB7XG4gIC8vIHdyYXAgdGhlIHNlbGVjdG9yIGluIGFuIG9iamVjdCB0aGF0IHRyYWNrcyBpdHMgcmVzdWx0cyBiZXR3ZWVuIHJ1bnMuXG4gIHZhciBzZWxlY3RvciA9IHtcbiAgICBydW46IGZ1bmN0aW9uIHJ1bkNvbXBvbmVudFNlbGVjdG9yKHByb3BzKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbmV4dFByb3BzID0gc291cmNlU2VsZWN0b3Ioc3RvcmUuZ2V0U3RhdGUoKSwgcHJvcHMpO1xuICAgICAgICBpZiAobmV4dFByb3BzICE9PSBzZWxlY3Rvci5wcm9wcyB8fCBzZWxlY3Rvci5lcnJvcikge1xuICAgICAgICAgIHNlbGVjdG9yLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgc2VsZWN0b3IucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICAgICAgc2VsZWN0b3IuZXJyb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSB0cnVlO1xuICAgICAgICBzZWxlY3Rvci5lcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZWN0b3I7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbm5lY3RBZHZhbmNlZChcbi8qXG4gIHNlbGVjdG9yRmFjdG9yeSBpcyBhIGZ1bmMgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgcmV0dXJuaW5nIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB1c2VkIHRvXG4gIGNvbXB1dGUgbmV3IHByb3BzIGZyb20gc3RhdGUsIHByb3BzLCBhbmQgZGlzcGF0Y2guIEZvciBleGFtcGxlOlxuICAgICBleHBvcnQgZGVmYXVsdCBjb25uZWN0QWR2YW5jZWQoKGRpc3BhdGNoLCBvcHRpb25zKSA9PiAoc3RhdGUsIHByb3BzKSA9PiAoe1xuICAgICAgdGhpbmc6IHN0YXRlLnRoaW5nc1twcm9wcy50aGluZ0lkXSxcbiAgICAgIHNhdmVUaGluZzogZmllbGRzID0+IGRpc3BhdGNoKGFjdGlvbkNyZWF0b3JzLnNhdmVUaGluZyhwcm9wcy50aGluZ0lkLCBmaWVsZHMpKSxcbiAgICB9KSkoWW91ckNvbXBvbmVudClcbiAgIEFjY2VzcyB0byBkaXNwYXRjaCBpcyBwcm92aWRlZCB0byB0aGUgZmFjdG9yeSBzbyBzZWxlY3RvckZhY3RvcmllcyBjYW4gYmluZCBhY3Rpb25DcmVhdG9yc1xuICBvdXRzaWRlIG9mIHRoZWlyIHNlbGVjdG9yIGFzIGFuIG9wdGltaXphdGlvbi4gT3B0aW9ucyBwYXNzZWQgdG8gY29ubmVjdEFkdmFuY2VkIGFyZSBwYXNzZWQgdG9cbiAgdGhlIHNlbGVjdG9yRmFjdG9yeSwgYWxvbmcgd2l0aCBkaXNwbGF5TmFtZSBhbmQgV3JhcHBlZENvbXBvbmVudCwgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAgIE5vdGUgdGhhdCBzZWxlY3RvckZhY3RvcnkgaXMgcmVzcG9uc2libGUgZm9yIGFsbCBjYWNoaW5nL21lbW9pemF0aW9uIG9mIGluYm91bmQgYW5kIG91dGJvdW5kXG4gIHByb3BzLiBEbyBub3QgdXNlIGNvbm5lY3RBZHZhbmNlZCBkaXJlY3RseSB3aXRob3V0IG1lbW9pemluZyByZXN1bHRzIGJldHdlZW4gY2FsbHMgdG8geW91clxuICBzZWxlY3Rvciwgb3RoZXJ3aXNlIHRoZSBDb25uZWN0IGNvbXBvbmVudCB3aWxsIHJlLXJlbmRlciBvbiBldmVyeSBzdGF0ZSBvciBwcm9wcyBjaGFuZ2UuXG4qL1xuc2VsZWN0b3JGYWN0b3J5KSB7XG4gIHZhciBfY29udGV4dFR5cGVzLCBfY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgX3JlZiRnZXREaXNwbGF5TmFtZSA9IF9yZWYuZ2V0RGlzcGxheU5hbWUsXG4gICAgICBnZXREaXNwbGF5TmFtZSA9IF9yZWYkZ2V0RGlzcGxheU5hbWUgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICdDb25uZWN0QWR2YW5jZWQoJyArIG5hbWUgKyAnKSc7XG4gIH0gOiBfcmVmJGdldERpc3BsYXlOYW1lLFxuICAgICAgX3JlZiRtZXRob2ROYW1lID0gX3JlZi5tZXRob2ROYW1lLFxuICAgICAgbWV0aG9kTmFtZSA9IF9yZWYkbWV0aG9kTmFtZSA9PT0gdW5kZWZpbmVkID8gJ2Nvbm5lY3RBZHZhbmNlZCcgOiBfcmVmJG1ldGhvZE5hbWUsXG4gICAgICBfcmVmJHJlbmRlckNvdW50UHJvcCA9IF9yZWYucmVuZGVyQ291bnRQcm9wLFxuICAgICAgcmVuZGVyQ291bnRQcm9wID0gX3JlZiRyZW5kZXJDb3VudFByb3AgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IF9yZWYkcmVuZGVyQ291bnRQcm9wLFxuICAgICAgX3JlZiRzaG91bGRIYW5kbGVTdGF0ID0gX3JlZi5zaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMgPSBfcmVmJHNob3VsZEhhbmRsZVN0YXQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfcmVmJHNob3VsZEhhbmRsZVN0YXQsXG4gICAgICBfcmVmJHN0b3JlS2V5ID0gX3JlZi5zdG9yZUtleSxcbiAgICAgIHN0b3JlS2V5ID0gX3JlZiRzdG9yZUtleSA9PT0gdW5kZWZpbmVkID8gJ3N0b3JlJyA6IF9yZWYkc3RvcmVLZXksXG4gICAgICBfcmVmJHdpdGhSZWYgPSBfcmVmLndpdGhSZWYsXG4gICAgICB3aXRoUmVmID0gX3JlZiR3aXRoUmVmID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkd2l0aFJlZixcbiAgICAgIGNvbm5lY3RPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnZ2V0RGlzcGxheU5hbWUnLCAnbWV0aG9kTmFtZScsICdyZW5kZXJDb3VudFByb3AnLCAnc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzJywgJ3N0b3JlS2V5JywgJ3dpdGhSZWYnXSk7XG5cbiAgdmFyIHN1YnNjcmlwdGlvbktleSA9IHN0b3JlS2V5ICsgJ1N1YnNjcmlwdGlvbic7XG4gIHZhciB2ZXJzaW9uID0gaG90UmVsb2FkaW5nVmVyc2lvbisrO1xuXG4gIHZhciBjb250ZXh0VHlwZXMgPSAoX2NvbnRleHRUeXBlcyA9IHt9LCBfY29udGV4dFR5cGVzW3N0b3JlS2V5XSA9IHN0b3JlU2hhcGUsIF9jb250ZXh0VHlwZXNbc3Vic2NyaXB0aW9uS2V5XSA9IHN1YnNjcmlwdGlvblNoYXBlLCBfY29udGV4dFR5cGVzKTtcbiAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gKF9jaGlsZENvbnRleHRUeXBlcyA9IHt9LCBfY2hpbGRDb250ZXh0VHlwZXNbc3Vic2NyaXB0aW9uS2V5XSA9IHN1YnNjcmlwdGlvblNoYXBlLCBfY2hpbGRDb250ZXh0VHlwZXMpO1xuXG4gIHJldHVybiBmdW5jdGlvbiB3cmFwV2l0aENvbm5lY3QoV3JhcHBlZENvbXBvbmVudCkge1xuICAgIGludmFyaWFudCh0eXBlb2YgV3JhcHBlZENvbXBvbmVudCA9PSAnZnVuY3Rpb24nLCAnWW91IG11c3QgcGFzcyBhIGNvbXBvbmVudCB0byB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgJyArICgnY29ubmVjdC4gSW5zdGVhZCByZWNlaXZlZCAnICsgSlNPTi5zdHJpbmdpZnkoV3JhcHBlZENvbXBvbmVudCkpKTtcblxuICAgIHZhciB3cmFwcGVkQ29tcG9uZW50TmFtZSA9IFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xuXG4gICAgdmFyIGRpc3BsYXlOYW1lID0gZ2V0RGlzcGxheU5hbWUod3JhcHBlZENvbXBvbmVudE5hbWUpO1xuXG4gICAgdmFyIHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgY29ubmVjdE9wdGlvbnMsIHtcbiAgICAgIGdldERpc3BsYXlOYW1lOiBnZXREaXNwbGF5TmFtZSxcbiAgICAgIG1ldGhvZE5hbWU6IG1ldGhvZE5hbWUsXG4gICAgICByZW5kZXJDb3VudFByb3A6IHJlbmRlckNvdW50UHJvcCxcbiAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlczogc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLFxuICAgICAgc3RvcmVLZXk6IHN0b3JlS2V5LFxuICAgICAgd2l0aFJlZjogd2l0aFJlZixcbiAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgIHdyYXBwZWRDb21wb25lbnROYW1lOiB3cmFwcGVkQ29tcG9uZW50TmFtZSxcbiAgICAgIFdyYXBwZWRDb21wb25lbnQ6IFdyYXBwZWRDb21wb25lbnRcbiAgICB9KTtcblxuICAgIHZhciBDb25uZWN0ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICAgIF9pbmhlcml0cyhDb25uZWN0LCBfQ29tcG9uZW50KTtcblxuICAgICAgZnVuY3Rpb24gQ29ubmVjdChwcm9wcywgY29udGV4dCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29ubmVjdCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSk7XG5cbiAgICAgICAgX3RoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIF90aGlzLnN0YXRlID0ge307XG4gICAgICAgIF90aGlzLnJlbmRlckNvdW50ID0gMDtcbiAgICAgICAgX3RoaXMuc3RvcmUgPSBwcm9wc1tzdG9yZUtleV0gfHwgY29udGV4dFtzdG9yZUtleV07XG4gICAgICAgIF90aGlzLnByb3BzTW9kZSA9IEJvb2xlYW4ocHJvcHNbc3RvcmVLZXldKTtcbiAgICAgICAgX3RoaXMuc2V0V3JhcHBlZEluc3RhbmNlID0gX3RoaXMuc2V0V3JhcHBlZEluc3RhbmNlLmJpbmQoX3RoaXMpO1xuXG4gICAgICAgIGludmFyaWFudChfdGhpcy5zdG9yZSwgJ0NvdWxkIG5vdCBmaW5kIFwiJyArIHN0b3JlS2V5ICsgJ1wiIGluIGVpdGhlciB0aGUgY29udGV4dCBvciBwcm9wcyBvZiAnICsgKCdcIicgKyBkaXNwbGF5TmFtZSArICdcIi4gRWl0aGVyIHdyYXAgdGhlIHJvb3QgY29tcG9uZW50IGluIGEgPFByb3ZpZGVyPiwgJykgKyAoJ29yIGV4cGxpY2l0bHkgcGFzcyBcIicgKyBzdG9yZUtleSArICdcIiBhcyBhIHByb3AgdG8gXCInICsgZGlzcGxheU5hbWUgKyAnXCIuJykpO1xuXG4gICAgICAgIF90aGlzLmluaXRTZWxlY3RvcigpO1xuICAgICAgICBfdGhpcy5pbml0U3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH1cblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICB2YXIgX3JlZjI7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBjb21wb25lbnQgcmVjZWl2ZWQgc3RvcmUgZnJvbSBwcm9wcywgaXRzIHN1YnNjcmlwdGlvbiBzaG91bGQgYmUgdHJhbnNwYXJlbnRcbiAgICAgICAgLy8gdG8gYW55IGRlc2NlbmRhbnRzIHJlY2VpdmluZyBzdG9yZStzdWJzY3JpcHRpb24gZnJvbSBjb250ZXh0OyBpdCBwYXNzZXMgYWxvbmdcbiAgICAgICAgLy8gc3Vic2NyaXB0aW9uIHBhc3NlZCB0byBpdC4gT3RoZXJ3aXNlLCBpdCBzaGFkb3dzIHRoZSBwYXJlbnQgc3Vic2NyaXB0aW9uLCB3aGljaCBhbGxvd3NcbiAgICAgICAgLy8gQ29ubmVjdCB0byBjb250cm9sIG9yZGVyaW5nIG9mIG5vdGlmaWNhdGlvbnMgdG8gZmxvdyB0b3AtZG93bi5cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMucHJvcHNNb2RlID8gbnVsbCA6IHRoaXMuc3Vic2NyaXB0aW9uO1xuICAgICAgICByZXR1cm4gX3JlZjIgPSB7fSwgX3JlZjJbc3Vic2NyaXB0aW9uS2V5XSA9IHN1YnNjcmlwdGlvbiB8fCB0aGlzLmNvbnRleHRbc3Vic2NyaXB0aW9uS2V5XSwgX3JlZjI7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuO1xuXG4gICAgICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBmaXJlcyBkdXJpbmcgc2VydmVyIHNpZGUgcmVuZGVyaW5nLCBidXQgY29tcG9uZW50RGlkTW91bnQgYW5kXG4gICAgICAgIC8vIGNvbXBvbmVudFdpbGxVbm1vdW50IGRvIG5vdC4gQmVjYXVzZSBvZiB0aGlzLCB0cnlTdWJzY3JpYmUgaGFwcGVucyBkdXJpbmcgLi4uZGlkTW91bnQuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdW5zdWJzY3JpcHRpb24gd291bGQgbmV2ZXIgdGFrZSBwbGFjZSBkdXJpbmcgU1NSLCBjYXVzaW5nIGEgbWVtb3J5IGxlYWsuXG4gICAgICAgIC8vIFRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhIGNoaWxkIGNvbXBvbmVudCBtYXkgaGF2ZSB0cmlnZ2VyZWQgYSBzdGF0ZSBjaGFuZ2UgYnlcbiAgICAgICAgLy8gZGlzcGF0Y2hpbmcgYW4gYWN0aW9uIGluIGl0cyBjb21wb25lbnRXaWxsTW91bnQsIHdlIGhhdmUgdG8gcmUtcnVuIHRoZSBzZWxlY3QgYW5kIG1heWJlXG4gICAgICAgIC8vIHJlLXJlbmRlci5cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udHJ5U3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IucnVuKHRoaXMucHJvcHMpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUpIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1bihuZXh0UHJvcHMpO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGU7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHRoaXMuc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5ub3RpZnlOZXN0ZWRTdWJzID0gbm9vcDtcbiAgICAgICAgdGhpcy5zdG9yZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IucnVuID0gbm9vcDtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmdldFdyYXBwZWRJbnN0YW5jZSA9IGZ1bmN0aW9uIGdldFdyYXBwZWRJbnN0YW5jZSgpIHtcbiAgICAgICAgaW52YXJpYW50KHdpdGhSZWYsICdUbyBhY2Nlc3MgdGhlIHdyYXBwZWQgaW5zdGFuY2UsIHlvdSBuZWVkIHRvIHNwZWNpZnkgJyArICgneyB3aXRoUmVmOiB0cnVlIH0gaW4gdGhlIG9wdGlvbnMgYXJndW1lbnQgb2YgdGhlICcgKyBtZXRob2ROYW1lICsgJygpIGNhbGwuJykpO1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVkSW5zdGFuY2U7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5zZXRXcmFwcGVkSW5zdGFuY2UgPSBmdW5jdGlvbiBzZXRXcmFwcGVkSW5zdGFuY2UocmVmKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZEluc3RhbmNlID0gcmVmO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuaW5pdFNlbGVjdG9yID0gZnVuY3Rpb24gaW5pdFNlbGVjdG9yKCkge1xuICAgICAgICB2YXIgc291cmNlU2VsZWN0b3IgPSBzZWxlY3RvckZhY3RvcnkodGhpcy5zdG9yZS5kaXNwYXRjaCwgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBtYWtlU2VsZWN0b3JTdGF0ZWZ1bChzb3VyY2VTZWxlY3RvciwgdGhpcy5zdG9yZSk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IucnVuKHRoaXMucHJvcHMpO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuaW5pdFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIGluaXRTdWJzY3JpcHRpb24oKSB7XG4gICAgICAgIGlmICghc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSByZXR1cm47XG5cbiAgICAgICAgLy8gcGFyZW50U3ViJ3Mgc291cmNlIHNob3VsZCBtYXRjaCB3aGVyZSBzdG9yZSBjYW1lIGZyb206IHByb3BzIHZzLiBjb250ZXh0LiBBIGNvbXBvbmVudFxuICAgICAgICAvLyBjb25uZWN0ZWQgdG8gdGhlIHN0b3JlIHZpYSBwcm9wcyBzaG91bGRuJ3QgdXNlIHN1YnNjcmlwdGlvbiBmcm9tIGNvbnRleHQsIG9yIHZpY2UgdmVyc2EuXG4gICAgICAgIHZhciBwYXJlbnRTdWIgPSAodGhpcy5wcm9wc01vZGUgPyB0aGlzLnByb3BzIDogdGhpcy5jb250ZXh0KVtzdWJzY3JpcHRpb25LZXldO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24odGhpcy5zdG9yZSwgcGFyZW50U3ViLCB0aGlzLm9uU3RhdGVDaGFuZ2UuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gYG5vdGlmeU5lc3RlZFN1YnNgIGlzIGR1cGxpY2F0ZWQgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBjb21wb25lbnQgaXMgIHVubW91bnRlZCBpblxuICAgICAgICAvLyB0aGUgbWlkZGxlIG9mIHRoZSBub3RpZmljYXRpb24gbG9vcCwgd2hlcmUgYHRoaXMuc3Vic2NyaXB0aW9uYCB3aWxsIHRoZW4gYmUgbnVsbC4gQW5cbiAgICAgICAgLy8gZXh0cmEgbnVsbCBjaGVjayBldmVyeSBjaGFuZ2UgY2FuIGJlIGF2b2lkZWQgYnkgY29weWluZyB0aGUgbWV0aG9kIG9udG8gYHRoaXNgIGFuZCB0aGVuXG4gICAgICAgIC8vIHJlcGxhY2luZyBpdCB3aXRoIGEgbm8tb3Agb24gdW5tb3VudC4gVGhpcyBjYW4gcHJvYmFibHkgYmUgYXZvaWRlZCBpZiBTdWJzY3JpcHRpb24nc1xuICAgICAgICAvLyBsaXN0ZW5lcnMgbG9naWMgaXMgY2hhbmdlZCB0byBub3QgY2FsbCBsaXN0ZW5lcnMgdGhhdCBoYXZlIGJlZW4gdW5zdWJzY3JpYmVkIGluIHRoZVxuICAgICAgICAvLyBtaWRkbGUgb2YgdGhlIG5vdGlmaWNhdGlvbiBsb29wLlxuICAgICAgICB0aGlzLm5vdGlmeU5lc3RlZFN1YnMgPSB0aGlzLnN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzLmJpbmQodGhpcy5zdWJzY3JpcHRpb24pO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUub25TdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uIG9uU3RhdGVDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IucnVuKHRoaXMucHJvcHMpO1xuXG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgICB0aGlzLm5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSA9IHRoaXMubm90aWZ5TmVzdGVkU3Vic09uQ29tcG9uZW50RGlkVXBkYXRlO1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoZHVtbXlTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLm5vdGlmeU5lc3RlZFN1YnNPbkNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIG5vdGlmeU5lc3RlZFN1YnNPbkNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgLy8gYGNvbXBvbmVudERpZFVwZGF0ZWAgaXMgY29uZGl0aW9uYWxseSBpbXBsZW1lbnRlZCB3aGVuIGBvblN0YXRlQ2hhbmdlYCBkZXRlcm1pbmVzIGl0XG4gICAgICAgIC8vIG5lZWRzIHRvIG5vdGlmeSBuZXN0ZWQgc3Vicy4gT25jZSBjYWxsZWQsIGl0IHVuaW1wbGVtZW50cyBpdHNlbGYgdW50aWwgZnVydGhlciBzdGF0ZVxuICAgICAgICAvLyBjaGFuZ2VzIG9jY3VyLiBEb2luZyBpdCB0aGlzIHdheSB2cyBoYXZpbmcgYSBwZXJtYW5lbnQgYGNvbXBvbmVudERpZFVwZGF0ZWAgdGhhdCBkb2VzXG4gICAgICAgIC8vIGEgYm9vbGVhbiBjaGVjayBldmVyeSB0aW1lIGF2b2lkcyBhbiBleHRyYSBtZXRob2QgY2FsbCBtb3N0IG9mIHRoZSB0aW1lLCByZXN1bHRpbmdcbiAgICAgICAgLy8gaW4gc29tZSBwZXJmIGJvb3N0LlxuICAgICAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5ub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5pc1N1YnNjcmliZWQgPSBmdW5jdGlvbiBpc1N1YnNjcmliZWQoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuc3Vic2NyaXB0aW9uKSAmJiB0aGlzLnN1YnNjcmlwdGlvbi5pc1N1YnNjcmliZWQoKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmFkZEV4dHJhUHJvcHMgPSBmdW5jdGlvbiBhZGRFeHRyYVByb3BzKHByb3BzKSB7XG4gICAgICAgIGlmICghd2l0aFJlZiAmJiAhcmVuZGVyQ291bnRQcm9wICYmICEodGhpcy5wcm9wc01vZGUgJiYgdGhpcy5zdWJzY3JpcHRpb24pKSByZXR1cm4gcHJvcHM7XG4gICAgICAgIC8vIG1ha2UgYSBzaGFsbG93IGNvcHkgc28gdGhhdCBmaWVsZHMgYWRkZWQgZG9uJ3QgbGVhayB0byB0aGUgb3JpZ2luYWwgc2VsZWN0b3IuXG4gICAgICAgIC8vIHRoaXMgaXMgZXNwZWNpYWxseSBpbXBvcnRhbnQgZm9yICdyZWYnIHNpbmNlIHRoYXQncyBhIHJlZmVyZW5jZSBiYWNrIHRvIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gaW5zdGFuY2UuIGEgc2luZ2xldG9uIG1lbW9pemVkIHNlbGVjdG9yIHdvdWxkIHRoZW4gYmUgaG9sZGluZyBhIHJlZmVyZW5jZSB0byB0aGVcbiAgICAgICAgLy8gaW5zdGFuY2UsIHByZXZlbnRpbmcgdGhlIGluc3RhbmNlIGZyb20gYmVpbmcgZ2FyYmFnZSBjb2xsZWN0ZWQsIGFuZCB0aGF0IHdvdWxkIGJlIGJhZFxuICAgICAgICB2YXIgd2l0aEV4dHJhcyA9IF9leHRlbmRzKHt9LCBwcm9wcyk7XG4gICAgICAgIGlmICh3aXRoUmVmKSB3aXRoRXh0cmFzLnJlZiA9IHRoaXMuc2V0V3JhcHBlZEluc3RhbmNlO1xuICAgICAgICBpZiAocmVuZGVyQ291bnRQcm9wKSB3aXRoRXh0cmFzW3JlbmRlckNvdW50UHJvcF0gPSB0aGlzLnJlbmRlckNvdW50Kys7XG4gICAgICAgIGlmICh0aGlzLnByb3BzTW9kZSAmJiB0aGlzLnN1YnNjcmlwdGlvbikgd2l0aEV4dHJhc1tzdWJzY3JpcHRpb25LZXldID0gdGhpcy5zdWJzY3JpcHRpb247XG4gICAgICAgIHJldHVybiB3aXRoRXh0cmFzO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuICAgICAgICBzZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc2VsZWN0b3IuZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBzZWxlY3Rvci5lcnJvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCB0aGlzLmFkZEV4dHJhUHJvcHMoc2VsZWN0b3IucHJvcHMpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbm5lY3Q7XG4gICAgfShDb21wb25lbnQpO1xuXG4gICAgQ29ubmVjdC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICBDb25uZWN0LmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgQ29ubmVjdC5jaGlsZENvbnRleHRUeXBlcyA9IGNoaWxkQ29udGV4dFR5cGVzO1xuICAgIENvbm5lY3QuY29udGV4dFR5cGVzID0gY29udGV4dFR5cGVzO1xuICAgIENvbm5lY3QucHJvcFR5cGVzID0gY29udGV4dFR5cGVzO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVXBkYXRlKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAvLyBXZSBhcmUgaG90IHJlbG9hZGluZyFcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbiAhPT0gdmVyc2lvbikge1xuICAgICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgdGhpcy5pbml0U2VsZWN0b3IoKTtcblxuICAgICAgICAgIC8vIElmIGFueSBjb25uZWN0ZWQgZGVzY2VuZGFudHMgZG9uJ3QgaG90IHJlbG9hZCAoYW5kIHJlc3Vic2NyaWJlIGluIHRoZSBwcm9jZXNzKSwgdGhlaXJcbiAgICAgICAgICAvLyBsaXN0ZW5lcnMgd2lsbCBiZSBsb3N0IHdoZW4gd2UgdW5zdWJzY3JpYmUuIFVuZm9ydHVuYXRlbHksIGJ5IGNvcHlpbmcgb3ZlciBhbGxcbiAgICAgICAgICAvLyBsaXN0ZW5lcnMsIHRoaXMgZG9lcyBtZWFuIHRoYXQgdGhlIG9sZCB2ZXJzaW9ucyBvZiBjb25uZWN0ZWQgZGVzY2VuZGFudHMgd2lsbCBzdGlsbCBiZVxuICAgICAgICAgIC8vIG5vdGlmaWVkIG9mIHN0YXRlIGNoYW5nZXM7IGhvd2V2ZXIsIHRoZWlyIG9uU3RhdGVDaGFuZ2UgZnVuY3Rpb24gaXMgYSBuby1vcCBzbyB0aGlzXG4gICAgICAgICAgLy8gaXNuJ3QgYSBodWdlIGRlYWwuXG4gICAgICAgICAgdmFyIG9sZExpc3RlbmVycyA9IFtdO1xuXG4gICAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBvbGRMaXN0ZW5lcnMgPSB0aGlzLnN1YnNjcmlwdGlvbi5saXN0ZW5lcnMuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmluaXRTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICBpZiAoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIG9sZExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLnN1YnNjcmlwdGlvbi5saXN0ZW5lcnMuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaG9pc3RTdGF0aWNzKENvbm5lY3QsIFdyYXBwZWRDb21wb25lbnQpO1xuICB9O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL2Nvbm5lY3RBZHZhbmNlZC5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHZlcmlmeVBsYWluT2JqZWN0IGZyb20gJy4uL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0JztcblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoZ2V0Q29uc3RhbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRDb25zdGFudFNlbGVjdG9yKGRpc3BhdGNoLCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnN0YW50ID0gZ2V0Q29uc3RhbnQoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuXG4gICAgZnVuY3Rpb24gY29uc3RhbnRTZWxlY3RvcigpIHtcbiAgICAgIHJldHVybiBjb25zdGFudDtcbiAgICB9XG4gICAgY29uc3RhbnRTZWxlY3Rvci5kZXBlbmRzT25Pd25Qcm9wcyA9IGZhbHNlO1xuICAgIHJldHVybiBjb25zdGFudFNlbGVjdG9yO1xuICB9O1xufVxuXG4vLyBkZXBlbmRzT25Pd25Qcm9wcyBpcyB1c2VkIGJ5IGNyZWF0ZU1hcFRvUHJvcHNQcm94eSB0byBkZXRlcm1pbmUgd2hldGhlciB0byBwYXNzIHByb3BzIGFzIGFyZ3Ncbi8vIHRvIHRoZSBtYXBUb1Byb3BzIGZ1bmN0aW9uIGJlaW5nIHdyYXBwZWQuIEl0IGlzIGFsc28gdXNlZCBieSBtYWtlUHVyZVByb3BzU2VsZWN0b3IgdG8gZGV0ZXJtaW5lXG4vLyB3aGV0aGVyIG1hcFRvUHJvcHMgbmVlZHMgdG8gYmUgaW52b2tlZCB3aGVuIHByb3BzIGhhdmUgY2hhbmdlZC5cbi8vIFxuLy8gQSBsZW5ndGggb2Ygb25lIHNpZ25hbHMgdGhhdCBtYXBUb1Byb3BzIGRvZXMgbm90IGRlcGVuZCBvbiBwcm9wcyBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuLy8gQSBsZW5ndGggb2YgemVybyBpcyBhc3N1bWVkIHRvIG1lYW4gbWFwVG9Qcm9wcyBpcyBnZXR0aW5nIGFyZ3MgdmlhIGFyZ3VtZW50cyBvciAuLi5hcmdzIGFuZFxuLy8gdGhlcmVmb3JlIG5vdCByZXBvcnRpbmcgaXRzIGxlbmd0aCBhY2N1cmF0ZWx5Li5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZXBlbmRzT25Pd25Qcm9wcyhtYXBUb1Byb3BzKSB7XG4gIHJldHVybiBtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzICE9PSBudWxsICYmIG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMgIT09IHVuZGVmaW5lZCA/IEJvb2xlYW4obWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgOiBtYXBUb1Byb3BzLmxlbmd0aCAhPT0gMTtcbn1cblxuLy8gVXNlZCBieSB3aGVuTWFwU3RhdGVUb1Byb3BzSXNGdW5jdGlvbiBhbmQgd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzRnVuY3Rpb24sXG4vLyB0aGlzIGZ1bmN0aW9uIHdyYXBzIG1hcFRvUHJvcHMgaW4gYSBwcm94eSBmdW5jdGlvbiB3aGljaCBkb2VzIHNldmVyYWwgdGhpbmdzOlxuLy8gXG4vLyAgKiBEZXRlY3RzIHdoZXRoZXIgdGhlIG1hcFRvUHJvcHMgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIGRlcGVuZHMgb24gcHJvcHMsIHdoaWNoXG4vLyAgICBpcyB1c2VkIGJ5IHNlbGVjdG9yRmFjdG9yeSB0byBkZWNpZGUgaWYgaXQgc2hvdWxkIHJlaW52b2tlIG9uIHByb3BzIGNoYW5nZXMuXG4vLyAgICBcbi8vICAqIE9uIGZpcnN0IGNhbGwsIGhhbmRsZXMgbWFwVG9Qcm9wcyBpZiByZXR1cm5zIGFub3RoZXIgZnVuY3Rpb24sIGFuZCB0cmVhdHMgdGhhdFxuLy8gICAgbmV3IGZ1bmN0aW9uIGFzIHRoZSB0cnVlIG1hcFRvUHJvcHMgZm9yIHN1YnNlcXVlbnQgY2FsbHMuXG4vLyAgICBcbi8vICAqIE9uIGZpcnN0IGNhbGwsIHZlcmlmaWVzIHRoZSBmaXJzdCByZXN1bHQgaXMgYSBwbGFpbiBvYmplY3QsIGluIG9yZGVyIHRvIHdhcm5cbi8vICAgIHRoZSBkZXZlbG9wZXIgdGhhdCB0aGVpciBtYXBUb1Byb3BzIGZ1bmN0aW9uIGlzIG5vdCByZXR1cm5pbmcgYSB2YWxpZCByZXN1bHQuXG4vLyAgICBcbmV4cG9ydCBmdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwVG9Qcm9wcywgbWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdFByb3h5U2VsZWN0b3IoZGlzcGF0Y2gsIF9yZWYpIHtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBfcmVmLmRpc3BsYXlOYW1lO1xuXG4gICAgdmFyIHByb3h5ID0gZnVuY3Rpb24gbWFwVG9Qcm9wc1Byb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcbiAgICAgIHJldHVybiBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA/IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykgOiBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCk7XG4gICAgfTtcblxuICAgIC8vIGFsbG93IGRldGVjdEZhY3RvcnlBbmRWZXJpZnkgdG8gZ2V0IG93blByb3BzXG4gICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSB0cnVlO1xuXG4gICAgcHJveHkubWFwVG9Qcm9wcyA9IGZ1bmN0aW9uIGRldGVjdEZhY3RvcnlBbmRWZXJpZnkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykge1xuICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IG1hcFRvUHJvcHM7XG4gICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpO1xuICAgICAgdmFyIHByb3BzID0gcHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcyk7XG5cbiAgICAgIGlmICh0eXBlb2YgcHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IHByb3BzO1xuICAgICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKHByb3BzKTtcbiAgICAgICAgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHZlcmlmeVBsYWluT2JqZWN0KHByb3BzLCBkaXNwbGF5TmFtZSwgbWV0aG9kTmFtZSk7XG5cbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3dyYXBNYXBUb1Byb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5leHBvcnQgdmFyIHN1YnNjcmlwdGlvblNoYXBlID0gUHJvcFR5cGVzLnNoYXBlKHtcbiAgdHJ5U3Vic2NyaWJlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB0cnlVbnN1YnNjcmliZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgbm90aWZ5TmVzdGVkU3ViczogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgaXNTdWJzY3JpYmVkOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG59KTtcblxuZXhwb3J0IHZhciBzdG9yZVNoYXBlID0gUHJvcFR5cGVzLnNoYXBlKHtcbiAgc3Vic2NyaWJlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBkaXNwYXRjaDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgZ2V0U3RhdGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1yZWR1eC9lcy91dGlscy9Qcm9wVHlwZXMuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJ2xvZGFzaC1lcy9pc1BsYWluT2JqZWN0JztcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4vd2FybmluZyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZlcmlmeVBsYWluT2JqZWN0KHZhbHVlLCBkaXNwbGF5TmFtZSwgbWV0aG9kTmFtZSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybmluZyhtZXRob2ROYW1lICsgJygpIGluICcgKyBkaXNwbGF5TmFtZSArICcgbXVzdCByZXR1cm4gYSBwbGFpbiBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQgJyArIHZhbHVlICsgJy4nKTtcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1yZWR1eC9lcy91dGlscy92ZXJpZnlQbGFpbk9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgcmVwZWF0ID0gZXhwb3J0cy5yZXBlYXQgPSBmdW5jdGlvbiByZXBlYXQoc3RyLCB0aW1lcykge1xuICByZXR1cm4gbmV3IEFycmF5KHRpbWVzICsgMSkuam9pbihzdHIpO1xufTtcblxudmFyIHBhZCA9IGV4cG9ydHMucGFkID0gZnVuY3Rpb24gcGFkKG51bSwgbWF4TGVuZ3RoKSB7XG4gIHJldHVybiByZXBlYXQoXCIwXCIsIG1heExlbmd0aCAtIG51bS50b1N0cmluZygpLmxlbmd0aCkgKyBudW07XG59O1xuXG52YXIgZm9ybWF0VGltZSA9IGV4cG9ydHMuZm9ybWF0VGltZSA9IGZ1bmN0aW9uIGZvcm1hdFRpbWUodGltZSkge1xuICByZXR1cm4gcGFkKHRpbWUuZ2V0SG91cnMoKSwgMikgKyBcIjpcIiArIHBhZCh0aW1lLmdldE1pbnV0ZXMoKSwgMikgKyBcIjpcIiArIHBhZCh0aW1lLmdldFNlY29uZHMoKSwgMikgKyBcIi5cIiArIHBhZCh0aW1lLmdldE1pbGxpc2Vjb25kcygpLCAzKTtcbn07XG5cbi8vIFVzZSBwZXJmb3JtYW5jZSBBUEkgaWYgaXQncyBhdmFpbGFibGUgaW4gb3JkZXIgdG8gZ2V0IGJldHRlciBwcmVjaXNpb25cbnZhciB0aW1lciA9IGV4cG9ydHMudGltZXIgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcGVyZm9ybWFuY2UgIT09IG51bGwgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gXCJmdW5jdGlvblwiID8gcGVyZm9ybWFuY2UgOiBEYXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWR1eC1sb2dnZXIvbGliL2hlbHBlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29tcG9zZXMgc2luZ2xlLWFyZ3VtZW50IGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuIFRoZSByaWdodG1vc3RcbiAqIGZ1bmN0aW9uIGNhbiB0YWtlIG11bHRpcGxlIGFyZ3VtZW50cyBhcyBpdCBwcm92aWRlcyB0aGUgc2lnbmF0dXJlIGZvclxuICogdGhlIHJlc3VsdGluZyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3MgVGhlIGZ1bmN0aW9ucyB0byBjb21wb3NlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIG9idGFpbmVkIGJ5IGNvbXBvc2luZyB0aGUgYXJndW1lbnQgZnVuY3Rpb25zXG4gKiBmcm9tIHJpZ2h0IHRvIGxlZnQuIEZvciBleGFtcGxlLCBjb21wb3NlKGYsIGcsIGgpIGlzIGlkZW50aWNhbCB0byBkb2luZ1xuICogKC4uLmFyZ3MpID0+IGYoZyhoKC4uLmFyZ3MpKSkuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZnVuY3NbMF07XG4gIH1cblxuICByZXR1cm4gZnVuY3MucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhKGIuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVkdXgvZXMvY29tcG9zZS5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0ICQkb2JzZXJ2YWJsZSBmcm9tICdzeW1ib2wtb2JzZXJ2YWJsZSc7XG5cbi8qKlxuICogVGhlc2UgYXJlIHByaXZhdGUgYWN0aW9uIHR5cGVzIHJlc2VydmVkIGJ5IFJlZHV4LlxuICogRm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHlvdSBtdXN0IHJldHVybiB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIElmIHRoZSBjdXJyZW50IHN0YXRlIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLlxuICogRG8gbm90IHJlZmVyZW5jZSB0aGVzZSBhY3Rpb24gdHlwZXMgZGlyZWN0bHkgaW4geW91ciBjb2RlLlxuICovXG5leHBvcnQgdmFyIEFjdGlvblR5cGVzID0ge1xuICBJTklUOiAnQEByZWR1eC9JTklUJ1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUmVkdXggc3RvcmUgdGhhdCBob2xkcyB0aGUgc3RhdGUgdHJlZS5cbiAgICogVGhlIG9ubHkgd2F5IHRvIGNoYW5nZSB0aGUgZGF0YSBpbiB0aGUgc3RvcmUgaXMgdG8gY2FsbCBgZGlzcGF0Y2goKWAgb24gaXQuXG4gICAqXG4gICAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIGEgc2luZ2xlIHN0b3JlIGluIHlvdXIgYXBwLiBUbyBzcGVjaWZ5IGhvdyBkaWZmZXJlbnRcbiAgICogcGFydHMgb2YgdGhlIHN0YXRlIHRyZWUgcmVzcG9uZCB0byBhY3Rpb25zLCB5b3UgbWF5IGNvbWJpbmUgc2V2ZXJhbCByZWR1Y2Vyc1xuICAgKiBpbnRvIGEgc2luZ2xlIHJlZHVjZXIgZnVuY3Rpb24gYnkgdXNpbmcgYGNvbWJpbmVSZWR1Y2Vyc2AuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZHVjZXIgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG5leHQgc3RhdGUgdHJlZSwgZ2l2ZW5cbiAgICogdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGFjdGlvbiB0byBoYW5kbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBbcHJlbG9hZGVkU3RhdGVdIFRoZSBpbml0aWFsIHN0YXRlLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICAgKiB0byBoeWRyYXRlIHRoZSBzdGF0ZSBmcm9tIHRoZSBzZXJ2ZXIgaW4gdW5pdmVyc2FsIGFwcHMsIG9yIHRvIHJlc3RvcmUgYVxuICAgKiBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgdXNlciBzZXNzaW9uLlxuICAgKiBJZiB5b3UgdXNlIGBjb21iaW5lUmVkdWNlcnNgIHRvIHByb2R1Y2UgdGhlIHJvb3QgcmVkdWNlciBmdW5jdGlvbiwgdGhpcyBtdXN0IGJlXG4gICAqIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGBjb21iaW5lUmVkdWNlcnNgIGtleXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlbmhhbmNlcl0gVGhlIHN0b3JlIGVuaGFuY2VyLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICAgKiB0byBlbmhhbmNlIHRoZSBzdG9yZSB3aXRoIHRoaXJkLXBhcnR5IGNhcGFiaWxpdGllcyBzdWNoIGFzIG1pZGRsZXdhcmUsXG4gICAqIHRpbWUgdHJhdmVsLCBwZXJzaXN0ZW5jZSwgZXRjLiBUaGUgb25seSBzdG9yZSBlbmhhbmNlciB0aGF0IHNoaXBzIHdpdGggUmVkdXhcbiAgICogaXMgYGFwcGx5TWlkZGxld2FyZSgpYC5cbiAgICpcbiAgICogQHJldHVybnMge1N0b3JlfSBBIFJlZHV4IHN0b3JlIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgc3RhdGUsIGRpc3BhdGNoIGFjdGlvbnNcbiAgICogYW5kIHN1YnNjcmliZSB0byBjaGFuZ2VzLlxuICAgKi9cbn07ZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlU3RvcmUocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKSB7XG4gIHZhciBfcmVmMjtcblxuICBpZiAodHlwZW9mIHByZWxvYWRlZFN0YXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbmhhbmNlciA9IHByZWxvYWRlZFN0YXRlO1xuICAgIHByZWxvYWRlZFN0YXRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBlbmhhbmNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHJldHVybiBlbmhhbmNlcihjcmVhdGVTdG9yZSkocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IHByZWxvYWRlZFN0YXRlO1xuICB2YXIgY3VycmVudExpc3RlbmVycyA9IFtdO1xuICB2YXIgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnM7XG4gIHZhciBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpIHtcbiAgICBpZiAobmV4dExpc3RlbmVycyA9PT0gY3VycmVudExpc3RlbmVycykge1xuICAgICAgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIHN0YXRlIHRyZWUgbWFuYWdlZCBieSB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHthbnl9IFRoZSBjdXJyZW50IHN0YXRlIHRyZWUgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNoYW5nZSBsaXN0ZW5lci4gSXQgd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQsXG4gICAqIGFuZCBzb21lIHBhcnQgb2YgdGhlIHN0YXRlIHRyZWUgbWF5IHBvdGVudGlhbGx5IGhhdmUgY2hhbmdlZC4gWW91IG1heSB0aGVuXG4gICAqIGNhbGwgYGdldFN0YXRlKClgIHRvIHJlYWQgdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBpbnNpZGUgdGhlIGNhbGxiYWNrLlxuICAgKlxuICAgKiBZb3UgbWF5IGNhbGwgYGRpc3BhdGNoKClgIGZyb20gYSBjaGFuZ2UgbGlzdGVuZXIsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBjYXZlYXRzOlxuICAgKlxuICAgKiAxLiBUaGUgc3Vic2NyaXB0aW9ucyBhcmUgc25hcHNob3R0ZWQganVzdCBiZWZvcmUgZXZlcnkgYGRpc3BhdGNoKClgIGNhbGwuXG4gICAqIElmIHlvdSBzdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgd2hpbGUgdGhlIGxpc3RlbmVycyBhcmUgYmVpbmcgaW52b2tlZCwgdGhpc1xuICAgKiB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3Qgb24gdGhlIGBkaXNwYXRjaCgpYCB0aGF0IGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcy5cbiAgICogSG93ZXZlciwgdGhlIG5leHQgYGRpc3BhdGNoKClgIGNhbGwsIHdoZXRoZXIgbmVzdGVkIG9yIG5vdCwgd2lsbCB1c2UgYSBtb3JlXG4gICAqIHJlY2VudCBzbmFwc2hvdCBvZiB0aGUgc3Vic2NyaXB0aW9uIGxpc3QuXG4gICAqXG4gICAqIDIuIFRoZSBsaXN0ZW5lciBzaG91bGQgbm90IGV4cGVjdCB0byBzZWUgYWxsIHN0YXRlIGNoYW5nZXMsIGFzIHRoZSBzdGF0ZVxuICAgKiBtaWdodCBoYXZlIGJlZW4gdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgYSBuZXN0ZWQgYGRpc3BhdGNoKClgIGJlZm9yZVxuICAgKiB0aGUgbGlzdGVuZXIgaXMgY2FsbGVkLiBJdCBpcywgaG93ZXZlciwgZ3VhcmFudGVlZCB0aGF0IGFsbCBzdWJzY3JpYmVyc1xuICAgKiByZWdpc3RlcmVkIGJlZm9yZSB0aGUgYGRpc3BhdGNoKClgIHN0YXJ0ZWQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgbGF0ZXN0XG4gICAqIHN0YXRlIGJ5IHRoZSB0aW1lIGl0IGV4aXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBBIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gZXZlcnkgZGlzcGF0Y2guXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0byByZW1vdmUgdGhpcyBjaGFuZ2UgbGlzdGVuZXIuXG4gICAqL1xuICBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG5cbiAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgbmV4dExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG5cbiAgICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICAgIHZhciBpbmRleCA9IG5leHRMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBuZXh0TGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFuIGFjdGlvbi4gSXQgaXMgdGhlIG9ubHkgd2F5IHRvIHRyaWdnZXIgYSBzdGF0ZSBjaGFuZ2UuXG4gICAqXG4gICAqIFRoZSBgcmVkdWNlcmAgZnVuY3Rpb24sIHVzZWQgdG8gY3JlYXRlIHRoZSBzdG9yZSwgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGVcbiAgICogY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgZ2l2ZW4gYGFjdGlvbmAuIEl0cyByZXR1cm4gdmFsdWUgd2lsbFxuICAgKiBiZSBjb25zaWRlcmVkIHRoZSAqKm5leHQqKiBzdGF0ZSBvZiB0aGUgdHJlZSwgYW5kIHRoZSBjaGFuZ2UgbGlzdGVuZXJzXG4gICAqIHdpbGwgYmUgbm90aWZpZWQuXG4gICAqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgcGxhaW4gb2JqZWN0IGFjdGlvbnMuIElmIHlvdSB3YW50IHRvXG4gICAqIGRpc3BhdGNoIGEgUHJvbWlzZSwgYW4gT2JzZXJ2YWJsZSwgYSB0aHVuaywgb3Igc29tZXRoaW5nIGVsc2UsIHlvdSBuZWVkIHRvXG4gICAqIHdyYXAgeW91ciBzdG9yZSBjcmVhdGluZyBmdW5jdGlvbiBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIG1pZGRsZXdhcmUuIEZvclxuICAgKiBleGFtcGxlLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UuIEV2ZW4gdGhlXG4gICAqIG1pZGRsZXdhcmUgd2lsbCBldmVudHVhbGx5IGRpc3BhdGNoIHBsYWluIG9iamVjdCBhY3Rpb25zIHVzaW5nIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIEEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGluZyDigJx3aGF0IGNoYW5nZWTigJ0uIEl0IGlzXG4gICAqIGEgZ29vZCBpZGVhIHRvIGtlZXAgYWN0aW9ucyBzZXJpYWxpemFibGUgc28geW91IGNhbiByZWNvcmQgYW5kIHJlcGxheSB1c2VyXG4gICAqIHNlc3Npb25zLCBvciB1c2UgdGhlIHRpbWUgdHJhdmVsbGluZyBgcmVkdXgtZGV2dG9vbHNgLiBBbiBhY3Rpb24gbXVzdCBoYXZlXG4gICAqIGEgYHR5cGVgIHByb3BlcnR5IHdoaWNoIG1heSBub3QgYmUgYHVuZGVmaW5lZGAuIEl0IGlzIGEgZ29vZCBpZGVhIHRvIHVzZVxuICAgKiBzdHJpbmcgY29uc3RhbnRzIGZvciBhY3Rpb24gdHlwZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEZvciBjb252ZW5pZW5jZSwgdGhlIHNhbWUgYWN0aW9uIG9iamVjdCB5b3UgZGlzcGF0Y2hlZC5cbiAgICpcbiAgICogTm90ZSB0aGF0LCBpZiB5b3UgdXNlIGEgY3VzdG9tIG1pZGRsZXdhcmUsIGl0IG1heSB3cmFwIGBkaXNwYXRjaCgpYCB0b1xuICAgKiByZXR1cm4gc29tZXRoaW5nIGVsc2UgKGZvciBleGFtcGxlLCBhIFByb21pc2UgeW91IGNhbiBhd2FpdCkuXG4gICAqL1xuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG11c3QgYmUgcGxhaW4gb2JqZWN0cy4gJyArICdVc2UgY3VzdG9tIG1pZGRsZXdhcmUgZm9yIGFzeW5jIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtYXkgbm90IGhhdmUgYW4gdW5kZWZpbmVkIFwidHlwZVwiIHByb3BlcnR5LiAnICsgJ0hhdmUgeW91IG1pc3NwZWxsZWQgYSBjb25zdGFudD8nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMgPSBuZXh0TGlzdGVuZXJzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHJlZHVjZXIgY3VycmVudGx5IHVzZWQgYnkgdGhlIHN0b3JlIHRvIGNhbGN1bGF0ZSB0aGUgc3RhdGUuXG4gICAqXG4gICAqIFlvdSBtaWdodCBuZWVkIHRoaXMgaWYgeW91ciBhcHAgaW1wbGVtZW50cyBjb2RlIHNwbGl0dGluZyBhbmQgeW91IHdhbnQgdG9cbiAgICogbG9hZCBzb21lIG9mIHRoZSByZWR1Y2VycyBkeW5hbWljYWxseS4gWW91IG1pZ2h0IGFsc28gbmVlZCB0aGlzIGlmIHlvdVxuICAgKiBpbXBsZW1lbnQgYSBob3QgcmVsb2FkaW5nIG1lY2hhbmlzbSBmb3IgUmVkdXguXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRSZWR1Y2VyIFRoZSByZWR1Y2VyIGZvciB0aGUgc3RvcmUgdG8gdXNlIGluc3RlYWQuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZVJlZHVjZXIobmV4dFJlZHVjZXIpIHtcbiAgICBpZiAodHlwZW9mIG5leHRSZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBuZXh0UmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSZWR1Y2VyID0gbmV4dFJlZHVjZXI7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVyb3BlcmFiaWxpdHkgcG9pbnQgZm9yIG9ic2VydmFibGUvcmVhY3RpdmUgbGlicmFyaWVzLlxuICAgKiBAcmV0dXJucyB7b2JzZXJ2YWJsZX0gQSBtaW5pbWFsIG9ic2VydmFibGUgb2Ygc3RhdGUgY2hhbmdlcy5cbiAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgb2JzZXJ2YWJsZSBwcm9wb3NhbDpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JzZXJ2YWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBvdXRlclN1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICByZXR1cm4gX3JlZiA9IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIG1pbmltYWwgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gbWV0aG9kLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9ic2VydmVyIEFueSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBvYnNlcnZlci5cbiAgICAgICAqIFRoZSBvYnNlcnZlciBvYmplY3Qgc2hvdWxkIGhhdmUgYSBgbmV4dGAgbWV0aG9kLlxuICAgICAgICogQHJldHVybnMge3N1YnNjcmlwdGlvbn0gQW4gb2JqZWN0IHdpdGggYW4gYHVuc3Vic2NyaWJlYCBtZXRob2QgdGhhdCBjYW5cbiAgICAgICAqIGJlIHVzZWQgdG8gdW5zdWJzY3JpYmUgdGhlIG9ic2VydmFibGUgZnJvbSB0aGUgc3RvcmUsIGFuZCBwcmV2ZW50IGZ1cnRoZXJcbiAgICAgICAqIGVtaXNzaW9uIG9mIHZhbHVlcyBmcm9tIHRoZSBvYnNlcnZhYmxlLlxuICAgICAgICovXG4gICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgICAgICBpZiAodHlwZW9mIG9ic2VydmVyICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvYnNlcnZlU3RhdGUoKSB7XG4gICAgICAgICAgaWYgKG9ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZ2V0U3RhdGUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JzZXJ2ZVN0YXRlKCk7XG4gICAgICAgIHZhciB1bnN1YnNjcmliZSA9IG91dGVyU3Vic2NyaWJlKG9ic2VydmVTdGF0ZSk7XG4gICAgICAgIHJldHVybiB7IHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSB9O1xuICAgICAgfVxuICAgIH0sIF9yZWZbJCRvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIF9yZWY7XG4gIH1cblxuICAvLyBXaGVuIGEgc3RvcmUgaXMgY3JlYXRlZCwgYW4gXCJJTklUXCIgYWN0aW9uIGlzIGRpc3BhdGNoZWQgc28gdGhhdCBldmVyeVxuICAvLyByZWR1Y2VyIHJldHVybnMgdGhlaXIgaW5pdGlhbCBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgLy8gdGhlIGluaXRpYWwgc3RhdGUgdHJlZS5cbiAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxuICB9LCBfcmVmMlskJG9ic2VydmFibGVdID0gb2JzZXJ2YWJsZSwgX3JlZjI7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlZHV4L2VzL2NyZWF0ZVN0b3JlLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFByaW50cyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWR1eC9lcy91dGlscy93YXJuaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtjb25uZWN0fSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgR3JhcGggZnJvbSAnY29udGFpbmVyL2dyYXBoX3RlbXAnO1xuaW1wb3J0IFJlYWxUaW1lIGZyb20gJ2NvbnRhaW5lci9yZWFsdGltZSc7XG5pbXBvcnQgTWFwIGZyb20gJ2NvbnRhaW5lci9tYXAnO1xuaW1wb3J0IFRvcE5hdiBmcm9tICd0b3BuYXYnO1xuXG5jb25zdCBfYXBwbHlMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBoaXN0RnVuYyA9IGhpc3RvcnlbdHlwZV07XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJ2ID0gaGlzdEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB2YXIgZSA9IG5ldyBFdmVudCh0eXBlKTtcbiAgICBlLmFyZ3VtZW50cyA9IGFyZ3VtZW50cztcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChlKTtcbiAgICByZXR1cm4gcnY7XG4gIH07XG59O1xuXG5mdW5jdGlvbiBzZWxlY3Qoc3RvcmUpIHtcbiAgLy8gSG93IERpZmZyZW50IFJlZHV4IHN0b3JlcyBnZXQgbWFwcGVkIHRvIHByb3BzXG4gIHJldHVybiB7cm91dGVzOiBzdG9yZS5yb3V0ZXN9XG59XG5jbGFzcyBMYXlvdXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIGhpc3RvcnkucHVzaFN0YXRlID0gX2FwcGx5TGlzdGVuZXIoJ3B1c2hTdGF0ZScpO1xuICAgIHdpbmRvdy5vbnBvcHN0YXRlID0gKGUpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgbGV0IG5ld1BhdGggPSBlLnN0YXRlLlVybDtcbiAgICAgIGxldCBjb21wID0gdGhpcy5wcm9wcy5yb3V0ZXMucm91dGVDb21wb25lbnRzW25ld1BhdGhdO1xuICAgICAgbGV0IHRvcE5hdiA9IDxUb3BOYXYgdGhlQ2xhc3M9e25ld1BhdGggPT09ICcvcmVhbHRpbWUnID8gJ3J0LWFsdGVyJyA6ICcnfSBwYXRoTmFtZT17bmV3UGF0aH0vPjtcbiAgICAgIHRoaXMucHJvcHMuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnTkVXX1BBVEgnLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgcGF0aE5hbWU6IG5ld1BhdGgsXG4gICAgICAgICAgYmxvY2tlZDogY29tcCxcbiAgICAgICAgICB0b3BOYXY6IHRvcE5hdlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIH07XG4gICAgY29uc3QgZXZlbnRIYW5kbGVyID0gKGUpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdTdGF0ZSBDaGFuZ2VkIScsIGUpO1xuICAgICAgbGV0IG5ld1BhdGggPSBlLmFyZ3VtZW50c1swXS5Vcmw7XG4gICAgICBsZXQgY29tcCA9IHRoaXMucHJvcHMucm91dGVzLnJvdXRlQ29tcG9uZW50c1tuZXdQYXRoXTtcbiAgICAgIGxldCB0b3BOYXYgPSA8VG9wTmF2IHRoZUNsYXNzPXtuZXdQYXRoID09PSAnL3JlYWx0aW1lJyA/ICdydC1hbHRlcicgOiAnJ30gcGF0aE5hbWU9e25ld1BhdGh9Lz47XG4gICAgICB0aGlzLnByb3BzLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ05FV19QQVRIJyxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIHBhdGhOYW1lOiBuZXdQYXRoLFxuICAgICAgICAgIGJsb2NrZWQ6IGNvbXAsXG4gICAgICAgICAgdG9wTmF2OiB0b3BOYXZcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwdXNoU3RhdGUnLCBldmVudEhhbmRsZXIpO1xuICB9XG4gIG5ld1NldChuZXdQYXRoKSB7XG4gICAgbGV0IGNvbXAgPSB0aGlzU2NvcGUucHJvcHMucm91dGVzLnJvdXRlQ29tcG9uZW50c1tuZXdQYXRoXTtcbiAgICB0aGlzLnByb3BzLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6ICdORVdfUEFUSCcsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIHBhdGhOYW1lOiBuZXdQYXRoLFxuICAgICAgICBibG9ja2VkOiBjb21wXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZ29TdGF0ZShwcCkge1xuICAgIHdpbmRvdy5jaGVja1BhdGgocHApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnNvbGUubG9nKCdyb3V0ZXMnLCB0aGlzLnByb3BzLnJvdXRlcyk7XG4gICAgY29uc3Qge3BhdGhOYW1lLCBibG9ja2VkLCB0b3BOYXZ9ID0gdGhpcy5wcm9wcy5yb3V0ZXM7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICAgIHt0b3BOYXZ9XG4gICAgICAgIHtibG9ja2VkfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChzZWxlY3QpKExheW91dCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvTGF5b3V0LmpzeCIsImltcG9ydCB7Y29tcG9zZSwgY3JlYXRlU3RvcmUsIGFwcGx5TWlkZGxld2FyZSwgY29tYmluZVJlZHVjZXJzfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgbG9nZ2VyIGZyb20gJ3JlZHV4LWxvZ2dlcidcblxuaW1wb3J0IHJlZHVjZXIgZnJvbSAnLi9yZWR1Y2VycydcbmNvbnN0IGNvbXBvc2VkU3RvcmUgPSBjb21wb3NlKGFwcGx5TWlkZGxld2FyZShsb2dnZXIoKSkpO1xuXG5leHBvcnQgZGVmYXVsdCBjb21wb3NlZFN0b3JlKGNyZWF0ZVN0b3JlKShyZWR1Y2VyKVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL3N0b3JlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja0RDRSgpIHtcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICBpZiAoXG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZFxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cbiAgICAvLyBUaGVyZWZvcmUgaWYgdGhlIGJyYW5jaCBpcyBzdGlsbCBoZXJlLCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2Fzbid0XG4gICAgLy8gcHJvcGVybHkgYXBwbGllZC5cbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcbiAgICAvLyB0aGlzIG1lc3NhZ2UgZG9lc24ndCBvY2N1ciBlbHNld2hlcmUgaW4gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYXVzZVxuICAgIC8vIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXG4gICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGNoZWNrRENFKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBXZSBzaG91bGQgc3RpbGwgcmVwb3J0IGluIGNhc2Ugd2UgYnJlYWsgdGhpcyBjb2RlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBEQ0UgY2hlY2sgc2hvdWxkIGhhcHBlbiBiZWZvcmUgUmVhY3RET00gYnVuZGxlIGV4ZWN1dGVzIHNvIHRoYXRcbiAgLy8gRGV2VG9vbHMgY2FuIHJlcG9ydCBiYWQgbWluaWZpY2F0aW9uIGR1cmluZyBpbmplY3Rpb24uXG4gIGNoZWNrRENFKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcycpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHtyYW5kb21GaW5hbmNpYWx9IGZyb20gJ2QzZmMtcmFuZG9tLWRhdGEnO1xuaW1wb3J0IENhbnZhczJEQ29udGV4dCBmcm9tICdDYW52YXMyRENvbnRleHQnXG5cbmNvbnN0IGFyZWFDaGFydENvbmZpZyA9IChkYXRhKSA9PiAoe1xuICBheGlzWDoge1xuICAgIHZhbHVlRm9ybWF0U3RyaW5nOiAnICcsXG4gICAgdGlja0xlbmd0aDogMCxcbiAgICBtYXJnaW46IC0zLFxuICAgIGxpbmVUaGlja25lc3M6IDFcbiAgfSxcbiAgYXhpc1k6IHtcbiAgICB2YWx1ZUZvcm1hdFN0cmluZzogJyAnLFxuICAgIGdyaWRUaGlja25lc3M6IDAuMyxcbiAgICBpbmNsdWRlWmVybzogZmFsc2UsXG4gICAgdGlja0xlbmd0aDogMC41LFxuICAgIG1hcmdpbjogLTUsXG4gICAgZ3JpZENvbG9yOiAnIzIyNDQ1OCcsXG4gICAgbGluZVRoaWNrbmVzczogMVxuICB9LFxuICBpbnRlcmFjdGl2aXR5RW5hYmxlZDogZmFsc2UsXG4gIGJhY2tncm91bmRDb2xvcjogJyMxODI1MmUnLFxuICB3aWR0aDogMTkwLFxuICBoZWlnaHQ6IDE3MCxcbiAgYW5pbWF0aW9uRW5hYmxlZDogZmFsc2UsXG4gIG1hcmtlclR5cGU6ICdub25lJyxcbiAgZGF0YTogZGF0YVxufSlcblxuY29uc3QgZ2VuZXJhdGVEYXRhID0gKHByKSA9PiAoXG4gIHJhbmRvbUZpbmFuY2lhbCgpXG4gIC5zdGFydERhdGUobmV3IERhdGUoKSlcbiAgLnN0YXJ0UHJpY2UocHIpKDMwKVxuICAubWFwKChpdG0sIGkpID0+ICh7eDogaSwgeTogaXRtLmNsb3NlfSkpXG4pO1xuXG5jb25zdCBDYXJkQ3R4ID0gKCkgPT4ge1xuICBsZXQgaW5WaWV3ID0gdHJ1ZTtcbiAgY29uc3QgY2FsbEFsbCA9IFtdO1xuXG4gIGNvbnN0IGNoYXJ0VmlldyA9IHtcbiAgICBzeW1iOiBudWxsLFxuICAgIGNvbmZpZzogbnVsbCxcbiAgICBjaGFydDogbnVsbCxcbiAgICBpaTogMCxcbiAgICBwcmljZVNlZWQ6IG51bGwsXG4gICAgZGF0YTogW1xuICAgICAge1xuICAgICAgICB0eXBlOiAnYXJlYScsXG4gICAgICAgIG1hcmtlclR5cGU6ICdub25lJyxcbiAgICAgICAgZmlsbE9wYWNpdHk6IDAuMyxcbiAgICAgICAgbGluZUNvbG9yOiAnd2hpdGUnLFxuICAgICAgICBjb2xvcjogJyMwMEZGMDAnLFxuICAgICAgICBkYXRhUG9pbnRzOiBbXVxuICAgICAgfVxuICAgIF0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuZGF0YVswXS5kYXRhUG9pbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmRhdGFbMF0uZGF0YVBvaW50cyA9IGdlbmVyYXRlRGF0YSh0aGlzLnByaWNlU2VlZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbmZpZyA9IGFyZWFDaGFydENvbmZpZyh0aGlzLmRhdGEpO1xuICAgICAgdGhpcy5paSA9IDI5O1xuICAgICAgdGhpcy5jaGFydCA9IG5ldyBDYW52YXNKUy5DaGFydCgndGlja0NoYXJ0JywgdGhpcy5jb25maWcpO1xuICAgICAgdGhpcy5jaGFydC5yZW5kZXIoKTtcbiAgICB9LFxuICAgIG5ld1NldDogZnVuY3Rpb24gKHN5bWJvbCwgcHJpY2UpIHtcbiAgICAgIHRoaXMuc3ltYiA9IHN5bWJvbDtcbiAgICAgIHRoaXMucHJpY2VTZWVkID0gcHJpY2U7XG4gICAgICB0aGlzLmRhdGFbMF0uZGF0YVBvaW50cyA9IGdlbmVyYXRlRGF0YSh0aGlzLnByaWNlU2VlZCk7XG4gICAgICB0aGlzLmlpID0gMjk7XG4gICAgICB0aGlzLmNvbmZpZy5kYXRhID0gdGhpcy5kYXRhO1xuICAgICAgdGhpcy5jaGFydC5yZW5kZXIoKTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKG5ld1BudCkge1xuICAgICAgdGhpcy5kYXRhWzBdLmRhdGFQb2ludHMuc2hpZnQoKTtcbiAgICAgIHRoaXMuaWkgKz0gMTtcbiAgICAgIHRoaXMuZGF0YVswXS5kYXRhUG9pbnRzLnB1c2goe3g6IHRoaXMuaWksIHk6IG5ld1BudC5jbG9zZX0pO1xuICAgICAgdGhpcy5jb25maWcuZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIHRoaXMuY2hhcnQucmVuZGVyKCk7XG4gICAgfVxuXG4gIH07XG4gIGNvbnN0IGFza0JpZCA9IHt9XG4gIGNvbnN0IHVwVHJpYW5nbGUgPSAoY3R4LCBwcm5DaG5nKSA9PiB7XG4gICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgLnN0cm9rZVN0eWxlKCcjMDBGRjAwJylcbiAgICAuZmlsbFN0eWxlKCcjMDBGRjAwJylcbiAgICAubW92ZVRvKDEwNSwgMzUpXG4gICAgLmxpbmVUbyg5NywgNDEpXG4gICAgLmxpbmVUbygxMTMsIDQxKVxuICAgIC5saW5lVG8oMTA1LCAzNSlcbiAgICAuc3Ryb2tlKClcbiAgICAuZmlsbCgpXG4gICAgLmZvbnQoJ2JvbGQgMTNweCBBcmlhbCcpXG4gICAgLnRleHRBbGlnbignY2VudGVyJylcbiAgICAuZmlsbFRleHQocHJuQ2huZywgMTA1LCAzMCk7XG4gIH1cbiAgY29uc3QgZG93blRyaWFuZ2xlID0gKGN0eCwgcHJuQ2huZykgPT4ge1xuICAgIGN0eC5iZWdpblBhdGgoKVxuICAgIC5zdHJva2VTdHlsZSgnI0ZGMjUwMCcpXG4gICAgLmZpbGxTdHlsZSgnI0ZGMjUwMCcpXG4gICAgLm1vdmVUbygxMDUsIDQxKVxuICAgIC5saW5lVG8oOTcsIDM1KVxuICAgIC5saW5lVG8oMTEzLCAzNSlcbiAgICAubGluZVRvKDEwNSwgNDEpXG4gICAgLnN0cm9rZSgpXG4gICAgLmZpbGwoKVxuICAgIC5mb250KCdib2xkIDEzcHggQXJpYWwnKVxuICAgIC50ZXh0QWxpZ24oJ2NlbnRlcicpXG4gICAgLmZpbGxUZXh0KHBybkNobmcsIDEwNSwgMzApO1xuICB9XG5cbiAgY29uc3QgcGVyY2VudENoYW5nZSA9IChjdHgsIGxhc3QsIGN1cnJlbnQpID0+IHtcbiAgICBpZiAoY3VycmVudCA+IGxhc3QpIHtcbiAgICAgIHVwVHJpYW5nbGUoY3R4LCAnKycgKyBTdHJpbmcoKChjdXJyZW50IC0gbGFzdCkgLyBsYXN0KSAqIDEwMCkuc2xpY2UoMCwgNCkgKyAnJScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb3duVHJpYW5nbGUoY3R4LCAnLScgKyBTdHJpbmcoKChsYXN0IC0gY3VycmVudCkgLyBsYXN0KSAqIDEwMCkuc2xpY2UoMCwgNCkgKyAnJScpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlbmRlckNoYW5nZSA9IChjdHgsIGxhc3QsIGN1cnJlbnQsIGNhbGwsIHB1dCkgPT4ge1xuICAgIGxldCBkaWZmID0gKGNhbGwgPj0gMTAwIHx8IHB1dCA+PSAxMDApID8gMjAgOiAwO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgMjEwLCA2MClcbiAgICAuZm9udCgnNDVweCBBcmlhbCcpXG4gICAgLnRleHRBbGlnbignZW5kJylcbiAgICAuZmlsbFN0eWxlKCd3aGl0ZScpXG4gICAgLmZpbGxUZXh0KE1hdGguZmxvb3IocHV0KSwgNzUsIDUwKVxuICAgIC50ZXh0QWxpZ24oJ3N0YXJ0JylcbiAgICAuZmlsbFRleHQoTWF0aC5jZWlsKGNhbGwpLCAxMzUsIDUwKVxuICAgIC5mb250KCcxMXB4IEFyaWFsJylcbiAgICAuZmlsbFRleHQoJ0FTSycsICgxNTAgKyBkaWZmKSwgMTApXG4gICAgLnRleHRBbGlnbignZW5kJylcbiAgICAuZmlsbFRleHQoJ0JJRCcsICg2NiAtIGRpZmYpLCAxMCk7XG4gICAgcGVyY2VudENoYW5nZShjdHgsIGxhc3QsIGN1cnJlbnQpO1xuXG4gIH1cbiAgY29uc3Qgc2V0Q2FyZCA9IChjYXJkSWQsIHByaWNlID0gODgsIHN5bWIpID0+IHtcbiAgICBjb25zdCBjID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FyZElkKTtcbiAgICBjb25zdCBjdHggPSBDYW52YXMyRENvbnRleHQoYyk7XG4gICAgbGV0IHBvaW50U3RyZWFtID0gcmFuZG9tRmluYW5jaWFsKCkuc3RhcnREYXRlKG5ldyBEYXRlKCkpLnN0YXJ0UHJpY2UocHJpY2UpLnN0cmVhbSgpO1xuICAgIGxldCBsYXN0ID0gcG9pbnRTdHJlYW0ubmV4dCgpO1xuXG4gICAgY29uc3Qgc3RhcnQgPSAoKSA9PiB7XG4gICAgICBsZXQgY3VycmVudCA9IHBvaW50U3RyZWFtLm5leHQoKTtcblxuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbmRlckNoYW5nZShjdHgsIGxhc3QuY2xvc2UsIGN1cnJlbnQuY2xvc2UsIGN1cnJlbnQuaGlnaCwgY3VycmVudC5sb3cpO1xuICAgICAgICBsYXN0ID0gY3VycmVudDtcbiAgICAgICAgaWYgKGNoYXJ0Vmlldy5zeW1iID09PSBzeW1iICYmIGZhbHNlKSB7XG4gICAgICAgICAgY2hhcnRWaWV3LnVwZGF0ZShjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRMb29wID0gKCkgPT4ge1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShzdGFydCk7XG5cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5WaWV3ID09PSB0cnVlKSB7XG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShzdGFydExvb3ApO1xuICAgICAgICB9XG4gICAgICB9LCAxNTAwKTtcbiAgICB9XG4gICAgY2FsbEFsbC5wdXNoKHN0YXJ0TG9vcC5iaW5kKHRoaXMpKTtcblxuICAgIGNvbnN0IHRoaXNDYXJkID0ge1xuICAgICAgc3RhcnQ6ICgpID0+IHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBwb2ludFN0cmVhbS5uZXh0KCk7XG5cbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVuZGVyQ2hhbmdlKGN0eCwgbGFzdC5jbG9zZSwgY3VycmVudC5jbG9zZSwgY3VycmVudC5oaWdoLCBjdXJyZW50Lmxvdyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNldFRpbWVvdXQoc3RhcnRMb29wLCAxNTAwKTtcblxuICAgICAgfSxcbiAgICAgIHN0YXJ0TG9vcDogc3RhcnRMb29wXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzQ2FyZDtcblxuICB9XG4gIHJldHVybiB7XG4gICAgc2V0Q2FyZDogc2V0Q2FyZCxcbiAgICBjaGFydFZpZXc6IGNoYXJ0VmlldyxcbiAgICBpblZpZXc6ICgpID0+IHtcbiAgICAgIGluVmlldyA9IHRydWU7XG4gICAgICBjYWxsQWxsLmZvckVhY2goKGl0bSkgPT4ge1xuICAgICAgICBsZXQgdE8gPSBNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpICogMTUwMCkgKyAxMClcbiAgICAgICAgc2V0VGltZW91dChpdG0sIHRPKTtcbiAgICAgIH0pO1xuXG4gICAgfSxcbiAgICBnZXRWaWV3OiAoKSA9PiB7XG4gICAgICByZXR1cm4gaW5WaWV3O1xuICAgIH0sXG4gICAgb3V0VmlldzogKCkgPT4ge1xuICAgICAgaW5WaWV3ID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhcmRDdHg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29tcG9uZW50cy9jYW52YXMvY2FyZGN0eC5qcyIsImltcG9ydCBDYW52YXMyRENvbnRleHQgZnJvbSAnQ2FudmFzMkRDb250ZXh0J1xuXG5jb25zdCBjbG9jayA9ICgpID0+IHtcbiAgbGV0IGluVmlldyA9IHRydWU7XG4gIGNvbnN0IGNoZWNrVGltZSA9IChpKSA9PiB7XG4gICAgaWYgKGkgPCAxMCkge1xuICAgICAgaSA9ICcwJyArIGlcbiAgICB9OyAvLyBhZGQgemVybyBpbiBmcm9udCBvZiBudW1iZXJzIDwgMTBcbiAgICByZXR1cm4gaTtcbiAgfVxuXG4gIGNvbnN0IHRpbWVyID0gKGN0eElkKSA9PiB7XG4gICAgY29uc3QgYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGN0eElkKTtcbiAgICBjb25zdCBjdHggPSBDYW52YXMyRENvbnRleHQoYyk7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gKCkgPT4ge1xuICAgICAgaWYgKGluVmlldykge1xuICAgICAgICBsZXQgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBsZXQgaCA9IHRvZGF5LmdldEhvdXJzKCk7XG4gICAgICAgIGxldCBtID0gdG9kYXkuZ2V0TWludXRlcygpO1xuICAgICAgICBsZXQgcyA9IHRvZGF5LmdldFNlY29uZHMoKTtcbiAgICAgICAgbSA9IGNoZWNrVGltZShtKTtcbiAgICAgICAgcyA9IGNoZWNrVGltZShzKTtcblxuICAgICAgICBsZXQgdG0gPSBoICsgJzonICsgbSArICc6JyArIHM7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgNjYsIDIwKS5mb250KCcxNnB4IGJvbGQgc2Fucy1zZXJpZicpLnRleHRBbGlnbignY2VudGVyJykuZmlsbFN0eWxlKCd3aGl0ZScpLmZpbGxUZXh0KHRtLCAzNCwgMTYpO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dChzdGFydFRpbWUsIDUwMCk7XG4gICAgfTtcblxuICAgIHJldHVybiBzdGFydFRpbWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzZXRDbG9jazogdGltZXIsXG4gICAgaW5WaWV3OiAoKSA9PiB7XG4gICAgICBpblZpZXcgPSB0cnVlO1xuXG4gICAgfSxcbiAgICBnZXRWaWV3OiAoKSA9PiB7XG4gICAgICByZXR1cm4gaW5WaWV3O1xuICAgIH0sXG4gICAgb3V0VmlldzogKCkgPT4ge1xuICAgICAgaW5WaWV3ID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvY2soKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9jb21wb25lbnRzL2NhbnZhcy9jbG9jay5qcyIsImNvbnN0IHRyZW5kTGluZUNyZWF0ZSA9IHJlcXVpcmUoJ2NhbnZhcy90cmVuZGxpbmVDVFguanMnKTtcblxuY29uc3QgbGluZURhdGFUcmFuc2Zvcm0gPSAoZGF0YSwgbG4pID0+IGRhdGEubWFwKChpdG0sIGkpID0+IChcbiAge3g6IGl0bS5kYXRhLngsIHk6IGl0bS5kYXRhLnlbM10sIGxpbmVDb2xvcjogaXRtLmxpbmVDb2xvcn1cbikpXG5cbmNvbnN0IG9obGNEYXRhVHJhbnNmb3JtID0gKGRhdGEsIGxuKSA9PiBkYXRhLnNsaWNlKC1sbikubWFwKChpdG0sIGkpID0+IChcbiAge3g6IGl0bS5kYXRhLngsIHk6IGl0bS5kYXRhLnl9XG4pKVxuXG5cbmZ1bmN0aW9uIEN0eENvbnRyb2xsZXIoKSB7XG4gIGxldCBpblZpZXcgPSB0cnVlO1xuICB0aGlzLm91dE9mVmlldyA9ICgpID0+IHtcbiAgICBpblZpZXcgPSBmYWxzZTtcbiAgfTtcbiAgdGhpcy5iYWNrSW5WaWV3ID0gKCkgPT4ge1xuICAgIGluVmlldyA9IHRydWU7XG4gIH07XG5cbiAgY29uc3QgQ3R4Q2hydCA9IChzeW1ibCkgPT4ge1xuICAgIGNvbnN0IGNoYXJ0U2V0dGluZ3MgPSB7XG4gICAgICBjVDogJ2NhbmRsZXN0aWNrJyxcbiAgICAgIHNldFR5cGU6IDAsXG4gICAgICB0eXBlczogWydhcmVhJywgJ2xpbmUnLCAnY2FuZGxlc3RpY2snLCAnb2hsYyddXG4gICAgfVxuICAgIGxldCBkYXRhRnVsbCA9IGZhbHNlO1xuICAgIGxldCBsYXN0WHZhbCA9IG51bGw7XG4gICAgY29uc3QgVHJlbmRMaW5lID0gdHJlbmRMaW5lQ3JlYXRlKHN5bWJsICsgJ190cmVuZCcpO1xuICAgIGNvbnN0IGZ1bGxEYXRhUG9pbnRzID0gW107XG4gICAgY29uc3QgbWFpblN5bWJvbCA9IHN5bWJsO1xuICAgIGNvbnN0IGRhdGFQb2ludHMgPSB7fVxuICAgIGNvbnN0IGFYID0ge1xuICAgICAgbGFiZWxGb250U2l6ZTogMTAsXG4gICAgICBtYXJnaW46IDIwLFxuICAgICAgdmFsdWVGb3JtYXRTdHJpbmc6ICdISDptbTpzcycsXG4gICAgICBsaW5lVGhpY2tuZXNzOiAxXG4gICAgfTtcblxuICAgIGNvbnN0IGFZID0ge1xuICAgICAgbWluaW11bTogOTk5OTksXG4gICAgICBsYWJlbEZvbnRTaXplOiAxNCxcbiAgICAgIGdyaWRUaGlja25lc3M6IDAuNSxcbiAgICAgIGdyaWRDb2xvcjogJyMyMjQ0NTgnLFxuICAgICAgbGluZVRoaWNrbmVzczogMVxuICAgIH1cbiAgICBjb25zdCBzZXRBeE1pbk1heCA9ICh4KSA9PiB7XG4gICAgICBhWC5taW5pbXVtID0geDtcbiAgICAgIGFYLm1heGltdW0gPSBuZXcgRGF0ZSh4LmdldFRpbWUoKSArIGNoYXJ0U2V0dGluZ3Muc2V0QmFjayArIDQwMCk7XG4gICAgfVxuICAgIGNvbnN0IHNldEF4TWluTWF4MiA9IChsZW4pID0+IHtcbiAgICAgIGxldCBkaWZmID0gY2hhcnRTZXR0aW5ncy5kYXRhTGVuZ3RoIC0gbGVuO1xuICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgIGxldCB4ID0gZGF0YVBvaW50c1ttYWluU3ltYm9sXVsxXS54O1xuICAgICAgICBhWC52aWV3cG9ydE1pbmltdW0gPSB4O1xuICAgICAgICBhWC5taW5pbXVtID0geDtcbiAgICAgICAgYVgudmlld3BvcnRNYXhpbXVtID0gbmV3IERhdGUoeC5nZXRUaW1lKCkgKyAoZGlmZiAqIDEwMCkpO1xuICAgICAgICBhWC5tYXhpbXVtID0gYVgudmlld3BvcnRNYXhpbXVtO1xuICAgICAgICBkYXRhRnVsbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gYVgubWF4aW11bSA9IG5ldyBEYXRlKGRhdGFQb2ludHNbbWFpblN5bWJvbF1bMF0ueC5nZXRUaW1lKCkgKyBjaGFydFNldHRpbmdzLnNldEJhY2spO1xuICAgIH1cbiAgICBjb25zdCBjaGFydENvbmZpZ3MgPSB7XG4gICAgICBhcmVhOiAoKSA9PiB7XG4gICAgICAgIGNoYXJ0U2V0dGluZ3Muc2V0VHlwZSA9IDE7XG4gICAgICAgIGNoYXJ0U2V0dGluZ3MuZGF0YUxlbmd0aCA9IDU5NDtcbiAgICAgICAgY2hhcnRTZXR0aW5ncy5zZXRCYWNrID0gMTIwMDAwO1xuICAgICAgICByZXR1cm4ge3R5cGU6ICdhcmVhJywgbWFya2VyU2l6ZTogMCwgY3Vyc29yOiAncG9pbnRlcicsIGF4aXNZVHlwZTogJ3NlY29uZGFyeScsIGZpbGxPcGFjaXR5OiAuM31cbiAgICAgIH0sXG4gICAgICBsaW5lOiAoKSA9PiB7XG4gICAgICAgIGNoYXJ0U2V0dGluZ3Muc2V0VHlwZSA9IDE7XG4gICAgICAgIGNoYXJ0U2V0dGluZ3MuZGF0YUxlbmd0aCA9IDU5NDtcbiAgICAgICAgY2hhcnRTZXR0aW5ncy5zZXRCYWNrID0gMTIwMDAwO1xuICAgICAgICByZXR1cm4ge3R5cGU6ICdsaW5lJywgbWFya2VyU2l6ZTogMCwgY3Vyc29yOiAncG9pbnRlcicsIGF4aXNZVHlwZTogJ3NlY29uZGFyeSd9XG4gICAgICB9LFxuICAgICAgb2hsYzogKCkgPT4ge1xuICAgICAgICBjaGFydFNldHRpbmdzLnNldFR5cGUgPSAwO1xuICAgICAgICBjaGFydFNldHRpbmdzLmRhdGFMZW5ndGggPSAxMzA7XG4gICAgICAgIGNoYXJ0U2V0dGluZ3Muc2V0QmFjayA9IDI3MDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdvaGxjJyxcbiAgICAgICAgICBtYXJrZXJTaXplOiAwLFxuICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgICAgIHJpc2luZ0NvbG9yOiAnIzAwRkYwMCcsXG4gICAgICAgICAgYXhpc1lUeXBlOiAnc2Vjb25kYXJ5J1xuXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYW5kbGVzdGljazogKCkgPT4ge1xuICAgICAgICAvLyAgIGFYLmludGVydmFsID0gMjtcbiAgICAgICAgZGF0YVBvaW50c1ttYWluU3ltYm9sXSA9IFtdXG4gICAgICAgIGNoYXJ0U2V0dGluZ3Muc2V0VHlwZSA9IDA7XG4gICAgICAgIGNoYXJ0U2V0dGluZ3MuZGF0YUxlbmd0aCA9IDEzMDtcbiAgICAgICAgY2hhcnRTZXR0aW5ncy5zZXRCYWNrID0gMjcwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2NhbmRsZXN0aWNrJyxcbiAgICAgICAgICBtYXJrZXJTaXplOiAwLFxuICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgICAgIHJpc2luZ0NvbG9yOiAnIzAwRkYwMCcsXG4gICAgICAgICAgYXhpc1lUeXBlOiAnc2Vjb25kYXJ5J1xuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGNvbnN0IG1ha2VTZXJpZXMgPSAodHlwZSwgc3ltYm9sKSA9PiB7XG4gICAgICBkYXRhUG9pbnRzW3N5bWJvbF0gPSBbXTtcbiAgICAgIGxldCBjaGFydENvbmZpZyA9IGNoYXJ0Q29uZmlnc1t0eXBlXSgpO1xuICAgICAgY2hhcnRDb25maWcuZGF0YVBvaW50cyA9IGRhdGFQb2ludHNbc3ltYm9sXTtcbiAgICAgIHJldHVybiBjaGFydENvbmZpZztcbiAgICB9XG4gICAgY29uc3Qgc2VyaWVzID0gW107XG4gICAgc2VyaWVzLnB1c2gobWFrZVNlcmllcyhjaGFydFNldHRpbmdzLmNULCBtYWluU3ltYm9sKSk7XG5cbiAgICBsZXQgY2hhcnQgPSBuZXcgQ2FudmFzSlMuQ2hhcnQobWFpblN5bWJvbCwge1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgdGV4dDogc3ltYmwsXG4gICAgICAgIGZvbnRDb2xvcjogJyMwMGQ4ZmYnLFxuICAgICAgICBmb250U2l6ZTogMjAsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgICBob3Jpem9udGFsQWxpZ246ICdsZWZ0J1xuICAgICAgfSxcbiAgICAgIHRvb2xUaXA6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgYW5pbWF0aW9uRW5hYmxlZDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBheGlzWDogYVgsXG4gICAgICBheGlzWTI6IGFZLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzE4MjUyZScsXG4gICAgICBkYXRhOiBzZXJpZXNcbiAgICB9KTtcbiAgICBjaGFydC5zZXRUcmVuZExpbmVDQihUcmVuZExpbmUubGluZVNoaWZ0LCBUcmVuZExpbmUuY2FsbFB1dExpbmVzKTtcbiAgICBjaGFydC5yZWN0QnNldENvbG9yID0gJyMwMDAwMDAnO1xuICAgIGNvbnN0IG1vZGlmeVNlcmllcyA9ICh0eXBlKSA9PiB7XG4gICAgICBsZXQgY2hhcnRDb25maWcgPSBjaGFydENvbmZpZ3NbdHlwZV0oKTtcbiAgICAgIGxldCB0eUNoYW5nZSA9IHtcbiAgICAgICAgbGluZTogMSxcbiAgICAgICAgYXJlYTogMSxcbiAgICAgICAgb2hsYzogMCxcbiAgICAgICAgY2FuZGxlc3RpY2s6IDBcbiAgICAgIH1cbiAgICAgIGNoYXJ0U2V0dGluZ3MuY1QgPSB0eXBlO1xuICAgICAgaWYgKHR5Q2hhbmdlW3R5cGVdICE9PSBjaGFydFNldHRpbmdzLnNldFR5cGUpIHtcbiAgICAgICAgaWYgKGNoYXJ0U2V0dGluZ3MuZGF0YUxlbmd0aCA8IGRhdGFQb2ludHNbbWFpblN5bWJvbF0ubGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IHNsaWNlVG8gPSBjaGFydFNldHRpbmdzLmRhdGFMZW5ndGggKiAtMTtcbiAgICAgICAgICBsZXQgYTEgPSBkYXRhUG9pbnRzW21haW5TeW1ib2xdLnNsaWNlKHNsaWNlVG8pO1xuICAgICAgICAgIGRhdGFQb2ludHNbbWFpblN5bWJvbF0gPSBhMTtcbiAgICAgICAgICBjaGFydENvbmZpZy5kYXRhUG9pbnRzID0gYTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBhWC5tYXhpbXVtO1xuICAgICAgZGVsZXRlIGFYLm1pbmltdW07XG4gICAgICBjaGFydENvbmZpZy5kYXRhUG9pbnRzID0gZGF0YVBvaW50c1ttYWluU3ltYm9sXTtcbiAgICAgIHNlcmllc1swXSA9IGNoYXJ0Q29uZmlnO1xuXG4gICAgfVxuXG4gICAgY29uc3QgbGluZUNoYXJ0cyA9IChwb2ludCkgPT4ge1xuICAgICAgbGV0IHhWYWwgPSBuZXcgRGF0ZShsYXN0WHZhbC5nZXRUaW1lKCkgKyAyMDApO1xuICAgICAgbGFzdFh2YWwgPSB4VmFsO1xuICAgICAgbGV0IGxuQ29sb3IgPSBwb2ludC5sYXN0VmFsIDwgcG9pbnQuZGF0YVszXSA/ICcjMTI5NGZmJyA6ICcjZWU1YzVjJztcbiAgICAgIGxldCBkYXRhID0ge1xuICAgICAgICB4OiB4VmFsLFxuICAgICAgICB5OiBwb2ludC5kYXRhWzNdLFxuICAgICAgICBsaW5lQ29sb3I6IGxuQ29sb3JcbiAgICAgIH07XG4gICAgICBhWS5taW5pbXVtID0gYVkubWluaW11bSA+IHBvaW50Lm1pbiA/IE1hdGguZmxvb3IocG9pbnQubWluKSA6IGFZLm1pbmltdW07XG5cbiAgICAgIGlmICghYVgubWF4aW11bSkge1xuICAgICAgICAvLyAgaWYgKGRhdGFQb2ludHNbcG9pbnQuc3ltYl0ubGVuZ3RoID09PSAwKXtcbiAgICAgICAgc2V0QXhNaW5NYXgoeFZhbClcbiAgICAgICAgLy8gfWVsc2V7XG4gICAgICAgIC8vc2V0QXhNaW5NYXgoZGF0YVBvaW50c1twb2ludC5zeW1iXVsxXS54LCBmYWxzZSlcbiAgICAgICAgc2V0QXhNaW5NYXgoeFZhbClcbiAgICAgICAgLy99XG4gICAgICB9XG4gICAgICBkYXRhUG9pbnRzW3BvaW50LnN5bWJdLnB1c2goZGF0YSk7XG5cbiAgICAgIGlmIChkYXRhUG9pbnRzW3BvaW50LnN5bWJdLmxlbmd0aCA+IGNoYXJ0U2V0dGluZ3MuZGF0YUxlbmd0aCkge1xuXG4gICAgICAgIGFYLm1heGltdW0gPSBuZXcgRGF0ZSh4VmFsLmdldFRpbWUoKSArIDEyMDApO1xuICAgICAgICBkYXRhRnVsbCA9IHRydWU7XG5cbiAgICAgICAgZGF0YVBvaW50c1twb2ludC5zeW1iXS5zaGlmdCgpO1xuICAgICAgICAvL2Z1bGxEYXRhUG9pbnRzLnNoaWZ0KCk7XG5cbiAgICAgICAgYVgubWluaW11bSA9IGRhdGFQb2ludHNbcG9pbnQuc3ltYl1bMF0ueFxuICAgICAgfVxuICAgICAgaWYgKGluVmlldykge1xuICAgICAgICBjaGFydC5yZW5kZXIoKTtcblxuICAgICAgICAvLyAgVHJlbmRMaW5lKGNoYXJ0LmdldExhc3RYWSgpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9obGNDaGFydHMgPSAocG9pbnQpID0+IHtcbiAgICAgIGxldCB4VmFsID0gbmV3IERhdGUobGFzdFh2YWwuZ2V0VGltZSgpICsgMjAwKTtcbiAgICAgIGxhc3RYdmFsID0geFZhbDtcbiAgICAgIGxldCBkYXRhID0ge1xuICAgICAgICB4OiB4VmFsLFxuICAgICAgICB5OiBwb2ludC5kYXRhXG4gICAgICB9O1xuICAgICAgYVkubWluaW11bSA9IGFZLm1pbmltdW0gPiBwb2ludC5taW4gPyBNYXRoLmZsb29yKChwb2ludC5taW4gKiAwLjk3NSkpIDogYVkubWluaW11bTtcblxuICAgICAgaWYgKCFhWC5tYXhpbXVtKSB7XG4gICAgICAgIGlmIChkYXRhUG9pbnRzW3BvaW50LnN5bWJdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzZXRBeE1pbk1heCh4VmFsKVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0QXhNaW5NYXgoeFZhbClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGF0YVBvaW50c1twb2ludC5zeW1iXS5wdXNoKGRhdGEpO1xuICAgICAgLy8gZnVsbERhdGFQb2ludHMucHVzaCh7ZGF0YTpkYXRhLCBsaW5lQ29sb3I6IHBvaW50Lmxhc3RWYWwgPCBwb2ludC5kYXRhWzNdID8gJyMxMjk0ZmYnIDogJyNlZTVjNWMnfSk7XG4gICAgICBpZiAoZGF0YVBvaW50c1twb2ludC5zeW1iXS5sZW5ndGggPiBjaGFydFNldHRpbmdzLmRhdGFMZW5ndGgpIHtcbiAgICAgICAgYVgubWF4aW11bSA9IG5ldyBEYXRlKHhWYWwuZ2V0VGltZSgpICsgMTIwMCk7XG4gICAgICAgIGRhdGFGdWxsID0gdHJ1ZTtcblxuICAgICAgICBkYXRhUG9pbnRzW3BvaW50LnN5bWJdLnNoaWZ0KCk7XG4gICAgICAgIC8vIGZ1bGxEYXRhUG9pbnRzLnNoaWZ0KCk7XG4gICAgICAgIGFYLm1pbmltdW0gPSBkYXRhUG9pbnRzW3BvaW50LnN5bWJdWzBdLng7XG5cbiAgICAgIH1cbiAgICAgIGlmIChpblZpZXcpIHtcbiAgICAgICAgY2hhcnQucmVuZGVyKCk7XG5cbiAgICAgICAgLy8gVHJlbmRMaW5lKGNoYXJ0LmdldExhc3RYWSgpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCBsYXN0UG9pbnQgPSBudWxsO1xuXG4gICAgcmV0dXJuIHtcblxuICAgICAgZGF0YVN0cmVhbTogKHBvaW50KSA9PiB7XG4gICAgICAgIGxhc3RQb2ludCA9IHBvaW50O1xuICAgICAgICBpZiAocG9pbnQuZGF0YVsyXSA8IDEpIHtcbiAgICAgICAgICBwb2ludC5kYXRhWzBdICo9IDEwMDA7XG4gICAgICAgICAgcG9pbnQuZGF0YVsxXSAqPSAxMDAwO1xuICAgICAgICAgIHBvaW50LmRhdGFbMl0gKj0gMTAwMDtcbiAgICAgICAgICBwb2ludC5kYXRhWzNdICo9IDEwMDA7XG4gICAgICAgICAgcG9pbnQubWluICo9IDEwMDA7XG4gICAgICAgICAgcG9pbnQubGFzdFZhbCAqPSAxMDAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsYXN0WHZhbCkge1xuICAgICAgICAgIGxhc3RYdmFsID0gbmV3IERhdGUobmV3IERhdGUoKS5nZXRUaW1lKCkgLSAyMDApO1xuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJ0U2V0dGluZ3MuY1QgPT09ICdhcmVhJyB8fCBjaGFydFNldHRpbmdzLmNUID09PSAnbGluZScpIHtcbiAgICAgICAgICBsaW5lQ2hhcnRzKHBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhcnRTZXR0aW5ncy5jVCA9PT0gJ2NhbmRsZXN0aWNrJyB8fCBjaGFydFNldHRpbmdzLmNUID09PSAnb2hsYycpIHtcbiAgICAgICAgICBvaGxjQ2hhcnRzKHBvaW50KTtcbiAgICAgICAgfVxuXG4gICAgICB9LFxuICAgICAgY2hhbmdlUmVjdENvbG9yOiAoY29sb3IpID0+IHtcblxuICAgICAgICBjaGFydC5yZWN0QnNldENvbG9yID0gY29sb3I7XG4gICAgICB9LFxuICAgICAgdXNlU29saWRzOiAoKSA9PiB7XG4gICAgICAgIGNoYXJ0LnJlY3RCc2V0ID0gZmFsc2U7XG4gICAgICB9LFxuICAgICAgYWRkU2VyaWVzOiAoc3ltKSA9PiB7XG4gICAgICAgIHNlcmllcy5wdXNoKG1ha2VTZXJpZXMoJ2xpbmUnLCBzeW0pKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3NlcmllcycsIHNlcmllcyk7XG4gICAgICB9LFxuICAgICAgZ2V0TGF0ZXN0UG9pbnQ6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGxhc3RQb2ludDtcbiAgICAgIH0sXG4gICAgICBhZGROZXdQb3M6IChwb3MpID0+IHtcbiAgICAgICAgVHJlbmRMaW5lLm5ld1Bvcyhwb3MpO1xuICAgICAgfSxcbiAgICAgIGdldFRyZW5kTGluZUNudHJsOiAoKSA9PiB7fSxcbiAgICAgIHBvc0V4cGlyZWQ6IChwb3MpID0+IHtcbiAgICAgICAgVHJlbmRMaW5lLnBvc0V4cGlyZWQocG9zLnRpbWVzdGFtcCk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlU2VyaWVzOiAoc3ltKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdyZW1vdmVTZXJpZXMnKVxuICAgICAgfSxcbiAgICAgIGdldENoYXJ0VHlwZTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gY2hhcnRTZXR0aW5ncy5jVDtcbiAgICAgIH0sXG4gICAgICBjaGFydFR5cGU6ICh0eXBlKSA9PiB7XG5cbiAgICAgICAgY2hhcnRTZXR0aW5ncy5jVCA9IHR5cGU7XG4gICAgICAgIG1vZGlmeVNlcmllcyh0eXBlKTtcbiAgICAgIH0sXG4gICAgICBjaGFuZ2VEYXRhTGVuZ3RoOiAobGVuKSA9PiB7XG4gICAgICAgIGRhdGFMZW5ndGggPSBsZW4gPiAxNTAgPyBsZW4gOiAxNTA7XG4gICAgICB9LFxuICAgICAgc2h1dGRvd246ICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ3RoZSBjb21wb25lbnQgdW5tb3VudGVkJyk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuICB0aGlzLnBhc3NDVFhjb25zdHJ1Y3RvciA9ICgpID0+IHtcbiAgICByZXR1cm4gQ3R4Q2hydDtcbiAgfVxufVxuXG5jb25zdCBDdHhDaGFydCA9IG5ldyBDdHhDb250cm9sbGVyKCk7XG5cbmV4cG9ydCBkZWZhdWx0IEN0eENoYXJ0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL2NvbXBvbmVudHMvY2FudmFzL2N0eENoYXJ0LmpzIiwiY29uc3QgbWFrZUdyYXBoID0gKGNoYXJ0SWQsIGRhdGEsIHRpdGxlKSA9PiB7XG4gIGNvbnN0IHRoZURhdGEgPSB7XG4gICAgZGF0YToge1xuICAgICAgdHlwZTogJ2RvdWdobnV0JyxcbiAgICAgIGRhdGFQb2ludHM6IGRhdGFcbiAgICB9LFxuXG4gICAgdGl0bGU6ICdUb3AgVS5TIFNtYXJ0cGhvbmUgT3BlcmF0aW5nIFN5c3RlbXMgQnkgTWFya2V0IFNoYXJlLCBRMyAyMDEyJ1xuICB9XG4gIGNvbnN0IGNoYXJ0ID0gbmV3IENhbnZhc0pTLkNoYXJ0KGNoYXJ0SWQsIHtcbiAgICBoZWlnaHQ6IDgwLFxuICAgIGFuaW1hdGlvbkVuYWJsZWQ6IHRydWUsXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDEzMDAsXG4gICAgZGF0YTogW3RoZURhdGEuZGF0YV1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyQ2hhcnQ6ICgpID0+IHtcbiAgICAgIGNoYXJ0LnJlbmRlcigpO1xuICAgIH0sXG4gICAgbmV3RGF0YTogKGRhdGEpID0+IHtcbiAgICAgIGNoYXJ0LnJlbmRlcigpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5leHBvcnQgZGVmYXVsdCBtYWtlR3JhcGg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29tcG9uZW50cy9jYW52YXMvY3R4Z3JhcGhzLmpzIiwiaW1wb3J0IENhbnZhczJEQ29udGV4dCBmcm9tICdDYW52YXMyRENvbnRleHQnXG5cbmNvbnN0IHRvdGFsQW1vdW50Q3R4ID0gKGNhc2gpID0+IHtcbiAgY29uc3Qgc3RhcnRBbXQgPSAnJCcgKyBjYXNoO1xuICBjb25zdCBjID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RvdGFsQWNjb3VudCcpO1xuICBjb25zdCBjdHggPSBDYW52YXMyRENvbnRleHQoYyk7XG4gIGN0eC5mb250KCcyM3B4IHNhbnMtc2VyaWYnKS50ZXh0QWxpZ24oJ2VuZCcpLmZpbGxTdHlsZSgnIzMwZDk0YycpLmZpbGxUZXh0KHN0YXJ0QW10LCA5OCwgMjgpO1xuICBjb25zdCBjdHhGaWxsID0gKGFtdCwgaWksIHVuaXQpID0+IHtcbiAgICBsZXQgdE8gPSBpaSAqIHVuaXQ7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCAxMDAsIDQwKS5maWxsU3R5bGUoYW10LmNvbG9yKS5maWxsVGV4dChhbXQudGV4dCwgOTgsIDI4KTtcbiAgICAgIH0pO1xuICAgIH0sIHRPKTtcbiAgfTtcbiAgY29uc3Qgc2hvd0RpZmYgPSAob2dWYWx1ZSwgbmV3VmFsdWUpID0+IHtcbiAgICBsZXQgdmFsdWVzID0gW107XG4gICAgbGV0IG9nQ1BZID0gb2dWYWx1ZTtcbiAgICBsZXQgdW5pdCA9IE1hdGguY2VpbCgoMSAvIE1hdGguYWJzKG9nVmFsdWUgLSBuZXdWYWx1ZSkpICogMTAwMCk7XG4gICAgbGV0IG5ld1ZsID0gTWF0aC5mbG9vcihuZXdWYWx1ZSk7XG4gICAgaWYgKG9nVmFsdWUgPiBuZXdWYWx1ZSkge1xuICAgICAgd2hpbGUgKG9nQ1BZID4gbmV3VmwpIHtcbiAgICAgICAgb2dDUFkgLT0gMTtcbiAgICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICAgIHRleHQ6ICckJyArIG9nQ1BZLFxuICAgICAgICAgIGNvbG9yOiBvZ0NQWSA+IDAgPyAnIzMwZDk0YycgOiAncmVkJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKG9nQ1BZIDwgbmV3VmwpIHtcbiAgICAgICAgb2dDUFkgKz0gMTtcblxuICAgICAgICB2YWx1ZXMucHVzaCh7XG4gICAgICAgICAgdGV4dDogJyQnICsgb2dDUFksXG4gICAgICAgICAgY29sb3I6IG9nQ1BZID4gMCA/ICcjMzBkOTRjJyA6ICdyZWQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZXMuZm9yRWFjaCgoaXRtLCBpKSA9PiB7XG4gICAgICBjdHhGaWxsKGl0bSwgaSwgdW5pdCk7XG4gICAgfSk7XG5cbiAgfTtcblxuICB3aW5kb3cuc2hvd0RpZmYgPSBzaG93RGlmZjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHRvdGFsQW1vdW50Q3R4O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL2NvbXBvbmVudHMvY2FudmFzL2RlcG9zaXRhbXQuanMiLCJpbXBvcnQgQ2FudmFzMkRDb250ZXh0IGZyb20gJ0NhbnZhczJEQ29udGV4dCdcblxuY29uc3QgQ3VycmVudFBvc2l0aW9ucyA9ICgpID0+IHtcbiAgbGV0IGluVmlldyA9IHRydWU7XG4gIGNvbnN0IHVwVHJpYW5nbGUgPSAoY3R4KSA9PiB7XG4gICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAuc3Ryb2tlU3R5bGUoJyMwMEZGMDAnKVxuICAgICAgLmZpbGxTdHlsZSgnIzAwRkYwMCcpXG4gICAgICAubW92ZVRvKDUsIDEyKVxuICAgICAgLmxpbmVUbygwLCAxOClcbiAgICAgIC5saW5lVG8oMTAsIDE4KVxuICAgICAgLmxpbmVUbyg1LCAxMilcbiAgICAgIC5zdHJva2UoKVxuICAgICAgLmZpbGwoKTtcbiAgfVxuXG4gIGNvbnN0IGRvd25UcmlhbmdsZSA9IChjdHgpID0+IHtcbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICAgIC5zdHJva2VTdHlsZSgnI0ZGMjUwMCcpXG4gICAgICAuZmlsbFN0eWxlKCcjRkYyNTAwJylcbiAgICAgIC5tb3ZlVG8oNSwgMTgpXG4gICAgICAubGluZVRvKDAsIDEyKVxuICAgICAgLmxpbmVUbygxMCwgMTIpXG4gICAgICAubGluZVRvKDUsIDE4KVxuICAgICAgLnN0cm9rZSgpXG4gICAgICAuZmlsbCgpO1xuICB9XG4gIGNvbnN0IHBlcmNlbnRDaG5nZSA9IChsYXN0LCBjdXJyZW50KSA9PiB7XG4gICAgbGV0IHNpZ24gPSAoY3VycmVudCA+IGxhc3QpID8gJysnIDogJy0nO1xuICAgIHJldHVybiBbXG4gICAgICAoY3VycmVudCA+IGxhc3QpLFxuICAgICAgc2lnbiArIFN0cmluZyhNYXRoLmFicygoY3VycmVudCAtIGxhc3QpIC8gbGFzdCkgKiAxMDApLnNsaWNlKDAsIDQpICsgJyUnXG4gICAgXTtcbiAgfVxuXG4gIGNvbnN0IGdldFRpbWVMZWZ0ID0gKGQpID0+IGQgPCAwID8gJ0VuZGVkJyA6IHBhcnNlSW50KGQgLyA2MCwgMTApICsgJzonICsgKCcwJyArIHBhcnNlSW50KGQgJSA2MCwgMTApKS5zbGljZSgtMik7XG5cbiAgY29uc3QgcmVuZGVyQXJyb3cgPSAodXBBcnJvdywgY3R4KSA9PiB1cEFycm93ID09PSB0cnVlID8gdXBUcmlhbmdsZShjdHgpIDogZG93blRyaWFuZ2xlKGN0eCk7XG4gIGZ1bmN0aW9uIHN0YXJ0VGltZXIoZHVyYXRpb24sIGN0eCwgcHJjLCBjdXJyZW50KSB7XG4gICAgY29uc3QgY2hhbmdlID0gcGVyY2VudENobmdlKHByYywgY3VycmVudCk7XG4gICAgY29uc3QgdGltZUxlZnQgPSBnZXRUaW1lTGVmdChkdXJhdGlvbilcblxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgMTAwLCAzMClcbiAgICAgIC50ZXh0QWxpZ24oJ2VuZCcpXG4gICAgICAuZm9udCgnMTVweCBBcmlhbCcpXG4gICAgICAuc3Ryb2tlU3R5bGUoJ3doaXRlJylcbiAgICAgIC5maWxsU3R5bGUoJ3doaXRlJylcbiAgICAgIC5maWxsVGV4dCh0aW1lTGVmdCwgOTgsIDIwKVxuICAgICAgLnRleHRBbGlnbignc3RhcnQnKVxuICAgICAgLmZvbnQoJzEycHggQXJpYWwnKVxuICAgICAgLmZpbGxUZXh0KGNoYW5nZVsxXSwgMTUsIDIwKTtcblxuICAgICAgcmVuZGVyQXJyb3coY2hhbmdlWzBdLCBjdHgpO1xuICB9XG5cbiAgZnVuY3Rpb24gUG9zdGlvblRpbGUocG9zaXRpb24sIGN0eElkKSB7XG4gICAgY29uc3QgYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGN0eElkKTtcbiAgICBjb25zdCBjdHggPSBDYW52YXMyRENvbnRleHQoYyk7XG5cbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgdGhpcy5leHBpcmVUaW1lID0gcG9zaXRpb24udGltZXN0YW1wLmdldFRpbWUoKTtcbiAgICB0aGlzLnNldFRpbWVyID0gKCkgPT4ge1xuICAgICAgbGV0IG5vd1RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIGlmIChpblZpZXcpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLnBvc2l0aW9uLmdldExhdGVzdFBvaW50KCk7XG5cbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgc3RhcnRUaW1lcigoKHRoaXMuZXhwaXJlVGltZSAtIG5vd1RpbWUpIC8gMTAwMCksIGN0eCwgdGhpcy5wb3NpdGlvbi51bml0UHJpY2UsIGN1cnJlbnQuZGF0YVszXSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmV4cGlyZVRpbWUgPiBub3dUaW1lKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZXRUaW1lcigpLCAxMDAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZXRUaW1lcigpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2V0VGlsZTogKHBvc2l0aW9uLCBjdHhJZCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQb3N0aW9uVGlsZShwb3NpdGlvbiwgY3R4SWQpO1xuICAgIH0sXG4gICAgaW5WaWV3OiAoKSA9PiB7XG4gICAgICBpblZpZXcgPSB0cnVlO1xuICAgIH0sXG4gICAgZ2V0VmlldzogKCkgPT4ge1xuICAgICAgcmV0dXJuIGluVmlldztcbiAgICB9LFxuICAgIG91dFZpZXc6ICgpID0+IHtcbiAgICAgIGluVmlldyA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBQb3NpdGlvblRpbGVzID0gQ3VycmVudFBvc2l0aW9ucygpO1xuXG5leHBvcnQgZGVmYXVsdCBQb3NpdGlvblRpbGVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL2NvbXBvbmVudHMvY2FudmFzL3Bvc2l0aW9uVGlsZS5qcyIsImltcG9ydCB7cmFuZG9tRmluYW5jaWFsfSBmcm9tICdkM2ZjLXJhbmRvbS1kYXRhJztcbmltcG9ydCBDYW52YXMyRENvbnRleHQgZnJvbSAnQ2FudmFzMkRDb250ZXh0J1xuXG5jb25zdCBzZWVkcyA9IFtcbiAge1xuICAgIHN5bWI6ICdBVUQvSlBZJyxcbiAgICBwcmM6IDc5LjAxM1xuICB9LCB7XG4gICAgc3ltYjogJ0FVRC9VU0QnLFxuICAgIHByYzogMC43NTg4XG4gIH0sIHtcbiAgICBzeW1iOiAnQ0FEL0NIRicsXG4gICAgcHJjOiAwLjc1MTRcbiAgfSwge1xuICAgIHN5bWI6ICdDQUQvSlBZJyxcbiAgICBwcmM6IDgwLjc1N1xuICB9LCB7XG4gICAgc3ltYjogJ0NIRi9KUFknLFxuICAgIHByYzogMTA3LjM0MlxuICB9LCB7XG4gICAgc3ltYjogJ0VVUi9BVUQnLFxuICAgIHByYzogMS40Njk0XG4gIH0sIHtcbiAgICBzeW1iOiAnRVVSL0NBRCcsXG4gICAgcHJjOiAxLjQ0MDY1XG4gIH0sIHtcbiAgICBzeW1iOiAnRVVSL0dCUCcsXG4gICAgcHJjOiAwLjgzNjhcbiAgfSwge1xuICAgIHN5bWI6ICdFVVIvSlBZJyxcbiAgICBwcmM6IDExMi44OVxuICB9LCB7XG4gICAgc3ltYjogJ0VVUi9OT0snLFxuICAgIHByYzogOS4zNzg2N1xuICB9LCB7XG4gICAgc3ltYjogJ0VVUi9TRUsnLFxuICAgIHByYzogOS40OTE2NVxuICB9LCB7XG4gICAgc3ltYjogJ0VVUi9VU0QnLFxuICAgIHByYzogMS4xMTUxXG4gIH0sIHtcbiAgICBzeW1iOiAnR0JQL0FVRCcsXG4gICAgcHJjOiAxLjg1MzAzXG4gIH0sIHtcbiAgICBzeW1iOiAnR0JQL0NIRicsXG4gICAgcHJjOiAxLjI5MjdcbiAgfSwge1xuICAgIHN5bWI6ICdHQlAvSlBZJyxcbiAgICBwcmM6IDEzOC45MjFcbiAgfSwge1xuICAgIHN5bWI6ICdHQlAvVVNEJyxcbiAgICBwcmM6IDEuMzMyNVxuICB9LCB7XG4gICAgc3ltYjogJ1VTRC9CUkwnLFxuICAgIHByYzogMy44NTM5N1xuICB9LCB7XG4gICAgc3ltYjogJ1VTRC9DQUQnLFxuICAgIHByYzogMS4zMTI1MlxuICB9LCB7XG4gICAgc3ltYjogJ1VTRC9DSEYnLFxuICAgIHByYzogMC45ODY2OVxuICB9LCB7XG4gICAgc3ltYjogJ1VTRC9DTlknLFxuICAgIHByYzogNi42NzU4XG4gIH0sIHtcbiAgICBzeW1iOiAnVVNEL0NaSycsXG4gICAgcHJjOiAyNC42MDg5XG4gIH0sIHtcbiAgICBzeW1iOiAnVVNEL0hLRCcsXG4gICAgcHJjOiA3Ljc1NjZcbiAgfSwge1xuICAgIHN5bWI6ICdVU0QvSU5SJyxcbiAgICBwcmM6IDY3LjA5NThcbiAgfSwge1xuICAgIHN5bWI6ICdVU0QvSlBZJyxcbiAgICBwcmM6IDEwMS4yNFxuICB9LCB7XG4gICAgc3ltYjogJ1VTRC9NWE4nLFxuICAgIHByYzogMTguNTM4OFxuICB9LCB7XG4gICAgc3ltYjogJ1VTRC9OT0snLFxuICAgIHByYzogOC41NDE5MlxuICB9LCB7XG4gICAgc3ltYjogJ1VTRC9QTE4nLFxuICAgIHByYzogMy45NzQyXG4gIH0sIHtcbiAgICBzeW1iOiAnVVNEL1JVQicsXG4gICAgcHJjOiA2NC43NDVcbiAgfSwge1xuICAgIHN5bWI6ICdVU0QvU0VLJyxcbiAgICBwcmM6IDguNjQ2NTdcbiAgfSwge1xuICAgIHN5bWI6ICdVU0QvU0dEJyxcbiAgICBwcmM6IDEuMzU3OVxuICB9XG5dO1xuXG5jb25zdCBwZXJjZW50Q2hhbmdlID0gKGxhc3QsIGN1cnJlbnQpID0+IHtcbiAgaWYgKGN1cnJlbnQgPiBsYXN0KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICcjMzBiOTExJywgJysnICsgU3RyaW5nKCgoY3VycmVudCAtIGxhc3QpIC8gbGFzdCkgKiAxMDApLnNsaWNlKDAsIDQpICsgJyUnXG4gICAgXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW1xuICAgICAgJyNEQzE0M0MnLCAnLScgKyBTdHJpbmcoKChsYXN0IC0gY3VycmVudCkgLyBsYXN0KSAqIDEwMCkuc2xpY2UoMCwgNCkgKyAnJSdcbiAgICBdXG4gIH1cbn1cbmNvbnN0IHNwcmVhZENUWCA9ICgpID0+IHtcbiAgY29uc3QgYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhY3RpdmVTcHJlYWRzJyk7XG4gIGNvbnN0IGN0eCA9IENhbnZhczJEQ29udGV4dChjKTtcbiAgY29uc3QgVGlja2VycyA9IHtcbiAgICBhY3RpdmVTeW1ib2xzOiBbXSxcbiAgICBoYXNSZW5kZXJlZDogZmFsc2VcbiAgfTtcbiAgbGV0IGluVmlldyA9IGZhbHNlO1xuICBsZXQgY3R4SGVpZ2h0ID0gNDAwO1xuICBsZXQgY2FuUmVuZGVyID0gdHJ1ZTtcbiAgbGV0IHR5cGVTZXR0aW5nID0gJ3NwcmVhZHMnO1xuICBjb25zdCBjdXJyZW50VGlja3MgPSBbXTtcbiAgY29uc3QgdHdvRGVjID0gKHZhbCkgPT4gTWF0aC5yb3VuZCh2YWwgKiAxMDApIC8gMTAwO1xuXG4gIGNvbnN0IHJlbmRlclJvdyA9IChhdFBvcywgc3ltYiwgYXNrLCBiaWQsIGxhc3QsIGN1cnJlbnQpID0+IHtcbiAgICBsZXQgdGV4dFBvcyA9IGF0UG9zICsgMTU7XG4gICAgbGV0IGNvbG9yTnBlcmNlbnQgPSBwZXJjZW50Q2hhbmdlKGxhc3QsIGN1cnJlbnQpO1xuXG4gICAgY3R4LmNsZWFyUmVjdCgwLCBhdFBvcywgMjAwLCAyMClcbiAgICAgIC5mb250KCcxM3B4IEFyaWFsJylcbiAgICAgIC5maWxsU3R5bGUoJ2JsYWNrJylcbiAgICAgIC5maWxsUmVjdCgwLCBhdFBvcywgMjAwLCAyMClcbiAgICAgIC5maWxsU3R5bGUoJ3NpbHZlcicpXG4gICAgICAuZmlsbFJlY3QoMCwgYXRQb3MgKyAxOSwgMjAwLCAxKVxuICAgICAgLnRleHRBbGlnbignc3RhcnQnKVxuICAgICAgLmZpbGxTdHlsZSgnIzAwZDhmZicpXG4gICAgICAuZmlsbFRleHQoc3ltYiwgMiwgdGV4dFBvcylcbiAgICAgIC50ZXh0QWxpZ24oJ2VuZCcpXG4gICAgICAuZmlsbFN0eWxlKGNvbG9yTnBlcmNlbnRbMF0pXG4gICAgICAuZmlsbFRleHQoY29sb3JOcGVyY2VudFsxXSwgMTk4LCB0ZXh0UG9zKVxuICAgICAgLmZpbGxTdHlsZSgnd2hpdGUnKVxuICAgICAgLmZvbnQoJzEycHggQXJpYWwnKVxuICAgICAgLmZpbGxUZXh0KFN0cmluZyhiaWQpLCAxNDgsIHRleHRQb3MgLSAxKVxuICAgICAgLnRleHRBbGlnbignc3RhcnQnKVxuICAgICAgLmZpbGxUZXh0KFN0cmluZyhhc2spLCA3MCwgdGV4dFBvcyAtIDEpO1xuICB9XG5cbiAgVGlja2Vycy5yZW5kZXJMaXZlID0gKCkgPT4ge1xuICAgIFRpY2tlcnMuYWN0aXZlU3ltYm9scy5mb3JFYWNoKChzeW1JdG0pID0+IHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBUaWNrZXJzW3N5bUl0bS5zXS5jYWxsUm91bmQoKTtcbiAgICAgIH0sIHN5bUl0bS5kKTtcbiAgICB9KTtcbiAgfVxuXG4gIFRpY2tlcnMucmVuZGVyU3ByZWFkID0gKCkgPT4ge1xuICAgIGNhblJlbmRlciA9IGZhbHNlO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgMjAwLCA2NTApO1xuICAgIGN1cnJlbnRUaWNrcy5mb3JFYWNoKChpdG0sIGluZGV4KSA9PiB7XG4gICAgICBsZXQgYXRQb3MgPSAoMjAgKiBpbmRleCkgKyAxO1xuICAgICAgcmVuZGVyUm93KGF0UG9zLCBpdG0uc3ltYiwgaXRtLmFzaywgaXRtLmJpZCwgaXRtLmxhc3QsIGl0bS5jbG9zZSk7XG4gICAgfSlcbiAgICBUaWNrZXJzLmhhc1JlbmRlcmVkID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhblJlbmRlciA9IHRydWU7XG4gICAgICBUaWNrZXJzLnJlbmRlckxpdmUoKTtcbiAgICB9LCAxMDApO1xuXG4gIH1cbiAgVGlja2Vycy5yZW5kZXJVbml0ID0gKHRvcFBvcywgdXRUaWNrKSA9PiB7XG4gICAgaWYgKGNhblJlbmRlcikge1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbmRlclJvdyh0b3BQb3MsIHV0VGljay5zeW1iLCB1dFRpY2suYXNrLCB1dFRpY2suYmlkLCB1dFRpY2subGFzdCwgdXRUaWNrLmNsb3NlKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5ld1RpY2tlciA9IChzeW1iLCBwcmljZSwgcmVuZGVyRGVsYXkpID0+IHtcbiAgICBjdXJyZW50VGlja3MucHVzaCh7c3ltYm9sOiBzeW1ifSk7XG4gICAgbGV0IGF0RGV4ID0gY3VycmVudFRpY2tzLmxlbmd0aCAtIDE7XG4gICAgbGV0IHRpY2tTeW1iID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBjdXJyZW50UG9pbnQ6IG51bGwsXG4gICAgICBsYXN0UG9pbnQ6IG51bGwsXG4gICAgICBjaGFuZ2U6IDAuMCxcbiAgICAgIHN5bWJvbDogc3ltYixcbiAgICAgIGF0UG9zOiAoMjAgKiBhdERleCkgKyAxLFxuICAgICAgdGlja0luZGV4OiBhdERleCxcbiAgICAgIHN0YXJ0UHJpY2U6IHByaWNlXG4gICAgfTtcblxuICAgIHRpY2tTeW1iLmxvZ0RhdGEgPSAocHIpID0+IHtcbiAgICAgIGxldCBzeW1ib2wgPSBzeW1iO1xuICAgICAgbGV0IHRoaXNJbmRleCA9IHRpY2tTeW1iLnRpY2tJbmRleDtcbiAgICAgIHRpY2tTeW1iLmdlbmVyYXRvciA9IHJhbmRvbUZpbmFuY2lhbCgpLnN0YXJ0RGF0ZShuZXcgRGF0ZSgpKS5zdGFydFByaWNlKHByKVxuICAgICAgdGlja1N5bWIuc3RyZWFtID0gdGlja1N5bWIuZ2VuZXJhdG9yLnN0cmVhbSgpO1xuICAgICAgbGV0IHAxcyA9IHRpY2tTeW1iLnN0cmVhbS5uZXh0KCk7XG4gICAgICBsZXQgcDJzID0gdGlja1N5bWIuc3RyZWFtLm5leHQoKTtcbiAgICAgIGxldCBsYXN0cG9pbnQgPSB7XG4gICAgICAgIHN5bWI6IHRpY2tTeW1iLnN5bWJvbCxcbiAgICAgICAgbGFzdDogMCxcbiAgICAgICAgY2xvc2U6IHR3b0RlYyhwMnMuY2xvc2UpLFxuICAgICAgICBhc2s6IHR3b0RlYyhwMnMuaGlnaCksXG4gICAgICAgIGJpZDogdHdvRGVjKHAycy5sb3cpLFxuICAgICAgICBhc2tWb2w6IHAycy52b2x1bWUsXG4gICAgICAgIGJpZFZvbDogTWF0aC5jZWlsKHAycy52b2x1bWUgKiAoTWF0aC5yYW5kb20oKSArIDAuNikpXG4gICAgICB9XG4gICAgICBsZXQgc3RhcnRwb2ludCA9IHtcbiAgICAgICAgc3ltYjogdGlja1N5bWIuc3ltYm9sLFxuICAgICAgICBsYXN0OiB0d29EZWMocDJzLmNsb3NlKSxcbiAgICAgICAgY2xvc2U6IHR3b0RlYyhwMXMuY2xvc2UpLFxuICAgICAgICBhc2s6IHR3b0RlYyhwMXMuaGlnaCksXG4gICAgICAgIGJpZDogdHdvRGVjKHAxcy5sb3cpLFxuICAgICAgICBhc2tWb2w6IHAxcy52b2x1bWUsXG4gICAgICAgIGJpZFZvbDogTWF0aC5jZWlsKHAxcy52b2x1bWUgKiAoTWF0aC5yYW5kb20oKSArIDAuNikpXG4gICAgICB9XG4gICAgICB0aWNrU3ltYi5jdXJyZW50UG9pbnQgPSBzdGFydHBvaW50O1xuICAgICAgdGlja1N5bWIubGFzdFBvaW50ID0gbGFzdHBvaW50O1xuICAgICAgY3VycmVudFRpY2tzW3RpY2tTeW1iLnRpY2tJbmRleF0gPSBzdGFydHBvaW50O1xuXG4gICAgICB0aWNrU3ltYi5jYWxsUm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpblZpZXcpIHtcbiAgICAgICAgICBsZXQgcDEgPSB0aWNrU3ltYi5zdHJlYW0ubmV4dCgpO1xuICAgICAgICAgIGxldCBiaWRWbCA9IE1hdGguY2VpbChwMS52b2x1bWUgKiAoTWF0aC5yYW5kb20oKSArIDAuNikpO1xuICAgICAgICAgIGxldCBwb2ludCA9IHtcbiAgICAgICAgICAgIHN5bWI6IHN5bWJvbCxcbiAgICAgICAgICAgIGxhc3Q6IHRpY2tTeW1iLmxhc3RQb2ludC5jbG9zZSxcbiAgICAgICAgICAgIGNsb3NlOiB0d29EZWMocDEuY2xvc2UpLFxuICAgICAgICAgICAgYXNrOiB0d29EZWMocDEuaGlnaCksXG4gICAgICAgICAgICBiaWQ6IHR3b0RlYyhwMS5sb3cpLFxuICAgICAgICAgICAgYXNrVm9sOiBwMS52b2x1bWUsXG4gICAgICAgICAgICBiaWRWb2w6IGJpZFZsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjdXJyZW50VGlja3NbdGhpc0luZGV4XSA9IHBvaW50O1xuICAgICAgICAgIHRpY2tTeW1iLmxhc3RQb2ludCA9IHRpY2tTeW1iLmN1cnJlbnRQb2ludDtcbiAgICAgICAgICB0aWNrU3ltYi5jdXJyZW50UG9pbnQgPSBwb2ludDtcbiAgICAgICAgICBUaWNrZXJzLnJlbmRlclVuaXQodGlja1N5bWIuYXRQb3MsIHRpY2tTeW1iLmN1cnJlbnRQb2ludCk7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aWNrU3ltYi5jYWxsUm91bmQoKTtcbiAgICAgICAgICB9LCAyMDAwKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgdGlja1N5bWIubG9nRGF0YS5iaW5kKHRpY2tTeW1iKTtcbiAgICBUaWNrZXJzW3N5bWJdID0gdGlja1N5bWI7XG4gICAgVGlja2Vycy5hY3RpdmVTeW1ib2xzLnB1c2goe3M6IHN5bWIsIGQ6IHJlbmRlckRlbGF5fSk7XG5cbiAgICB0aWNrU3ltYi5sb2dEYXRhKHByaWNlKTtcblxuICB9XG5cbiAgZnVuY3Rpb24gc2VlZFNwcmVhZCgpIHtcbiAgICBzZWVkcy5mb3JFYWNoKChpdG0sIGluZGV4KSA9PiB7XG4gICAgICBuZXdUaWNrZXIoaXRtLnN5bWIsIGl0bS5wcmMsIE1hdGguZmxvb3IoKE1hdGgucmFuZG9tKCkgKiAyMDAwKSArIDEwKSk7XG4gICAgfSk7XG4gICAgY3R4SGVpZ2h0ID0gKHNlZWRzLmxlbmd0aCAqIDIwKSArIDEwO1xuXG4gIH1cblxuICBjb25zdCBzcHJlYWRJbnRlcmZhY2UgPSB7XG4gICAgcmVuZGVyUm93OiByZW5kZXJSb3dcbiAgfVxuICBzcHJlYWRJbnRlcmZhY2Uuc2VlZFNwcmVhZCA9IHNlZWRTcHJlYWQuYmluZChzcHJlYWRJbnRlcmZhY2UpO1xuICBzcHJlYWRJbnRlcmZhY2UuaW5WaWV3ID0gKCkgPT4ge1xuICAgIGluVmlldyA9IHRydWU7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICBUaWNrZXJzLmhhc1JlbmRlcmVkID8gVGlja2Vycy5yZW5kZXJMaXZlKCkgOiBUaWNrZXJzLnJlbmRlclNwcmVhZCgpO1xuICAgIH0pO1xuXG4gIH1cbiAgc3ByZWFkSW50ZXJmYWNlLmdldFZpZXcgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGluVmlldztcbiAgfVxuICBzcHJlYWRJbnRlcmZhY2Uub3V0VmlldyA9ICgpID0+IHtcbiAgICBpblZpZXcgPSBmYWxzZTtcbiAgfVxuICBzcHJlYWRJbnRlcmZhY2Uuc2V0dGluZyA9ICh0cCkgPT4ge1xuICAgIHR5cGVTZXR0aW5nID0gdHA7XG4gIH1cbiAgcmV0dXJuIHNwcmVhZEludGVyZmFjZTtcblxufVxuXG5leHBvcnQgZGVmYXVsdCBzcHJlYWRDVFg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29tcG9uZW50cy9jYW52YXMvc3ByZWFkQ1RYLmpzIiwiaW1wb3J0IENhbnZhczJEQ29udGV4dCBmcm9tICdDYW52YXMyRENvbnRleHQnXG5cbmNvbnN0IHRyZW5kTGluZTIgPSAoY3R4SWQpID0+IHtcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY3R4SWQpO1xuICBjb25zdCBjID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xuICBjLmhlaWdodCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gIGMud2lkdGggPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gIGxldCB0aGVXaWQgPSBjLndpZHRoO1xuICBsZXQgdGhlSGVpZ2h0ID0gYy53aWR0aDtcbiAgbGV0IGN0eCA9IENhbnZhczJEQ29udGV4dChjKTtcbiAgY29uc3QgbGluZVNoaWZ0ID0gKHNoaWZ0KSA9PiB7XG4gICAgbGV0IHRoZVkgPSBzaGlmdC55ICsgMC41O1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhlV2lkLCB0aGVIZWlnaHQpLmdsb2JhbEFscGhhKDEpLmJlZ2luUGF0aCgpLm1vdmVUbygwLCB0aGVZKS5saW5lVG8oKHRoZVdpZCAtIDQwKSwgdGhlWSkubGluZVdpZHRoKDEpLnN0cm9rZVN0eWxlKCcjZjcwJykuc3Ryb2tlKCk7XG5cbiAgfTtcblxuICByZXR1cm4gbGluZVNoaWZ0O1xufTtcbmNvbnN0IHRyZW5kTGluZSA9IChjdHhJZCkgPT4ge1xuICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjdHhJZCk7XG4gIGNvbnN0IGMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignY2FudmFzJyk7XG4gIGxldCBjdHgyID0gQ2FudmFzMkRDb250ZXh0KGMpO1xuICBsZXQgdHJlbmRMaW5lQ29sb3IgPSBmYWxzZSA/ICcjZjcwJyA6ICcjZmZmJztcbiAgbGV0IG9wZW5Qb3MgPSBbXTtcbiAgY29uc3QgTGluZVNoaWZ0ID0gKGN0eCwgeCwgeSwgdGhlV2lkLCBjdXJyZW50KSA9PiB7XG4gICAgbGV0IG51bSA9IGN1cnJlbnQudG9GaXhlZCgyKTtcbiAgICBsZXQgdGhlWSA9IHkgKyAwLjU7XG5cbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBjdHgubW92ZVRvKDAsIHRoZVkpXG4gICAgY3R4LmxpbmVUbyh0aGVXaWQsIHRoZVkpXG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdHJlbmRMaW5lQ29sb3I7XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAvL2N0eC5maWxsU3R5bGUgPSAnI2ZmZic7XG4gICAgLy9jdHguZmlsbCgpO1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgY3R4Mi5iZWdpblBhdGgoKS5tb3ZlVG8oOCwgKHRoZVkgLSA4KSkubGluZVRvKDAsIHRoZVkpLmxpbmVUbyg4LCAodGhlWSArIDgpKS5saW5lVG8oOCwgKHRoZVkgKyA4KSkuc3Ryb2tlU3R5bGUoJyNmZmYnKS5zdHJva2UoKS5maWxsU3R5bGUoJyNmZmYnKS5maWxsKCkuY2xvc2VQYXRoKCkuZmlsbFN0eWxlKCcjZmZmJykuZmlsbFJlY3QoOCwgKHRoZVkgLSA4KSwgMzgsIDE2KS5maWxsU3R5bGUoJ2JsYWNrJykuZm9udCgnMTFweCBBcmlhbCcpLnRleHRBbGlnbignc3RhcnQnKS5maWxsVGV4dChudW0sIDgsICh0aGVZICsgNCkpO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBDYWxsUHV0TGluZXMgPSAoY3R4LCB0aGVXaWQsIGNvbnZlcnRlcikgPT4ge1xuICAgIGN0eDIuY2xlYXJSZWN0KDAsIDAsIDQ2LCA4MDApO1xuICAgIC8vbGV0IHN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgaWYgKG9wZW5Qb3MubGVuZ3RoKSB7XG4gICAgICAvLyBjdHguc2F2ZSgpO1xuICAgICAgb3BlblBvcy5mb3JFYWNoKChpdG0pID0+IHtcbiAgICAgICAgbGV0IHRoZVkgPSBjb252ZXJ0ZXIoaXRtLnVuaXRQcmljZSkgKyAwLjU7XG4gICAgICAgIGxldCBudW0gPSBpdG0udW5pdFByaWNlLnRvRml4ZWQoMik7XG4gICAgICAgIGxldCB0aGVDb2xvciA9IGl0bS50eXBlID09PSAnQ0FMTCcgPyAnIzAwRkYwMCcgOiAnI2ZmMDAwMCc7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKFsyLCAyXSk7XG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgdGhlWSlcbiAgICAgICAgY3R4LmxpbmVUbyh0aGVXaWQsIHRoZVkpXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGVDb2xvcjtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguc2V0TGluZURhc2goW10pO1xuXG4gICAgICAgIGN0eDIuYmVnaW5QYXRoKCkubW92ZVRvKDgsICh0aGVZIC0gOCkpLmxpbmVUbygwLCB0aGVZKS5saW5lVG8oOCwgKHRoZVkgKyA4KSkubGluZVRvKDgsICh0aGVZICsgOCkpLnN0cm9rZVN0eWxlKHRoZUNvbG9yKS5zdHJva2UoKS5maWxsU3R5bGUodGhlQ29sb3IpLmZpbGwoKS5jbG9zZVBhdGgoKS5maWxsU3R5bGUodGhlQ29sb3IpLmZpbGxSZWN0KDgsICh0aGVZIC0gOCksIDM4LCAxNikuZmlsbFN0eWxlKCdibGFjaycpLmZvbnQoJzExcHggQXJpYWwnKS50ZXh0QWxpZ24oJ3N0YXJ0JykuZmlsbFRleHQobnVtLCA4LCAodGhlWSArIDQpKTtcbiAgICAgICAgLy9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIC8vY3R4LmZpbGxTdHlsZSA9ICcjZmZmJztcblxuICAgICAgICAvL2N0eC5maWxsKCk7XG5cbiAgICAgIH0pO1xuICAgICAgLy9jdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGluZVNoaWZ0OiBMaW5lU2hpZnQsXG4gICAgY2FsbFB1dExpbmVzOiBDYWxsUHV0TGluZXMsXG4gICAgbmV3UG9zOiAocG9zKSA9PiB7XG4gICAgICBvcGVuUG9zID0gb3BlblBvcy5jb25jYXQocG9zKTtcbiAgICB9LFxuICAgIHBvc0V4cGlyZWQ6IChzdGFtcCkgPT4ge1xuICAgICAgb3BlblBvcyA9IG9wZW5Qb3MuZmlsdGVyKChpdG0pID0+IHtcbiAgICAgICAgcmV0dXJuIGl0bS50aW1lc3RhbXAgIT09IHN0YW1wO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBuZXdDb2xvcjogKGNvbG9yKSA9PiB7XG4gICAgICB0cmVuZExpbmVDb2xvciA9IGNvbG9yO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB0cmVuZExpbmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29tcG9uZW50cy9jYW52YXMvdHJlbmRsaW5lQ1RYLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuY2xhc3MgQ2hhcnRDb250YWluZXIgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgY29udGFpbmVyQ2xhc3NOYW1lKHtjaGFydFFudHksIGluZGV4fSkge1xuICAgIGlmIChjaGFydFFudHkgPT09IDEpIHtcbiAgICAgIHJldHVybiAnY2hhcnQtYm94LTEwMCBjb2wtc20tMTIgZmFkZS1pbi1mYXN0J1xuICAgIH1cbiAgICBpZiAoY2hhcnRRbnR5ID09PSAyICkge1xuICAgICAgcmV0dXJuICdjaGFydC1ib3gtNTAgY29sLXNtLTEyIGZhZGUtaW4tZmFzdCc7XG4gICAgfVxuICAgIGlmIChjaGFydFFudHkgPT09IDMpIHtcbiAgICAgIHJldHVybiBpbmRleCA9PT0gMiA/ICdjaGFydC1ib3gtNTAgY29sLXNtLTEyIGZhZGUtaW4tZmFzdCcgOiAnY2hhcnQtYm94LTUwIHRkLXJlZHVjZSBjb2wtc20tNiBmYWRlLWluLWZhc3QnO1xuICAgIH1cbiAgICByZXR1cm4gJ2NoYXJ0LWJveC01MCB0ZC1yZWR1Y2UgY29sLXNtLTYgZmFkZS1pbi1mYXN0J1xuXG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17dGhpcy5jb250YWluZXJDbGFzc05hbWUodGhpcy5wcm9wcyl9PlxuICAgICAgICB7dGhpcy5wcm9wcy5jaGlsZHJlbn1cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaGFydENvbnRhaW5lcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9jb21wb25lbnRzL2Rhc2hib2FyZC9jaGFydF9jb250YWluZXIuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmNvbnN0IHBlcmNlbnRDaGFuZ2UyID0gKGxhc3QsIGN1cnJlbnQpID0+IHtcbiAgIGlmIChjdXJyZW50ID4gbGFzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIHBvczogdHJ1ZSwgYXJyb3c6IDxpIGNsYXNzTmFtZT0nbWF0ZXJpYWwtaWNvbnMgcG9zJz5hcnJvd19kcm9wX3VwPC9pPixcbiAgICAgICAgIHBybmN0OiAnKycgKyBTdHJpbmcoKChjdXJyZW50IC0gbGFzdCkgLyBsYXN0KSAqIDEwMCkuc2xpY2UoMCwgNCkgKyAnJSdcbiAgICAgIH07XG4gICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIHBvczogZmFsc2UsIGFycm93OiA8aSBjbGFzc05hbWU9J21hdGVyaWFsLWljb25zIG5lZyc+YXJyb3dfZHJvcF9kb3duPC9pPixcbiAgICAgICAgIHBybmN0OiAnLScgKyBTdHJpbmcoKChsYXN0IC0gY3VycmVudCkgLyBsYXN0KSAqIDEwMCkuc2xpY2UoMCwgNCkgKyAnJSdcbiAgICAgIH07XG4gICB9XG59XG5jb25zdCByZXR1cm5MaUNsYXNzID0gKGFuaW1hdGUsIGFjdGl2ZSkgPT4ge1xuICAgaWYgKGFjdGl2ZSkge1xuICAgICAgcmV0dXJuIGFuaW1hdGUgPyAnbGktaW5mby1ib3ggcG9zLWxpLWFjdGl2ZSBsaS1zbGlkZXVwJyA6ICdsaS1pbmZvLWJveCBwb3MtbGktYWN0aXZlJztcbiAgIH1cbiAgIHJldHVybiBhbmltYXRlID8gJ2xpLWluZm8tYm94IGxpLXNsaWRldXAnIDogJ2xpLWluZm8tYm94Jztcbn07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbmZvTGkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgc3VwZXIocHJvcHMpXG4gICAgICB0aGlzLndoZW5DbGlja2VkID0gdGhpcy53aGVuQ2xpY2tlZC5iaW5kKHRoaXMpO1xuICAgfTtcbiAgIHdoZW5DbGlja2VkKCkge1xuICAgICAgdGhpcy5wcm9wcy5jbGlja2VkKHRoaXMucHJvcHMucG9zLCB0aGlzLnByb3BzLmluZGV4KTtcbiAgIH1cbiAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHt9XG4gICByZW5kZXIoKSB7XG4gICAgICBsZXQge3BvcywgYWRkU3R5bGUsIGFuaW1hdGUsIGFjdGl2ZX0gPSB0aGlzLnByb3BzO1xuICAgICAgbGV0IGxpQ2xhc3MgPSAhYWRkU3R5bGUgPyByZXR1cm5MaUNsYXNzKGFuaW1hdGUsIGFjdGl2ZSkgOiByZXR1cm5MaUNsYXNzKGZhbHNlLCBhY3RpdmUpICsgJyBsaS1zY2FsZSBib3VuY2UtaW4tZmFzdCc7XG4gICAgICBsZXQgYW5pID0gKHRoaXMucHJvcHMuYW5pbWF0ZSAmJiAhYWRkU3R5bGUpID8gJ3NsaWRlVXAgJyArIFN0cmluZygwLjA4ICogdGhpcy5wcm9wcy5pbmRleCkgKyAncyBlYXNlLW91dCAwLjZzIDEgZm9yd2FyZHMnIDogJyc7XG4gICAgICBsZXQgcGVyY2VudGFnZSA9IHBlcmNlbnRDaGFuZ2UyKHRoaXMucHJvcHMucG9zLnByaWNlc3RhcnQsIHRoaXMucHJvcHMucG9zLnByaWNlZW5kKTtcbiAgICAgIGxldCBwcm9maXQgPSAnJCcgKyBTdHJpbmcoTWF0aC5yb3VuZCgocG9zLnByaWNlZW5kICogcG9zLnZvbHVtZSkgLSAocG9zLnByaWNlc3RhcnQgKiBwb3Mudm9sdW1lKSkpO1xuICAgICAgbGV0IGR0YSA9IHRoaXMucHJvcHMucG9zLmRhdGUuc2xpY2UoMCwgLTUpO1xuICAgICAgbGV0IHVuaXRQcmljZSA9ICckJyArIHBvcy5wcmljZWVuZC50b0ZpeGVkKDIpO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgIDxsaSBjbGFzc05hbWU9e2xpQ2xhc3N9IHN0eWxlPXt7XG4gICAgICAgICAgICBhbmltYXRpb246IGFuaVxuICAgICAgICAgfX0gb25EcmFnRW5kPXt0aGlzLndoZW5DbGlja2VkLmJpbmQodGhpcyl9IG9uTW91c2VVcD17dGhpcy53aGVuQ2xpY2tlZC5iaW5kKHRoaXMpfSBkcmFnZ2FibGU9J3RydWUnPlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nbGktc3Bhbi1ibG9jayBkdC1zcGFuJz5cbiAgICAgICAgICAgICAgIHtkdGF9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdsaS1zcGFuLWJsb2NrIHNwYW4tbGFiZWwtYmx1ZSB0aC1zcGFuJz5cbiAgICAgICAgICAgICAgIHt0aGlzLnByb3BzLnBvcy5wb3NpdGlvbn1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2xpLXNwYW4tYmxvY2snPlxuICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPSdiaWcta2FodW5hJz57dW5pdFByaWNlfTwvc3Bhbj5cbiAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT0ndm9sLXNwYW4nPlxuICAgICAgICAgICAgICAgICAge3RoaXMucHJvcHMucG9zLnZvbHVtZX08L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdsaS1zcGFuLWJsb2NrJz5cbiAgICAgICAgICAgICAgIDxzcGFuPntwZXJjZW50YWdlLmFycm93fTwvc3Bhbj5cbiAgICAgICAgICAgICAgIDxzcGFuPntwZXJjZW50YWdlLnBybmN0fTwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2xpLXNwYW4tYmxvY2snPlxuICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtwZXJjZW50YWdlLnBvcyA/ICdzcGFuLWdyZWVuJyA6ICdzcGFuLXJlZCd9Pntwcm9maXR9PC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgIDwvbGk+XG4gICAgICApXG5cbiAgIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29tcG9uZW50cy9kYXNoYm9hcmQvaGlzdG9yeS9pbmZvbGkuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuY29uc3QgcG9zdGl2ZUNoYW5nZSA9IChsYXN0LCBjdXJyZW50KSA9PiAoe1xuICAgcG9zOiB0cnVlLFxuICAgYXJyb3c6IDxpIGNsYXNzTmFtZT0nbWF0ZXJpYWwtaWNvbnMgcG9zJz5hcnJvd19kcm9wX3VwPC9pPixcbiAgIHBybmN0OiBgKyR7U3RyaW5nKCgoY3VycmVudCAtIGxhc3QpIC8gbGFzdCkgKiAxMDApLnNsaWNlKDAsIDQpfSVgXG59KVxuXG5jb25zdCBuZWdhdGl2ZUNoYW5nZSA9IChsYXN0LCBjdXJyZW50KSA9PiAoe1xuICAgICAgcG9zOiBmYWxzZSxcbiAgICAgIGFycm93OiA8aSBjbGFzc05hbWU9J21hdGVyaWFsLWljb25zIG5lZyc+YXJyb3dfZHJvcF9kb3duPC9pPixcbiAgICAgIHBybmN0OiBgLSR7U3RyaW5nKCgobGFzdCAtIGN1cnJlbnQpIC8gbGFzdCkgKiAxMDApLnNsaWNlKDAsIDQpfSVgXG4gfSlcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9zaXRpb25WaWV3IGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgcHJvcHMuR3JhcGhDb250cm9sbGVyLnVwZGF0ZVBvc1Byb3BzKHByb3BzLnBvcyk7XG4gICB9O1xuICAgcGVyY2VudENoYW5nZSA9ICh7cHJpY2VzdGFydCwgcHJpY2VlbmR9KSA9PiBwcmljZXN0YXJ0IDwgcHJpY2VlbmQgPyBwb3N0aXZlQ2hhbmdlKHByaWNlc3RhcnQsIHByaWNlZW5kKSA6IG5lZ2F0aXZlQ2hhbmdlKHByaWNlc3RhcnQsIHByaWNlZW5kKTtcbiAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdGhpcy5wcm9wcy5HcmFwaENvbnRyb2xsZXIuY3JlYXRlQ2hhcnRzKHRoaXMucHJvcHMucG9zKTtcbiAgIH1cbiAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgIHRoaXMucHJvcHMuR3JhcGhDb250cm9sbGVyLnVwZGF0ZVBvc1Byb3BzKHRoaXMucHJvcHMucG9zKTtcbiAgICAgIHRoaXMucHJvcHMuR3JhcGhDb250cm9sbGVyLnVwZGF0ZUNoYXJ0cygpO1xuICAgfVxuICAgY3VycmVudFByb2ZpdCA9ICgpID0+IHtcbiAgICAgY29uc3QgeyBwcmljZWVuZCwgdm9sdW1lLCBwcmljZXN0YXJ0fSA9IHRoaXMucHJvcHMucG9zO1xuICAgICByZXR1cm4gJyQnICsgU3RyaW5nKE1hdGgucm91bmQoKHByaWNlZW5kICogdm9sdW1lKSAtIChwcmljZXN0YXJ0ICogdm9sdW1lKSkpXG4gICB9XG4gICByZW5kZXIoKSB7XG4gICAgICBjb25zdCB7IHBvcyB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSB0aGlzLnBlcmNlbnRDaGFuZ2UocG9zKVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSd2aWV3LXRyZCBmYWRlLWluJz5cbiAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9J3VuZGVyLWxpbmUgc3Bhbi1sYWJlbC1ibHVlIG1hcmdpbi1idG0tc20nPlxuICAgICAgICAgICAgICAgeyBwb3MucG9zaXRpb24gfVxuICAgICAgICAgICAgIDwvaDM+XG4gICAgICAgICAgICAgeyBwb3MuZGF0ZX1cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdyb3cgcG9zLW92ZXJ2aWV3Jz5cbiAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdjb2wteHMtMiBwb3MtY29sIHBvcy1maXJzdCc+XG4gICAgICAgICAgICAgICAgICA8c3Ryb25nPlBvc2l0aW9uczwvc3Ryb25nPlxuICAgICAgICAgICAgICAgICAgeyBwb3Mudm9sdW1lIH1cbiAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2NvbC14cy0yIHBvcy1jb2wnPlxuICAgICAgICAgICAgICAgICAgPHN0cm9uZz5TdGFydCBWYWx1ZTwvc3Ryb25nPlxuICAgICAgICAgICAgICAgICAgeyBwb3MucHJpY2VzdGFydCB9XG4gICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2NvbC14cy0yIHBvcy1jb2wnPlxuICAgICAgICAgICAgICAgICAgPHN0cm9uZz5FbmQgVmFsdWU8L3N0cm9uZz5cbiAgICAgICAgICAgICAgICAgIHsgcG9zLnByaWNlZW5kIH1cbiAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nY29sLXhzLTMgcG9zLWNvbCc+XG4gICAgICAgICAgICAgICAgICA8c3Ryb25nPkNoYW5nZTwvc3Ryb25nPlxuICAgICAgICAgICAgICAgICAgPHNwYW4+eyBwZXJjZW50YWdlLmFycm93IH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICA8c3Bhbj57IHBlcmNlbnRhZ2UucHJuY3QgfTwvc3Bhbj5cbiAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2NvbC14cy0yIHBvcy1jb2wnPlxuICAgICAgICAgICAgICAgICAgPHN0cm9uZz5Qcm9maXQ8L3N0cm9uZz5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17cGVyY2VudGFnZS5wb3MgPyAnc3Bhbi1ncmVlbicgOiAnc3Bhbi1yZWQnfT5cbiAgICAgICAgICAgICAgICAgICAge3RoaXMuY3VycmVudFByb2ZpdCgpfVxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdyb3cnPlxuICAgICAgICAgICAgICAgPGRpdiBpZD0nY2hhcnQxdmlldycgY2xhc3NOYW1lPSdjdHgtY2hhcnRzLWNsYXNzJz48L2Rpdj5cbiAgICAgICAgICAgICAgIDxkaXYgaWQ9J2NoYXJ0MnZpZXcnIGNsYXNzTmFtZT0nY3R4LWNoYXJ0cy1jbGFzcyc+PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgKVxuICAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9jb21wb25lbnRzL2Rhc2hib2FyZC9oaXN0b3J5L3Bvc2l0aW9udmlldy5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFN0YXQgZnJvbSAnc3ZnL3N0YXQnO1xuXG5jb25zdCBzdmcxID0ge1xuICAgcGx1c1ZhbHVlOiAwLFxuICAgYnVmZmVyOiAxMSxcbiAgIGRvbUVsZW06IG51bGwsXG4gICB0eXBlOiAnbnVtYmVyJyxcbiAgIGFuaW1hdGU6IHRydWUsXG4gICBmaWxsQ2hhbmdlOiBmYWxzZSxcbiAgIGxhc3RWYWx1ZTogMCxcbiAgIGN1cnJlbnQ6IDAsXG4gICBuYW1lOiAnc3ZnMSdcbn07XG5jb25zdCBzdmcyID0ge1xuICAgcGx1c1ZhbHVlOiAwLFxuICAgdHlwZTogJ2Zsb2F0JyxcbiAgIGJ1ZmZlcjogMTEsXG4gICBkb21FbGVtOiBudWxsLFxuICAgYW5pbWF0ZTogdHJ1ZSxcbiAgIGZpbGxDaGFuZ2U6IHRydWUsXG4gICBsYXN0VmFsdWU6IDAuMCxcbiAgIGN1cnJlbnQ6IDAuMCxcbiAgIG5hbWU6ICdzdmcyJ1xufTtcbmNvbnN0IHN2ZzMgPSB7XG4gICBwbHVzVmFsdWU6IDAsXG4gICBidWZmZXI6IDExLFxuICAgZG9tRWxlbTogbnVsbCxcbiAgIHR5cGU6ICdmbG9hdCcsXG4gICBmaWxsQ2hhbmdlOiB0cnVlLFxuICAgYW5pbWF0ZTogdHJ1ZSxcbiAgIGxhc3RWYWx1ZTogMC4wLFxuICAgY3VycmVudDogMC4wLFxuICAgbmFtZTogJ3N2ZzMnXG59XG5jb25zdCBzdmc0ID0ge1xuICAgcGx1c1ZhbHVlOiAwLFxuICAgYnVmZmVyOiAxMSxcbiAgIGRvbUVsZW06IG51bGwsXG4gICB0eXBlOiAnZmxvYXQnLFxuICAgZmlsbENoYW5nZTogdHJ1ZSxcbiAgIGFuaW1hdGU6IHRydWUsXG4gICBsYXN0VmFsdWU6IDAsXG4gICBjdXJyZW50OiAwLFxuICAgbmFtZTogJ3N2ZzQnXG59XG5jb25zdCBzdmc1ID0ge1xuICAgcGx1c1ZhbHVlOiAwLFxuICAgYnVmZmVyOiAxMSxcbiAgIGRvbUVsZW06IG51bGwsXG4gICB0eXBlOiAnbnVtYmVyJyxcbiAgIGZpbGxDaGFuZ2U6IGZhbHNlLFxuICAgYW5pbWF0ZTogdHJ1ZSxcbiAgIGxhc3RWYWx1ZTogMCxcbiAgIGN1cnJlbnQ6IDAsXG4gICBuYW1lOiAnc3ZnNSdcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdFRpbGVzIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICByZW5kZXIoKSB7XG4gICAgICBsZXQge3RyYWRlUHJvcHN9ID0gdGhpcy5wcm9wcztcbiAgICAgIHJldHVybiAoXG4gICAgICAgICA8ZGl2IGlkPSdzdGF0VGlsZXMnPlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nY29sLXhzLTIgc3RhdC10aWxlIGJvcmRlci1ub25lJz5cbiAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT0ndG9wX3NwYW4gc3Bhbi1sYWJlbC13aGl0ZSc+V2Vla2x5IFRyYW5zYWN0aW9uczwvc3Bhbj5cblxuICAgICAgICAgICAgICAgPFN0YXQgc3ZnSWQ9eydzdmcxJ30gU3ZnQ0I9e3RoaXMucHJvcHMuU3ZnQ0J9IGNvbmZpZz17c3ZnMX0gZmlsbENvbG9yPXsnIzAwZDhmZid9IGNsYXNzVHlwZT17J3N2Zy1jb3VudCd9Lz5cbiAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT0nYm90dG9tX3NwYW4nPlRoaW5nPC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nY29sLXhzLTIgc3RhdC10aWxlJz5cbiAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT0ndG9wX3NwYW4gc3Bhbi1sYWJlbC13aGl0ZSc+Q3VycmVudCBUb3RhbDwvc3Bhbj5cbiAgICAgICAgICAgICAgIDxTdGF0IHN2Z0lkPXsnc3ZnMid9IFN2Z0NCPXt0aGlzLnByb3BzLlN2Z0NCfSBjb25maWc9e3N2ZzJ9IGZpbGxDb2xvcj17JyMwMGQ4ZmYnfSBjbGFzc1R5cGU9eydzdmctY291bnQnfS8+XG4gICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9J2JvdHRvbV9zcGFuJz5UaGluZzwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2NvbC14cy0yIHN0YXQtdGlsZSc+XG4gICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9J3RvcF9zcGFuIHNwYW4tbGFiZWwtd2hpdGUnPldrLW9uLVdrIEdhaW5zPC9zcGFuPlxuICAgICAgICAgICAgICAgPFN0YXQgc3ZnSWQ9eydzdmczJ30gU3ZnQ0I9e3RoaXMucHJvcHMuU3ZnQ0J9IGNvbmZpZz17c3ZnM30gZmlsbENvbG9yPXsnI0RDMTQzQyd9IGNsYXNzVHlwZT17J3N2Zy1jb3VudCd9Lz5cbiAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT0nYm90dG9tX3NwYW4nPlRoaW5nPC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nY29sLXhzLTIgc3RhdC10aWxlJz5cbiAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT0ndG9wX3NwYW4gc3Bhbi1sYWJlbC13aGl0ZSc+VG9kYXkncyBQcm9maXQ8L3NwYW4+XG5cbiAgICAgICAgICAgICAgIDxTdGF0IHN2Z0lkPXsnc3ZnNCd9IFN2Z0NCPXt0aGlzLnByb3BzLlN2Z0NCfSBjb25maWc9e3N2ZzR9IGZpbGxDb2xvcj17JyMzMGQ5NGMnfSBjbGFzc1R5cGU9eydzdmctY291bnQnfS8+XG5cbiAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT0nYm90dG9tX3NwYW4nPlRoaW5nPC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nY29sLXhzLTIgc3RhdC10aWxlJz5cbiAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT0ndG9wX3NwYW4gc3Bhbi1sYWJlbC13aGl0ZSc+Vm9sdW1lIFRyYWRlZDwvc3Bhbj5cblxuICAgICAgICAgICAgICAgPFN0YXQgc3ZnSWQ9eydzdmc1J30gU3ZnQ0I9e3RoaXMucHJvcHMuU3ZnQ0J9IGNvbmZpZz17c3ZnNX0gZmlsbENvbG9yPXsnIzAwZDhmZid9IGNsYXNzVHlwZT17J3N2Zy1jb3VudCd9Lz5cblxuICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPSdib3R0b21fc3Bhbic+VGhpbmc8L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgPC9kaXY+XG5cbiAgICAgIClcbiAgIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29tcG9uZW50cy9kYXNoYm9hcmQvaGlzdG9yeS9zdGF0c3RpbGVzLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFza0JpZE92ZXJ2aWV3IGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gIHBvc1ZhbHVlKHBvcywgdmFsSW5kZXgpIHtcbiAgICBpZiAocG9zLnBvaW50ID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICByZXR1cm4gJyQnICsgKE1hdGgucm91bmQocG9zLnBvaW50LmRhdGFbdmFsSW5kZXhdICogMTAwKSAvIDEwMCk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgdGltZUV4cGlyZXMsIHZhbEluZGV4IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMucHJvcHMucG9zID09PSBudWxsID8geyBpc251bGw6IHRydWUgfSA6IHRoaXMucHJvcHMucG9zO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17IHBvcy5pc251bGwgPT09IHRydWUgPyAnaGlkZS1lbG0nIDogJ3RyYWRlLWRlc2NyaXB0aW9uJyB9PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT0ndHJuLWJsayB0cm4tc3ltYic+XG4gICAgICAgICAgPHNwYW4+U3ltYm9sPC9zcGFuPlxuICAgICAgICAgIDxzcGFuPntwb3Muc3ltYiB8fCAnTk9ORSd9PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9J3Rybi1ibGsnPlxuICAgICAgICAgIDxzcGFuPlF1YW50aXR5PC9zcGFuPlxuICAgICAgICAgIDxzcGFuPntwb3MucXR5IHx8IDB9PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9J3Rybi1ibGsnPlxuICAgICAgICAgIDxzcGFuPlBQVTwvc3Bhbj5cbiAgICAgICAgICA8c3Bhbj57dGhpcy5wb3NWYWx1ZShwb3MsIHZhbEluZGV4KX08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT0ndHJuLWJsayc+XG4gICAgICAgICAgPHNwYW4+RXhwaXJlczwvc3Bhbj5cbiAgICAgICAgICA8c3Bhbj57dGltZUV4cGlyZXN9PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL2NvbXBvbmVudHMvZGFzaGJvYXJkL2xpdmVncmFwaC9hc2tfYmlkX292ZXJ2aWV3LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgVGltZUludGVydmFscyBmcm9tICdtaWNyby90aW1laW50ZXJ2YWxzJztcbmltcG9ydCBBc2tCaWRPdmVydmlldyBmcm9tICcuL2Fza19iaWRfb3ZlcnZpZXcnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYWxsUHV0IGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuY2xvY2sgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB0aW1lTWVudU9wZW46IGZhbHNlLFxuICAgICAgbWVudXR5cGU6IG51bGwsXG4gICAgICBxbnR5OiAxLFxuICAgICAgYmlkT3BlbjogZmFsc2UsXG4gICAgICBhc2tPcGVuOiBmYWxzZSxcbiAgICAgIGJpZEJ0bkNsYXNzOiAnJyxcbiAgICAgIHB1dEJ0bkNsYXNzOiAnJyxcbiAgICAgIHRpbWVTZXQ6IDEsXG4gICAgICBwb3NOdW06IDAsXG4gICAgICBzeW1iOiBwcm9wcy5tYWluU3ltLFxuICAgICAgcG9zOiBudWxsXG4gICAgfVxuICB9XG4gIHRvZ2dsZU1lbnVCaWQgPSAoKSA9PiB7XG4gICAgbGV0IHBvcyA9IHRoaXMuc3RhdGUucG9zID8gdGhpcy5zdGF0ZS5wb3MgOiB7XG4gICAgICBxdHk6IDEsXG4gICAgICB0aW1lOiB0aGlzLnN0YXRlLnRpbWVTZXQsXG4gICAgICBwb2ludDoge1xuICAgICAgICBkYXRhOiBbMiwgMywgMiwgMl1cbiAgICAgIH0sXG4gICAgICBzeW1iOiB0aGlzLnByb3BzLm1haW5TeW1cbiAgICB9O1xuICAgIHBvcy5xdHkgPSB0aGlzLnN0YXRlLnFudHk7XG4gICAgcG9zLnR5cGUgPSAnQ0FMTCc7XG4gICAgcG9zLnBvaW50ID0gdGhpcy5wcm9wcy5jdHhDaGFydC5nZXRMYXRlc3RQb2ludCgpO1xuICAgIHBvcy51bml0UHJpY2UgPSBwb3MucG9pbnQuZGF0YVszXTtcbiAgICB0aGlzLnNldFN0YXRlKHtiaWRPcGVuOiB0cnVlLCBhc2tPcGVuOiBmYWxzZSwgdGltZU1lbnVPcGVuOiBmYWxzZSwgcG9zOiBwb3N9KTtcbiAgfVxuICB0b2dnbGVNZW51QXNrID0gKCkgPT4ge1xuICAgIGxldCBwb3MgPSB0aGlzLnN0YXRlLnBvcyA/IHRoaXMuc3RhdGUucG9zIDoge1xuICAgICAgcXR5OiAxLFxuICAgICAgdGltZTogdGhpcy5zdGF0ZS50aW1lU2V0LFxuICAgICAgcG9pbnQ6IHtcbiAgICAgICAgZGF0YTogWzIsIDMsIDIsIDJdXG4gICAgICB9LFxuICAgICAgc3ltYjogdGhpcy5wcm9wcy5tYWluU3ltXG4gICAgfTtcbiAgICBwb3MucXR5ID0gdGhpcy5zdGF0ZS5xbnR5O1xuICAgIHBvcy50eXBlID0gJ1BVVCc7XG4gICAgcG9zLnBvaW50ID0gdGhpcy5wcm9wcy5jdHhDaGFydC5nZXRMYXRlc3RQb2ludCgpO1xuICAgIHBvcy51bml0UHJpY2UgPSBwb3MucG9pbnQuZGF0YVszXTtcbiAgICB0aGlzLnNldFN0YXRlKHthc2tPcGVuOiB0cnVlLCBiaWRPcGVuOiBmYWxzZSwgdGltZU1lbnVPcGVuOiBmYWxzZSwgcG9zOiBwb3N9KTtcbiAgfVxuICBzZXRQb3NUaW1lID0gKHRtKSA9PiAoKSA9PiB7XG4gICAgbGV0IHBvcyA9IHRoaXMuc3RhdGUucG9zID8gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZS5wb3MpIDoge1xuICAgICAgcXR5OiAxLFxuICAgICAgdGltZTogdGhpcy5zdGF0ZS50aW1lU2V0LFxuICAgICAgcG9pbnQ6IHtcbiAgICAgICAgZGF0YTogWzIsIDMsIDIsIDJdXG4gICAgICB9LFxuICAgICAgc3ltYjogdGhpcy5wcm9wcy5tYWluU3ltXG4gICAgfTtcbiAgICBwb3MudGltZSA9IHRtO1xuICAgIHBvcy5xdHkgPSB0aGlzLnN0YXRlLnFudHk7XG4gICAgcG9zLnBvaW50ID0gdGhpcy5wcm9wcy5jdHhDaGFydC5nZXRMYXRlc3RQb2ludCgpO1xuICAgIHBvcy5zeW1iID0gdGhpcy5zdGF0ZS5zeW1iO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdGltZVNldDogdG0sXG4gICAgICBwb3M6IHBvc1xuICAgIH0pO1xuXG4gIH1cbiAgcG9zU2V0ID0gKGJpZE9yQXNrKSA9PiAoKSA9PiB7XG4gICAgbGV0IHtwb3MsIHBvc051bX0gPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlKTtcbiAgICBsZXQgZCA9IG5ldyBEYXRlKCk7XG4gICAgcG9zLmV4cGlyZXMgPSBkLmdldEhvdXJzKCkgKyAnOicgKyAoJzAnICsgKGQuZ2V0TWludXRlcygpICsgcG9zLnRpbWUpKS5zbGljZSgtMik7XG4gICAgcG9zLnRpbWVzdGFtcCA9IG5ldyBEYXRlKG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgcG9zLnRpbWUgKiA2MDAwMCk7XG4gICAgcG9zTnVtICs9IDE7XG5cbiAgICBwb3MudHlwZSA9IGJpZE9yQXNrO1xuICAgIHBvcy5nZXRMYXRlc3RQb2ludCA9IHRoaXMucHJvcHMuY3R4Q2hhcnQuZ2V0TGF0ZXN0UG9pbnQ7XG4gICAgcG9zLmN0eGlkID0gcG9zLnN5bWIgKyAnXycgKyBEYXRlLm5vdygpLnRvU3RyaW5nKCkuc2xpY2UoLTQpO1xuICAgIHRoaXMucHJvcHMubmV3UG9zKE9iamVjdC5hc3NpZ24oe30sIHBvcykpO1xuICAgIHRoaXMuc2V0U3RhdGUoe2Fza09wZW46IGZhbHNlLCBiaWRPcGVuOiBmYWxzZSwgcG9zTnVtOiBwb3NOdW0sIHBvczogbnVsbH0pO1xuXG4gIH1cbiAgY2xvc2VNb2RhbCA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHthc2tPcGVuOiBmYWxzZSwgYmlkT3BlbjogZmFsc2UsIGJpZEJ0bkNsYXNzOiAnJywgcHV0QnRuQ2xhc3M6ICcnfSk7XG4gIH1cbiAgbWVudVNldCA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHt0aW1lTWVudU9wZW46IGZhbHNlfSk7XG4gIH1cbiAgdGltZU1lbnVPcGVuID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdGltZU1lbnVPcGVuOiAhdGhpcy5zdGF0ZS50aW1lTWVudU9wZW5cbiAgICB9KTtcbiAgfVxuICBwbHVzTWludXMgPSAobnVtKSA9PiAoKSA9PiB7XG4gICAgbGV0IHFudHkgPSAodGhpcy5zdGF0ZS5xbnR5ICsgbnVtKSA+IDAgPyB0aGlzLnN0YXRlLnFudHkgKyBudW0gOiAxO1xuICAgIGxldCBwb3MgPSB0aGlzLnN0YXRlLnBvcyA/IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUucG9zLCB7cXR5OiBxbnR5fSkgOiBudWxsO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7cW50eTogcW50eSwgcG9zOiBwb3N9KTtcbiAgfVxuXG4gIGJ0blB0bnB1c2ggPSAoYm9vbCkgPT4gKCkgPT4ge1xuICAgIGlmIChib29sKSB7XG4gICAgICBsZXQgYnRuID0gdGhpcy5zdGF0ZS5iaWRCdG5DbGFzcyA9PT0gJ2J1dHRvbi1jbGljaycgPyAnYnV0dG9uLWluJyA6ICdidXR0b24tY2xpY2snO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7YmlkQnRuQ2xhc3M6IGJ0biwgcHV0QnRuQ2xhc3M6ICcnfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBidG4gPSB0aGlzLnN0YXRlLnB1dEJ0bkNsYXNzID09PSAnYnV0dG9uLWNsaWNrJyA/ICdidXR0b24taW4nIDogJ2J1dHRvbi1jbGljayc7XG4gICAgICB0aGlzLnNldFN0YXRlKHtwdXRCdG5DbGFzczogYnRuLCBiaWRCdG5DbGFzczogJyd9KTtcbiAgICB9XG4gIH1cbiAgY2FsY1RpbWVFeHBpcmVzKHBvcywgZGF0ZSkge1xuICAgIGlmIChwb3MgPT09IG51bGwpIHJldHVybiAnJztcbiAgICByZXR1cm4gZGF0ZS5nZXRIb3VycygpICsgJzonICsgKCcwJyArIChkYXRlLmdldE1pbnV0ZXMoKSArIHBvcy50aW1lKSkuc2xpY2UoLTIpO1xuXG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG5cbiAgICB0aGlzLmNsb2NrID0gdGhpcy5wcm9wcy5jbG9ja0N0eC5zZXRDbG9jayh0aGlzLnByb3BzLnRpbWVySWQpO1xuICAgIHRoaXMuY2xvY2soKTtcbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblxuICAgIHRoaXMuY2xvY2sgPSBudWxsO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBsZXQge3B1dEJ0bkNsYXNzLCBiaWRCdG5DbGFzcywgcG9zfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgdGltZUV4cGlyZXMgPSB0aGlzLmNhbGNUaW1lRXhwaXJlcyhwb3MsIGRhdGUpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT0nb3B0aW9uLWJ1eS1zZWxsIHJlZHVjdCc+XG4gICAgICAgIDxkaXYgaWQ9J3RpbWVNZW51JyBjbGFzc05hbWU9e3RoaXMuc3RhdGUudGltZU1lbnVPcGVuID8gJ3ppbmctaW4tZmFzdCcgOiAnaGlkZS1lbG0nfT5cbiAgICAgICAgICA8c3Ryb25nPlBvc2l0aW9uIEV4cGlyYXRpb248L3N0cm9uZz5cbiAgICAgICAgICA8VGltZUludGVydmFscyBpbmQ9e3RoaXMuc3RhdGUudGltZVNldH0gZGF0ZT17ZGF0ZX0gdGltZVNldD17dGhpcy5zZXRQb3NUaW1lfS8+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2Nvb2wtYnV0dG9uICBhZGQtY2hhcnQtYnQgc2V0LXBvcycgb25DbGljaz17dGhpcy5tZW51U2V0fT5TZXQgVGltZTwvZGl2PlxuXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGlkPSdCaWQnIGNsYXNzTmFtZT17dGhpcy5zdGF0ZS5iaWRPcGVuID8gJ2JvdW5jZS1pbi1mYXN0JyA6ICdoaWRlLWVsbSd9PlxuICAgICAgICAgIDxwIGNsYXNzTmFtZT0ncG9zLXR5cGUtaGVhZGVyIGNhbGwtdCc+Q2FsbCBQb3NpdGlvblxuICAgICAgICAgIDwvcD5cbiAgICAgICAgICA8aSBjbGFzc05hbWU9J21hdGVyaWFsLWljb25zICBjbG9zZS1tb2RhbCcgb25DbGljaz17dGhpcy5jbG9zZU1vZGFsfT5jbGVhcjwvaT5cbiAgICAgICAgICA8QXNrQmlkT3ZlcnZpZXcgcG9zPXtwb3N9IHRpbWVFeHBpcmVzPXt0aW1lRXhwaXJlc30gdmFsSW5kZXg9ezJ9IC8+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2Nvb2wtYnV0dG9uICBhZGQtY2hhcnQtYnQgc2V0LXBvcycgb25DbGljaz17dGhpcy5wb3NTZXQoJ0NBTEwnKX0+UGxhY2UgT3JkZXI8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgaWQ9J0FzaycgY2xhc3NOYW1lPXt0aGlzLnN0YXRlLmFza09wZW4gPyAnYm91bmNlLWluLWZhc3QnIDogJ2hpZGUtZWxtJ30+XG4gICAgICAgICAgPHAgY2xhc3NOYW1lPSdwb3MtdHlwZS1oZWFkZXIgcHV0LXQnPlB1dCBQb3NpdGlvbjwvcD5cbiAgICAgICAgICA8aSBjbGFzc05hbWU9J21hdGVyaWFsLWljb25zIGNsb3NlLW1vZGFsJyBvbkNsaWNrPXt0aGlzLmNsb3NlTW9kYWx9PmNsZWFyPC9pPlxuICAgICAgICAgIDxBc2tCaWRPdmVydmlldyBwb3M9e3Bvc30gdGltZUV4cGlyZXM9e3RpbWVFeHBpcmVzfSB2YWxJbmRleD17MX0gLz5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nY29vbC1idXR0b24gIGFkZC1jaGFydC1idCBzZXQtcG9zJyBvbkNsaWNrPXt0aGlzLnBvc1NldCgnUFVUJyl9PlBsYWNlIE9yZGVyPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8cCBjbGFzc05hbWU9J3RleHQtd3JhcC12YWx1ZXMgdGltZS10aWNrZXIgdGltZS12JyBvbkNsaWNrPXt0aGlzLnRpbWVNZW51T3Blbn0+XG4gICAgICAgICAgPGNhbnZhcyBpZD17dGhpcy5wcm9wcy50aW1lcklkfSBoZWlnaHQ9ezE4fSB3aWR0aD17NjZ9PjwvY2FudmFzPlxuICAgICAgICA8L3A+XG4gICAgICAgIDxwIGNsYXNzTmFtZT0ndGV4dC13cmFwLXZhbHVlcyB0aW1lLXRpY2tlcic+XG4gICAgICAgICAgPHN0cm9uZz57dGhpcy5zdGF0ZS5xbnR5fTwvc3Ryb25nPlxuICAgICAgICA8L3A+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPSd0ZXh0LXdyYXAtdmFsdWVzIHBsdXMtbWludXMgc3ViLXYnIG9uQ2xpY2s9e3RoaXMucGx1c01pbnVzKC0xKX0+XG4gICAgICAgICAgPGkgY2xhc3NOYW1lPSdtYXRlcmlhbC1pY29ucyc+cmVtb3ZlPC9pPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9J3RleHQtd3JhcC12YWx1ZXMgcGx1cy1taW51cyBhZGQtdicgb25DbGljaz17dGhpcy5wbHVzTWludXMoMSl9PlxuICAgICAgICAgIDxpIGNsYXNzTmFtZT0nbWF0ZXJpYWwtaWNvbnMnPmFkZDwvaT5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxwIGNsYXNzTmFtZT0ncHJvZml0Jz5cbiAgICAgICAgICA3MSVcbiAgICAgICAgPC9wPlxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXsndHJhZGUtYnV0dCBwdXQtYnV0dCAnICsgYmlkQnRuQ2xhc3N9IG9uTW91c2VEb3duPXt0aGlzLmJ0blB0bnB1c2godHJ1ZSl9IG9uTW91c2VVcD17dGhpcy50b2dnbGVNZW51QmlkfT5cbiAgICAgICAgICA8aW1nIHNyYz0nL2ljb25zL2dhaW4ucG5nJy8+XG4gICAgICAgICAgPHN0cm9uZz5DYWxsPC9zdHJvbmc+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17J3RyYWRlLWJ1dHQgY2FsbC1idXR0ICcgKyBwdXRCdG5DbGFzc30gb25Nb3VzZURvd249e3RoaXMuYnRuUHRucHVzaChmYWxzZSl9IG9uTW91c2VVcD17dGhpcy50b2dnbGVNZW51QXNrfT5cbiAgICAgICAgICA8aW1nIHNyYz0nL2ljb25zL2xvc3MucG5nJy8+XG4gICAgICAgICAgPHN0cm9uZz5QdXQ8L3N0cm9uZz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29tcG9uZW50cy9kYXNoYm9hcmQvbGl2ZWdyYXBoL2J1eXNlbGwuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBDYWxsUHV0IGZyb20gJy4vYnV5c2VsbCc7XG5pbXBvcnQge1xuICBDSEFSVF9TVEFURV9VUERBVEVcbn0gZnJvbSAnY29uc3RhbnRzL2Rhc2hib2FyZCdcblxuY29uc3QgY2hhcnRPcHRzID0gKHR5cGUpID0+IHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnY2FuZGxlc3RpY2snOlxuICAgICAgcmV0dXJuIDxzcGFuIGRhdGEtdHA9J2NhbmRsZXN0aWNrJz5DYW5kbGVzdGljazxpbWcgZGF0YS10cD0nY2FuZGxlc3RpY2snIGhlaWdodD0nMTgnIHNyYz0nL2ljb25zL2NhbmRsZXN0aWNrLnBuZycvPjwvc3Bhbj47XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvaGxjJzpcbiAgICAgIHJldHVybiA8c3BhbiBkYXRhLXRwPSdvaGxjJz5PSExDPGltZyBkYXRhLXRwPSdvaGxjJyBoZWlnaHQ9JzE4JyBzcmM9Jy9pY29ucy9vaGxjLnBuZycvPjwvc3Bhbj47XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhcmVhJzpcbiAgICAgIHJldHVybiA8c3BhbiBkYXRhLXRwPSdhcmVhJz5BcmVhPGltZyBkYXRhLXRwPSdhcmVhJyBoZWlnaHQ9JzE4JyBzcmM9Jy9pY29ucy9hcmVhLnBuZycvPjwvc3Bhbj47XG4gICAgICBicmVhaztcbiAgICBjYXNlICdsaW5lJzpcbiAgICAgIHJldHVybiA8c3BhbiBkYXRhLXRwPSdsaW5lJz5MaW5lPGltZyBkYXRhLXRwPSdsaW5lJyBoZWlnaHQ9JzE4JyBzcmM9Jy9pY29ucy9saW5lLnBuZycvPjwvc3Bhbj47XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDxzcGFuIGRhdGEtdHA9J2FyZWEnPkFyZWE8aW1nIGRhdGEtdHA9J2FyZWEnIGhlaWdodD0nMTgnIHNyYz0nL2ljb25zL2FyZWEucG5nJy8+PC9zcGFuPjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYW52YXNDaGFydCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLmRiU291cmNlID0gcHJvcHMuZGF0YVNvdXJjZTtcbiAgICB0aGlzLmRhdGFQb2ludHMgPSBbXTtcblxuICAgIHRoaXMuZmVlZFdhdGNoID0gcHJvcHMubWFpblN5bTtcbiAgICB0aGlzLmN0eENoYXJ0ID0gbnVsbDtcbiAgICB0aGlzLmRiU291cmNlLmRpc3BhdGNoRXZlbnQodGhpcy5mZWVkV2F0Y2gsIChkZXRhaWxzKSA9PiB0aGlzLmxpdmVVcGRhdGUoZGV0YWlscykpO1xuXG4gIH1cbiAgZGlzcGF0Y2hDaGFuZ2UgPSAocGF5bG9hZCkgPT4gdGhpcy5wcm9wcy5kaXNwYXRjaCh7dHlwZTogQ0hBUlRfU1RBVEVfVVBEQVRFLCBjaGFydFN5bWJvbDogdGhpcy5wcm9wcy5tYWluU3ltLCBwYXlsb2FkOiBwYXlsb2FkfSlcbiAgdG9nZ2xlTW9kYWwgPSAoYm9vbCkgPT4gKCkgPT4gdGhpcy5kaXNwYXRjaENoYW5nZSh7bW9kYWxPcGVuOiBib29sfSk7XG4gIHRvZ2dsZVNldHMgPSAoYm9vbCkgPT4gKCkgPT4gdGhpcy5kaXNwYXRjaENoYW5nZSh7b3B0c09wZW46IGJvb2x9KTtcbiAgZGVwb3NpdENoYW5nZWQgPSAobnVtKSA9PiB0aGlzLnByb3BzLmRlcENoZyhudW0pO1xuICBuZXdQb3MgPSAocG9zKSA9PiB0aGlzLnByb3BzLm5ld1Bvcyhwb3MpO1xuICBoaWRlVUwgPSAoKSA9PiB0aGlzLmRpc3BhdGNoQ2hhbmdlKHtvcHRzT3BlbjogZmFsc2V9KTtcbiAgbGl2ZVVwZGF0ZSA9IChkYXRhKSA9PiB0aGlzLmN0eENoYXJ0LmRhdGFTdHJlYW0oZGF0YSk7XG5cbiAgY2hhcnRUeXBlU2VsID0gKGUpID0+IHtcbiAgICBpZiAoZS50YXJnZXQuY2xhc3NOYW1lID09PSAnc2VsZWN0ZWQtY2hhcnQnIHx8IGUudGFyZ2V0LnBhcmVudEVsZW1lbnQuY2xhc3NOYW1lID09PSAnc2VsZWN0ZWQtY2hhcnQnKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgbGV0IGNoYXJ0VHlwZSA9IGUudGFyZ2V0LmRhdGFzZXQudHA7XG4gICAgaWYgKGNoYXJ0VHlwZSkge1xuICAgICAgdGhpcy5kaXNwYXRjaENoYW5nZSh7Y2hhcnRUeXBlOiBjaGFydFR5cGUsIG9wdHNPcGVuOiBmYWxzZX0pO1xuXG4gICAgICB0aGlzLmN0eENoYXJ0LmNoYXJ0VHlwZShjaGFydFR5cGUpO1xuICAgIH1cbiAgfVxuICBjbG9zZUNoYXJ0ID0gKCkgPT4ge1xuICAgIGxldCBmZWVkRXhpdCA9ICdleGl0XycgKyB0aGlzLnByb3BzLm1haW5TeW07XG4gICAgdGhpcy5kYlNvdXJjZS5zZW5kKGZlZWRFeGl0KTtcbiAgICB0aGlzLnByb3BzLmNsQ3R4KHRoaXMucHJvcHMubWFpblN5bSlcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuY3R4Q2hhcnQgPSB0aGlzLnByb3BzLmN0eCh0aGlzLnByb3BzLm1haW5TeW0pO1xuICAgIGxldCBzeW1iQ2hhcnQgPSB7fTtcbiAgICBzeW1iQ2hhcnRbdGhpcy5wcm9wcy5tYWluU3ltXSA9IHtcbiAgICAgIGN0eENoYXJ0OiB0aGlzLmN0eENoYXJ0LFxuICAgICAgb3Blbjoge31cbiAgICB9O1xuICAgIHRoaXMucHJvcHMud2hlbk1vdW50ZWQoc3ltYkNoYXJ0KTtcbiAgICB0aGlzLmRiU291cmNlLnNlbmQodGhpcy5wcm9wcy5tYWluU3ltKTtcbiAgICB0aGlzLmRpc3BhdGNoQ2hhbmdlKHtjYWxsUHV0OiB0aGlzLnByb3BzLm1haW5TeW19KTtcbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAvL3JlbW92ZVNlcmllc1xuICAgIGxldCBmZWVkRXhpdCA9ICdleGl0XycgKyB0aGlzLnByb3BzLm1haW5TeW07XG4gICAgdGhpcy5kYlNvdXJjZS5zZW5kKGZlZWRFeGl0KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IHN0YXRlLCBtYWluU3ltIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGNoYXJ0VHlwZUxpcyA9IFsnY2FuZGxlc3RpY2snLCAnYXJlYScsICdvaGxjJywgJ2xpbmUnXS5tYXAoKGl0bSwgaWkpID0+IHtcbiAgICAgIGxldCBjbE5hbWUgPSBzdGF0ZS5jaGFydFR5cGUgPT09IGl0bSA/ICdzZWxlY3RlZC1jaGFydCcgOiAnJztcbiAgICAgIHJldHVybiA8bGkga2V5PXsnZ2V0LScgKyBpdG19IGRhdGEtdHA9e2l0bX0gY2xhc3NOYW1lPXtjbE5hbWV9PlxuICAgICAgICB7Y2hhcnRPcHRzKGl0bSl9XG4gICAgICA8L2xpPjtcbiAgICB9KTtcbiAgICByZXR1cm4gKFxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT0ncmVhbC10aW1lLWNoYXJ0Jz5cbiAgICAgICAgPGRpdiBpZD17dGhpcy5wcm9wcy5tYWluU3ltfSBjbGFzc05hbWU9J2NoYXJ0Q29udGFpbmVyIHJlZHVjdCc+PC9kaXY+XG4gICAgICAgIDxkaXYgaWQ9e21haW5TeW0gKyAnX3RyZW5kJ30gY2xhc3NOYW1lPSdjaGFydENvbnRhaW5lciByZWR1Y3QgdHJlbmRsaW5lLWN0eCc+XG4gICAgICAgICAgPGNhbnZhcyBoZWlnaHQ9JzgwMCcgd2lkdGg9JzQ2JyBjbGFzc05hbWU9J2Zsb2F0UmlnaHRzJz48L2NhbnZhcz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPSdjaGFydC1zd2l0Y2gnPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdzZWNsZWN0LWNoYXJ0LWJ1dHQnPlxuICAgICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLnRvZ2dsZVNldHModHJ1ZSl9IGNsYXNzTmFtZT17c3RhdGUub3B0c09wZW4gPyAnaGlkZS1lbG0nIDogJ2N1cnJlbnQtdHlwZSd9PlxuICAgICAgICAgICAgICA8c3Bhbj57c3RhdGUuY2hhcnRUeXBlfTwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPSdtYXRlcmlhbC1pY29ucyBzbWFsbC1pJz5hcnJvd19kcm9wX2Rvd248L2k+XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPHVsIGNsYXNzTmFtZT17c3RhdGUub3B0c09wZW4gPyAnY2hhcnQtc2VsZWN0LXVsJyA6ICdoaWRlLWVsbSd9IG9uTW91c2VMZWF2ZT17dGhpcy5oaWRlVUx9IG9uQ2xpY2s9e3RoaXMuY2hhcnRUeXBlU2VsfT5cbiAgICAgICAgICAgICAge2NoYXJ0VHlwZUxpc31cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLnRvZ2dsZU1vZGFsKHRydWUpfSBjbGFzc05hbWU9J2NoYXJ0LXJlbW92ZSc+XG4gICAgICAgICAgICA8c3Bhbj5DbG9zZTwvc3Bhbj5cbiAgICAgICAgICAgIDxpIGNsYXNzTmFtZT0nbWF0ZXJpYWwtaWNvbnMnPmNsZWFyPC9pPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAge1xuICAgICAgICAgIHN0YXRlLmNhbGxQdXQgIT09IG51bGwgJiZcbiAgICAgICAgICA8Q2FsbFB1dCBtYWluU3ltPXttYWluU3ltfSBuZXdQb3M9e3RoaXMubmV3UG9zfSBkZXBvc2l0Q2hhbmdlZD17dGhpcy5kZXBvc2l0Q2hhbmdlZH0gY3R4Q2hhcnQ9e3RoaXMuY3R4Q2hhcnR9IHRpbWVySWQ9e21haW5TeW0gKyAnX2Nsb2NrJ30gY2xvY2tDdHg9e3RoaXMucHJvcHMuY2xvY2t9Lz5cbiAgICAgICAgfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3RhdGUubW9kYWxPcGVuID8gJ3dhcm4tbW9kYWwgZmFkZS1pbi1mYXN0JyA6ICdoaWRlLWVsbSd9PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdoZWFkaW5nLWJsb2NrJz5cbiAgICAgICAgICAgIDxpIGNsYXNzTmFtZT0nbWF0ZXJpYWwtaWNvbnMnPndhcm5pbmc8L2k+XG4gICAgICAgICAgICA8c3Bhbj5GWUk8L3NwYW4+XG4gICAgICAgICAgICA8cD5DbG9zaW5nIHRoaXMgbW9kYWwgd2lsbCBjbG9zZSB5b3VyIEZlZWQgbGlzdGVuZXIgZm9yXG4gICAgICAgICAgICAgIDxiPnt0aGlzLnByb3BzLm1haW5TeW19PC9iPlxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLmNsb3NlQ2hhcnR9IGNsYXNzTmFtZT0nY29vbC1idXR0b24gYWdyZWUtb2snPkkga25vdzwvZGl2PlxuICAgICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLnRvZ2dsZU1vZGFsKGZhbHNlKX0gY2xhc3NOYW1lPSdjb29sLWJ1dHRvbiBkaXNhZ3JlZS1vayc+TmV2ZXJtaW5kPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL2NvbXBvbmVudHMvZGFzaGJvYXJkL2xpdmVncmFwaC9jYW52YXNjaGFydC5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFRpY2tDYXJkIGZyb20gJ21pY3JvL3RpY2tlcnMvdGlja2NhcmQnO1xuaW1wb3J0IFRpY2tlclZpZXcgZnJvbSAnbWljcm8vdGlja2Vycy90aWNrZXJ2aWV3JztcblxuY29uc3QgbGwgPSBbXG4gIHtcbiAgICBzeW1iOiAnQVVEL0pQWScsXG4gICAgcHJjOiA3OS4wMTNcbiAgfSwge1xuICAgIHN5bWI6ICdBVUQvVVNEJyxcbiAgICBwcmM6IDAuNzU4OFxuICB9LCB7XG4gICAgc3ltYjogJ0NBRC9DSEYnLFxuICAgIHByYzogMC43NTE0XG4gIH0sIHtcbiAgICBzeW1iOiAnRVVSL0FVRCcsXG4gICAgcHJjOiAxLjQ2OTRcbiAgfSwge1xuICAgIHN5bWI6ICdFVVIvQ0FEJyxcbiAgICBwcmM6IDEuNDQwNjVcbiAgfSwge1xuICAgIHN5bWI6ICdFVVIvR0JQJyxcbiAgICBwcmM6IDAuODM2OFxuICB9LCB7XG4gICAgc3ltYjogJ0VVUi9KUFknLFxuICAgIHByYzogMTEyLjg5XG4gIH0sIHtcbiAgICBzeW1iOiAnVVNEL0JSTCcsXG4gICAgcHJjOiAzLjg1Mzk3XG4gIH0sIHtcbiAgICBzeW1iOiAnVVNEL0NBRCcsXG4gICAgcHJjOiAxLjMxMjUyXG4gIH0sIHtcbiAgICBzeW1iOiAnR0JQL0pQWScsXG4gICAgcHJjOiAxMzguOTIxXG4gIH0sIHtcbiAgICBzeW1iOiAnR0JQL1VTRCcsXG4gICAgcHJjOiAxLjMzMjVcbiAgfVxuXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl2ZVRpY2tlcnMgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGFjdGl2ZTogMCxcbiAgICAgIGNhcmRsaXN0OiBsbCxcbiAgICAgIGxlZnRDYXJkOiBudWxsLFxuICAgICAgdXBkYXRlVmlld2VkOiBudWxsLFxuICAgICAgdmlld2VkVGlja2VyOiBsbFswXSxcbiAgICAgIGFwcGx5T3V0QW5pOiA4OCxcbiAgICAgIGhvdmVyZWRDYXJkOiBudWxsLFxuICAgICAgZHJhZ2dlZENhcmQ6IG51bGxcblxuICAgIH1cbiAgfTtcbiAgY2FyZFBvc3Rpb25DbGljayA9IChpbmQpID0+IHtcbiAgICBsZXQge2xlZnRDYXJkLCBob3ZlcmVkQ2FyZCwgdXBkYXRlVmlld2VkLCBjYXJkbGlzdH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChob3ZlcmVkQ2FyZCAhPT0gbGVmdENhcmQgJiYgaG92ZXJlZENhcmQgIT09IG51bGwgJiYgdXBkYXRlVmlld2VkICE9PSBudWxsKSB7XG4gICAgICB0aGlzLndoZW5Ecm9wKGhvdmVyZWRDYXJkKTtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBsZXQgY2FyZFN5bWJvbCA9IHVwZGF0ZVZpZXdlZCA/IHVwZGF0ZVZpZXdlZCA6IGNhcmRsaXN0W2luZF07XG4gICAgbGV0IHByaWNlID0gY2FyZFN5bWJvbC5wcmMgPCAxMCA/IE1hdGgucm91bmQoY2FyZFN5bWJvbC5wcmMgKiAxMDApIDogTWF0aC5yb3VuZChjYXJkU3ltYm9sLnByYyk7XG4gICAgdGhpcy5wcm9wcy5jYXJkQ3R4LmNoYXJ0Vmlldy5uZXdTZXQoY2FyZFN5bWJvbC5zeW1iLCBwcmljZSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBhY3RpdmU6IGluZCxcbiAgICAgIGNhcmRsaXN0OiBjYXJkbGlzdCxcbiAgICAgIGFwcGx5T3V0QW5pOiBudWxsLFxuICAgICAgdXBkYXRlVmlld2VkOiBudWxsLFxuICAgICAgZHJhZ2dlZENhcmQ6IG51bGwsXG4gICAgICBsZWZ0Q2FyZDogbnVsbCxcbiAgICAgIGhvdmVyZWRDYXJkOiBudWxsLFxuICAgICAgdmlld2VkVGlja2VyOiBjYXJkU3ltYm9sXG4gICAgfSlcbiAgfVxuICBjYXJkRHJhZ1N0YXJ0ID0gKGluZGV4KSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7ZHJhZ2dlZENhcmQ6IGluZGV4LCBhcHBseU91dEFuaTogbnVsbH0pXG5cbiAgfTtcbiAgZHJhZ092ZXJDYXJkID0gKGluZGV4KSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7aG92ZXJlZENhcmQ6IGluZGV4fSlcblxuICB9O1xuICBzaWRlRW50ZXIgPSAoZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdzaWRlRW50ZXJlZCcpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGxldCB7Y2FyZGxpc3QsIGRyYWdnZWRDYXJkfSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5zZXRTdGF0ZSh7dXBkYXRlVmlld2VkOiBjYXJkbGlzdFtkcmFnZ2VkQ2FyZF19KTtcbiAgfVxuICBzaWRlTGVhdmUgPSAoZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdzaWRlTGVmdCcpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHRoaXMuc2V0U3RhdGUoe3VwZGF0ZVZpZXdlZDogbnVsbH0pO1xuICB9XG4gIGRyYWdMZWZ0Q2FyZCA9IChpbmRleCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe2xlZnRDYXJkOiBpbmRleH0pXG5cbiAgfTtcbiAgb25EcmFnT3ZlciA9IChlKSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIH1cbiAgc2lkZURyb3AgPSAoKSA9PiB7XG4gICAgbGV0IGNhcmRsaXN0ID0gdGhpcy5zdGF0ZS5jYXJkbGlzdDtcbiAgICBsZXQgY2FyZFN5bWJvbCA9IHRoaXMuc3RhdGUudXBkYXRlVmlld2VkO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjYXJkbGlzdDogY2FyZGxpc3QsXG4gICAgICB1cGRhdGVWaWV3ZWQ6IG51bGwsXG4gICAgICB2aWV3ZWRUaWNrZXI6IGNhcmRTeW1ib2wsXG4gICAgICBhcHBseU91dEFuaTogbnVsbCxcbiAgICAgIGxlZnRDYXJkOiBudWxsLFxuICAgICAgZHJhZ2dlZENhcmQ6IG51bGxcbiAgICB9KVxuXG4gIH1cbiAgZHJvcEhhbmRsZSA9ICgpID0+IHtcbiAgICBsZXQge2NhcmRsaXN0LCB1cGRhdGVWaWV3ZWR9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQgZHJhZ2dlZFN5bWIgPSBjYXJkbGlzdFt0aGlzLnN0YXRlLmRyYWdnZWRDYXJkXTtcbiAgICBsZXQgY2FyZGxzdCA9IGNhcmRsaXN0LnJlZHVjZSgob2JiLCBpdG0sIGkpID0+IHtcbiAgICAgIGlmIChpdG0uc3ltYiAhPT0gZHJhZ2dlZFN5bWIuc3ltYikge1xuICAgICAgICBvYmIucHVzaChpdG0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JiO1xuICAgIH0sIFtdKTtcblxuICAgIGNhcmRsc3QucHVzaChkcmFnZ2VkU3ltYik7XG4gICAgbGV0IGNhcmRTeW1ib2wgPSB1cGRhdGVWaWV3ZWQgPyBkcmFnZ2VkU3ltYiA6IHRoaXMuc3RhdGUudmlld2VkVGlja2VyO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY2FyZGxpc3Q6IGNhcmRsaXN0LFxuICAgICAgaG92ZXJlZENhcmQ6IG51bGwsXG4gICAgICB1cGRhdGVWaWV3ZWQ6IG51bGwsXG4gICAgICB2aWV3ZWRUaWNrZXI6IGNhcmRTeW1ib2wsXG4gICAgICBhcHBseU91dEFuaTogY2FyZGxzdC5sZW5ndGggLSAxLFxuICAgICAgbGVmdENhcmQ6IG51bGwsXG4gICAgICBkcmFnZ2VkQ2FyZDogbnVsbFxuICAgIH0pXG5cbiAgfVxuICBkcmFnRW50ZXIgPSAoZSkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gIH07XG4gIGNhcmREcm9wcGVkID0gKGluZGV4KSA9PiB7XG4gICAgbGV0IGRyYWdnZWRTeW1iID0gdGhpcy5zdGF0ZS5jYXJkbGlzdFt0aGlzLnN0YXRlLmRyYWdnZWRDYXJkXTtcbiAgICBsZXQgY2FyZGxpc3QgPSB0aGlzLnN0YXRlLmNhcmRsaXN0LnJlZHVjZSgob2JiLCBpdG0sIGkpID0+IHtcbiAgICAgIGlmIChpbmRleCA9PT0gaSkge1xuICAgICAgICBvYmIucHVzaChkcmFnZ2VkU3ltYik7XG4gICAgICB9XG4gICAgICBpZiAoaXRtLnN5bWIgIT09IGRyYWdnZWRTeW1iLnN5bWIpIHtcbiAgICAgICAgb2JiLnB1c2goaXRtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iYjtcbiAgICB9LCBbXSk7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtjYXJkbGlzdDogY2FyZGxpc3QsIGhvdmVyZWRDYXJkOiBudWxsLCBhcHBseU91dEFuaTogaW5kZXgsIGxlZnRDYXJkOiBudWxsLCBkcmFnZ2VkQ2FyZDogbnVsbH0pXG4gIH1cbiAgZHJhZ0xlYXZlID0gKGUpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICB9O1xuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnByb3BzLmNhcmRDdHguY2hhcnRWaWV3LnN5bWIgPSBsbFswXS5zeW1iO1xuICAgIHRoaXMucHJvcHMuY2FyZEN0eC5jaGFydFZpZXcucHJpY2VTZWVkID0gbGxbMF0ucHJjO1xuICAgIHRoaXMucHJvcHMuY2FyZEN0eC5jaGFydFZpZXcucmVuZGVyKCk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7ZHJhZ2dlZENhcmQsIGFwcGx5T3V0QW5pfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgdGlja0NhcmRzID0gdGhpcy5zdGF0ZS5jYXJkbGlzdC5tYXAoKGl0bSwgaSkgPT4ge1xuICAgICAgbGV0IGFuaW1hdGlvbiA9ICcnXG4gICAgICBpZiAoYXBwbHlPdXRBbmkgPT09IGkgfHwgZHJhZ2dlZENhcmQgPT09IGkpIHtcbiAgICAgICAgYW5pbWF0aW9uID0gaSA9PT0gZHJhZ2dlZENhcmQgPyAnc2NhbGVTbWFsbCAgZWFzZS1vdXQgMC40cyAxIGZvcndhcmRzJyA6ICdncm93QmlnICBlYXNlLW91dCAwLjNzIDEgZm9yd2FyZHMnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8VGlja0NhcmRcbiAgICAgICAgICBrZXk9e2kgKyAnX3d3J31cbiAgICAgICAgICBhY3RpdmU9e3RoaXMuc3RhdGUuYWN0aXZlID09PSBpfVxuICAgICAgICAgIGFwcGx5T3V0PXthcHBseU91dEFuaSA9PT0gaX1cbiAgICAgICAgICBjYXJkQ3R4PXt0aGlzLnByb3BzLmNhcmRDdHh9XG4gICAgICAgICAgYW5pbWF0aW9uPXthbmltYXRpb259XG4gICAgICAgICAgY2FyZElkPXtgY2FyZF8ke2l0bS5zeW1ifWB9XG4gICAgICAgICAgY2FyZFBvc3Rpb25DbGljaz17dGhpcy5jYXJkUG9zdGlvbkNsaWNrfVxuICAgICAgICAgIGRyYWdMZWZ0Q2FyZD17dGhpcy5kcmFnTGVmdENhcmR9XG4gICAgICAgICAgZHJhZ092ZXJDYXJkPXt0aGlzLmRyYWdPdmVyQ2FyZH1cbiAgICAgICAgICBjYXJkRHJvcHBlZD17dGhpcy5jYXJkRHJvcHBlZH1cbiAgICAgICAgICBjYXJkRHJhZ1N0YXJ0PXt0aGlzLmNhcmREcmFnU3RhcnR9XG4gICAgICAgICAgaW5kZXg9e2l9XG4gICAgICAgICAgc3ltYm9sPXtpdG19Lz5cbiAgICAgICAgKVxuICAgIH0pO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT0nY29udGFpbmVyLWZsdWlkIHdyYXBwZXInPlxuICAgICAgICA8c2VjdGlvbiBpZD0nY2FyZENvbnRhaW4nPlxuICAgICAgICAgIHt0aWNrQ2FyZHN9XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9J3RyYWRlLWNhcmQtaG9sZGVyIG5vcm1hbC1jbGFzcyc+XG4gICAgICAgICAgICA8ZGl2IGlkPSdBZGRUaWNrZXInIG9uRHJhZ092ZXI9e3RoaXMuZHJhZ0VudGVyfSBvbkRyb3A9e3RoaXMuZHJvcEhhbmRsZX0+XG4gICAgICAgICAgICAgIDxpIGNsYXNzTmFtZT0nZmEgZmEtcGx1cyBiaWctZmEnIGFyaWEtaGlkZGVuPSd0cnVlJz48L2k+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9J3NpZGUtbG9vay1hdCcgb25EcmFnRW50ZXI9e3RoaXMuc2lkZUVudGVyfSBvbkRyb3A9e3RoaXMuZHJvcEhhbmRsZX0gb25EcmFnTGVhdmU9e3RoaXMuc2lkZUxlYXZlfT5cbiAgICAgICAgICA8VGlja2VyVmlldyBzeW1ib2w9e3RoaXMuc3RhdGUudmlld2VkVGlja2VyfS8+XG4gICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgPHNlY3Rpb24gaWQ9J2JvdHRvbUxvb2tVcCc+PC9zZWN0aW9uPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL2NvbXBvbmVudHMvZGFzaGJvYXJkL2xpdmV0aWNrZXJzLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFjdGl2ZVNwcmVhZHMgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5DVFhzcHJlYWQgPSBudWxsO1xuICAgIHRoaXMuZGJTb3VyY2UgPSBwcm9wcy5kYXRhU291cmNlO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB0cmFja2VkQmlkczogW10sXG4gICAgICBvblZpZXc6IGZhbHNlXG4gICAgfTtcblxuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuQ1RYc3ByZWFkID0gdGhpcy5wcm9wcy5jYWxsQ1QoKVxuICAgIHRoaXMuQ1RYc3ByZWFkLnNlZWRTcHJlYWQoKTtcbiAgICB0aGlzLnByb3BzLnNldFNwcmVhZFJlZih0aGlzLkNUWHNwcmVhZCk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT0nYWN0aXZlLXNwcmVhZHMnPlxuICAgICAgICA8dWwgY2xhc3NOYW1lPSdzcHJlYWQtbGFiZWxzJz5cbiAgICAgICAgICA8bGkgY2xhc3NOYW1lPSdpbmRleC1saSc+SW5kZXg8L2xpPlxuICAgICAgICAgIDxsaT5Bc2s8L2xpPlxuICAgICAgICAgIDxsaT5CaWQ8L2xpPlxuICAgICAgICAgIDxsaT4lPC9saT5cbiAgICAgICAgPC91bD5cbiAgICAgICAgPGNhbnZhcyBpZD0nYWN0aXZlU3ByZWFkcycgd2lkdGg9JzIwMCcgaGVpZ2h0PSc2NTAnPjwvY2FudmFzPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL2NvbXBvbmVudHMvZGFzaGJvYXJkL29wdGlvbnMvYWN0aXZlc3ByZWFkcy5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3NpdGlvblRpbGUgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5wcm9wcy5wb3NUaWxlQ1RYLnNldFRpbGUodGhpcy5wcm9wcy5wb3MsIHRoaXMucHJvcHMucG9zLmN0eGlkKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgbGV0IHtwb3N9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gKFxuICAgICAgPGxpIGNsYXNzTmFtZT17cG9zLnR5cGUgPT09ICdDQUxMJyA/ICdwb3MtYmxvY2sgcG9zLWNhbGwnIDogJ3Bvcy1ibG9jayBwb3MtcHV0J30+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPSdzcGFuLWxhYmVsLWJsdWUgdGgtc3BhbiBkaXYtc3ltYi1ob2xkJz57cG9zLnN5bWJ9PC9kaXY+XG4gICAgICAgIDxkaXY+e3Bvcy5xdHl9PC9kaXY+XG4gICAgICAgIDxjYW52YXMgaWQ9e3Bvcy5jdHhpZH0gd2lkdGg9JzEwMCcgaGVpZ2h0PSczMCc+PC9jYW52YXM+XG4gICAgICA8L2xpPlxuXG4gICAgKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29tcG9uZW50cy9kYXNoYm9hcmQvb3B0aW9ucy9wb3NpdGlvblRpbGVzLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUG9zaXRpb25UaWxlIGZyb20gJy4vcG9zaXRpb25UaWxlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdhdGNoZWRTcHJlYWRzIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICB9XG4gIGN1cnJlbnRCbG9ja3MgPSAoYWN0aXZlUG9zTGlzdCwgcG9zQ1RYKSA9PiBhY3RpdmVQb3NMaXN0Lm1hcCggKGl0bSkgPT4gKFxuICAgIDxQb3NpdGlvblRpbGUga2V5PXtpdG0uY3R4aWQgKyAnXycgKyBpdG0udHlwZX0gcG9zVGlsZUNUWD17cG9zQ1RYfSBwb3M9e2l0bX0vPlxuICApKVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge2FjdGl2ZVBvc0xpc3QsIFBvc2l0aW9uVGlsZXN9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9J2FjdGl2ZS1zcHJlYWRzIHdhdGNoZWQtc3ByZWFkcyc+XG4gICAgICAgIHsgYWN0aXZlUG9zTGlzdC5sZW5ndGggPT09IDAgJiYgPGRpdiBjbGFzc05hbWU9J25vLXBvc2l0aW9ucyc+Tm8gQWN0aXZlIFBvc2l0aW9uczwvZGl2PiB9XG4gICAgICAgIDx1bCBjbGFzc05hbWU9J3Bvcy1ibG9ja3MnPlxuICAgICAgICAgIHsgdGhpcy5jdXJyZW50QmxvY2tzKGFjdGl2ZVBvc0xpc3QsIFBvc2l0aW9uVGlsZXMpIH1cbiAgICAgICAgPC91bD5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL2NvbXBvbmVudHMvZGFzaGJvYXJkL29wdGlvbnMvd2F0Y2hlZHNwcmVhZHMuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2lkZU9wdGlvbnMgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cbiAgb3B0aW9uVmlldyA9ICh0eXBlKSA9PiAoKSA9PiB0aGlzLnByb3BzLml0bVZpZXcodHlwZSlcbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtwbGF0Zm9ybVZpZXcsIG9wdHNDb21wb25lbnQsIHRkQ2xhc3MsIG9uU3RhcnR9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBpZD0nc2lkZU9wdGlvbnMnIGNsYXNzTmFtZT17b25TdGFydCA/ICdoaWRlLWVsbScgOiAnJ30+XG4gICAgICAgIDxkaXYgb25DbGljaz17dGhpcy5vcHRpb25WaWV3KCdvdmVydmlldycpfSBjbGFzc05hbWU9e3BsYXRmb3JtVmlldyA9PT0gJ3RyYWRlIGhpc3RvcnknID8gJ29wdHMtYnV0dG9uIG9wdHMtYWN0aXZlLXNlYycgOiAnb3B0cy1idXR0b24nfT5cbiAgICAgICAgICA8aSBjbGFzc05hbWU9J21hdGVyaWFsLWljb25zJz51cGRhdGU8L2k+XG4gICAgICAgICAgPHA+VFJBRElORyBISVNUT1JZPC9wPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLm9wdGlvblZpZXcoJ2NoYXJ0cycpfSBjbGFzc05hbWU9e3BsYXRmb3JtVmlldyA9PT0gJ2xpdmUgZ3JhcGhzJyA/ICdvcHRzLWJ1dHRvbiBvcHRzLWFjdGl2ZS1zZWMnIDogJ29wdHMtYnV0dG9uJ30+XG4gICAgICAgICAgPGkgY2xhc3NOYW1lPSdmYSBmYS1saW5lLWNoYXJ0IGZpeC1mYScgYXJpYS1oaWRkZW49J3RydWUnPjwvaT5cbiAgICAgICAgICA8cD5DSEFSVFM8L3A+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IG9uQ2xpY2s9e3RoaXMub3B0aW9uVmlldygnY3VycmVudC1iaWRzJyl9IGNsYXNzTmFtZT17KG9wdHNDb21wb25lbnQgPT09ICdjdXJyZW50LWJpZHMnICYmIHRkQ2xhc3MpID8gJ29wdHMtYnV0dG9uIG9wdHMtYWN0aXZlJyA6ICdvcHRzLWJ1dHRvbid9PlxuICAgICAgICAgIDxpIGNsYXNzTmFtZT0nbWF0ZXJpYWwtaWNvbnMnPmV2ZW50X2F2YWlsYWJsZTwvaT5cbiAgICAgICAgICA8cD5QT1NJVElPTlM8L3A+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IG9uQ2xpY2s9e3RoaXMub3B0aW9uVmlldygnc3ByZWFkcycpfSBjbGFzc05hbWU9eyhvcHRzQ29tcG9uZW50ID09PSAnc3ByZWFkcycgJiYgdGRDbGFzcykgPyAnb3B0cy1idXR0b24gb3B0cy1hY3RpdmUnIDogJ29wdHMtYnV0dG9uJ30+XG4gICAgICAgICAgPGkgY2xhc3NOYW1lPSdtYXRlcmlhbC1pY29ucyc+dmlld19saXN0PC9pPlxuICAgICAgICAgIDxwPk9QVElPTlM8L3A+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IG9uQ2xpY2s9e3RoaXMub3B0aW9uVmlldygnbGl2ZSBvcHRpb25zJyl9IGNsYXNzTmFtZT17cGxhdGZvcm1WaWV3ID09PSAnbGl2ZSBvcHRpb25zJyA/ICdvcHRzLWJ1dHRvbiBvcHRzLWFjdGl2ZS1zZWMnIDogJ29wdHMtYnV0dG9uJ30+XG4gICAgICAgICAgPGkgY2xhc3NOYW1lPSdtYXRlcmlhbC1pY29ucyc+dmlld19jb21wYWN0PC9pPlxuICAgICAgICAgIDxwPk9QVElPTlM8L3A+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IG9uQ2xpY2s9e3RoaXMub3B0aW9uVmlldygncGFzdC1wb3MnKX0gY2xhc3NOYW1lPXtwbGF0Zm9ybVZpZXcgPT09ICd0cmFkZSBsaXN0JyA/ICdvcHRzLWJ1dHRvbiBvcHRzLWFjdGl2ZS1zZWMnIDogJ29wdHMtYnV0dG9uJ30+XG4gICAgICAgICAgPGkgY2xhc3NOYW1lPSdtYXRlcmlhbC1pY29ucyc+d2F0Y2hfbGF0ZXI8L2k+XG4gICAgICAgICAgPHA+SElTVE9SWTwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29tcG9uZW50cy9kYXNoYm9hcmQvc2lkZW9wdGlvbnMuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IEluZm9MaSBmcm9tIFwiLi9oaXN0b3J5L2luZm9saVwiO1xuaW1wb3J0IFN0YXRUaWxlcyBmcm9tIFwiLi9oaXN0b3J5L3N0YXRzdGlsZXNcIjtcbmltcG9ydCBQb3NpdGlvblZpZXcgZnJvbSBcIi4vaGlzdG9yeS9wb3NpdGlvbnZpZXdcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhbnNhY3Rpb25MaXN0IGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMubGFzdCA9IHByb3BzLnBhc3RUcmFkZXMubGVuZ3RoO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBhY3RpdmU6IDAsXG4gICAgICBhbmltYXRlOiB0cnVlXG5cbiAgICB9XG4gIH07XG4gIHBvc3Rpb25DbGljayA9IChwb3MsIGluZCkgPT4gdGhpcy5zZXRTdGF0ZSh7YWN0aXZlOiBpbmR9KVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge3Bhc3RUcmFkZXMsIGluVmlldywgU3ZnQ0IsIEdyYXBoQ29udHJvbGxlcn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGZpcnN0Q2xhc3MgPSAodGhpcy5sYXN0IDwgcGFzdFRyYWRlcy5sZW5ndGggJiYgaW5WaWV3KTtcbiAgICBjb25zdCBhY3RpdmVJbmRleCA9IHRoaXMuc3RhdGUuYWN0aXZlID8gdGhpcy5zdGF0ZS5hY3RpdmUgOiAwO1xuICAgIGNvbnN0IHBhc3RUcmFkZUxpc3QgPSBwYXN0VHJhZGVzLm1hcCgoaXRtLCBpKSA9PiAoXG4gICAgICA8SW5mb0xpXG4gICAgICAgIGNsaWNrZWQ9e3RoaXMucG9zdGlvbkNsaWNrfVxuICAgICAgICBrZXk9e2l9XG4gICAgICAgIGFkZFN0eWxlPXtpID09PSAwID8gZmlyc3RDbGFzcyA6IGZhbHNlfVxuICAgICAgICBhY3RpdmU9e2FjdGl2ZUluZGV4ID09PSBpfVxuICAgICAgICBpbmRleD17aX1cbiAgICAgICAgYW5pbWF0ZT17dGhpcy5zdGF0ZS5hbmltYXRlfVxuICAgICAgICBwb3M9e2l0bX0vPlxuICAgICAgKVxuICAgIClcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXItZmx1aWQgd3JhcHBlclwiPlxuICAgICAgICA8U3RhdFRpbGVzIFN2Z0NCPXtTdmdDQn0gdHJhZGVQcm9wcz17dGhpcy5wcm9wc30vPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWQtbGluZS1saXN0XCI+XG4gICAgICAgICAgPHN0cm9uZz5QYXN0IFRyYW5zYWN0aW9uczwvc3Ryb25nPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1sZy03IGNvbC1tZC02XCI+XG4gICAgICAgICAgICA8UG9zaXRpb25WaWV3IGluVmlldz17aW5WaWV3fSBHcmFwaENvbnRyb2xsZXI9e0dyYXBoQ29udHJvbGxlcn0gcG9zPXtwYXN0VHJhZGVzW2FjdGl2ZUluZGV4XX0vPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidHJhZGUtdWwtbGlzdCBjb2wtbGctNSBjb2wtbWQtNlwiPlxuICAgICAgICAgICAgPHVsIGlkPVwicGFzdFRyYWRlc1wiPlxuICAgICAgICAgICAgICB7cGFzdFRyYWRlTGlzdH1cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKX1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29tcG9uZW50cy9kYXNoYm9hcmQvdHJhbnNhY3Rpb25saXN0LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge2Nvbm5lY3R9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCBGdWxsV2lkZ2V0IGZyb20gJy4vd2lkZ2V0cy9mdWxsd2lkZ2V0JztcbmltcG9ydCBEQVRBU09VUkNFIGZyb20gJ2RhdGEvZGF0YXNvdXJjZSc7XG5pbXBvcnQge1xuICBXSURHRVRfRFJPUCxcbiAgV0lER0VUX0RSQUdHRUQsXG4gIEdPVF9NRVNTQUdFLFxuICBHT1RfREFUQVxufSAgZnJvbSAnY29uc3RhbnRzL3dpZGdldHMnXG5cblxuXG5mdW5jdGlvbiBzZWxlY3Qoc3RvcmUpIHtcbiAgLy8gSG93IERpZmZyZW50IFJlZHV4IHN0b3JlcyBnZXQgbWFwcGVkIHRvIHByb3BzXG4gIHJldHVybiB7d2lkZ2V0czogc3RvcmUud2lkZ2V0c31cbn1cblxuY2xhc3MgV2lkZ2V0QmxvY2sgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICBzdXBlcihwcm9wcyk7XG4gICAgICB0aGlzLmRiU291cmNlID0gREFUQVNPVVJDRTtcbiAgIH07XG4gICB1cGRhdGVXaWRnZXQgPSAoZHRhKSA9PiB7fVxuICAgZ2V0TWVzc2FnZSA9IChtZXNzLCB3aWQpID0+IHtcbiAgICAgIGxldCBuZXdXYWl0ID0ge307XG4gICAgICBuZXdXYWl0W21lc3NdID0gd2lkO1xuICAgICAgdGhpcy5wcm9wcy5kaXNwYXRjaCh7dHlwZTogR09UX01FU1NBR0UsIHBheWxvYWQ6IG5ld1dhaXR9KVxuICAgICAgdGhpcy5kYlNvdXJjZS5nZXRNYXJrZXREYXRhWEhSKG1lc3MsIHRoaXMuZ290RGF0YSk7XG4gICB9XG4gICBkcm9wSGFuZGxlID0gKHdpZGdldE51bSkgPT4gKCkgPT4ge1xuICAgICAgY29uc3QgeyBkcmFnZ2VkV2lkZ2V0IH0gPSB0aGlzLnByb3BzLndpZGdldHM7XG4gICAgICBjb25zdCBzdGF0ZUNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLndpZGdldHMsXG4gICAgICAgIHtcbiAgICAgICAgICBkcmFnZ2VkV2lkZ2V0OiBudWxsLFxuICAgICAgICAgIFdpZGdldExpc3Q6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMud2lkZ2V0cy5XaWRnZXRMaXN0KVxuICAgICAgICB9KVxuICAgICAgc3RhdGVDb3B5LldpZGdldExpc3RbZHJhZ2dlZFdpZGdldF0gPSAgdGhpcy5wcm9wcy53aWRnZXRzW2RyYWdnZWRXaWRnZXRdLmRhdGE7XG4gICAgICBzdGF0ZUNvcHkuV2lkZ2V0TGlzdFt3aWRnZXROdW1dID0gdGhpcy5wcm9wcy53aWRnZXRzW3dpZGdldE51bV0uZGF0YTtcblxuICAgICAgc3RhdGVDb3B5W2RyYWdnZWRXaWRnZXRdID0gdGhpcy5wcm9wcy53aWRnZXRzW3dpZGdldE51bV07XG4gICAgICBzdGF0ZUNvcHlbd2lkZ2V0TnVtXSA9IHRoaXMucHJvcHMud2lkZ2V0c1tkcmFnZ2VkV2lkZ2V0XTtcblxuICAgICAgdGhpcy5wcm9wcy5kaXNwYXRjaCh7dHlwZTogV0lER0VUX0RST1AsIHBheWxvYWQ6IHN0YXRlQ29weX0pO1xuXG4gICB9O1xuICAgaGFuZGxlRHJhZ0V2ID0gKHdpZGdldCwgZGF0YSkgPT4ge1xuXG4gICAgICB0aGlzLnByb3BzLmRpc3BhdGNoKHt0eXBlOiBXSURHRVRfRFJBR0dFRCwgcGF5bG9hZDogd2lkZ2V0fSk7XG5cbiAgIH07XG4gICBvbkRyYWdPdmVyKGUpe1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICB9XG4gICBkcmFnRW50ZXIoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgIH07XG4gICBkcmFnTGVhdmUoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgIH07XG4gICBnb3REYXRhID0gKGRldGFpbHMpID0+IHtcbiAgICAgIGNvbnN0IHsgV2lkZ2V0TGlzdCwgbmVlZHNVcGRhdGUgfSA9IE9iamVjdC5hc3NpZ24oe30sdGhpcy5wcm9wcy53aWRnZXRzKTtcbiAgICAgIGNvbnNvbGUubG9nKCduZWVkc1VwZGF0ZScsIG5lZWRzVXBkYXRlKTtcbiAgICAgIGNvbnN0IG5lZWRzVXBkYXRlS2V5ID0gZGV0YWlscy5yZXN1bHRzWzBdLnN5bWJvbDtcbiAgICAgIGxldCB3aWRnZXROdW0gPSBuZWVkc1VwZGF0ZVtuZWVkc1VwZGF0ZUtleV07XG5cbiAgICAgIFdpZGdldExpc3Rbd2lkZ2V0TnVtXS5jb250ZW50LmRhdGEgPSBkZXRhaWxzLnJlc3VsdHM7XG5cbiAgICAgIGNvbnN0IHN0YXRlVXBkYXRlcyA9IHtcbiAgICAgICAgV2lkZ2V0TGlzdCxcbiAgICAgICAgbmVlZHNVcGRhdGU6IE9iamVjdC5rZXlzKG5lZWRzVXBkYXRlKS5yZWR1Y2UoKG9iYiwgaXRtKSA9PiB7XG4gICAgICAgICAgIGlmIChpdG0gIT09IG5lZWRzVXBkYXRlS2V5KSB7XG4gICAgICAgICAgICAgIG9iYltpdG1dID0gbmVlZHNVcGRhdGVbaXRtXTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4gb2JiO1xuICAgICAgICB9LCB7fSlcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wcy5kaXNwYXRjaCh7dHlwZTogR09UX0RBVEEsIHBheWxvYWQ6IHN0YXRlVXBkYXRlc30pO1xuXG4gICB9XG4gICByZW5kZXIoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgICByb3dUb3BTdHlsZSxcbiAgICAgICAgIHJvd0J0bVN0eWxlLFxuICAgICAgICAgd2lkZ2V0MSxcbiAgICAgICAgIHdpZGdldDIsXG4gICAgICAgICB3aWRnZXQzLFxuICAgICAgICAgd2lkZ2V0NFxuICAgICAgfSA9IHRoaXMucHJvcHMud2lkZ2V0cztcbiAgICAgIHJldHVybiAoXG4gICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nY29udGFpbmVyLWZsdWlkIHdyYXBwZXInPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J3Jvdycgc3R5bGU9e3Jvd1RvcFN0eWxlfT5cbiAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXt3aWRnZXQxLnNob3duID8gd2lkZ2V0MS5jbFR5cGUgOiAnaGlkZS1lbG0nfSBkYXRhLXc9J3dpZGdldDEnIG9uRHJvcD17dGhpcy5kcm9wSGFuZGxlKCd3aWRnZXQxJyl9IG9uRHJhZ092ZXI9e3RoaXMuZHJhZ0VudGVyfT5cbiAgICAgICAgICAgICAgICAgIDxGdWxsV2lkZ2V0IGluVmlldz17dGhpcy5wcm9wcy5pblZpZXd9IG1zPXt0aGlzLmdldE1lc3NhZ2V9IHdoZW5EcmFnPXt0aGlzLmhhbmRsZURyYWdFdn0gZGF0YT17d2lkZ2V0MS5kYXRhfSB3ZD0nd2lkZ2V0MScgY2FuZHJhZz17dHJ1ZX0vPlxuICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17d2lkZ2V0Mi5zaG93biA/IHdpZGdldDIuY2xUeXBlIDogJ2hpZGUtZWxtJ30gZGF0YS13PSd3aWRnZXQyJyBvbkRyb3A9e3RoaXMuZHJvcEhhbmRsZSgnd2lkZ2V0MicpfSBvbkRyYWdPdmVyPXt0aGlzLmRyYWdFbnRlcn0+XG4gICAgICAgICAgICAgICAgICA8RnVsbFdpZGdldCBpblZpZXc9e3RoaXMucHJvcHMuaW5WaWV3fSBtcz17dGhpcy5nZXRNZXNzYWdlfSB3aGVuRHJhZz17dGhpcy5oYW5kbGVEcmFnRXZ9IGRhdGE9e3dpZGdldDIuZGF0YX0gd2Q9J3dpZGdldDInIGNhbmRyYWc9e3RydWV9Lz5cbiAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0ncm93JyBzdHlsZT17cm93QnRtU3R5bGV9PlxuICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3dpZGdldDMuc2hvd24gPyB3aWRnZXQzLmNsVHlwZSA6ICdoaWRlLWVsbSd9IGRhdGEtdz0nd2lkZ2V0Mycgb25Ecm9wPXt0aGlzLmRyb3BIYW5kbGUoJ3dpZGdldDMnKX0gb25EcmFnT3Zlcj17dGhpcy5kcmFnRW50ZXJ9PlxuICAgICAgICAgICAgICAgICAgPEZ1bGxXaWRnZXQgaW5WaWV3PXt0aGlzLnByb3BzLmluVmlld30gbXM9e3RoaXMuZ2V0TWVzc2FnZX0gd2hlbkRyYWc9e3RoaXMuaGFuZGxlRHJhZ0V2fSBkYXRhPXt3aWRnZXQzLmRhdGF9IHdkPSd3aWRnZXQzJyBjYW5kcmFnPXt0cnVlfS8+XG4gICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXt3aWRnZXQ0LnNob3duID8gd2lkZ2V0NC5jbFR5cGUgOiAnaGlkZS1lbG0nfSBkYXRhLXc9J3dpZGdldDQnIG9uRHJvcD17dGhpcy5kcm9wSGFuZGxlKCd3aWRnZXQ0Jyl9IG9uRHJhZ092ZXI9e3RoaXMuZHJhZ0VudGVyfT5cbiAgICAgICAgICAgICAgICAgIDxGdWxsV2lkZ2V0IGluVmlldz17dGhpcy5wcm9wcy5pblZpZXd9IG1zPXt0aGlzLmdldE1lc3NhZ2V9IHdoZW5EcmFnPXt0aGlzLmhhbmRsZURyYWdFdn0gZGF0YT17d2lkZ2V0NC5kYXRhfSB3ZD0nd2lkZ2V0NCcgY2FuZHJhZz17dHJ1ZX0vPlxuICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgKVxuICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChzZWxlY3QpKFdpZGdldEJsb2NrKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9jb21wb25lbnRzL2Rhc2hib2FyZC93aWRnZXRibG9jay5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5jb25zdCBSZWFjdEhpZ2hzdG9jayA9IHJlcXVpcmUoJ3JlYWN0LWhpZ2hjaGFydHMvUmVhY3RIaWdoc3RvY2snKVxuXG5pbXBvcnQgZ3JhcGhDb25maWdzIGZyb20gJ2dyYXBoX2hlbHBlcnMvZ3JhcGhjb25maWdzJztcbmltcG9ydCBkYXRhRm9ybWF0IGZyb20gJ2dyYXBoX2hlbHBlcnMvZGF0YV90cmFuc2Zvcm0nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFydFdpZGdldCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLmRhdGFHZW4gPSBudWxsO1xuICB9O1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICh0aGlzLnByb3BzLmRhdGEuY29udGVudC5kYXRhID09PSBudWxsKSB7XG4gICAgICB0aGlzLnByb3BzLmNiKHRoaXMucHJvcHMuZGF0YS5zeW1iKTtcbiAgICB9XG5cbiAgfVxuICBudWxsRGF0YSA9ICgpID0+IChcbiAgICA8ZGl2IGNsYXNzTmFtZT0nbG9hZC1ib3gnPlxuICAgICAgPGRpdiBjbGFzc05hbWU9J2xvYWRpbmctcHVsc2UnPjwvZGl2PlxuICAgIDwvZGl2PlxuICApXG5cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLnByb3BzLmRhdGEuY29udGVudC5kYXRhID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5udWxsRGF0YSgpXG4gICAgfVxuICAgICBjb25zdCBncmFwaFR5cGUgPSB0aGlzLnByb3BzLmRhdGEuY29udGVudC5ncmFwaFR5cGU7XG4gICAgIGNvbnN0IGRhdGFUcmFuc2Zvcm0gPSBkYXRhRm9ybWF0W2dyYXBoVHlwZV0oKVxuICAgICBjb25zdCBjb250ZW50RGF0YSA9IHRoaXMucHJvcHMuZGF0YS5jb250ZW50LmRhdGEubWFwKCBkYXRhID0+IGRhdGFUcmFuc2Zvcm0oZGF0YSkpO1xuICAgICBjb25zdCBjb25maWcgPSBncmFwaENvbmZpZ3NbZ3JhcGhUeXBlXSh0aGlzLnByb3BzLmRhdGEuY29udGVudC5kYXRhWzBdLnN5bWJvbCwgY29udGVudERhdGEpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPSdjaGFydC1ibG9ja2VkJz5cbiAgICAgICAgPFJlYWN0SGlnaHN0b2NrIGNvbmZpZz17Y29uZmlnfS8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPSd3aWRnZXQtaGFuZGxlJz48L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9jb21wb25lbnRzL2Rhc2hib2FyZC93aWRnZXRzL2NoYXJ0d2lkZ2V0LmpzeCIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBUYWJsZSBmcm9tIFwiZGFzaGJvYXJkL3dpZGdldHMvdGFibGVcIjtcbmltcG9ydCBQcm9ncmVzc0JhcnMgZnJvbSBcImRhc2hib2FyZC93aWRnZXRzL3Byb2dyZXNzYmFyc1wiO1xuaW1wb3J0IE1pbmlHcmFwaCBmcm9tIFwiZGFzaGJvYXJkL3dpZGdldHMvbWluaWdyYXBoXCI7XG5pbXBvcnQgQ2hhcnRXaWRnZXQgZnJvbSBcImRhc2hib2FyZC93aWRnZXRzL2NoYXJ0d2lkZ2V0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZ1bGxXaWRnZXQgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gIH07XG4gIGhhbmRsZURyYWcgPSAoKSA9PiB7XG4gICAgdGhpcy5wcm9wcy53aGVuRHJhZyh0aGlzLnByb3BzLndkLCB0aGlzLnByb3BzLmRhdGEpXG4gIH1cbiAgcGFzc01lc3NhZ2UgPSAobWVzcykgPT4ge1xuICAgIHRoaXMucHJvcHMubXMobWVzcywgdGhpcy5wcm9wcy53ZCk7XG4gIH1cbiAgZ3JhcGggPSAoZGF0YSkgPT4gPE1pbmlHcmFwaCBjdHhJZD17ZGF0YS5jb250ZW50LmNoYXJ0aWR9IGRhdGE9e2RhdGEuY29udGVudC5kYXRhfS8+O1xuICB0YWJsZSA9IChkYXRhKSA9PiA8VGFibGUgZGF0YT17ZGF0YX0vPjtcbiAgZ3JhcGhqcyA9IChkYXRhKSA9PiA8Q2hhcnRXaWRnZXQgaW5WaWV3PXt0aGlzLnByb3BzLmluVmlld30gY2I9e3RoaXMucGFzc01lc3NhZ2V9IGRhdGE9e2RhdGF9Lz47XG4gIHByb2dyZXNzID0gKGRhdGEpID0+IDxQcm9ncmVzc0JhcnMgZGF0YT17ZGF0YX0vPjtcbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtkYXRhLCBpblZpZXcsIGNhbmRyYWd9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dGl0bGUsIGtpbmR9ID0gZGF0YTtcbiAgICBjb25zdCB3aWRnZXRzID0gdGhpc1traW5kXSAhPT0gdW5kZWZpbmVkID8gdGhpc1traW5kXShkYXRhKSA6IG51bGw7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmdWxsLXdpZGdldCBjYW4tZHJhZ1wiIG9uRHJhZ1N0YXJ0PXt0aGlzLmhhbmRsZURyYWd9IGRyYWdnYWJsZT1cInRydWVcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2tpbmQgIT09IFwiZ3JhcGhqc1wiID8gXCJ3aWRnZXQtdGl0bGVcIiA6IFwiaGlkZS1lbG1cIn0+XG4gICAgICAgICAgPGgyIGNsYXNzTmFtZT17a2luZCAhPT0gXCJncmFwaGpzXCIgPyBcIlwiIDogXCJoaWRlLWVsbVwifT57dGl0bGV9PC9oMj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIHt3aWRnZXRzfVxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL2NvbXBvbmVudHMvZGFzaGJvYXJkL3dpZGdldHMvZnVsbHdpZGdldC5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgbWFrZUdyYXBoIGZyb20gJ2NhbnZhcy9jdHhncmFwaHMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNaW5pR3JhcGggZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgY2hhcnQgPSBtYWtlR3JhcGgodGhpcy5wcm9wcy5jdHhJZCwgdGhpcy5wcm9wcy5kYXRhLCB0aGlzLnByb3BzLmRhdGEudGl0bGUpXG4gICAgY2hhcnQucmVuZGVyQ2hhcnQoKVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBpZD17dGhpcy5wcm9wcy5jdHhJZH0gY2xhc3NOYW1lPVwiaG9sZHMtZ3JhcGggZG9udXQtZ3JhcGhcIj48L2Rpdj5cbiAgICApXG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29tcG9uZW50cy9kYXNoYm9hcmQvd2lkZ2V0cy9taW5pZ3JhcGguanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvZ3Jlc3NCYXJzIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gIHdpZHRoNjYgPSB7d2lkdGg6ICc2NiUnfVxuICB3aWR0aDQ1ID0ge3dpZHRoOiAnNDUlJ31cbiAgd2lkdGgyNSA9IHt3aWR0aDogJzI1JSd9XG4gIHdpZHRoMyA9IHt3aWR0aDogJzMlJ31cbiAgd2lkdGgxID0geyB3aWR0aDogJzElJ31cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPSd4X2NvbnRlbnQnPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nd2lkZ2V0X3N1bW1hcnknPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSd3X2xlZnQgd18yNSc+XG4gICAgICAgICAgICA8c3Bhbj4wLjEuNS4yPC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSd3X2NlbnRlciB3XzU1Jz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdwcm9ncmVzcyc+XG4gICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9J3Byb2dyZXNzLWJhciBiZy1ncmVlbidcbiAgICAgICAgICAgICAgICByb2xlPSdwcm9ncmVzc2JhcidcbiAgICAgICAgICAgICAgICBhcmlhLXZhbHVlbm93PSc2MCdcbiAgICAgICAgICAgICAgICBhcmlhLXZhbHVlbWluPScwJ1xuICAgICAgICAgICAgICAgIGFyaWEtdmFsdWVtYXg9JzEwMCdcbiAgICAgICAgICAgICAgICBzdHlsZT17dGhpcy53aWR0aDY2fT5cblxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSd3X3JpZ2h0IHdfMjAnPlxuICAgICAgICAgICAgPHNwYW4+MTIzazwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nY2xlYXJmaXgnPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nd2lkZ2V0X3N1bW1hcnknPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSd3X2xlZnQgd18yNSc+XG4gICAgICAgICAgICA8c3Bhbj4wLjEuNS4zPC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSd3X2NlbnRlciB3XzU1Jz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdwcm9ncmVzcyc+XG4gICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9J3Byb2dyZXNzLWJhciBiZy1ncmVlbidcbiAgICAgICAgICAgICAgICByb2xlPSdwcm9ncmVzc2JhcidcbiAgICAgICAgICAgICAgICBhcmlhLXZhbHVlbm93PSc2MCdcbiAgICAgICAgICAgICAgICBhcmlhLXZhbHVlbWluPScwJ1xuICAgICAgICAgICAgICAgIGFyaWEtdmFsdWVtYXg9JzEwMCdcbiAgICAgICAgICAgICAgICBzdHlsZT17dGhpcy53aWR0aDQ1fT5cblxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSd3X3JpZ2h0IHdfMjAnPlxuICAgICAgICAgICAgPHNwYW4+NTNrPC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdjbGVhcmZpeCc+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nd2lkZ2V0X3N1bW1hcnknPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSd3X2xlZnQgd18yNSc+XG4gICAgICAgICAgICA8c3Bhbj4wLjEuNS40PC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSd3X2NlbnRlciB3XzU1Jz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdwcm9ncmVzcyc+XG4gICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9J3Byb2dyZXNzLWJhciBiZy1ncmVlbidcbiAgICAgICAgICAgICAgICByb2xlPSdwcm9ncmVzc2JhcidcbiAgICAgICAgICAgICAgICBhcmlhLXZhbHVlbm93PSc2MCdcbiAgICAgICAgICAgICAgICBhcmlhLXZhbHVlbWluPScwJ1xuICAgICAgICAgICAgICAgIGFyaWEtdmFsdWVtYXg9JzEwMCdcbiAgICAgICAgICAgICAgICBzdHlsZT17dGhpcy53aWR0aDI1fT5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9J3NyLW9ubHknPjYwJSBDb21wbGV0ZTwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nd19yaWdodCB3XzIwJz5cbiAgICAgICAgICAgIDxzcGFuPjIzazwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nY2xlYXJmaXgnPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9J3dpZGdldF9zdW1tYXJ5Jz5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nd19sZWZ0IHdfMjUnPlxuICAgICAgICAgICAgPHNwYW4+MC4xLjUuNTwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nd19jZW50ZXIgd181NSc+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0ncHJvZ3Jlc3MnPlxuICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPSdwcm9ncmVzcy1iYXIgYmctZ3JlZW4nXG4gICAgICAgICAgICAgICAgcm9sZT0ncHJvZ3Jlc3NiYXInXG4gICAgICAgICAgICAgICAgYXJpYS12YWx1ZW5vdz0nNjAnXG4gICAgICAgICAgICAgICAgYXJpYS12YWx1ZW1pbj0nMCdcbiAgICAgICAgICAgICAgICBhcmlhLXZhbHVlbWF4PScxMDAnXG4gICAgICAgICAgICAgICAgc3R5bGU9e3RoaXMud2lkdGgzfT5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nd19yaWdodCB3XzIwJz5cbiAgICAgICAgICAgIDxzcGFuPjNrPC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdjbGVhcmZpeCc+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nd2lkZ2V0X3N1bW1hcnknPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSd3X2xlZnQgd18yNSc+XG4gICAgICAgICAgICA8c3Bhbj4wLjEuNS42PC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSd3X2NlbnRlciB3XzU1Jz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdwcm9ncmVzcyc+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdwcm9ncmVzcy1iYXIgYmctZ3JlZW4nXG4gICAgICAgICAgICAgICAgcm9sZT0ncHJvZ3Jlc3NiYXInXG4gICAgICAgICAgICAgICAgYXJpYS12YWx1ZW5vdz0nNjAnXG4gICAgICAgICAgICAgICAgYXJpYS12YWx1ZW1pbj0nMCdcbiAgICAgICAgICAgICAgICBhcmlhLXZhbHVlbWF4PScxMDAnXG4gICAgICAgICAgICAgICAgc3R5bGU9e3RoaXMud2lkdGgxfT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSd3X3JpZ2h0IHdfMjAnPlxuICAgICAgICAgICAgPHNwYW4+MWs8L3NwYW4+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9jb21wb25lbnRzL2Rhc2hib2FyZC93aWRnZXRzL3Byb2dyZXNzYmFycy5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWJsZSBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDx0YWJsZSBjbGFzc05hbWU9J3RhYmxlIHRhYmxlLXN0cmlwZWQgIHRhYmxlLW1kIHRhYmxlLWludmVyc2UnPlxuICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgPHRyPlxuICAgICAgICAgICAgPHRoPlxuICAgICAgICAgICAgICA8aSBjbGFzc05hbWU9J2ZhIGZhLWNvZGVwZW4nIGFyaWEtaGlkZGVuPSd0cnVlJz48L2k+XG4gICAgICAgICAgICA8L3RoPlxuICAgICAgICAgICAgPHRoPlxuICAgICAgICAgICAgICBDb2x1bW4gaGVhZGluZ1xuICAgICAgICAgICAgPC90aD5cbiAgICAgICAgICAgIDx0aD5cbiAgICAgICAgICAgICAgQ29sdW1uIGhlYWRpbmdcbiAgICAgICAgICAgIDwvdGg+XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgPC90aGVhZD5cbiAgICAgICAgPHRib2R5PlxuICAgICAgICAgIDx0ciBjbGFzc05hbWU9J2FjdGl2ZSc+XG4gICAgICAgICAgICA8dGggY2xhc3NOYW1lPSdyb3ctc2NvcGUnPjE8L3RoPlxuICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICBDb2x1bW4gY29udGVudFxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgQ29sdW1uIGNvbnRlbnRcbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgIENvbHVtbiBjb250ZW50XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgPHRyPlxuICAgICAgICAgICAgPHRoIGNsYXNzTmFtZT0ncm93LXNjb3BlJz4yPC90aD5cbiAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgQ29sdW1uIGNvbnRlbnRcbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgIENvbHVtbiBjb250ZW50XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICBDb2x1bW4gY29udGVudFxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICA8L3RyPlxuICAgICAgICAgIDx0ciBjbGFzc05hbWU9J3N1Y2Nlc3MnPlxuICAgICAgICAgICAgPHRoIGNsYXNzTmFtZT0ncm93LXNjb3BlJz4zPC90aD5cbiAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgQ29sdW1uIGNvbnRlbnRcbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgIENvbHVtbiBjb250ZW50XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICBDb2x1bW4gY29udGVudFxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICA8L3RyPlxuICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgIDx0aCBjbGFzc05hbWU9J3Jvdy1zY29wZSc+NDwvdGg+XG4gICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgIENvbHVtbiBjb250ZW50XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICBDb2x1bW4gY29udGVudFxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgQ29sdW1uIGNvbnRlbnRcbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgICA8dHIgY2xhc3NOYW1lPSd3YXJuaW5nJz5cbiAgICAgICAgICAgIDx0aCBjbGFzc05hbWU9J3Jvdy1zY29wZSc+NTwvdGg+XG4gICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgIENvbHVtbiBjb250ZW50XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICBDb2x1bW4gY29udGVudFxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgQ29sdW1uIGNvbnRlbnRcbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgICA8dHI+XG4gICAgICAgICAgICA8dGggY2xhc3NOYW1lPSdyb3ctc2NvcGUnPjY8L3RoPlxuICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICBDb2x1bW4gY29udGVudFxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgQ29sdW1uIGNvbnRlbnRcbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgIENvbHVtbiBjb250ZW50XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgPHRyIGNsYXNzTmFtZT0nZGFuZ2VyJz5cbiAgICAgICAgICAgIDx0aCBjbGFzc05hbWU9J3Jvdy1zY29wZSc+NzwvdGg+XG4gICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgIENvbHVtbiBjb250ZW50XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICBDb2x1bW4gY29udGVudFxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgQ29sdW1uIGNvbnRlbnRcbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgPC90Ym9keT5cbiAgICAgIDwvdGFibGU+XG5cbiAgICApO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL2NvbXBvbmVudHMvZGFzaGJvYXJkL3dpZGdldHMvdGFibGUuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9hZEJhcnMgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT0nc3Bpbm5lcic+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPSdyZWN0MSc+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPSdyZWN0Mic+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPSdyZWN0Myc+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPSdyZWN0NCc+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPSdyZWN0NSc+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29tcG9uZW50cy9sb2FkZXJzL2xvYWRiYXJzLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvYWRDb25uZWN0IGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9J2Nvbm5lY3RpbmcnPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nc3Bpbm5lci1ibic+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2JvdW5jZTEnPjwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdib3VuY2UyJz48L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nYm91bmNlMyc+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8aDI+Q29ubmVjdGluZyB0byBXZWJTb2NrZXQuIC4gLlxuICAgICAgICA8L2gyPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL2NvbXBvbmVudHMvbG9hZGVycy9zcGlubG9hZC5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgZm9yZXhTeW1ib2xQYWlycyBmcm9tICdkYXRhL2ZvcmV4X3N5bWJvbF9wYWlycyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvcmV4TGlzdCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZXhjaGFuZ2U6ICdOQVNEQVEnXG4gICAgfVxuICB9O1xuICBleGNoYW5nZUNoYW5nZSA9IChlKSA9PiB0aGlzLnNldFN0YXRlKHtleGNoYW5nZTogZS50YXJnZXQudmFsdWV9KTtcbiAgaGFuZGxlU3RhcnQgPSAoKSA9PiB7XG4gICAgdGhpcy5wcm9wcy5zdGFydENoYXJ0KHRoaXMuZmVlZFN5bWJvbC52YWx1ZSwgXCJmb3JleFwiKVxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB1c2VkID0gdGhpcy5wcm9wcy51c2VkLmxlbmd0aCA9PT0gMCA/IFtcIk5PUEVcIiwgXCJXSEFUXCJdIDogdGhpcy5wcm9wcy51c2VkO1xuICAgIGNvbnN0IGluVXNlID0gbmV3IFJlZ0V4cChcIihcIiArIHVzZWQuam9pbihcInxcIikgKyBcIilcIik7XG4gICAgY29uc3QgbGlzdCA9IGZvcmV4U3ltYm9sUGFpcnMubWFwKChpdG0pID0+IHtcbiAgICAgIGlmIChpblVzZS50ZXN0KGl0bSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gPG9wdGlvbiBrZXk9e2l0bX0gdmFsdWU9e2l0bX0+e2l0bX08L29wdGlvbj47XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sdW1uLXR3byB0ZXh0LWNlbnRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNlbC1pbmRcIj5cbiAgICAgICAgICA8c3Ryb25nPkN1cnJlbmN5IFBhaXJzPC9zdHJvbmc+XG4gICAgICAgICAgPHNlbGVjdCBkYXRhLXR5cGU9XCJmb3JleFwiIHJlZj17KHNlbGVjdCkgPT4gdGhpcy5mZWVkU3ltYm9sID0gc2VsZWN0fSBjbGFzc05hbWU9XCJzeW1ib2wtcGljayBsaXZlLXN5bVwiPlxuICAgICAgICAgICAge2xpc3R9XG4gICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFkZC1jaGFydC1idXR0LWRpdiB0ZXh0LWNlbnRlclwiPlxuICAgICAgICAgIDxkaXYgb25DbGljaz17dGhpcy5oYW5kbGVTdGFydH0gY2xhc3NOYW1lPVwiY29vbC1idXR0b24gYWRkLWNoYXJ0LWJ0XCI+VHJhY2s8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29tcG9uZW50cy9taWNyby9saXN0cy9mb3JleGxpc3QuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgZXhjaGFuZ2VTeW1icyBmcm9tICdkYXRhL2dvc3ltYm9scyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b2NrTGlzdCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZXhjaGFuZ2U6ICdOQVNEQVEnXG4gICAgfVxuICB9O1xuICBleGNoYW5nZUNoYW5nZSA9IChlKSA9PiB0aGlzLnNldFN0YXRlKHtleGNoYW5nZTogZS50YXJnZXQudmFsdWV9KTtcbiAgaGFuZGxlU3RhcnQgPSAoKSA9PiB7XG4gICAgdGhpcy5wcm9wcy5zdGFydENoYXJ0KHRoaXMuZmVlZFN5bWJvbC52YWx1ZSwgXCJzdG9ja3NcIilcbiAgfTtcbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHVzZWQgPSB0aGlzLnByb3BzLnVzZWQubGVuZ3RoID09PSAwID8gW1wiTk9QRVwiLCBcIldIQVRcIl0gOiB0aGlzLnByb3BzLnVzZWQ7XG4gICAgY29uc3QgaW5Vc2UgPSBuZXcgUmVnRXhwKFwiKFwiICsgdXNlZC5qb2luKFwifFwiKSArIFwiKVwiKTtcbiAgICBjb25zdCBleGNoYW5nZU9wdHMgPSBleGNoYW5nZVN5bWJzKGluVXNlKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2x1bW4tdHdvXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2VsLWluZFwiPlxuICAgICAgICAgIDxzdHJvbmc+RXhjaGFuZ2U8L3N0cm9uZz5cbiAgICAgICAgICA8c2VsZWN0IHJlZj17KHNlbGVjdCkgPT4gdGhpcy5jaGFuZ2VFeGNoYW5nZSA9IHNlbGVjdH0gY2xhc3NOYW1lPVwic3ltYm9sLXBpY2sgbGl2ZS1zeW1cIiBkZWZhdWx0VmFsdWU9e3RoaXMuc3RhdGUuZXhjaGFuZ2V9IG9uQ2hhbmdlPXt0aGlzLmV4Y2hhbmdlQ2hhbmdlfT5cbiAgICAgICAgICAgIDxvcHRpb24ga2V5PSdOQVNEQVEtMicgdmFsdWU9XCJOQVNEQVFcIj5OQVNEQVE8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24ga2V5PSdOWVNFLTInIHZhbHVlPVwiTllTRVwiPk5ZU0U8L29wdGlvbj5cbiAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2VsLWluZFwiPlxuICAgICAgICAgIDxzdHJvbmc+U3ltYm9sPC9zdHJvbmc+XG4gICAgICAgICAgPHNlbGVjdCByZWY9eyhzZWxlY3QpID0+IHRoaXMuZmVlZFN5bWJvbCA9IHNlbGVjdH0gY2xhc3NOYW1lPVwic3ltYm9sLXBpY2sgbGl2ZS1zeW1cIj5cbiAgICAgICAgICAgIHtleGNoYW5nZU9wdHNbdGhpcy5zdGF0ZS5leGNoYW5nZV19XG4gICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWRkLWNoYXJ0LWJ1dHQtZGl2IHRleHQtY2VudGVyXCI+XG4gICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLmhhbmRsZVN0YXJ0fSBjbGFzc05hbWU9XCJjb29sLWJ1dHRvbiBhZGQtY2hhcnQtYnRcIj5Tb21ldGhpbmc8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29tcG9uZW50cy9taWNyby9saXN0cy9zb2NrbGlzdC5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgZXhjaGFuZ2VPcHRpb25zIGZyb20gJ2RhdGEvc3RvY2tzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl2ZVN0YXJ0IGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBleGNoYW5nZTogJ05BU0RBUSdcbiAgICB9XG4gIH07XG4gIGV4Y2hhbmdlQ2hhbmdlID0gKGUpID0+IHRoaXMuc2V0U3RhdGUoe2V4Y2hhbmdlOiBlLnRhcmdldC52YWx1ZX0pO1xuICBoYW5kbGVTdGFydCA9ICgpID0+IHRoaXMucHJvcHMuc3RhcnRDaGFydCh0aGlzLmZlZWRTeW1ib2wudmFsdWUpO1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPSdjb250YWluZXInPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nY2hhcnQtY29udHJvbGxlciBjaGFydC1saXZlLWNudHJsIGxpdmUtc2V0Jz5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nc2VsZWN0LWhvbGRlcnMgc3ByZWFkLW0nPlxuICAgICAgICAgICAgPHN0cm9uZz5TeW1ib2xzOjwvc3Ryb25nPlxuICAgICAgICAgICAgPHNlbGVjdCByZWY9eyhzZWxlY3QpID0+IHRoaXMuZmVlZFN5bWJvbCA9IHNlbGVjdH0gY2xhc3NOYW1lPSdzeW1ib2wtcGljayBsaXZlLXN5bSc+XG4gICAgICAgICAgICAgIHtleGNoYW5nZU9wdGlvbnNbdGhpcy5zdGF0ZS5leGNoYW5nZV19XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nc2VsZWN0LWhvbGRlcnMgc3ByZWFkLW0nPlxuICAgICAgICAgICAgPHN0cm9uZz5FeGNoYW5nZTo8L3N0cm9uZz5cbiAgICAgICAgICAgIDxzZWxlY3QgcmVmPXsoc2VsZWN0KSA9PiB0aGlzLmNoYW5nZUV4Y2hhbmdlID0gc2VsZWN0fSBjbGFzc05hbWU9J3N5bWJvbC1waWNrIGxpdmUtc3ltJyB2YWx1ZT17dGhpcy5zdGF0ZS5leGNoYW5nZX0gb25DaGFuZ2U9e3RoaXMuZXhjaGFuZ2VDaGFuZ2V9PlxuICAgICAgICAgICAgICA8b3B0aW9uIGtleT0nTkFTREFRLTInIHZhbHVlPSdOQVNEQVEnPk5BU0RBUTwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIGtleT0nTllTRS0yJyB2YWx1ZT0nTllTRSc+TllTRTwvb3B0aW9uPlxuICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT0ncm93IHRleHQtY2VudGVyJz5cbiAgICAgICAgICA8ZGl2IG9uQ2xpY2s9e3RoaXMuaGFuZGxlU3RhcnR9IGNsYXNzTmFtZT0nYmlnLWJ1dHQgY29vbC1idXR0b24nPlN0YXJ0IExpdmVGZWVkITwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9jb21wb25lbnRzL21pY3JvL2xpdmVzdGFydC5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpY2tDYXJkIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yIChwcm9wcykge1xuXHQgIHN1cGVyKHByb3BzKTtcblx0ICB0aGlzLmNhcmRDVFggPSBudWxsO1xuXHR9XG5cdGRyYWdTdGFydCA9ICgpID0+IHRoaXMucHJvcHMuY2FyZERyYWdTdGFydCh0aGlzLnByb3BzLmluZGV4KTtcblx0b25EcmFnT3ZlciA9IChlKSA9PiBlLnByZXZlbnREZWZhdWx0KClcblx0bW91c2VVcCA9ICgpID0+IHRoaXMucHJvcHMuY2FyZFBvc3Rpb25DbGljayh0aGlzLnByb3BzLmluZGV4KTtcblx0ZHJhZ0VudGVyID0gKGUpID0+IHtcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR0aGlzLnByb3BzLmRyYWdPdmVyQ2FyZCh0aGlzLnByb3BzLmluZGV4KTtcblx0fVxuXHRkcmFnTGVhdmUgPSAoZSkgPT4ge1xuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdHRoaXMucHJvcHMuZHJhZ0xlZnRDYXJkKHRoaXMucHJvcHMuaW5kZXgpO1xuXG5cdH1cblx0ZHJvcEhhbmRsZSA9IChlKSA9PiB7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdHRoaXMucHJvcHMuY2FyZERyb3BwZWQodGhpcy5wcm9wcy5pbmRleCk7XG5cdH1cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgICBsZXQgcHJpY2UgPSB0aGlzLnByb3BzLnN5bWJvbC5wcmMgPCAxMCA/IE1hdGgucm91bmQodGhpcy5wcm9wcy5zeW1ib2wucHJjICogMTAwKSA6IE1hdGgucm91bmQodGhpcy5wcm9wcy5zeW1ib2wucHJjKTtcbiAgICAgdGhpcy5jYXJkQ1RYID0gdGhpcy5wcm9wcy5jYXJkQ3R4LnNldENhcmQodGhpcy5wcm9wcy5jYXJkSWQsIHByaWNlLCB0aGlzLnByb3BzLnN5bWJvbC5zeW1iKTtcbiAgICAgdGhpcy5jYXJkQ1RYLnN0YXJ0TG9vcCgpO1xuXHR9XG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCB7IGFwcGx5T3V0LCBhY3RpdmUgfSA9IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIChcbiAgICBcdDxkaXZcblx0XHRcdFx0Y2xhc3NOYW1lPXthcHBseU91dCA/IFwidHJhZGUtY2FyZC1ob2xkZXIgIGFwcGx5LW91dFwiIDogXCJ0cmFkZS1jYXJkLWhvbGRlciBub3JtYWwtY2xhc3NcIn1cblx0XHRcdFx0b25EcmFnT3Zlcj17dGhpcy5kcmFnRW50ZXJ9XG5cdFx0XHRcdG9uTW91c2VVcD17dGhpcy5tb3VzZVVwfVxuXHRcdFx0XHRzdHlsZT17e2FuaW1hdGlvbjogdGhpcy5wcm9wcy5hbmltYXRpb259fVxuXHRcdFx0XHRvbkRyb3A9e3RoaXMuZHJvcEhhbmRsZX0gPlxuICAgICBcdFx0PGRpdiBjbGFzc05hbWU9eyBhY3RpdmUgPyBcInRyYWRlLWNhcmQgY2FyZC1hY3RpdmVcIiA6IFwidHJhZGUtY2FyZFwiIH1cblx0XHRcdFx0XHRcdGRyYWdnYWJsZT1cInRydWVcIlxuXHRcdFx0XHRcdFx0b25EcmFnU3RhcnQ9e3RoaXMuZHJhZ1N0YXJ0fSA+XG4gICAgXHRcdFx0PHAgY2xhc3NOYW1lPVwic3Bhbi1sYWJlbC1ibHVlIHN5bWItbGFiZWxcIj57dGhpcy5wcm9wcy5zeW1ib2wuc3ltYn08L3A+XG4gICAgICAgICAgXHQ8Y2FudmFzIGlkPXt0aGlzLnByb3BzLmNhcmRJZH0gY2xhc3NOYW1lPVwiY2FudmFzVGlja1wiIHdpZHRoPXsyMTB9IGhlaWdodD17NjB9PjwvY2FudmFzPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcblx0fVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9jb21wb25lbnRzL21pY3JvL3RpY2tlcnMvdGlja2NhcmQuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlja2VyVmlldyBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPSd0aWNrZXItc2lkZS1jb250ZW50Jz5cbiAgICAgICAgPGgyIGNsYXNzTmFtZT0ndC1zaWRlLWgyJz57dGhpcy5wcm9wcy5zeW1ib2wuc3ltYn08L2gyPlxuICAgICAgICA8ZGl2IGlkPSd0aWNrQ2hhcnQnPjwvZGl2PlxuICAgICAgICA8Y2FudmFzIGlkPSdhc2tCaWRSYXRpbycgd2lkdGg9ezE5MH0gaGVpZ2h0PXs1MH0+PC9jYW52YXM+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9jb21wb25lbnRzL21pY3JvL3RpY2tlcnMvdGlja2Vydmlldy5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5jb25zdCB0aW1lVW5pdCA9IChkLCBpbmRleCwgc2V0SW5kZXgsIHRpbWVTZXQpID0+IHtcbiAgIGxldCB0aW1lID0gZC5nZXRIb3VycygpICsgJzonICsgKCcwJyArIChkLmdldE1pbnV0ZXMoKSArIGluZGV4KSkuc2xpY2UoLTIpO1xuICAgbGV0IGRpc3BsYXlDbGFzcyA9IGluZGV4ID09PSBzZXRJbmRleCA/ICdhY3RpdmUtdCcgOiAnJztcbiAgIHJldHVybiAoXG4gICAgICA8bGkga2V5PXsndG1fJyArIGluZGV4fSBvbkNsaWNrPXt0aW1lU2V0KGluZGV4KX0gY2xhc3NOYW1lPXtkaXNwbGF5Q2xhc3N9PlxuICAgICAgICAgPHNwYW4+e3RpbWV9PC9zcGFuPlxuICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPSdmdC1ydCc+e2Ake2luZGV4fSBtaW5gfTwvc3Bhbj5cbiAgICAgIDwvbGk+XG4gICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVJbnRlcnZhbHMgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgIHJlbmRlcigpIHtcbiAgICAgIGNvbnN0IHt0aW1lU2V0LCBpbmQsIGRhdGV9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHRpbWVMaXN0ID0gW107XG4gICAgICBmb3IobGV0IGkgPSAxOyBpIDwgMTE7IGkrKykge1xuICAgICAgICAgdGltZUxpc3QucHVzaCh0aW1lVW5pdChkYXRlLCBpLCBpbmQsIHRpbWVTZXQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXG4gICAgICAgICA8dWwgY2xhc3NOYW1lPSd0aW1lLXBpY2snPlxuICAgICAgICAgICAge3RpbWVMaXN0fVxuICAgICAgICAgPC91bD5cbiAgICAgIClcbiAgIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29tcG9uZW50cy9taWNyby90aW1laW50ZXJ2YWxzLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgTWF0aEZ1bmNzIGZyb20gJ2hlbHBlci9tYXRoZnVuY3MnO1xuY29uc3QgY2FsY1ggPSAobnVtYmVyKSA9PiB7XG4gICByZXR1cm4gMTEgKyAoLTExICogTWF0aEZ1bmNzLmdldERpZ2l0TGVuKG51bWJlcikpO1xufVxuY29uc3QgYW5pbWF0ZVN0YXQgPSAoKSA9PiB7fVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0IGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgdGhpcy5zdmcgPSBudWxsO1xuXG4gICB9O1xuICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICBsZXQgeyBzdmdJZCwgU3ZnQ0IsIGNvbmZpZyAgfSA9IHRoaXMucHJvcHNcbiAgICAgIGxldCB0aGVTVkcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzdmdJZCkucXVlcnlTZWxlY3RvcigndGV4dCcpO1xuICAgICAgdGhpcy5zdmcgPSB0aGVTVkc7XG4gICAgICBTdmdDQi5zZXRSZWYoc3ZnSWQsIE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZywge2RvbUVsZW06IHRoZVNWR30pKTtcbiAgIH1cbiAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHt9XG4gICByZW5kZXIoKSB7XG4gICAgICBsZXQge2NsYXNzVHlwZSwgbnVtYmVyLCBzdmdJZCwgZmlsbENvbG9yfSA9IHRoaXMucHJvcHM7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2NvdW50IGNvdW50LTQ3Jz5cbiAgICAgICAgICAgIDxzdmcgaWQ9e3N2Z0lkfSBjbGFzc05hbWU9J3N2Zy1jb250YWluZXInIGhlaWdodD0nNDAnIHdpZHRoPScyMic+XG4gICAgICAgICAgICAgICA8dGV4dCBjbGFzc05hbWU9e2NsYXNzVHlwZX0geD0nMTEnIHk9JzM1JyBmaWxsPXtmaWxsQ29sb3J9PjwvdGV4dD5cbiAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgPC9kaXY+XG4gICAgICApXG4gICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL2NvbXBvbmVudHMvc3ZnL3N0YXQuanN4IiwiaW1wb3J0IE1hdGhGdW5jcyBmcm9tICdoZWxwZXIvbWF0aGZ1bmNzJztcblxuY29uc3Qgc3RhdFNWR3MgPSAoKSA9PiB7XG4gICBjb25zdCBjYWxjWCA9IChudW1iZXIsIGJ1ZmZlciA9IDExKSA9PiB7XG4gICAgICByZXR1cm4gYnVmZmVyICsgKC0xMSAqIE1hdGhGdW5jcy5nZXREaWdpdExlbihudW1iZXIpKTtcbiAgIH1cblxuICAgZnVuY3Rpb24gU3ZnQ2FsbEJhY2tzKCkge307XG5cbiAgIGNvbnN0IFN2Z0NCID0gbmV3IFN2Z0NhbGxCYWNrcygpO1xuICAgU3ZnQ0IuaW5WaWV3Qm9vbCA9IGZhbHNlO1xuICAgU3ZnQ0Iuc2hvdWxkQW5pbWF0ZSA9IHRydWU7XG4gICBTdmdDQi5zdmcxID0gbnVsbDtcbiAgIFN2Z0NCLnN2ZzIgPSBudWxsO1xuICAgU3ZnQ0Iuc3ZnMyA9IG51bGw7XG4gICBTdmdDQi5zdmc0ID0gbnVsbDtcbiAgIFN2Z0NCLnN2ZzUgPSBudWxsO1xuXG4gICBTdmdDQi5zdmdSZXBlYXQgPSAoc3ZnRWxtLCBpdG0sIGlpLCB1bml0LCBmaWxsQ2huZykgPT4ge1xuICAgICAgbGV0IHRPID0gaWkgKiB1bml0O1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN2Z0VsbS5zZXRBdHRyaWJ1dGUoJ3gnLCBpdG0ueFZhbCk7XG4gICAgICAgICAgICBpZiAoZmlsbENobmcpIHtcbiAgICAgICAgICAgICAgIHN2Z0VsbS5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBpdG0uZmlsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdmdFbG0udGV4dENvbnRlbnQgPSBpdG0udGV4dDtcbiAgICAgICAgIH0pO1xuICAgICAgfSwgdE8pO1xuXG4gICB9O1xuICAgU3ZnQ0Iuc2V0UmVmID0gKHN2Z0lkLCBjb25maWcpID0+IHtcbiAgICAgIFN2Z0NCW3N2Z0lkXSA9IGNvbmZpZztcbiAgICAgIGlmIChjb25maWcuY3VycmVudCA9PT0gY29uZmlnLmxhc3RWYWx1ZSkge1xuICAgICAgICAgbGV0IG51bVN0cmluZyA9IGNvbmZpZy50eXBlID09PSBcImZsb2F0XCIgPyBNYXRoRnVuY3MubmljZUZsb2F0cyhjb25maWcuY3VycmVudCkgOiBjb25maWcuY3VycmVudDtcbiAgICAgICAgIGxldCB4eCA9IGNvbmZpZy50eXBlID09PSBcImZsb2F0XCIgPyAtMTEgKiAobnVtU3RyaW5nLmxlbmd0aCAtIDEpIDogKGNvbmZpZy5jdXJyZW50ID09PSAwID8gMCA6IGNhbGNYKGNvbmZpZy5jdXJyZW50KSk7XG4gICAgICAgICBsZXQgZmlsbENvbG9yID0gY29uZmlnLmN1cnJlbnQgPT09IDAgPyBcIiM3Mzg3OUNcIiA6IChjb25maWcuY3VycmVudCA+IDAgPyBcIiMzMGQ5NGNcIiA6IFwiI0RDMTQzQ1wiKTtcbiAgICAgICAgIGNvbmZpZy5kb21FbGVtLnNldEF0dHJpYnV0ZSgneCcsIHh4KTtcbiAgICAgICAgIGNvbmZpZy5kb21FbGVtLnNldEF0dHJpYnV0ZSgnZmlsbCcsIGZpbGxDb2xvcik7XG4gICAgICAgICBjb25maWcuZG9tRWxlbS50ZXh0Q29udGVudCA9IG51bVN0cmluZztcbiAgICAgIH1cbiAgICAgIC8vY29uc29sZS5sb2coJ3NldFJlZicsIHtjb25maWc6IGNvbmZpZywgc3ZnSWQ6IHN2Z0lkfSwgU3ZnQ0IpO1xuICAgfVxuXG4gICBTdmdDQi5zdmdBbmltYXRlID0gKG9nVmFsdWUsIG5ld1ZhbHVlLCBzdmdPYikgPT4ge1xuXG4gICAgICAvL2xldCBTdkcgPSBzdmdPYi5kb21FbGVtO1xuICAgICAgbGV0IGJ1ZmZlciA9IHN2Z09iLmJ1ZmZlcjtcbiAgICAgIGxldCBwbHVzVmFsdWUgPSBzdmdPYi5wbHVzVmFsdWU7XG4gICAgICBsZXQgdmFsdWVzID0gW107XG4gICAgICBsZXQgaW5jID0gc3ZnT2IudHlwZSA9PT0gXCJmbG9hdFwiID8gMTAwIDogMTtcbiAgICAgIGxldCBvZ0NQWSA9IE1hdGgucm91bmQob2dWYWx1ZSAqIGluYyk7XG4gICAgICBsZXQgbmV3VmwgPSBNYXRoLnJvdW5kKG5ld1ZhbHVlICogaW5jKTtcbiAgICAgIGxldCBkaWZmID0gTWF0aC5hYnMob2dDUFkgLSBuZXdWbCk7XG4gICAgICBsZXQgdW5pdCA9IGRpZmYgPiAxMDAwID8gMTYgOiBNYXRoLmNlaWwoKDEgLyBkaWZmKSAqIDUwMCk7XG4gICAgICBsZXQgc3ViID0gZGlmZiA+IDEwMDAgPyBNYXRoLmNlaWwoZGlmZiAvIDYwKSA6IChkaWZmIC8gaW5jID4gMTAgPyBpbmMgOiAxKTtcbiAgICAgIGlmIChvZ1ZhbHVlID4gbmV3VmFsdWUpIHtcbiAgICAgICAgIHdoaWxlIChvZ0NQWSA+IG5ld1ZsKSB7XG4gICAgICAgICAgICBvZ0NQWSAtPSBzdWI7XG4gICAgICAgICAgICBsZXQgbnVtU3RyaW5nID0gc3ZnT2IudHlwZSA9PT0gXCJmbG9hdFwiID8gTWF0aEZ1bmNzLm5pY2VGbG9hdHMob2dDUFkgLyBpbmMpIDogb2dDUFk7XG4gICAgICAgICAgICBsZXQgeHggPSBzdmdPYi50eXBlID09PSBcImZsb2F0XCIgPyAtMTEgKiAobnVtU3RyaW5nLmxlbmd0aCAtIDEpIDogY2FsY1gob2dDUFksIDExKTtcbiAgICAgICAgICAgIC8vIGxldCBtZWFzdXJlTnVtID0gc3ZnT2IudHlwZSA9PT0gXCJmbG9hdFwiID8gIE1hdGgucm91bmQob2dDUFkgKiAxMDApIDogb2dDcHk7XG4gICAgICAgICAgICAvL2xldCB0eHROdW0gPSBzdmdPYi50eXBlID09PSBcImZsb2F0XCIgPyAobWVhc3VyZU51bS8xMDApIDogb2dDcHk7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICB0ZXh0OiBudW1TdHJpbmcsXG4gICAgICAgICAgICAgICBmaWxsOiBvZ0NQWSA9PT0gMCA/IFwiIzczODc5Q1wiIDogKG9nQ1BZID4gMCA/IFwiIzMwZDk0Y1wiIDogXCIjREMxNDNDXCIpLFxuICAgICAgICAgICAgICAgeFZhbDogeHhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHdoaWxlIChvZ0NQWSA8IG5ld1ZsKSB7XG4gICAgICAgICAgICBvZ0NQWSArPSBzdWI7XG4gICAgICAgICAgICBsZXQgbnVtU3RyaW5nID0gc3ZnT2IudHlwZSA9PT0gXCJmbG9hdFwiID8gTWF0aEZ1bmNzLm5pY2VGbG9hdHMob2dDUFkgLyBpbmMpIDogb2dDUFk7XG4gICAgICAgICAgICBsZXQgeHggPSBzdmdPYi50eXBlID09PSBcImZsb2F0XCIgPyAtMTEgKiAobnVtU3RyaW5nLmxlbmd0aCAtIDEpIDogY2FsY1gob2dDUFksIC0xKTtcbiAgICAgICAgICAgIC8vbGV0IG1lYXN1cmVOdW0gPSBzdmdPYi50eXBlID09PSBcImZsb2F0XCIgPyAgTWF0aC5yb3VuZChvZ0NQWSAqIDEwMCkgOiBvZ0NweTtcbiAgICAgICAgICAgIC8vbGV0IHR4dE51bSA9IHN2Z09iLnR5cGUgPT09IFwiZmxvYXRcIiA/IChtZWFzdXJlTnVtLzEwMCkgOiBvZ0NweTtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHtcbiAgICAgICAgICAgICAgIHRleHQ6IG51bVN0cmluZyxcbiAgICAgICAgICAgICAgIGZpbGw6IG9nQ1BZID09PSAwID8gXCIjNzM4NzlDXCIgOiAob2dDUFkgPiAwID8gXCIjMzBkOTRjXCIgOiBcIiNEQzE0M0NcIiksXG4gICAgICAgICAgICAgICB4VmFsOiB4eFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBjb25zb2xlLmxvZygndmFsdWVzJywgdmFsdWVzKTtcbiAgICAgIHZhbHVlcy5mb3JFYWNoKChpdG0sIGkpID0+IHtcbiAgICAgICAgIFN2Z0NCLnN2Z1JlcGVhdChzdmdPYi5kb21FbGVtLCBpdG0sIGksIHVuaXQsIHN2Z09iLmZpbGxDaGFuZ2UpO1xuICAgICAgfSk7XG5cbiAgIH1cbiAgIFN2Z0NCLmluVmlldyA9ICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdTdmdDQicsIFN2Z0NCKTtcbiAgICAgIFN2Z0NCLmluVmlld0Jvb2wgPSB0cnVlO1xuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIFsnc3ZnMScsICdzdmcyJywgJ3N2ZzMnLCAnc3ZnNCcsICdzdmc1J10uZm9yRWFjaCgoaXRtKSA9PiB7XG4gICAgICAgICAgICBpZiAoIVN2Z0NCW2l0bV0pXG4gICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIGxldCBjdVNWRyA9IFN2Z0NCW2l0bV07XG4gICAgICAgICAgICBpZiAoY3VTVkcuYW5pbWF0ZSkge1xuICAgICAgICAgICAgICAgU3ZnQ0Iuc3ZnQW5pbWF0ZShjdVNWRy5sYXN0VmFsdWUsIGN1U1ZHLmN1cnJlbnQsIGN1U1ZHKTtcbiAgICAgICAgICAgICAgIGN1U1ZHLmFuaW1hdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH0pO1xuXG4gICAgICB9LCAxNTApO1xuXG4gICB9O1xuXG4gICBTdmdDQi51cERhdGUgPSAocGFzdFRyYWRlcywgdG90YWxSZXYpID0+IHtcbiAgICAgIGlmICghU3ZnQ0Iuc3ZnMSlcbiAgICAgICAgIHJldHVybiAnJztcblxuICAgICAgLy9sZXQgczEgPSBPYmplY3QuYXNzaWduKHt9LCBTdmdDQi5zdmcxKTtcbiAgICAgIFN2Z0NCLnN2ZzEubGFzdFZhbHVlID0gU3ZnQ0Iuc3ZnMS5jdXJyZW50O1xuICAgICAgU3ZnQ0Iuc3ZnMS5hbmltYXRlID0gdHJ1ZTtcbiAgICAgIFN2Z0NCLnN2ZzEuY3VycmVudCArPSAxO1xuICAgICAgLy9sZXQgczIgPSAgT2JqZWN0LmFzc2lnbih7fSwgU3ZnQ0Iuc3ZnMik7XG4gICAgICBTdmdDQi5zdmcyLmxhc3RWYWx1ZSA9IFN2Z0NCLnN2ZzIuY3VycmVudDtcbiAgICAgIFN2Z0NCLnN2ZzIuYW5pbWF0ZSA9IHRydWU7XG4gICAgICBTdmdDQi5zdmcyLmN1cnJlbnQgPSB0b3RhbFJldjtcbiAgICAgIC8vICBsZXQgczMgPSBPYmplY3QuYXNzaWduKHt9LCBTdmdDQi5zdmczKTtcbiAgICAgIFN2Z0NCLnN2ZzMubGFzdFZhbHVlID0gU3ZnQ0Iuc3ZnMy5jdXJyZW50O1xuICAgICAgU3ZnQ0Iuc3ZnMy5hbmltYXRlID0gdHJ1ZTtcbiAgICAgIFN2Z0NCLnN2ZzMuY3VycmVudCA9IFN2Z0NCLnN2ZzMuY3VycmVudCArIChTdmdDQi5zdmcyLmN1cnJlbnQgLSBTdmdDQi5zdmcyLmxhc3RWYWx1ZSk7XG4gICAgICAvLyAgbGV0IHM0ID0gIE9iamVjdC5hc3NpZ24oe30sIFN2Z0NCLnN2ZzQpO1xuICAgICAgU3ZnQ0Iuc3ZnNC5sYXN0VmFsdWUgPSBTdmdDQi5zdmc0LmN1cnJlbnQ7XG4gICAgICBTdmdDQi5zdmc0LmFuaW1hdGUgPSB0cnVlO1xuICAgICAgU3ZnQ0Iuc3ZnNC5jdXJyZW50ICs9IChNYXRoLnJvdW5kKHBhc3RUcmFkZXNbMF0ucHJvZml0ICogMTAwKSAvIDEwMCk7XG4gICAgICAvLyAgIGxldCBzNSA9ICBPYmplY3QuYXNzaWduKHt9LCBTdmdDQi5zdmc1KTtcbiAgICAgIFN2Z0NCLnN2ZzUubGFzdFZhbHVlID0gU3ZnQ0Iuc3ZnNS5jdXJyZW50XG4gICAgICBTdmdDQi5zdmc1LmFuaW1hdGUgPSB0cnVlO1xuICAgICAgU3ZnQ0Iuc3ZnNS5jdXJyZW50ICs9IHBhc3RUcmFkZXNbMF0udm9sdW1lO1xuICAgICAgaWYgKFN2Z0NCLmluVmlld0Jvb2wpIHtcbiAgICAgICAgIFsnc3ZnMScsICdzdmcyJywgJ3N2ZzMnLCAnc3ZnNCcsICdzdmc1J10uZm9yRWFjaCgoaXRtKSA9PiB7XG4gICAgICAgICAgICBpZiAoIVN2Z0NCW2l0bV0pXG4gICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIGxldCBjdVNWRyA9IFN2Z0NCW2l0bV07XG4gICAgICAgICAgICBpZiAoY3VTVkcuYW5pbWF0ZSkge1xuICAgICAgICAgICAgICAgU3ZnQ0Iuc3ZnQW5pbWF0ZShjdVNWRy5sYXN0VmFsdWUsIGN1U1ZHLmN1cnJlbnQsIGN1U1ZHKTtcbiAgICAgICAgICAgICAgIC8vY3VTVkcuYW5pbWF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfSk7XG4gICAgICB9XG4gICB9XG4gICByZXR1cm4gU3ZnQ0I7XG5cbn07XG5leHBvcnQgZGVmYXVsdCBzdGF0U1ZHcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9jb21wb25lbnRzL3N2Zy9zdGF0U1ZHLmpzIiwiY29uc3QgTkVXX1BBVEggPSAnTkVXX1BBVEgnO1xuXG5leHBvcnQgeyBORVdfUEFUSCB9XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29uc3RhbnRzL3JvdXRlcy5qcyIsImNvbnN0IEZFVENIX1RSQURFUyA9ICdGRVRDSF9UUkFERVMnXG5jb25zdCBGRVRDSF9UUkFERVNfUkVKRUNURUQgPSAnRkVUQ0hfVFJBREVTX1JFSkVDVEVEJ1xuY29uc3QgRkVUQ0hfVFJBREVTX0ZVTEZJTExFRCA9ICdGRVRDSF9UUkFERVNfRlVMRklMTEVEJ1xuY29uc3QgREVQT1NJVF9DSEFOR0UgPSAnREVQT1NJVF9DSEFOR0UnXG5jb25zdCBBRERfVFJBREUgPSAnQUREX1RSQURFJ1xuY29uc3QgVFJBREVfQ09NUExFVEUgPSAnVFJBREVfQ09NUExFVEUnXG5jb25zdCBBRERfTU9ORVkgPSAnQUREX01PTkVZJ1xuXG5cbmV4cG9ydCB7XG4gIEZFVENIX1RSQURFUyxcbiAgRkVUQ0hfVFJBREVTX1JFSkVDVEVELFxuICBGRVRDSF9UUkFERVNfRlVMRklMTEVELFxuICBERVBPU0lUX0NIQU5HRSxcbiAgQUREX1RSQURFLFxuICBUUkFERV9DT01QTEVURSxcbiAgQUREX01PTkVZXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvY29uc3RhbnRzL3RyYWRlcy5qcyIsImNvbnN0IERFUE9TSVRfQ0hBTkdFID0gJ0RFUE9TSVRfQ0hBTkdFJ1xuXG5leHBvcnQge1xuICBERVBPU0lUX0NIQU5HRVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL2NvbnN0YW50cy90cmFuc2FjdGlvbnMuanMiLCJjb25zdCBDb3VudHJpZXMgPSB7QU1FUklDQTpbXCJBbnRpZ3VhIEFuZCBCYXJidWRhXCIsXCJBcmdlbnRpbmFcIixcIkFydWJhXCIsXCJCYWhhbWFzXCIsXCJCYXJiYWRvc1wiLFwiQmVsaXplXCIsXCJCZXJtdWRhXCIsXCJCb2xpdmlhXCIsXG5cIkJyYXppbFwiLFwiQ2FuYWRhXCIsXCJDYXltYW4gSXNsYW5kc1wiLFwiQ2hpbGVcIixcIkNvbG9tYmlhXCIsIFwiQ29zdGEgUmljYVwiLFwiQ3ViYVwiLFwiRG9taW5pY2FcIixcIkRvbWluaWNhbiBSZXB1YmxpY1wiLFxuXCJFY3VhZG9yXCIsXCJFbCBTYWx2YWRvclwiLFwiR3JlbmFkYVwiLFwiR3VhdGVtYWxhXCIsXCJHdXlhbmFcIixcIkhhaXRpXCIsXCJIb25kdXJhc1wiLFwiSmFtYWljYVwiLFwiTWV4aWNvXCIsXCJOaWNhcmFndWFcIixcblwiUGFuYW1hXCIsXCJQYXJhZ3VheVwiLFwiUGVydVwiLFwiUHVlcnRvIFJpY29cIixcIlN1cmluYW1lXCIsXCJUcmluaWRhZCBBbmQgVG9iYWdvXCIsXCJVbml0ZWQgU3RhdGVzXCIsXCJVcnVndWF5XCIsXCJWZW5lenVlbGFcIl0sXG5FVVJPUEU6W1wiQWxiYW5pYVwiLFwiQW5kb3JyYVwiLFwiQXVzdHJpYVwiLFwiQmVsYXJ1c1wiLFwiQmVsZ2l1bVwiLFwiQm9zbmlhIEFuZCBIZXJ6ZWdvdmluYVwiLFwiQnVsZ2FyaWFcIixcIkNyb2F0aWFcIixcIkN5cHJ1c1wiLFxuXCJDemVjaCBSZXB1YmxpY1wiLFwiRGVubWFya1wiLFwiRXN0b25pYVwiLFwiRXVybyBBcmVhXCIsXCJFdXJvcGVhbiBVbmlvblwiLFwiRmlubGFuZFwiLFwiRnJhbmNlXCIsXCJHZXJtYW55XCIsXCJHcmVlY2VcIixcIkh1bmdhcnlcIixcblwiSWNlbGFuZFwiLFwiSXJlbGFuZFwiLFwiSXNsZSBPZiBNYW5cIixcIkl0YWx5XCIsXCJLb3Nvdm9cIixcIkxhdHZpYVwiLFwiTGllY2h0ZW5zdGVpblwiLFwiTGl0aHVhbmlhXCIsXCJMdXhlbWJvdXJnXCIsXCJNYWNlZG9uaWFcIixcblwiTWFsdGFcIixcIk1vbGRvdmFcIixcIk1vbmFjb1wiLFwiTW9udGVuZWdyb1wiLFwiTmV0aGVybGFuZHNcIixcIk5vcndheVwiLFwiUG9sYW5kXCIsXCJQb3J0dWdhbFwiLFwiUm9tYW5pYVwiLFwiUnVzc2lhXCIsXCJTZXJiaWFcIixcblwiU2xvdmFraWFcIixcIlNsb3ZlbmlhXCIsXCJTcGFpblwiLFwiU3dlZGVuXCIsXCJTd2l0emVybGFuZFwiLFwiVHVya2V5XCIsXCJVa3JhaW5lXCIsXCJVbml0ZWQgS2luZ2RvbVwiXSxcbkFGUklDQTpbXCJBbGdlcmlhXCIsXCJBbmdvbGFcIixcIkJlbmluXCIsXCJCb3Rzd2FuYVwiLFwiQnVya2luYSBGYXNvXCIsXCJCdXJ1bmRpXCIsXCJDYW1lcm9vblwiLFwiQ2FwZSBWZXJkZVwiLFwiQ2VudHJhbCBBZnJpY2FuIFJlcHVibGljXCIsXG5cIkNoYWRcIixcIkNvbW9yb3NcIixcIkNvbmdvXCIsXCJEamlib3V0aVwiLFwiRWd5cHRcIixcIkVxdWF0b3JpYWwgR3VpbmVhXCIsXCJFcml0cmVhXCIsXCJFdGhpb3BpYVwiLFwiR2Fib25cIixcIkdhbWJpYVwiLFwiR2hhbmFcIixcIkd1aW5lYVwiLFwiR3VpbmVhIEJpc3NhdVwiLFwiSXZvcnkgQ29hc3RcIixcblwiS2VueWFcIixcIkxlc290aG9cIixcIkxpYmVyaWFcIixcIkxpYnlhXCIsXCJNYWRhZ2FzY2FyXCIsXCJNYWxhd2lcIixcIk1hbGlcIixcIk1hdXJpdGFuaWFcIixcIk1hdXJpdGl1c1wiLFxuXCJNb3JvY2NvXCIsXCJNb3phbWJpcXVlXCIsXCJOYW1pYmlhXCIsXCJOaWdlclwiLFwiTmlnZXJpYVwiLFwiUmVwdWJsaWMgT2YgVGhlIENvbmdvXCIsXCJSd2FuZGFcIixcIlNhbyBUb21lIEFuZCBQcmluY2lwZVwiLFwiU2VuZWdhbFwiLFxuXCJTZXljaGVsbGVzXCIsXCJTaWVycmEgTGVvbmVcIixcIlNvbWFsaWFcIixcIlNvdXRoIEFmcmljYVwiLFwiU291dGggU3VkYW5cIixcIlN1ZGFuXCIsXCJTd2F6aWxhbmRcIixcIlRhbnphbmlhXCIsXCJUb2dvXCIsXCJUdW5pc2lhXCIsXCJVZ2FuZGFcIixcblwiWmFtYmlhXCIsXCJaaW1iYWJ3ZVwiXSxcbkFTSUE6W1wiQWZnaGFuaXN0YW5cIixcIkFybWVuaWFcIixcIkF6ZXJiYWlqYW5cIixcIkJhaHJhaW5cIixcIkJhbmdsYWRlc2hcIixcIkJodXRhblwiLFwiQnJ1bmVpXCIsXCJDYW1ib2RpYVwiLFwiQ2hpbmFcIixcIkVhc3QgVGltb3JcIixcIkdlb3JnaWFcIixcIkluZGlhXCIsXCJJbmRvbmVzaWFcIixcIklyYW5cIixcIklyYXFcIixcIklzcmFlbFwiLFwiSmFwYW5cIixcIkpvcmRhblwiLFwiS2F6YWtoc3RhblwiLFwiS3V3YWl0XCIsXCJLeXJneXpzdGFuXCIsXCJMYW9zXCIsXCJMZWJhbm9uXCIsXCJNYWxheXNpYVwiLFwiTWFsZGl2ZXNcIixcIk1vbmdvbGlhXCIsXCJNeWFubWFyXCIsXG5cIk5lcGFsXCIsXCJOb3J0aCBLb3JlYVwiLFwiT21hblwiLFwiUGFsZXN0aW5lXCIsXCJQYWtpc3RhblwiLFwiUGhpbGlwcGluZXNcIixcIlFhdGFyXCIsXCJTYXVkaSBBcmFiaWFcIixcIlNpbmdhcG9yZVwiLFxuXCJTb3V0aCBLb3JlYVwiLFwiU3JpIExhbmthXCIsXCJTeXJpYVwiLFwiVGFpd2FuXCIsXCJUYWppa2lzdGFuXCIsXCJUaGFpbGFuZFwiLFwiVHVya21lbmlzdGFuXCIsXCJVbml0ZWQgQXJhYiBFbWlyYXRlc1wiLFxuXCJVemJla2lzdGFuXCIsXCJWaWV0bmFtXCIsXCJZZW1lblwiXSxcIkFVU1RSQUxJQVwiOltcIkF1c3RyYWxpYVwiLFwiRmlqaVwiLFwiS2lyaWJhdGlcIixcIk5ldyBDYWxlZG9uaWFcIixcIk5ldyBaZWFsYW5kXCIsXG5cIlBhcHVhIE5ldyBHdWluZWFcIixcIlNhbW9hXCIsXCJTb2xvbW9uIElzbGFuZHNcIixcIlRvbmdhXCIsXCJWYW51YXR1XCJdfTtcblxuZXhwb3J0IGRlZmF1bHQgQ291bnRyaWVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL2RhdGEvY291bnRyaWVzLmpzIiwiY29uc3QgZm9yZXhTeW1ib2xQYWlycyA9IFtcbiAgICdBVUQvSlBZJyxcbiAgICdBVUQvVVNEJyxcbiAgICdDQUQvQ0hGJyxcbiAgICdDQUQvSlBZJyxcbiAgICdDSEYvSlBZJyxcbiAgICdFVVIvQVVEJyxcbiAgICdFVVIvQ0FEJyxcbiAgICdFVVIvR0JQJyxcbiAgICdFVVIvSlBZJyxcbiAgICdFVVIvTk9LJyxcbiAgICdFVVIvU0VLJyxcbiAgICdFVVIvVVNEJyxcbiAgICdHQlAvQ0hGJyxcbiAgICdHQlAvSlBZJyxcbiAgICdHQlAvVVNEJyxcbiAgICdOWkQvSlBZJyxcbiAgICdOWkQvVVNEJyxcbiAgICdVU0QvQlJMJyxcbiAgICdVU0QvQ0FEJyxcbiAgICdVU0QvQ0hGJyxcbiAgICdVU0QvQ05ZJyxcbiAgICdVU0QvQ1pLJyxcbiAgICdVU0QvSEtEJyxcbiAgICdVU0QvSU5SJyxcbiAgICdVU0QvSlBZJyxcbiAgICdVU0QvS1JXJyxcbiAgICdVU0QvTVhOJyxcbiAgICdVU0QvTk9LJyxcbiAgICdVU0QvUExOJyxcbiAgICdVU0QvUlVCJyxcbiAgICdVU0QvU0VLJyxcbiAgICdVU0QvU0dEJyxcbiAgICdVU0QvWkFSJ1xuXTtcblxuZXhwb3J0IGRlZmF1bHQgZm9yZXhTeW1ib2xQYWlycztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9kYXRhL2ZvcmV4X3N5bWJvbF9wYWlycy5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IHN0b2NrU3ltYnMgPSBbXG4gICAnQUFQTCcsXG4gICAnWUhPTycsXG4gICAnTVNGVCcsXG4gICAnU05FJyxcbiAgICdHT09HJyxcbiAgICdBTVpOJyxcbiAgICdPSUxEJyxcbiAgICdBRUlTJyxcbiAgICdBTUQnLFxuICAgJ0FMR04nLFxuICAgJ0FQRUknLFxuICAgJ0FTTUwnLFxuICAgJ0FTVEUnLFxuICAgJ0FMT1QnLFxuICAgJ0FUUkknLFxuICAgJ0FEUkUnLFxuICAgJ0JNQ0gnLFxuICAgJ0JSS1MnLFxuICAgJ0NBJyxcbiAgICdDUExBJyxcbiAgICdDQVJPJyxcbiAgICdDQVNZJyxcbiAgICdDQk5LJyxcbiAgICdDU0NPJyxcbiAgICdDVkxUJyxcbiAgICdDWUJFJyxcbiAgICdDWU5PJyxcbiAgICdDWVJOJyxcbiAgICdETFRSJyxcbiAgICdET1JNJyxcbiAgICdFQkFZJyxcbiAgICdGTlRDVycsXG4gICAnRkZCQycsXG4gICAnVEhGRicsXG4gICAnU0tZWScsXG4gICAnRkVYJyxcbiAgICdGVEMnLFxuICAgJ0ZUQScsXG4gICAnRkFCJyxcbiAgICdURElWJyxcbiAgICdRVEVDJyxcbiAgICdGWVgnLFxuICAgJ0ZJVkUnLFxuICAgJ0ZFTEUnLFxuICAgJ0dSTU4nLFxuICAgJ0dFTkMnLFxuICAgJ0dOVFgnLFxuICAgJ1NPQ0wnLFxuICAgJ0dERU4nLFxuICAgJ0dCREMnLFxuICAgJ0lFU0MnLFxuICAgJ0lQQVInLFxuICAgJ1NPWFgnLFxuICAgJ0pLSFknLFxuICAgJ0pTTUQnLFxuICAgJ0tFUVUnLFxuICAgJ0tMQUMnLFxuICAgJ0xLRk4nLFxuICAgJ0xSQ1gnLFxuICAgJ0xYUlgnLFxuICAgJ0xHSUgnLFxuICAgJ0xTWE1CJyxcbiAgICdMU1hNQScsXG4gICAnTExUQycsXG4gICAnTElURScsXG4gICAnTUdJQycsXG4gICAnTUJGSScsXG4gICAnTUdQSScsXG4gICAnTUNIUCcsXG4gICAnTUtTSScsXG4gICAnTVBXUicsXG4gICAnTkFOTycsXG4gICAnTkdIQ1onLFxuICAgJ05BVEwnLFxuICAgJ05URVMnLFxuICAgJ05WRUUnLFxuICAgJ05WREEnLFxuICAgJ09DTFInLFxuICAgJ09STFknLFxuICAgJ1BERlMnLFxuICAgJ1BFQk8nLFxuICAgJ1BFQksnLFxuICAgJ1BSRlQnLFxuICAgJ1BPV0knLFxuICAgJ1BTQ0knLFxuICAgJ1BTQ1QnLFxuICAgJ1BTRUMnLFxuICAgJ1BST1YnLFxuICAgJ1FDUkgnLFxuICAgJ1JBVk4nLFxuICAgJ1JPU1QnLFxuICAgJ1NNVEMnLFxuICAgJ1NJUkknLFxuICAgJ0pTTScsXG4gICAnT0tTQicsXG4gICAnU1BBUicsXG4gICAnVFhOJyxcbiAgICdTUE5DJyxcbiAgICdVQk5UJyxcbiAgICdVRlBJJyxcbiAgICdWVFdWJyxcbiAgICdWQVNDJyxcbiAgICdDRk8nLFxuICAgJ0NGQScsXG4gICAnQ0RMJyxcbiAgICdGTEFHJ1xuXS5zb3J0KCk7XG5jb25zdCBueXNlID0gW1xuICAgJ0FDTScsXG4gICAnQUtTJyxcbiAgICdBTUJSJyxcbiAgICdBUk1LJyxcbiAgICdCQU5DJyxcbiAgICdCU0JSJyxcbiAgICdCQVgnLFxuICAgJ0JITCcsXG4gICAnQkVSWScsXG4gICAnTE5EJyxcbiAgICdCUicsXG4gICAnQ0FUJyxcbiAgICdJR1InLFxuICAgJ0NJTScsXG4gICAnTUpOJyxcbiAgICdNU0NJJyxcbiAgICdNVVNBJyxcbiAgICdOQ0knLFxuICAgJ05YUlQnLFxuICAgJ05UQycsXG4gICAnTkVWJyxcbiAgICdQQ0knLFxuICAgJ1BISycsXG4gICAnUkNTJyxcbiAgICdQUFgnLFxuICAgJ1BMRCcsXG4gICAnUFJIJyxcbiAgICdUTEsnLFxuICAgJ1BTQScsXG4gICAnQ1RZJyxcbiAgICdDVEFBJyxcbiAgICdSRlQnLFxuICAgJ1NBUCcsXG4gICAnQU9TJyxcbiAgICdTV0snLFxuICAgJ0VERicsXG4gICAnU1JJJyxcbiAgICdCTEQnLFxuICAgJ1RUQycsXG4gICAnVERHJyxcbiAgICdVVFgnLFxuICAgJ1dDTicsXG4gICAnV0ZDJ1xuXS5zb3J0KCk7XG5cbmNvbnN0IGV4Y2hhbmdlU3ltYnMgPSAodXNlZEl0bXMpID0+IHtcbiAgIGNvbnN0IG5hc2RhcU9wdGlvbnMgPSBzdG9ja1N5bWJzLm1hcCgoc3ltYnMsIGlpKSA9PiB7XG4gICAgICBpZiAodXNlZEl0bXMudGVzdChzeW1icykpIHtcbiAgICAgICAgIC8vIHJldHVybiAgPG9wdGlvbiBrZXk9e3N5bWJzfSBkaXNhYmxlZD1cInRydWVcIiB2YWx1ZT17c3ltYnN9ID57c3ltYnN9PC9vcHRpb24+O1xuICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIDxvcHRpb24ga2V5PXtzeW1ic30gdmFsdWU9e3N5bWJzfT57c3ltYnN9PC9vcHRpb24+O1xuICAgICAgfVxuICAgfSk7XG4gICBjb25zdCBueXNlT3B0aW9ucyA9IG55c2UubWFwKChzeW1icywgaWkpID0+IHtcbiAgICAgIGlmICh1c2VkSXRtcy50ZXN0KHN5bWJzKSkge1xuICAgICAgICAgLy8gIHJldHVybiAgPG9wdGlvbiBrZXk9e3N5bWJzfSBkaXNhYmxlZD1cInRydWVcIiB2YWx1ZT17c3ltYnN9ID57c3ltYnN9PC9vcHRpb24+O1xuICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIDxvcHRpb24ga2V5PXtzeW1ic30gdmFsdWU9e3N5bWJzfT57c3ltYnN9PC9vcHRpb24+O1xuICAgICAgfVxuICAgfSk7XG5cbiAgIHJldHVybiB7XG4gICAgICBOQVNEQVE6IG5hc2RhcU9wdGlvbnMsXG4gICAgICBOWVNFOiBueXNlT3B0aW9uc1xuICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgIGV4Y2hhbmdlU3ltYnM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvZGF0YS9nb3N5bWJvbHMuanMiLCJjb25zdCB1cmxCYXNlID0gZmFsc2UgPyAnMTI3LjAuMC4xOjgwMDAvd3MnIDogJ2RhbXAtYmV5b25kLTY0MTM4Lmhlcm9rdWFwcC5jb20vd3MnO1xuXG5jb25zdCBPcGVuV2Vic29ja2V0ID0gKCkgPT4ge1xuICBjb25zdCB0aGVTb2NrZXRVcmwgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgIT09ICdodHRwczonID8gJ3dzOi8vJyArIHVybEJhc2UgOiAnd3NzOi8vJyArIHVybEJhc2U7XG5cbiAgY29uc3QgU09DS0VUID0gbmV3IFdlYlNvY2tldCh0aGVTb2NrZXRVcmwpO1xuICBTT0NLRVQub24gPSB7fTtcbiAgU09DS0VULndhdGNoZWRGZWVkcyA9IHt9XG4gIFNPQ0tFVC5kaXNwYXRjaEV2ZW50ID0gKG5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgU09DS0VULm9uW25hbWVdID0gY2FsbGJhY2s7XG4gIH1cblxuICBTT0NLRVQub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgdGhlRGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgaWYgKCFTT0NLRVQud2F0Y2hlZEZlZWRzW3RoZURhdGEuc3ltYl0pIHtcbiAgICAgIFNPQ0tFVC53YXRjaGVkRmVlZHNbdGhlRGF0YS5zeW1iXSA9IHRydWU7XG4gICAgICBTT0NLRVQub24ubGl2ZUZlZWRTdGFydGVkKHRoZURhdGEuc3ltYik7XG4gICAgfVxuICAgIFNPQ0tFVC5vblt0aGVEYXRhLnN5bWJdKHRoZURhdGEpO1xuICB9XG4gIHJldHVybiBTT0NLRVQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IE9wZW5XZWJzb2NrZXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvZGF0YS9nb3dlYnNvY2tldC5qcyIsImNvbnN0IEluZGljYXRvcnMgPSBbXG4gICBcImdkcC1wZXItY2FwaXRhXCIsXG4gICBcImdkcC1ncm93dGgtcmF0ZVwiLFxuICAgXCJnZHAtYW5udWFsLWdyb3d0aC1yYXRlXCIsXG4gICBcImludGVyZXN0LXJhdGVcIixcbiAgIFwiaW5mbGF0aW9uLXJhdGVcIixcbiAgIFwidW5lbXBsb3ltZW50LXJhdGVcIixcbiAgIFwiZ292ZXJubWVudC1kZWJ0LXRvLWdkcFwiLFxuICAgXCJnZHBcIixcbiAgIFwiZ2RwLXBlci1jYXBpdGFcIixcbiAgIFwicG9wdWxhdGlvblwiLFxuICAgXCJwcm9kdWN0aXZpdHlcIixcbiAgIFwiYmFsYW5jZS1vZi10cmFkZVwiLFxuICAgXCJjdXJyZW50LWFjY291bnQtdG8tZ2RwXCIsXG4gICBcImNydWRlLW9pbC1wcm9kdWN0aW9uXCIsXG4gICBcImZvcmVpZ24tZXhjaGFuZ2UtcmVzZXJ2ZXNcIixcbiAgIFwicmF0aW5nXCIsXG4gICBcImNvcnBvcmF0ZS10YXgtcmF0ZVwiLFxuICAgXCJwZXJzb25hbC1pbmNvbWUtdGF4LXJhdGVcIixcbiAgIFwicmV0aXJlbWVudC1hZ2UtbWVuXCIsXG4gICBcInJldGlyZW1lbnQtYWdlLXdvbWVuXCIsXG4gICBcInBvcHVsYXRpb25cIixcbiAgIFwiZ2RwLXBlci1jYXBpdGFcIlxuXTtcblxuZXhwb3J0IGRlZmF1bHQgSW5kaWNhdG9ycztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9kYXRhL2luZGljYXRvcnMuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5jb25zdCBuYXNTeW1icyA9IFtcbiAgICdBQVBMJyxcbiAgICdZSE9PJyxcbiAgICdNU0ZUJyxcbiAgICdTTkUnLFxuICAgJ0dPT0cnLFxuICAgJ0FNWk4nLFxuICAgJ09JTEQnLFxuICAgJ0FFSVMnLFxuICAgJ0FNRCcsXG4gICAnQUxHTicsXG4gICAnQVBFSScsXG4gICAnQVNNTCcsXG4gICAnQVNURScsXG4gICAnQUxPVCcsXG4gICAnQVRSSScsXG4gICAnQURSRScsXG4gICAnQk1DSCcsXG4gICAnQlJLUycsXG4gICAnQ0EnLFxuICAgJ0NQTEEnLFxuICAgJ0NBUk8nLFxuICAgJ0NBU1knLFxuICAgJ0NCTksnLFxuICAgJ0NTQ08nLFxuICAgJ0NWTFQnLFxuICAgJ0NZQkUnLFxuICAgJ0NZTk8nLFxuICAgJ0NZUk4nLFxuICAgJ0RMVFInLFxuICAgJ0RPUk0nLFxuICAgJ0VCQVknLFxuICAgJ0ZOVENXJyxcbiAgICdGRkJDJyxcbiAgICdUSEZGJyxcbiAgICdTS1lZJyxcbiAgICdGRVgnLFxuICAgJ0ZUQycsXG4gICAnRlRBJyxcbiAgICdGQUInLFxuICAgJ1RESVYnLFxuICAgJ1FURUMnLFxuICAgJ0ZZWCcsXG4gICAnRklWRScsXG4gICAnRkVMRScsXG4gICAnR1JNTicsXG4gICAnR0VOQycsXG4gICAnR05UWCcsXG4gICAnU09DTCcsXG4gICAnR0RFTicsXG4gICAnR0JEQycsXG4gICAnSUVTQycsXG4gICAnSVBBUicsXG4gICAnU09YWCcsXG4gICAnSktIWScsXG4gICAnSlNNRCcsXG4gICAnS0VRVScsXG4gICAnS0xBQycsXG4gICAnTEtGTicsXG4gICAnTFJDWCcsXG4gICAnTFhSWCcsXG4gICAnTEdJSCcsXG4gICAnTFNYTUInLFxuICAgJ0xTWE1BJyxcbiAgICdMTFRDJyxcbiAgICdMSVRFJyxcbiAgICdNR0lDJyxcbiAgICdNQkZJJyxcbiAgICdNR1BJJyxcbiAgICdNQ0hQJyxcbiAgICdNS1NJJyxcbiAgICdNUFdSJyxcbiAgICdOQU5PJyxcbiAgICdOR0hDWicsXG4gICAnTkFUTCcsXG4gICAnTlRFUycsXG4gICAnTlZFRScsXG4gICAnTlZEQScsXG4gICAnT0NMUicsXG4gICAnT1JMWScsXG4gICAnUERGUycsXG4gICAnUEVCTycsXG4gICAnUEVCSycsXG4gICAnUFJGVCcsXG4gICAnUE9XSScsXG4gICAnUFNDSScsXG4gICAnUFNDVCcsXG4gICAnUFNFQycsXG4gICAnUFJPVicsXG4gICAnUUNSSCcsXG4gICAnUkFWTicsXG4gICAnUk9TVCcsXG4gICAnU01UQycsXG4gICAnU0lSSScsXG4gICAnSlNNJyxcbiAgICdPS1NCJyxcbiAgICdTUEFSJyxcbiAgICdUWE4nLFxuICAgJ1NQTkMnLFxuICAgJ1VCTlQnLFxuICAgJ1VGUEknLFxuICAgJ1ZUV1YnLFxuICAgJ1ZBU0MnLFxuICAgJ0NGTycsXG4gICAnQ0ZBJyxcbiAgICdDREwnLFxuICAgJ0ZMQUcnXG5dLnNvcnQoKTtcbmNvbnN0IG55c2VTeW1icyA9IFtcbiAgICdBQ00nLFxuICAgJ0FLUycsXG4gICAnQU1CUicsXG4gICAnQVJNSycsXG4gICAnQkFOQycsXG4gICAnQlNCUicsXG4gICAnQkFYJyxcbiAgICdCSEwnLFxuICAgJ0JFUlknLFxuICAgJ0xORCcsXG4gICAnQlInLFxuICAgJ0NBVCcsXG4gICAnSUdSJyxcbiAgICdDSU0nLFxuICAgJ01KTicsXG4gICAnTVNDSScsXG4gICAnTVVTQScsXG4gICAnTkNJJyxcbiAgICdOWFJUJyxcbiAgICdOVEMnLFxuICAgJ05FVicsXG4gICAnUENJJyxcbiAgICdQSEsnLFxuICAgJ1JDUycsXG4gICAnUFBYJyxcbiAgICdQTEQnLFxuICAgJ1BSSCcsXG4gICAnVExLJyxcbiAgICdQU0EnLFxuICAgJ0NUWScsXG4gICAnQ1RBQScsXG4gICAnUkZUJyxcbiAgICdTQVAnLFxuICAgJ0FPUycsXG4gICAnU1dLJyxcbiAgICdFREYnLFxuICAgJ1NSSScsXG4gICAnQkxEJyxcbiAgICdUVEMnLFxuICAgJ1RERycsXG4gICAnVVRYJyxcbiAgICdXQ04nLFxuICAgJ1dGQydcbl0uc29ydCgpO1xuXG5jb25zdCBuYXNkYXFPcHRzID0gbmFzU3ltYnMubWFwKChzeW1icywgaWkpID0+IHtcblxuICAgcmV0dXJuIDxvcHRpb24ga2V5PXtzeW1ic30gdmFsdWU9e3N5bWJzfT57c3ltYnN9PC9vcHRpb24+O1xuXG59KTtcbmNvbnN0IG55c2VPcHRzID0gbnlzZVN5bWJzLm1hcCgoc3ltYnMsIGlpKSA9PiB7XG5cbiAgIHJldHVybiA8b3B0aW9uIGtleT17c3ltYnN9IHZhbHVlPXtzeW1ic30+e3N5bWJzfTwvb3B0aW9uPjtcblxufSk7XG5cbmNvbnN0IGV4Y2hhbmdlT3B0aW9ucyA9IHtcbiAgIE5BU0RBUTogbmFzZGFxT3B0cyxcbiAgIE5ZU0U6IG55c2VPcHRzXG59XG5leHBvcnQgZGVmYXVsdCBleGNoYW5nZU9wdGlvbnM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvZGF0YS9zdG9ja3MuanMiLCJpbXBvcnQgY2hhcnRNYWtlciBmcm9tICdncmFwaF9oZWxwZXJzL2NoYXJ0cy5qcyc7XG5cbmNvbnN0IGFza0JpZFZvbHVtZSA9IChib29sLCB2MSwgdjIpID0+IHtcbiAgIGlmIChib29sKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAgTWF0aC5tYXgodjEsIHYyKSxcbiAgICAgICAgIE1hdGgubWluKHYxLCB2MilcbiAgICAgIF1cbiAgIH1cbiAgIHJldHVybiBbXG4gICAgICBNYXRoLm1pbih2MSwgdjIpLFxuICAgICAgTWF0aC5tYXgodjEsIHYyKVxuICAgXVxuXG59O1xuXG5jbGFzcyBHcmFwaENvbnRyb2xsZXIge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLmRvbnV0Q2hhcnQgPSBudWxsO1xuXHRcdHRoaXMuY29tYm9DaGFydCA9IG51bGw7XG4gICAgdGhpcy5wb3NQcm9wcyA9IHtcbiAgICAgIHByaWNlc3RhcnQ6IDAsXG4gICAgICBwcmljZWVuZDogMFxuICAgIH1cblx0fVxuICB1cGRhdGVQb3NQcm9wcyA9ICh7cHJpY2VzdGFydCwgcHJpY2VlbmR9KSA9PiB7XG4gICAgdGhpcy5wb3NQcm9wcyA9IHtcbiAgICAgIHByaWNlc3RhcnQsXG4gICAgICBwcmljZWVuZFxuICAgIH1cbiAgfVxuICBjcmVhdGVDaGFydHMgPSAoe3ByaWNlc3RhcnQsIHByaWNlZW5kfSkgPT4ge1xuICAgIHRoaXMucG9zUHJvcHMgPSB7XG4gICAgICBwcmljZXN0YXJ0LFxuICAgICAgcHJpY2VlbmRcbiAgICB9XG4gICAgdGhpcy5kb251dENoYXJ0ID0gY2hhcnRNYWtlci5tYWtlQ2hhcnQoJ2NoYXJ0MXZpZXcnLCB0aGlzLnJhdGlvRGF0YSgpLCAnZG91Z2hudXQnLCB7XG4gICAgICAgaGVpZ2h0OiAxNTAsXG4gICAgICAgYW5pbWF0ZTogdHJ1ZSxcbiAgICAgICBiYWNrZ3JvdW5kOiAnIzE4MjUyZScsXG4gICAgICAgbXNBbmk6IDkwMFxuICAgIH0pXG4gICAgdGhpcy5jb21ib0NoYXJ0ID0gY2hhcnRNYWtlci5tYWtlQ29tYm9DaGFydCgnY2hhcnQydmlldycsIHtcbiAgICAgICBwcmljZTogcHJpY2VzdGFydCxcbiAgICAgICBsZW46IDMwXG4gICAgfSwge1xuICAgICAgIG1zQW5pOiA5MDAsXG4gICAgICAgYVltaW46IHByaWNlc3RhcnQgKiAwLjhcbiAgICB9KTtcbiAgfVxuICByYXRpb0RhdGEgPSAoKSA9PiB7XG4gICAgY29uc3QgYXNrQmlkID0gYXNrQmlkVm9sdW1lKHRoaXMucG9zUHJvcHMucHJpY2VzdGFydCA8IHRoaXMucG9zUHJvcHMucHJpY2VlbmQsIChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkgKyAxMDAwKSwgKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKSArIDEwMDApKTtcblxuICAgIHJldHVybiBbXG4gICAgICAge1xuICAgICAgICAgIHk6IGFza0JpZFswXSxcbiAgICAgICAgICBuYW1lOiAnQmlkJyxcbiAgICAgICAgICBmaWxsT3BhY2l0eTogLjksXG4gICAgICAgICAgbGVnZW5kVGV4dDogJ0JpZCcsXG4gICAgICAgICAgY29sb3I6ICcjMzBkOTRjJ1xuICAgICAgIH0sIHtcbiAgICAgICAgICB5OiBhc2tCaWRbMV0sXG4gICAgICAgICAgbmFtZTogJ0FzaycsXG4gICAgICAgICAgZmlsbE9wYWNpdHk6IC45LFxuICAgICAgICAgIGxlZ2VuZFRleHQ6ICdBc2snLFxuICAgICAgICAgIGNvbG9yOiAncmVkJ1xuICAgICAgIH1cbiAgICAgIF1cbiAgfVxuICB1cGRhdGVDaGFydHMgPSAoKSA9PiB7XG4gICAgdGhpcy5kb251dENoYXJ0Lm5ld1NldCh0aGlzLnJhdGlvRGF0YSgpKVxuICAgIHRoaXMuY29tYm9DaGFydC5nZW5EYXRhKHRoaXMucG9zUHJvcHMucHJpY2VzdGFydCwgMzApO1xuICB9XG5cdHJlbmRlckNoYXJ0cyA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5kb251dENoYXJ0ID09PSBudWxsIHx8IHRoaXMuY29tYm9DaGFydCA9PT0gbnVsbCApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2V0VGltZW91dCh0aGlzLnVwZGF0ZUNoYXJ0cywgNzApO1xuXHR9XG59XG5cbmNvbnN0IHZpZXdDbnRybCA9IG5ldyBHcmFwaENvbnRyb2xsZXIoKTtcblxuZXhwb3J0IGRlZmF1bHQgdmlld0NudHJsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL2hlbHBlcnMvZ3JhcGhfY29udHJvbGxlci5qcyIsImltcG9ydCB7cmFuZG9tRmluYW5jaWFsfSBmcm9tICdkM2ZjLXJhbmRvbS1kYXRhJztcblxuY29uc3QgZ2V0UmFuZG9tRGF0YSA9IChzZWVkRGF0ZSwgcHJpY2UpID0+IHJhbmRvbUZpbmFuY2lhbCgpLnN0YXJ0RGF0ZShuZXcgRGF0ZSgpKS5zdGFydFByaWNlKHByaWNlKTtcblxuY29uc3QgZG9udXRDb25maWcgPSAoZGF0YSwge2hlaWdodCwgYW5pbWF0ZSwgYmFja2dyb3VuZCwgbXNBbml9KSA9PiAoe1xuICBoZWlnaHQ6IGhlaWdodCA/IGhlaWdodCA6IDE1MCxcbiAgYW5pbWF0aW9uRW5hYmxlZDogYW5pbWF0ZSA/IGFuaW1hdGUgOiB0cnVlLFxuICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmQgPyBiYWNrZ3JvdW5kIDogXCIjMTgyNTJlXCIsXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiBtc0FuaSA/IG1zQW5pIDogMTMwMCxcbiAgbGVnZW5kOiB7XG4gICAgdmVydGljYWxBbGlnbjogXCJ0b3BcIixcbiAgICBob3Jpem9udGFsQWxpZ246IFwiY2VudGVyXCJcbiAgfSxcbiAgZGF0YTogW1xuICAgIHtcbiAgICAgIHN0YXJ0QW5nbGU6IDQ1LFxuICAgICAgdHlwZTogXCJkb3VnaG51dFwiLFxuICAgICAgZGF0YVBvaW50czogZGF0YVxuICAgIH1cbiAgXVxufSlcblxuY29uc3QgY29sdW1uQ29uZmlnID0gKGRhdGEsIHtoZWlnaHQsIGFuaW1hdGUsIGJhY2tncm91bmQsIG1zQW5pfSkgPT4gKHtcbiAgaGVpZ2h0OiBoZWlnaHQgPyBoZWlnaHQgOiAxNTAsXG4gIGFuaW1hdGlvbkVuYWJsZWQ6IGFuaW1hdGUgPyBhbmltYXRlIDogdHJ1ZSxcbiAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kID8gYmFja2dyb3VuZCA6IFwiIzE4MjUyZVwiLFxuICBhbmltYXRpb25EdXJhdGlvbjogbXNBbmkgPyBtc0FuaSA6IDEzMDAsXG4gIGRhdGE6IFtcbiAgICB7XG4gICAgICB0eXBlOiBcImNvbHVtblwiLFxuICAgICAgZGF0YVBvaW50czogZGF0YVxuICAgIH1cbiAgXVxufSlcblxuY29uc3QgcmFuZ2VBcmVhQ29uZmlnID0gKGRhdGEsIHtoZWlnaHQsIGFuaW1hdGUsIGJhY2tncm91bmQsIG1zQW5pfSkgPT4gKHtcbiAgaGVpZ2h0OiBoZWlnaHQgPyBoZWlnaHQgOiAxNTAsXG4gIGFuaW1hdGlvbkVuYWJsZWQ6IGFuaW1hdGUgPyBhbmltYXRlIDogdHJ1ZSxcbiAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kID8gYmFja2dyb3VuZCA6IFwiIzE4MjUyZVwiLFxuICBhbmltYXRpb25EdXJhdGlvbjogbXNBbmkgPyBtc0FuaSA6IDEzMDAsXG4gIGRhdGE6IFtcbiAgICB7XG4gICAgICB0eXBlOiBcInJhbmdlQXJlYVwiLFxuICAgICAgZmlsbE9wYWNpdHk6IC42LFxuICAgICAgbWFya2VyVHlwZTogXCJub25lXCIsXG4gICAgICBkYXRhUG9pbnRzOiBkYXRhXG4gICAgfVxuICBdXG59KVxuXG5jb25zdCBwbGFpbk11bHRpU2VyaWVzID0gKGRhdGEsIHNldHRpbmdzID0ge30pID0+IHtcbiAgcmV0dXJuIHtcbiAgICBpbnRlcmFjdGl2aXR5RW5hYmxlZDogZmFsc2UsXG4gICAgYXhpc1g6IHtcbiAgICAgIHZhbHVlRm9ybWF0U3RyaW5nOiBcIiBcIixcblxuICAgICAgdGlja0xlbmd0aDogMSxcbiAgICAgIC8vICBsYWJlbEZvbnRDb2xvcjogIHNldHRpbmdzLmJhY2tncm91bmQgPyBzZXR0aW5ncy5iYWNrZ3JvdW5kIDogXCIjMTgyNTJlXCIsXG4gICAgICBsaW5lVGhpY2tuZXNzOiAxXG4gICAgfSxcbiAgICBheGlzWToge1xuICAgICAgdmFsdWVGb3JtYXRTdHJpbmc6IFwiXCIsXG4gICAgICBncmlkVGhpY2tuZXNzOiAwLjMsXG4gICAgICBtaW5pbXVtOiBzZXR0aW5ncy5taW4sXG4gICAgICBtYXhpbXVtOiBzZXR0aW5ncy5tYXgsXG4gICAgICBpbmNsdWRlWmVybzogZmFsc2UsXG4gICAgICB0aWNrTGVuZ3RoOiAxLFxuICAgICAgbWFyZ2luOiA1LFxuICAgICAgLy8gIGxhYmVsRm9udENvbG9yOiAgc2V0dGluZ3MuYmFja2dyb3VuZCA/IHNldHRpbmdzLmJhY2tncm91bmQgOiBcIiMxODI1MmVcIixcbiAgICAgIGdyaWRDb2xvcjogXCIjMjI0NDU4XCIsXG4gICAgICBsaW5lVGhpY2tuZXNzOiAxXG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHNldHRpbmdzLmJhY2tncm91bmQgPyBzZXR0aW5ncy5iYWNrZ3JvdW5kIDogXCIjMTgyNTJlXCIsXG4gICAgYW5pbWF0aW9uRW5hYmxlZDogdHJ1ZSxcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMTMwMCxcbiAgICBkYXRhOiBkYXRhXG4gIH1cbn1cbmNvbnN0IHZvbHVtZUFuZFJhbmdlID0gKGRhdGEsIHByaWNlKSA9PiB7XG4gIGxldCB0aGVNaW4gPSBwcmljZSAqIDI7XG4gIGxldCB0aGVNYXggPSAwO1xuICBsZXQgcG9pbnRzID0gZGF0YS5yZWR1Y2UoKG9iLCBpdG0pID0+IHtcbiAgICBvYi5yYW5nZS5wdXNoKHtcbiAgICAgIHg6IGl0bS5kYXRlLFxuICAgICAgeTogW2l0bS5sb3csIGl0bS5oaWdoXVxuICAgIH0pO1xuICAgIGxldCBjb2xDb2xvciA9IGl0bS5vcGVuIDwgaXRtLmNsb3NlID8gXCIjMzBkOTRjXCIgOiBcInJlZFwiO1xuICAgIHRoZU1pbiA9IE1hdGgubWluKHRoZU1pbiwgaXRtLmxvdyk7XG4gICAgdGhlTWF4ID0gTWF0aC5tYXgodGhlTWF4LCBpdG0uaGlnaCk7XG4gICAgb2IuY29sdW1uLnB1c2goe1xuICAgICAgeDogaXRtLmRhdGUsXG4gICAgICB5OiBNYXRoLmZsb29yKChpdG0udm9sdW1lIC8gMTAwMCkpLFxuICAgICAgY29sb3I6IGNvbENvbG9yXG4gICAgfSk7XG4gICAgcmV0dXJuIG9iO1xuICB9LCB7XG4gICAgY29sdW1uOiBbXSxcbiAgICByYW5nZTogW11cbiAgfSk7XG4gIGxldCBjb2x1bW5zID0gcG9pbnRzLmNvbHVtbi5tYXAoKGl0bSkgPT4ge1xuICAgIGl0bS55ID0gTWF0aC5mbG9vcigoTWF0aC5yYW5kb20oKSAqICgodGhlTWF4IC0gdGhlTWluKSkgLyAzKSArIHRoZU1pbik7XG4gICAgcmV0dXJuIGl0bTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgbWluTWF4OiB7XG4gICAgICBtaW46IHRoZU1pbixcbiAgICAgIG1heDogdGhlTWF4XG4gICAgfSxcbiAgICBkOiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiY29sdW1uXCIsXG4gICAgICAgIGRhdGFQb2ludHM6IGNvbHVtbnNcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJyYW5nZUFyZWFcIixcbiAgICAgICAgZmlsbE9wYWNpdHk6IC42LFxuICAgICAgICBtYXJrZXJUeXBlOiBcIm5vbmVcIixcbiAgICAgICAgZGF0YVBvaW50czogcG9pbnRzLnJhbmdlXG4gICAgICB9XG5cbiAgICBdXG4gIH07XG59XG5jb25zdCBraW5kQ29uZmlnID0gKGtpbmQsIGRhdGEsIHNldHRpbmdzKSA9PiB7XG4gIHN3aXRjaCAoa2luZCkge1xuICAgIGNhc2UgXCJkb3VnaG51dFwiOlxuICAgICAgcmV0dXJuIGRvbnV0Q29uZmlnKGRhdGEsIHNldHRpbmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJiYXJcIjpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJwaWVcIjpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtdWx0aXNlcmllc1BsYWluXCI6XG4gICAgICByZXR1cm4gcGxhaW5NdWx0aVNlcmllcyhkYXRhLCBzZXR0aW5ncyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicmFuZ2VBcmVhXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29sdW1uXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic2NhdHRlclwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgbWFrZUNoYXJ0ID0gKGNoYXJ0SWQsIGRhdGEsIGtpbmQsIHNldHRpbmdzKSA9PiB7XG4gIGxldCB0aGVJZCA9IGNoYXJ0SWQ7XG4gIGxldCB0aGVTZXR0aW5ncyA9IHNldHRpbmdzO1xuICBsZXQgdGhlQ29uZmlnID0ga2luZENvbmZpZyhraW5kLCBkYXRhLCBzZXR0aW5ncyk7XG4gIGNvbnNvbGUubG9nKCd0aGVDb25maWcnLCB0aGVDb25maWcpO1xuICBsZXQgY2hhcnQgPSBuZXcgQ2FudmFzSlMuQ2hhcnQoY2hhcnRJZCwgdGhlQ29uZmlnKTtcbiAgY29uc29sZS5sb2coJ2NoYXJ0JywgY2hhcnQpXG4gIHJldHVybiB7XG4gICAgcmVuZGVyQ2hhcnQ6ICgpID0+IHtcbiAgICAgIGNoYXJ0LnJlbmRlcigpO1xuICAgIH0sXG4gICAgbmV3U2V0OiAobmV3ZGF0YSkgPT4ge1xuICAgICAgdGhlQ29uZmlnID0ga2luZENvbmZpZyhraW5kLCBuZXdkYXRhLCB0aGVTZXR0aW5ncyk7XG4gICAgICBjaGFydCA9IG5ldyBDYW52YXNKUy5DaGFydCh0aGVJZCwgdGhlQ29uZmlnKTtcbiAgICAgIGNoYXJ0LnJlbmRlcigpO1xuICAgIH1cbiAgfVxuXG59O1xuY29uc3QgbWFrZUNvbWJvQ2hhcnQgPSAoY2hhcnRJZCwgZGF0YSwga2luZCwgc2V0dGluZ3MpID0+IHtcblxuICBsZXQgdGhlSWQgPSBjaGFydElkO1xuICBsZXQgcmVzID0gdm9sdW1lQW5kUmFuZ2UoZ2V0UmFuZG9tRGF0YShuZXcgRGF0ZSgpLCBkYXRhLnByaWNlKShkYXRhLmxlbiksIGRhdGEucHJpY2UpO1xuICBsZXQgZGF0YVNldHMgPSByZXMuZDtcbiAgbGV0IHRoZVNldHRpbmdzID0ge1xuICAgIG1pbjogcmVzLm1pbk1heC5taW4sXG4gICAgbWF4OiByZXMubWluTWF4Lm1heFxuICB9O1xuICBsZXQgdGhlQ29uZmlnID0ga2luZENvbmZpZyhcIm11bHRpc2VyaWVzUGxhaW5cIiwgZGF0YVNldHMsIHRoZVNldHRpbmdzKTtcbiAgY29uc29sZS5sb2coJ3RoZUNvbmZpZycsIHRoZUNvbmZpZyk7XG4gIGxldCBjaGFydCA9IG5ldyBDYW52YXNKUy5DaGFydChjaGFydElkLCB0aGVDb25maWcpO1xuICBjb25zb2xlLmxvZygnY2hhcnQnLCBjaGFydClcbiAgY2hhcnQucmVuZGVyKCk7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyQ2hhcnQ6ICgpID0+IHtcbiAgICAgIGNoYXJ0LnJlbmRlcigpO1xuICAgIH0sXG4gICAgZ2VuRGF0YTogKHByLCBsbikgPT4ge1xuICAgICAgbGV0IHJlcyA9IHZvbHVtZUFuZFJhbmdlKGdldFJhbmRvbURhdGEobmV3IERhdGUoKSwgZGF0YS5wcmljZSkoZGF0YS5sZW4pLCBkYXRhLnByaWNlKTtcbiAgICAgIGRhdGFTZXRzID0gcmVzLmQ7XG4gICAgICB0aGVDb25maWcgPSBraW5kQ29uZmlnKFwibXVsdGlzZXJpZXNQbGFpblwiLCBkYXRhU2V0cywge1xuICAgICAgICBtaW46IHJlcy5taW5NYXgubWluLFxuICAgICAgICBtYXg6IHJlcy5taW5NYXgubWF4XG4gICAgICB9KTtcbiAgICAgIGNoYXJ0ID0gbmV3IENhbnZhc0pTLkNoYXJ0KHRoZUlkLCB0aGVDb25maWcpO1xuICAgICAgY2hhcnQucmVuZGVyKCk7XG4gICAgfSxcbiAgICBuZXdTZXQ6IChuZXdkYXRhKSA9PiB7XG4gICAgICB0aGVDb25maWcgPSBraW5kQ29uZmlnKGtpbmQsIG5ld2RhdGEsIHRoZVNldHRpbmdzKTtcbiAgICAgIGNoYXJ0ID0gbmV3IENhbnZhc0pTLkNoYXJ0KHRoZUlkLCB0aGVDb25maWcpO1xuICAgICAgY2hhcnQucmVuZGVyKCk7XG4gICAgfVxuICB9XG5cbn07XG5jb25zdCBjaGFydE1ha2VyID0ge1xuICBtYWtlQ29tYm9DaGFydDogbWFrZUNvbWJvQ2hhcnQsXG4gIG1ha2VDaGFydDogbWFrZUNoYXJ0XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjaGFydE1ha2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL2hlbHBlcnMvZ3JhcGhfaGVscGVyL2NoYXJ0cy5qcyIsImNvbnN0IGNhbmRsZVN0aWNrID0gKGR0YSkgPT4gW25ldyBEYXRlKGR0YS50aW1lc3RhbXApLmdldFRpbWUoKSwgZHRhLm9wZW4sIGR0YS5oaWdoLCBkdGEubG93LCBkdGEuY2xvc2VdO1xuY29uc3Qgc3BsaW5lID0gKGR0YSkgPT4gW25ldyBEYXRlKGR0YS50aW1lc3RhbXApLmdldFRpbWUoKSwgZHRhLmNsb3NlXTtcbmNvbnN0IGNvbHVtbiA9IChkdGEpID0+IFtuZXcgRGF0ZShkdGEudGltZXN0YW1wKS5nZXRUaW1lKCksIGR0YS52b2x1bWVdO1xuY29uc3QgY29sdW1ucmFuZ2UgPSAoZHRhKSA9PiBbbmV3IERhdGUoZHRhLnRpbWVzdGFtcCkuZ2V0VGltZSgpLCBkdGEubG93LCBkdGEuaGlnaHRdO1xuXG5jb25zdCBkYXRhVHJhbnNmb3JtID0ge1xuXHRjYW5kbGVzdGljazogKCkgPT4gKGR0YSkgPT4gW25ldyBEYXRlKGR0YS50aW1lc3RhbXApLmdldFRpbWUoKSwgIGR0YS5vcGVuLCBkdGEuaGlnaCwgZHRhLmxvdywgZHRhLmNsb3NlXSxcblx0b2hsYzogKCkgPT4gKGR0YSkgPT4gW25ldyBEYXRlKGR0YS50aW1lc3RhbXApLmdldFRpbWUoKSwgIGR0YS5vcGVuLCBkdGEuaGlnaCwgZHRhLmxvdywgZHRhLmNsb3NlXSxcblx0c3BsaW5lOiAoKSA9PiAoZHRhKSA9PiBbbmV3IERhdGUoZHRhLnRpbWVzdGFtcCkuZ2V0VGltZSgpLCBkdGEuY2xvc2VdLFxuXHRsaW5lOiAoKSA9PiAoZHRhKSA9PiBbbmV3IERhdGUoZHRhLnRpbWVzdGFtcCkuZ2V0VGltZSgpLCBkdGEuY2xvc2VdLFxuXHRhcmVhOiAoKSA9PiAoZHRhKSA9PiBbbmV3IERhdGUoZHRhLnRpbWVzdGFtcCkuZ2V0VGltZSgpLCBkdGEuY2xvc2VdLFxuXHRzdGVwOiAoKSA9PiAoZHRhKSA9PiBbbmV3IERhdGUoZHRhLnRpbWVzdGFtcCkuZ2V0VGltZSgpLCBkdGEuY2xvc2VdLFxuXHRjb2x1bW46ICAoKSA9PiAoZHRhKSA9PiBbbmV3IERhdGUoZHRhLnRpbWVzdGFtcCkuZ2V0VGltZSgpLCBkdGEudm9sdW1lXSxcblx0Y29sdW1ucmFuZ2U6ICgpID0+IChkdGEpID0+IFtuZXcgRGF0ZShkdGEudGltZXN0YW1wKS5nZXRUaW1lKCksIGR0YS5sb3csIGR0YS5oaWdoXVxufVxuXG5leHBvcnQgZGVmYXVsdCBkYXRhVHJhbnNmb3JtO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL2hlbHBlcnMvZ3JhcGhfaGVscGVyL2RhdGFfdHJhbnNmb3JtLmpzIiwiY29uc3QgY2FuZGxlc3RpY2tDb25maWcgPSAoc3ltYm9sLCBkYXRhKSA9PiB7XG4gICBsZXQgbmFtZSA9IHN5bWJvbCArICcgU3RvY2sgUHJpY2UnO1xuICAgcmV0dXJuIHtcbiAgICAgIHJhbmdlU2VsZWN0b3I6IHtcbiAgICAgICAgIHNlbGVjdGVkOiAxXG4gICAgICB9LFxuXG4gICAgICB0aXRsZToge1xuICAgICAgICAgdGV4dDogbmFtZVxuICAgICAgfSxcbiAgICAgIHNlcmllczogW1xuICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ2NhbmRsZXN0aWNrJyxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgZGF0YUdyb3VwaW5nOiB7XG4gICAgICAgICAgICAgICB1bml0czogW1xuICAgICAgICAgICAgICAgICAgWyd3ZWVrJywgWzFdXG4gICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgICAgICAgICAgICAgIFsxLCAyLCAzLCA0LCA2XVxuICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgXVxuICAgfTtcbn07XG5jb25zdCBvaGxjQ29uZmlnID0gKHN5bWJvbCwgZGF0YSkgPT4ge1xuICAgbGV0IG5hbWUgPSBzeW1ib2wgKyAnIFN0b2NrIFByaWNlJztcbiAgIHJldHVybiB7XG4gICAgICByYW5nZVNlbGVjdG9yOiB7XG4gICAgICAgICBzZWxlY3RlZDogMVxuICAgICAgfSxcblxuICAgICAgdGl0bGU6IHtcbiAgICAgICAgIHRleHQ6IG5hbWVcbiAgICAgIH0sXG4gICAgICBzZXJpZXM6IFtcbiAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICdvaGxjJyxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgZGF0YUdyb3VwaW5nOiB7XG4gICAgICAgICAgICAgICB1bml0czogW1xuICAgICAgICAgICAgICAgICAgWyd3ZWVrJywgWzFdXG4gICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgICAgICAgICAgICAgIFsxLCAyLCAzLCA0LCA2XVxuICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgXVxuICAgfTtcbn07XG5jb25zdCBjb2x1bW5Db25maWcgPSAoc3ltYm9sLCBkYXRhKSA9PiB7XG4gICBsZXQgbmFtZSA9IHN5bWJvbCArICcgU3RvY2sgVm9sdW1lJztcbiAgIHJldHVybiB7XG4gICAgICBjaGFydDoge1xuICAgICAgICAgYWxpZ25UaWNrczogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIHJhbmdlU2VsZWN0b3I6IHtcbiAgICAgICAgIHNlbGVjdGVkOiAxXG4gICAgICB9LFxuXG4gICAgICB0aXRsZToge1xuICAgICAgICAgdGV4dDogbmFtZVxuICAgICAgfSxcblxuICAgICAgc2VyaWVzOiBbXG4gICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAnY29sdW1uJyxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgZGF0YUdyb3VwaW5nOiB7XG4gICAgICAgICAgICAgICB1bml0czogW1xuICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgJ3dlZWsnLCAvLyB1bml0IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgIFsxXSAvLyBhbGxvd2VkIG11bHRpcGxlc1xuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICdtb250aCcsXG4gICAgICAgICAgICAgICAgICAgICBbMSwgMiwgMywgNCwgNl1cbiAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgIF1cbiAgIH1cbn07XG5jb25zdCBjb2x1bW5SYW5nZUNvbmZpZyA9IChzeW1ib2wsIGRhdGEpID0+IHtcbiAgIGxldCBuYW1lID0gc3ltYm9sICsgJyBEYWlseSBMb3cgSGlnaCc7XG4gICByZXR1cm4ge1xuICAgICAgY2hhcnQ6IHtcbiAgICAgICAgIHR5cGU6ICdjb2x1bW5yYW5nZSdcbiAgICAgIH0sXG5cbiAgICAgIHJhbmdlU2VsZWN0b3I6IHtcbiAgICAgICAgIHNlbGVjdGVkOiAyXG4gICAgICB9LFxuXG4gICAgICB0aXRsZToge1xuICAgICAgICAgdGV4dDogbmFtZVxuICAgICAgfSxcblxuICAgICAgc2VyaWVzOiBbXG4gICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAnY29sdW1ucmFuZ2UnLFxuICAgICAgICAgICAgbmFtZTogJ0xvdyAtIEhpZ2gnLFxuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgfVxuICAgICAgXVxuICAgfVxufTtcbmNvbnN0IGxpbmVDb25maWcgPSAoc3ltYm9sLCBkYXRhKSA9PiB7XG4gICBsZXQgbmFtZSA9IHN5bWJvbCArICcgU3RvY2sgUHJpY2UnO1xuICAgcmV0dXJuIHtcblxuICAgICAgcmFuZ2VTZWxlY3Rvcjoge1xuICAgICAgICAgc2VsZWN0ZWQ6IDFcbiAgICAgIH0sXG5cbiAgICAgIHRpdGxlOiB7XG4gICAgICAgICB0ZXh0OiBuYW1lXG4gICAgICB9LFxuXG4gICAgICBzZXJpZXM6IFtcbiAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgICAgdmFsdWVEZWNpbWFsczogMlxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgXVxuICAgfVxufVxuY29uc3QgYXJlYUNvbmZpZyA9IChzeW1ib2wsIGRhdGEpID0+IHtcbiAgIGxldCBuYW1lID0gc3ltYm9sICsgJyBTdG9jayBQcmljZSc7XG4gICByZXR1cm4ge1xuXG4gICAgICByYW5nZVNlbGVjdG9yOiB7XG4gICAgICAgICBzZWxlY3RlZDogMVxuICAgICAgfSxcblxuICAgICAgdGl0bGU6IHtcbiAgICAgICAgIHRleHQ6IG5hbWVcbiAgICAgIH0sXG5cbiAgICAgIHNlcmllczogW1xuICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICB0eXBlOiAnYXJlYScsXG4gICAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICAgICB2YWx1ZURlY2ltYWxzOiAyXG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICBdXG4gICB9XG59XG5jb25zdCBzdGVwQ29uZmlnID0gKHN5bWJvbCwgZGF0YSkgPT4ge1xuICAgbGV0IG5hbWUgPSBzeW1ib2wgKyAnIFN0b2NrIFByaWNlJztcbiAgIHJldHVybiB7XG4gICAgICByYW5nZVNlbGVjdG9yOiB7XG4gICAgICAgICBzZWxlY3RlZDogMVxuICAgICAgfSxcblxuICAgICAgdGl0bGU6IHtcbiAgICAgICAgIHRleHQ6IG5hbWVcbiAgICAgIH0sXG5cbiAgICAgIHNlcmllczogW1xuICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBzdGVwOiB0cnVlLFxuICAgICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgICAgdmFsdWVEZWNpbWFsczogMlxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgXVxuICAgfVxufVxuY29uc3Qgc3BsaW5lQ29uZmlnID0gKHN5bWJvbCwgZGF0YSkgPT4ge1xuICAgbGV0IG5hbWUgPSBzeW1ib2wgKyAnIFN0b2NrIFByaWNlJztcbiAgIHJldHVybiB7XG5cbiAgICAgIHJhbmdlU2VsZWN0b3I6IHtcbiAgICAgICAgIHNlbGVjdGVkOiAxXG4gICAgICB9LFxuXG4gICAgICB0aXRsZToge1xuICAgICAgICAgdGV4dDogbmFtZVxuICAgICAgfSxcblxuICAgICAgc2VyaWVzOiBbXG4gICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIHR5cGU6ICdzcGxpbmUnLFxuICAgICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgICAgdmFsdWVEZWNpbWFsczogMlxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgXVxuICAgfVxufVxuY29uc3Qgc3RhY2tDb2x1bW5Db25maWcgPSAoc3ltYm9sID0gXCJoZXlcIiwgZGF0YSA9IFtdKSA9PiB7XG4gICBsZXQgbmFtZSA9IHN5bWJvbCArICcgcGVyIHF1YXJ0ZXInO1xuICAgcmV0dXJuIHtcblxuICAgICAgdGl0bGU6IHtcbiAgICAgICAgIHRleHQ6IG5hbWVcbiAgICAgIH0sXG4gICAgICB4QXhpczoge1xuICAgICAgICAgY2F0ZWdvcmllczogWydBcHBsZXMnLCAnT3JhbmdlcycsICdQZWFycycsICdHcmFwZXMnLCAnQmFuYW5hcyddXG4gICAgICB9LFxuICAgICAgeUF4aXM6IHtcbiAgICAgICAgIG1pbjogMCxcbiAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICB0ZXh0OiAnVG90YWwgZnJ1aXQgY29uc3VtcHRpb24nXG4gICAgICAgICB9LFxuICAgICAgICAgc3RhY2tMYWJlbHM6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgICAgICAgICAgLy8gY29sb3I6ICdncmF5J1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgIGhlYWRlckZvcm1hdDogJzxiPntwb2ludC54fTwvYj48YnIvPicsXG4gICAgICAgICBwb2ludEZvcm1hdDogJ3tzZXJpZXMubmFtZX06IHtwb2ludC55fTxici8+VG90YWw6IHtwb2ludC5zdGFja1RvdGFsfSdcbiAgICAgIH0sXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgIGFsaWduOiAncmlnaHQnLFxuICAgICAgICAgeDogLTMwLFxuICAgICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICAgICB5OiAyNSxcbiAgICAgICAgIGZsb2F0aW5nOiB0cnVlLFxuICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgYm9yZGVyQ29sb3I6ICcjQ0NDJyxcbiAgICAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgICAgc2hhZG93OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHBsb3RPcHRpb25zOiB7XG4gICAgICAgICBjb2x1bW46IHtcbiAgICAgICAgICAgIHN0YWNraW5nOiAnbm9ybWFsJyxcbiAgICAgICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAvLyBjb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICB0ZXh0U2hhZG93OiAnMCAwIDNweCBibGFjaydcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHNlcmllczogW1xuICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ1ExJyxcbiAgICAgICAgICAgIGRhdGE6IFs1LCAzLCA0LCA3LCAyXVxuICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ1EyJyxcbiAgICAgICAgICAgIGRhdGE6IFsyLCAyLCAzLCAyLCAxXVxuICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ1EzJyxcbiAgICAgICAgICAgIGRhdGE6IFszLCA0LCA0LCAyLCA1XVxuICAgICAgICAgfVxuICAgICAgXVxuICAgfVxufVxuY29uc3QgbXVsdGlDb25maWcgPSAoc3ltYm9sLCBzZXJpZXNPcHRpb25zKSA9PiB7XG4gICBjb25zb2xlLmxvZygnc2VyaWVzT3B0aW9ucycsIHNlcmllc09wdGlvbnMpO1xuICAgcmV0dXJuIHtcbiAgICAgIHJhbmdlU2VsZWN0b3I6IHtcbiAgICAgICAgIHNlbGVjdGVkOiA0XG4gICAgICB9LFxuXG4gICAgICB5QXhpczoge1xuICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgIHJldHVybiAodGhpcy52YWx1ZSA+IDAgPyAnICsgJyA6ICcnKSArIHRoaXMudmFsdWUgKyAnJSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9LFxuICAgICAgICAgcGxvdExpbmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgICAgIHdpZHRoOiAyLFxuICAgICAgICAgICAgICAgY29sb3I6ICdzaWx2ZXInXG4gICAgICAgICAgICB9XG4gICAgICAgICBdXG4gICAgICB9LFxuXG4gICAgICBwbG90T3B0aW9uczoge1xuICAgICAgICAgc2VyaWVzOiB7XG4gICAgICAgICAgICBjb21wYXJlOiAncGVyY2VudCdcbiAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgIHBvaW50Rm9ybWF0OiAnPHNwYW4gc3R5bGU9XCJjb2xvcjp7c2VyaWVzLmNvbG9yfVwiPntzZXJpZXMubmFtZX08L3NwYW4+OiA8Yj57cG9pbnQueX08L2I+ICh7cG9pbnQuY2hhbmdlfSUpPGJyLz4nLFxuICAgICAgICAgdmFsdWVEZWNpbWFsczogMlxuICAgICAgfSxcblxuICAgICAgc2VyaWVzOiBzZXJpZXNPcHRpb25zXG4gICB9XG59XG5cbmNvbnN0IGdyYXBoQ29uZmlncyA9IHtcbiAgIGNhbmRsZXN0aWNrOiBjYW5kbGVzdGlja0NvbmZpZyxcbiAgIHNwbGluZTogc3BsaW5lQ29uZmlnLFxuICAgY29sdW1uOiBjb2x1bW5Db25maWcsXG4gICBsaW5lOiBsaW5lQ29uZmlnLFxuICAgc3RlcDogc3RlcENvbmZpZyxcbiAgIGFyZWE6IGFyZWFDb25maWcsXG4gICBvaGxjOiBvaGxjQ29uZmlnLFxuICAgc3RhY2tDb2x1bW5Db25maWc6IHN0YWNrQ29sdW1uQ29uZmlnLFxuICAgbXVsdGljb25maWc6IG11bHRpQ29uZmlnLFxuICAgY29sdW1ucmFuZ2U6IGNvbHVtblJhbmdlQ29uZmlnXG59XG5cbmV4cG9ydCBkZWZhdWx0IGdyYXBoQ29uZmlncztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9oZWxwZXJzL2dyYXBoX2hlbHBlci9ncmFwaGNvbmZpZ3MuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgTGF5b3V0IGZyb20gJy4vTGF5b3V0JztcbmltcG9ydCB7UHJvdmlkZXJ9IGZyb20gJ3JlYWN0LXJlZHV4J1xuaW1wb3J0IHN0b3JlIGZyb20gJy4vc3RvcmUnXG5jb25zdCByb290ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpO1xuXG5SZWFjdERPTS5yZW5kZXIoXG4gIDxQcm92aWRlciBzdG9yZT17c3RvcmV9PlxuICA8TGF5b3V0Lz5cbjwvUHJvdmlkZXI+LCByb290KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9tYWluLmpzIiwiaW1wb3J0IHtcbiAgICBBRERfQ0hBUlQsXG4gICAgQ0xPU0VfQ0hBUlQsXG4gICAgQ0hBUlRfU1RBVEVfVVBEQVRFLFxuICAgIFdBVENIRURfUE9TSVRJT05TLFxuICAgIEZFRURfU1RBUlQsXG4gICAgT1BUU19WSUVXLFxuICAgIFNXSVRDSF9JTkRJQ0VTLFxuICAgIFRPR0dMRV9DSEFSVF9NRU5VLFxuICAgIENPTk5FQ1RJT05fTE9TVCxcbiAgICBDT05ORUNURURcbn0gZnJvbSAnY29uc3RhbnRzL2Rhc2hib2FyZCdcblxuY29uc3QgaW5uaXRpYWxTdGF0ZSA9IHtcbiAgb25TdGFydDogdHJ1ZSxcbiAgY2hhcnRQb3NpdGlvbnM6IHt9LFxuICBjaGFydFN0YXRlczoge30sXG4gIGNoYXJ0QWRkT3BlbjogZmFsc2UsXG4gIHNlbGVjdFVsOiAnZm9yZXgnLFxuICB0b3RhbENoYXJ0czogMCxcbiAgYWRkQnV0dG9uOiBmYWxzZSxcbiAgb3B0c0NvbXBvbmVudDogbnVsbCxcbiAgbmV3U2V0OiBudWxsLFxuICBjaGFydExpc3Q6IFtdLFxuICBwbGF0Zm9ybVZpZXc6ICdsaXZlIGdyYXBocycsXG4gIHRyYWRWaWV3Q2xhc3M6ICdmdWxsLXZpZXcnLFxuICBjb25uZWN0ZWQ6IGZhbHNlLFxuICBzZXJpZXNXYXRjaDogW11cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSA9IGlubml0aWFsU3RhdGUsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBBRERfQ0hBUlQ6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAuLi5hY3Rpb24ucGF5bG9hZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgY2FzZSBDTE9TRV9DSEFSVDoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIC4uLmFjdGlvbi5wYXlsb2FkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBjYXNlIENIQVJUX1NUQVRFX1VQREFURToge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGNoYXJ0U3RhdGVzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuY2hhcnRTdGF0ZXMsXG4gICAgICAgICAgW2FjdGlvbi5jaGFydFN5bWJvbF0gOiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5jaGFydFN0YXRlc1thY3Rpb24uY2hhcnRTeW1ib2xdLFxuICAgICAgICAgICAgLi4uYWN0aW9uLnBheWxvYWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY2FzZSBXQVRDSEVEX1BPU0lUSU9OUzoge1xuICAgICAgICByZXR1cm4gYWN0aW9uLnBheWxvYWRcbiAgICAgIH1cbiAgICBjYXNlIEZFRURfU1RBUlQ6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICBzZXJpZXNXYXRjaDogYWN0aW9uLnBheWxvYWQuc2VyaWVzV2F0Y2gsXG4gICAgICAgICAgYWRkQnV0dG9uOiBhY3Rpb24ucGF5bG9hZC5hZGRCdXR0b25cbiAgICAgICAgfVxuICAgICAgfVxuICAgIGNhc2UgT1BUU19WSUVXOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgdHJhZFZpZXdDbGFzczogYWN0aW9uLnBheWxvYWQudHJhZFZpZXdDbGFzcyxcbiAgICAgICAgICBvcHRzQ29tcG9uZW50OiBhY3Rpb24ucGF5bG9hZC5vcHRzQ29tcG9uZW50LFxuICAgICAgICAgIHBsYXRmb3JtVmlldzogYWN0aW9uLnBheWxvYWQucGxhdGZvcm1WaWV3XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBjYXNlIFNXSVRDSF9JTkRJQ0VTOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgc2VsZWN0VWw6IGFjdGlvbi5wYXlsb2FkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBjYXNlIFRPR0dMRV9DSEFSVF9NRU5VOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgY2hhcnRBZGRPcGVuOiBhY3Rpb24ucGF5bG9hZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgY2FzZSBDT05ORUNUSU9OX0xPU1Q6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICBjb25uZWN0ZWQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBjYXNlIENPTk5FQ1RFRDoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIGNvbm5lY3RlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhdGVcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9yZWR1Y2Vycy9kYXNoYm9hcmRSZWR1Y2VyLmpzIiwiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSAncmVkdXgnO1xuXG5pbXBvcnQgcnQgZnJvbSAnLi9kYXNoYm9hcmRSZWR1Y2VyJztcbmltcG9ydCB0cmFkZXMgZnJvbSAnLi90cmFkZVJlZHVjZXInO1xuaW1wb3J0IHdpZGdldHMgZnJvbSAnLi93aWRnZXRSZWR1Y2VyJztcbmltcG9ydCByb3V0ZXMgZnJvbSAnLi9yb3V0ZVJlZHVjZXInO1xuaW1wb3J0IHRyYW5zYWN0aW9ucyBmcm9tICcuL3RyYW5zYWN0aW9uUmVkdWNlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIHJ0LFxuICB0cmFkZXMsXG4gIHdpZGdldHMsXG4gIHRyYW5zYWN0aW9ucyxcbiAgcm91dGVzLFxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvanMvcmVkdWNlcnMvaW5kZXguanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgR3JhcGggZnJvbSAnY29udGFpbmVyL2dyYXBoX3RlbXAnO1xuaW1wb3J0IFJlYWxUaW1lIGZyb20gJ2NvbnRhaW5lci9yZWFsdGltZSc7XG5pbXBvcnQgTWFwIGZyb20gJ2NvbnRhaW5lci9tYXAnO1xuaW1wb3J0IFRvcE5hdiBmcm9tICdjb250YWluZXIvdG9wbmF2JztcbmltcG9ydCB7TkVXX1BBVEh9IGZyb20gJ2NvbnN0YW50cy9yb3V0ZXMnXG5cbndpbmRvdy5jaGVja1BhdGggPSAoKCkgPT4ge1xuXG4gIGNvbnN0IENoYW5nZVVybCA9ICh0aXRsZSwgdXJsKSA9PiB7XG4gICAgaWYgKHR5cGVvZihoaXN0b3J5LnB1c2hTdGF0ZSkgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG5cbiAgICBsZXQgb2JqID0ge1xuICAgICAgVGl0bGU6IHRpdGxlLFxuICAgICAgVXJsOiB1cmxcbiAgICB9O1xuICAgIGhpc3RvcnkucHVzaFN0YXRlKG9iaiwgb2JqLlRpdGxlLCBvYmouVXJsKTtcbiAgfTtcbiAgY29uc3QgYWxsUGF0aHMgPSBbJy8nLCAnL2hpc3RvcnknLCAnL3JlYWx0aW1lJywgJy9tYXAnXTtcbiAgY29uc3QgYWxsVGl0bGVzID0ge1xuICAgICcvJzogJ0V4YW1wbGVzJyxcbiAgICAnL2hpc3RvcnknOiAnSGlzdG9yeScsXG4gICAgJy9yZWFsdGltZSc6ICdSZWFsIFRpbWUnLFxuICAgICcvbWFwJzogJ01hcCBTdHVmZidcbiAgfVxuICBjb25zdCBwYXRoUmVkdWNlciA9IChwYXRoKSA9PiB7fTtcbiAgcmV0dXJuIChwYXRoKSA9PiB7XG4gICAgLy8gIGxldCByb3V0ZUFycmF5ID0gcGF0aC5zcGxpdCgnLycpLmZpbHRlcihCb29sZWFuKTtcbiAgICBsZXQgcGF0aElTID0gYWxsUGF0aHMucmVkdWNlKChxLCBpKSA9PiB7XG4gICAgICByZXR1cm4gaSA9PT0gcGF0aCA/IGkgOiBxO1xuICAgIH0sICcvJyk7XG4gICAgQ2hhbmdlVXJsKGFsbFRpdGxlc1twYXRoSVNdLCBwYXRoSVMpO1xuICAgIHJldHVybiBwYXRoSVM7XG4gIH1cbn0pKCk7XG5cbmNvbnN0IHJvdXRlQ29tcG9uZW50cyA9IHtcbiAgJy8nOiAoPEdyYXBoLz4pLFxuICAnL2hpc3RvcnknOiAoPEdyYXBoLz4pLFxuICAnL3JlYWx0aW1lJzogKDxSZWFsVGltZS8+KSxcbiAgJy9tYXAnOiAoPE1hcC8+KVxufVxuY29uc3QgZ2V0VG9wTmF2ID0ge1xuICAnLyc6ICg8VG9wTmF2IHRoZUNsYXNzPSdub3JtYWwnIHBhdGhOYW1lPScvJy8+KSxcbiAgJy9oaXN0b3J5JzogKDxUb3BOYXYgdGhlQ2xhc3M9J25vcm1hbCcgcGF0aE5hbWU9Jy9oaXN0b3J5Jy8+KSxcbiAgJy9yZWFsdGltZSc6ICg8VG9wTmF2IHRoZUNsYXNzPSdydC1hbHRlcicgcGF0aE5hbWU9Jy9yZWFsdGltZScvPiksXG4gICcvbWFwJzogKDxUb3BOYXYgdGhlQ2xhc3M9J25vcm1hbCcgcGF0aE5hbWU9Jy9tYXAnLz4pXG59XG5sZXQgaW5pdGlhbFBhdGggPSB3aW5kb3cuY2hlY2tQYXRoKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWR1Y2VyKHN0YXRlID0ge1xuICBwYXRoTmFtZTogd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLFxuICBibG9ja2VkOiByb3V0ZUNvbXBvbmVudHNbaW5pdGlhbFBhdGhdLFxuICB0b3BOYXY6IDxUb3BOYXYgdGhlQ2xhc3M9e2luaXRpYWxQYXRoID09PSAnL3JlYWx0aW1lJyA/ICdydC1hbHRlcicgOiAnJ30gcGF0aE5hbWU9e2luaXRpYWxQYXRofS8+LFxuICByb3V0ZUNvbXBvbmVudHM6IHJvdXRlQ29tcG9uZW50c1xufSwgYWN0aW9uKSB7XG5cbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgTkVXX1BBVEg6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgcGF0aE5hbWU6IGFjdGlvbi5wYXlsb2FkLnBhdGhuYW1lLFxuICAgICAgICAgIGJsb2NrZWQ6IGFjdGlvbi5wYXlsb2FkLmJsb2NrZWQsXG4gICAgICAgICAgdG9wTmF2OiBhY3Rpb24ucGF5bG9hZC50b3BOYXZcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgfVxuXG4gIH1cblxuICByZXR1cm4gc3RhdGVcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9yZWR1Y2Vycy9yb3V0ZVJlZHVjZXIuanMiLCJpbXBvcnQge1xuICBGRVRDSF9UUkFERVMsXG4gIEZFVENIX1RSQURFU19SRUpFQ1RFRCxcbiAgRkVUQ0hfVFJBREVTX0ZVTEZJTExFRCxcbiAgREVQT1NJVF9DSEFOR0UsXG4gIEFERF9UUkFERSxcbiAgVFJBREVfQ09NUExFVEUsXG4gIEFERF9NT05FWVxufSAgZnJvbSAnY29uc3RhbnRzL3RyYWRlcydcblxuY29uc3QgcGFzdFRyYWRlcyA9IFtcbiAge1xuICAgIHBvc2l0aW9uOiAnR09PRycsXG4gICAgdm9sdW1lOiAxMjAsXG4gICAgZGF0ZTogbmV3IERhdGUoKS50b0RhdGVTdHJpbmcoKSxcbiAgICBzaG9ydDogZmFsc2UsXG4gICAgcHJpY2VzdGFydDogNzc2LjE1LFxuICAgIHByaWNlZW5kOiA3NzYuOTVcbiAgfSwge1xuICAgIHBvc2l0aW9uOiAnWUhPTycsXG4gICAgdm9sdW1lOiA0NSxcbiAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvRGF0ZVN0cmluZygpLFxuICAgIHNob3J0OiBmYWxzZSxcbiAgICBwcmljZXN0YXJ0OiAzOC4xOSxcbiAgICBwcmljZWVuZDogMzguODBcbiAgfSwge1xuICAgIHBvc2l0aW9uOiAnQVBQTCcsXG4gICAgdm9sdW1lOiAxMCxcbiAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvRGF0ZVN0cmluZygpLFxuICAgIHNob3J0OiBmYWxzZSxcbiAgICBwcmljZXN0YXJ0OiAxMjEsXG4gICAgcHJpY2VlbmQ6IDg4XG4gIH0sIHtcbiAgICBwb3NpdGlvbjogJ01TRlQnLFxuICAgIHZvbHVtZTogOTUsXG4gICAgZGF0ZTogbmV3IERhdGUoKS50b0RhdGVTdHJpbmcoKSxcbiAgICBzaG9ydDogZmFsc2UsXG4gICAgcHJpY2VzdGFydDogNjEuNzksXG4gICAgcHJpY2VlbmQ6IDYxLjUyXG4gIH0sIHtcbiAgICBwb3NpdGlvbjogJ0dCUC9VU0QnLFxuICAgIHZvbHVtZTogODAsXG4gICAgZGF0ZTogbmV3IERhdGUoKS50b0RhdGVTdHJpbmcoKSxcbiAgICBzaG9ydDogZmFsc2UsXG4gICAgcHJpY2VzdGFydDogMS4zMjcsXG4gICAgcHJpY2VlbmQ6IDEuMzI3MlxuICB9LCB7XG4gICAgcG9zaXRpb246ICdBVUQvSlBZJyxcbiAgICB2b2x1bWU6IDIwLFxuICAgIGRhdGU6IG5ldyBEYXRlKCkudG9EYXRlU3RyaW5nKCksXG4gICAgc2hvcnQ6IGZhbHNlLFxuICAgIHByaWNlc3RhcnQ6IDgyLjIxLFxuICAgIHByaWNlZW5kOiA4MS45NFxuICB9LCB7XG4gICAgcG9zaXRpb246ICdBTVpOJyxcbiAgICB2b2x1bWU6IDIwMCxcbiAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvRGF0ZVN0cmluZygpLFxuICAgIHNob3J0OiBmYWxzZSxcbiAgICBwcmljZXN0YXJ0OiA3NTEuNzcsXG4gICAgcHJpY2VlbmQ6IDc1MC43N1xuICB9XG5cbl07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlZHVjZXIoc3RhdGUgPSB7XG4gIHBhc3RUcmFkZXM6IHBhc3RUcmFkZXMsXG4gIGN1cnJlbnRQb3M6IFtdLFxuICB0b2RheVRyYWRlQ291bnQ6IDAsXG4gIHdlZWtseVRyYWRlQ291bnQ6IDAsXG4gIG5ldFBvc1RyYWRlczogMCxcbiAgdG90YWxWb2x1bWU6IDAsXG4gIG5ldE5lZ1RyYWRlczogMCxcbiAgdG90YWxSZXY6IDAsXG4gIHRvZGF5VG90YWxOZXQ6IDAuMCxcbiAgbW9uZXlBdmFsaWFibGU6IDAuMCxcbiAgZmV0Y2hpbmc6IGZhbHNlLFxuICBmZXRjaGVkOiBmYWxzZSxcbiAgZGVwb3NpdDogMjUwMCxcbiAgZXJyb3I6IG51bGxcbn0sIGFjdGlvbikge1xuXG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIEZFVENIX1RSQURFUzoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIGZldGNoaW5nOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBjYXNlIEZFVENIX1RSQURFU19SRUpFQ1RFRDoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIGZldGNoaW5nOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogYWN0aW9uLnBheWxvYWRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGNhc2UgRkVUQ0hfVFJBREVTX0ZVTEZJTExFRDoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIGZldGNoaW5nOiBmYWxzZSxcbiAgICAgICAgICBmZXRjaGVkOiB0cnVlLFxuICAgICAgICAgIHBhc3RUcmFkZXM6IGFjdGlvbi5wYXlsb2FkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBjYXNlIERFUE9TSVRfQ0hBTkdFOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgZGVwb3NpdDogYWN0aW9uLnBheWxvYWRcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgY2FzZSBBRERfVFJBREU6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAuLi5hY3Rpb24ucGF5bG9hZFxuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBjYXNlIFRSQURFX0NPTVBMRVRFOiB7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAuLi5hY3Rpb24ucGF5bG9hZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgY2FzZSBBRERfTU9ORVk6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgbW9uZXlBdmFsaWFibGU6IGFjdGlvbi5wYXlsb2FkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdGF0ZVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2pzL3JlZHVjZXJzL3RyYWRlUmVkdWNlci5qcyIsImltcG9ydCB7REVQT1NJVF9DSEFOR0V9IGZyb20gJ2NvbnN0YW50cy90cmFuc2FjdGlvbnMnXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWR1Y2VyKHN0YXRlID0ge1xuICBkZXBvc2l0OiAyNTAwXG59LCBhY3Rpb24pIHtcblxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBERVBPU0lUX0NIQU5HRToge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIGRlcG9zaXQ6IGFjdGlvbi5wYXlsb2FkXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdGVcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9yZWR1Y2Vycy90cmFuc2FjdGlvblJlZHVjZXIuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQge1xuICBXSURHRVRfRFJPUCxcbiAgV0lER0VUX0RSQUdHRUQsXG4gIEdPVF9NRVNTQUdFLFxuICBHT1RfREFUQVxufSAgZnJvbSAnY29uc3RhbnRzL3dpZGdldHMnXG5cbmNvbnN0IFdpZGdldExpc3QgPSB7XG4gIHdpZGdldDE6IHtcbiAgICB0aXRsZTogXCJzdHVmZlwiLFxuICAgIGtpbmQ6IFwiZ3JhcGhqc1wiLFxuICAgIHN5bWI6IFwiQU1aTlwiLFxuICAgIGNvbnRlbnQ6IHtcbiAgICAgIGNoYXJ0aWQ6IFwiQU1aTl9ISVNUXCIsXG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgZ3JhcGhUeXBlOiAnYXJlYScsXG4gICAgICBkeW5hbWljOiB0cnVlXG4gICAgfVxuICB9LFxuICB3aWRnZXQyOiB7XG4gICAgdGl0bGU6IFwi6bOz5Yew5YKz5aWHXCIsXG4gICAga2luZDogXCJ0YWJsZVwiLFxuICAgIGNvbnRlbnQ6IHtcbiAgICAgIHRpdGxlOiBcIumzs+WHsOWCs+Wlh1wiLFxuICAgICAgZGF0YTogbnVsbFxuICAgIH1cbiAgfSxcbiAgd2lkZ2V0Mzoge1xuICAgIHRpdGxlOiBcInN0dWZmXCIsXG4gICAga2luZDogXCJncmFwaGpzXCIsXG4gICAgc3ltYjogXCJTTkVcIixcbiAgICBjb250ZW50OiB7XG4gICAgICBjaGFydGlkOiBcIlNORV9ISVNUXCIsXG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgZ3JhcGhUeXBlOiAnY29sdW1uJyxcbiAgICAgIGR5bmFtaWM6IHRydWVcbiAgICB9XG4gIH0sXG4gIHdpZGdldDQ6IHtcbiAgICB0aXRsZTogXCLmnbHopb9cIixcbiAgICBraW5kOiBcInByb2dyZXNzXCIsXG4gICAgY29udGVudDoge1xuICAgICAgdGl0bGU6IFwi5p2x6KW/XCIsXG4gICAgICBkYXRhOiBudWxsXG4gICAgfVxuICB9XG59XG5jb25zdCBpbm5pdGlhbFN0YXRlID0ge1xuICBXaWRnZXRMaXN0OiBXaWRnZXRMaXN0LFxuICByb3dUb3BTdHlsZToge1xuICAgIGhlaWdodDogXCI1MCVcIlxuICB9LFxuICByb3dCdG1TdHlsZToge1xuICAgIGhlaWdodDogXCI1MCVcIlxuICB9LFxuICByb3dUb3A6IHtcbiAgICBjb21wczogW11cbiAgfSxcbiAgcm93QnRtOiB7XG4gICAgY29tcHM6IFtdXG4gIH0sXG4gIG5lZWRzVXBkYXRlOiB7fSxcbiAgZHJhZ2dlZFdpZGdldDogbnVsbCxcbiAgb3ZlcldpZGdldDogbnVsbCxcbiAgd2lkZ2V0MToge1xuICAgIGNsVHlwZTogXCJjb2wteHMtNiB3aWRnZXQtYm94XCIsXG4gICAgY29sVHlwZTogNixcbiAgICBzdHlsZToge30sXG4gICAgaG9sZFR5cGU6IFwiRnVsbFdpZGdldFwiLFxuICAgIHNob3duOiB0cnVlLFxuICAgIGRhdGE6IFdpZGdldExpc3Qud2lkZ2V0MVxuICB9LFxuICB3aWRnZXQyOiB7XG4gICAgY2xUeXBlOiBcImNvbC14cy02IHdpZGdldC1ib3hcIixcbiAgICBjb2xUeXBlOiA2LFxuICAgIHN0eWxlOiB7fSxcbiAgICBzaG93bjogdHJ1ZSxcbiAgICBob2xkVHlwZTogXCJGdWxsV2lkZ2V0XCIsXG4gICAgZGF0YTogV2lkZ2V0TGlzdC53aWRnZXQyXG4gIH0sXG4gIHdpZGdldDM6IHtcbiAgICBjbFR5cGU6IFwiY29sLXhzLTYgd2lkZ2V0LWJveFwiLFxuICAgIGNvbFR5cGU6IDYsXG4gICAgc3R5bGU6IHt9LFxuICAgIHNob3duOiB0cnVlLFxuICAgIGhvbGRUeXBlOiBcIkZ1bGxXaWRnZXRcIixcbiAgICBkYXRhOiBXaWRnZXRMaXN0LndpZGdldDNcbiAgfSxcbiAgd2lkZ2V0NDoge1xuICAgIGNsVHlwZTogXCJjb2wteHMtNiB3aWRnZXQtYm94XCIsXG4gICAgY29sVHlwZTogNixcbiAgICBzdHlsZToge30sXG4gICAgc2hvd246IHRydWUsXG4gICAgaG9sZFR5cGU6IFwiRnVsbFdpZGdldFwiLFxuICAgIGRhdGE6IFdpZGdldExpc3Qud2lkZ2V0NFxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSA9IGlubml0aWFsU3RhdGUsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBXSURHRVRfRFJPUDoge1xuICAgICAgICByZXR1cm4gYWN0aW9uLnBheWxvYWRcbiAgICAgIH1cbiAgICBjYXNlIFdJREdFVF9EUkFHR0VEOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgZHJhZ2dlZFdpZGdldDogYWN0aW9uLnBheWxvYWRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGNhc2UgR09UX01FU1NBR0U6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICBuZWVkc1VwZGF0ZToge1xuICAgICAgICAgICAgLi4uc3RhdGUubmVlZHNVcGRhdGUsXG4gICAgICAgICAgICAuLi5hY3Rpb24ucGF5bG9hZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIEdPVF9EQVRBOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgLi4uYWN0aW9uLnBheWxvYWRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gIH1cblxuICByZXR1cm4gc3RhdGVcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9qcy9yZWR1Y2Vycy93aWRnZXRSZWR1Y2VyLmpzIiwiZXhwb3J0IHtkZWZhdWx0IGFzIHJhbmRvbVVuaWZvcm19IGZyb20gXCIuL3NyYy91bmlmb3JtXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcmFuZG9tTm9ybWFsfSBmcm9tIFwiLi9zcmMvbm9ybWFsXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcmFuZG9tTG9nTm9ybWFsfSBmcm9tIFwiLi9zcmMvbG9nTm9ybWFsXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcmFuZG9tQmF0ZXN9IGZyb20gXCIuL3NyYy9iYXRlc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHJhbmRvbUlyd2luSGFsbH0gZnJvbSBcIi4vc3JjL2lyd2luSGFsbFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHJhbmRvbUV4cG9uZW50aWFsfSBmcm9tIFwiLi9zcmMvZXhwb25lbnRpYWxcIjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kMy1yYW5kb20vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgaXJ3aW5IYWxsIGZyb20gXCIuL2lyd2luSGFsbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuKSB7XG4gIHZhciByYW5kb21JcndpbkhhbGwgPSBpcndpbkhhbGwobik7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcmFuZG9tSXJ3aW5IYWxsKCkgLyBuO1xuICB9O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2QzLXJhbmRvbS9zcmMvYmF0ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihsYW1iZGEpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAtTWF0aC5sb2coMSAtIE1hdGgucmFuZG9tKCkpIC8gbGFtYmRhO1xuICB9O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2QzLXJhbmRvbS9zcmMvZXhwb25lbnRpYWwuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgbm9ybWFsIGZyb20gXCIuL25vcm1hbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHJhbmRvbU5vcm1hbCA9IG5vcm1hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKHJhbmRvbU5vcm1hbCgpKTtcbiAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kMy1yYW5kb20vc3JjL2xvZ05vcm1hbC5qc1xuLy8gbW9kdWxlIGlkID0gMTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gIG1pbiA9IG1pbiA9PSBudWxsID8gMCA6ICttaW47XG4gIG1heCA9IG1heCA9PSBudWxsID8gMSA6ICttYXg7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSBtYXggPSBtaW4sIG1pbiA9IDA7XG4gIGVsc2UgbWF4IC09IG1pbjtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogbWF4ICsgbWluO1xuICB9O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2QzLXJhbmRvbS9zcmMvdW5pZm9ybS5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgdGltZUludGVydmFsXG59IGZyb20gXCIuL3NyYy9pbnRlcnZhbFwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHRpbWVNaWxsaXNlY29uZCxcbiAgbWlsbGlzZWNvbmRzIGFzIHRpbWVNaWxsaXNlY29uZHMsXG4gIGRlZmF1bHQgYXMgdXRjTWlsbGlzZWNvbmQsXG4gIG1pbGxpc2Vjb25kcyBhcyB1dGNNaWxsaXNlY29uZHNcbn0gZnJvbSBcIi4vc3JjL21pbGxpc2Vjb25kXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgdGltZVNlY29uZCxcbiAgc2Vjb25kcyBhcyB0aW1lU2Vjb25kcyxcbiAgZGVmYXVsdCBhcyB1dGNTZWNvbmQsXG4gIHNlY29uZHMgYXMgdXRjU2Vjb25kc1xufSBmcm9tIFwiLi9zcmMvc2Vjb25kXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgdGltZU1pbnV0ZSxcbiAgbWludXRlcyBhcyB0aW1lTWludXRlc1xufSBmcm9tIFwiLi9zcmMvbWludXRlXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgdGltZUhvdXIsXG4gIGhvdXJzIGFzIHRpbWVIb3Vyc1xufSBmcm9tIFwiLi9zcmMvaG91clwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHRpbWVEYXksXG4gIGRheXMgYXMgdGltZURheXNcbn0gZnJvbSBcIi4vc3JjL2RheVwiO1xuXG5leHBvcnQge1xuICBzdW5kYXkgYXMgdGltZVdlZWssXG4gIHN1bmRheXMgYXMgdGltZVdlZWtzLFxuICBzdW5kYXkgYXMgdGltZVN1bmRheSxcbiAgc3VuZGF5cyBhcyB0aW1lU3VuZGF5cyxcbiAgbW9uZGF5IGFzIHRpbWVNb25kYXksXG4gIG1vbmRheXMgYXMgdGltZU1vbmRheXMsXG4gIHR1ZXNkYXkgYXMgdGltZVR1ZXNkYXksXG4gIHR1ZXNkYXlzIGFzIHRpbWVUdWVzZGF5cyxcbiAgd2VkbmVzZGF5IGFzIHRpbWVXZWRuZXNkYXksXG4gIHdlZG5lc2RheXMgYXMgdGltZVdlZG5lc2RheXMsXG4gIHRodXJzZGF5IGFzIHRpbWVUaHVyc2RheSxcbiAgdGh1cnNkYXlzIGFzIHRpbWVUaHVyc2RheXMsXG4gIGZyaWRheSBhcyB0aW1lRnJpZGF5LFxuICBmcmlkYXlzIGFzIHRpbWVGcmlkYXlzLFxuICBzYXR1cmRheSBhcyB0aW1lU2F0dXJkYXksXG4gIHNhdHVyZGF5cyBhcyB0aW1lU2F0dXJkYXlzXG59IGZyb20gXCIuL3NyYy93ZWVrXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgdGltZU1vbnRoLFxuICBtb250aHMgYXMgdGltZU1vbnRoc1xufSBmcm9tIFwiLi9zcmMvbW9udGhcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyB0aW1lWWVhcixcbiAgeWVhcnMgYXMgdGltZVllYXJzXG59IGZyb20gXCIuL3NyYy95ZWFyXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgdXRjTWludXRlLFxuICB1dGNNaW51dGVzIGFzIHV0Y01pbnV0ZXNcbn0gZnJvbSBcIi4vc3JjL3V0Y01pbnV0ZVwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHV0Y0hvdXIsXG4gIHV0Y0hvdXJzIGFzIHV0Y0hvdXJzXG59IGZyb20gXCIuL3NyYy91dGNIb3VyXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgdXRjRGF5LFxuICB1dGNEYXlzIGFzIHV0Y0RheXNcbn0gZnJvbSBcIi4vc3JjL3V0Y0RheVwiO1xuXG5leHBvcnQge1xuICB1dGNTdW5kYXkgYXMgdXRjV2VlayxcbiAgdXRjU3VuZGF5cyBhcyB1dGNXZWVrcyxcbiAgdXRjU3VuZGF5IGFzIHV0Y1N1bmRheSxcbiAgdXRjU3VuZGF5cyBhcyB1dGNTdW5kYXlzLFxuICB1dGNNb25kYXkgYXMgdXRjTW9uZGF5LFxuICB1dGNNb25kYXlzIGFzIHV0Y01vbmRheXMsXG4gIHV0Y1R1ZXNkYXkgYXMgdXRjVHVlc2RheSxcbiAgdXRjVHVlc2RheXMgYXMgdXRjVHVlc2RheXMsXG4gIHV0Y1dlZG5lc2RheSBhcyB1dGNXZWRuZXNkYXksXG4gIHV0Y1dlZG5lc2RheXMgYXMgdXRjV2VkbmVzZGF5cyxcbiAgdXRjVGh1cnNkYXkgYXMgdXRjVGh1cnNkYXksXG4gIHV0Y1RodXJzZGF5cyBhcyB1dGNUaHVyc2RheXMsXG4gIHV0Y0ZyaWRheSBhcyB1dGNGcmlkYXksXG4gIHV0Y0ZyaWRheXMgYXMgdXRjRnJpZGF5cyxcbiAgdXRjU2F0dXJkYXkgYXMgdXRjU2F0dXJkYXksXG4gIHV0Y1NhdHVyZGF5cyBhcyB1dGNTYXR1cmRheXNcbn0gZnJvbSBcIi4vc3JjL3V0Y1dlZWtcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyB1dGNNb250aCxcbiAgdXRjTW9udGhzIGFzIHV0Y01vbnRoc1xufSBmcm9tIFwiLi9zcmMvdXRjTW9udGhcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyB1dGNZZWFyLFxuICB1dGNZZWFycyBhcyB1dGNZZWFyc1xufSBmcm9tIFwiLi9zcmMvdXRjWWVhclwiO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2QzLXRpbWUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWxcIjtcbmltcG9ydCB7ZHVyYXRpb25EYXksIGR1cmF0aW9uTWludXRlfSBmcm9tIFwiLi9kdXJhdGlvblwiO1xuXG52YXIgZGF5ID0gaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogZHVyYXRpb25NaW51dGUpIC8gZHVyYXRpb25EYXk7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldERhdGUoKSAtIDE7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZGF5O1xuZXhwb3J0IHZhciBkYXlzID0gZGF5LnJhbmdlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2QzLXRpbWUvc3JjL2RheS5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbFwiO1xuaW1wb3J0IHtkdXJhdGlvbkhvdXIsIGR1cmF0aW9uTWludXRlfSBmcm9tIFwiLi9kdXJhdGlvblwiO1xuXG52YXIgaG91ciA9IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgdmFyIG9mZnNldCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIGR1cmF0aW9uTWludXRlICUgZHVyYXRpb25Ib3VyO1xuICBpZiAob2Zmc2V0IDwgMCkgb2Zmc2V0ICs9IGR1cmF0aW9uSG91cjtcbiAgZGF0ZS5zZXRUaW1lKE1hdGguZmxvb3IoKCtkYXRlIC0gb2Zmc2V0KSAvIGR1cmF0aW9uSG91cikgKiBkdXJhdGlvbkhvdXIgKyBvZmZzZXQpO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25Ib3VyKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbkhvdXI7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldEhvdXJzKCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgaG91cjtcbmV4cG9ydCB2YXIgaG91cnMgPSBob3VyLnJhbmdlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2QzLXRpbWUvc3JjL2hvdXIuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWxcIjtcblxudmFyIG1pbGxpc2Vjb25kID0gaW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gIC8vIG5vb3Bcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQgLSBzdGFydDtcbn0pO1xuXG4vLyBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgc2ltcGxlIGNhc2UuXG5taWxsaXNlY29uZC5ldmVyeSA9IGZ1bmN0aW9uKGspIHtcbiAgayA9IE1hdGguZmxvb3Ioayk7XG4gIGlmICghaXNGaW5pdGUoaykgfHwgIShrID4gMCkpIHJldHVybiBudWxsO1xuICBpZiAoIShrID4gMSkpIHJldHVybiBtaWxsaXNlY29uZDtcbiAgcmV0dXJuIGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFRpbWUoTWF0aC5mbG9vcihkYXRlIC8gaykgKiBrKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBrKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gaztcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBtaWxsaXNlY29uZDtcbmV4cG9ydCB2YXIgbWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmQucmFuZ2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZDMtdGltZS9zcmMvbWlsbGlzZWNvbmQuanNcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWxcIjtcbmltcG9ydCB7ZHVyYXRpb25NaW51dGV9IGZyb20gXCIuL2R1cmF0aW9uXCI7XG5cbnZhciBtaW51dGUgPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VGltZShNYXRoLmZsb29yKGRhdGUgLyBkdXJhdGlvbk1pbnV0ZSkgKiBkdXJhdGlvbk1pbnV0ZSk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbk1pbnV0ZSk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25NaW51dGU7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldE1pbnV0ZXMoKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtaW51dGU7XG5leHBvcnQgdmFyIG1pbnV0ZXMgPSBtaW51dGUucmFuZ2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZDMtdGltZS9zcmMvbWludXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsXCI7XG5cbnZhciBtb250aCA9IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXREYXRlKDEpO1xuICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldE1vbnRoKGRhdGUuZ2V0TW9udGgoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldE1vbnRoKCkgLSBzdGFydC5nZXRNb250aCgpICsgKGVuZC5nZXRGdWxsWWVhcigpIC0gc3RhcnQuZ2V0RnVsbFllYXIoKSkgKiAxMjtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtb250aDtcbmV4cG9ydCB2YXIgbW9udGhzID0gbW9udGgucmFuZ2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZDMtdGltZS9zcmMvbW9udGguanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWxcIjtcbmltcG9ydCB7ZHVyYXRpb25TZWNvbmR9IGZyb20gXCIuL2R1cmF0aW9uXCI7XG5cbnZhciBzZWNvbmQgPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VGltZShNYXRoLmZsb29yKGRhdGUgLyBkdXJhdGlvblNlY29uZCkgKiBkdXJhdGlvblNlY29uZCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvblNlY29uZCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25TZWNvbmQ7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ1NlY29uZHMoKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzZWNvbmQ7XG5leHBvcnQgdmFyIHNlY29uZHMgPSBzZWNvbmQucmFuZ2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZDMtdGltZS9zcmMvc2Vjb25kLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsXCI7XG5pbXBvcnQge2R1cmF0aW9uRGF5fSBmcm9tIFwiLi9kdXJhdGlvblwiO1xuXG52YXIgdXRjRGF5ID0gaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbkRheTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDRGF0ZSgpIC0gMTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB1dGNEYXk7XG5leHBvcnQgdmFyIHV0Y0RheXMgPSB1dGNEYXkucmFuZ2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZDMtdGltZS9zcmMvdXRjRGF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsXCI7XG5pbXBvcnQge2R1cmF0aW9uSG91cn0gZnJvbSBcIi4vZHVyYXRpb25cIjtcblxudmFyIHV0Y0hvdXIgPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDTWludXRlcygwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uSG91cik7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25Ib3VyO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENIb3VycygpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHV0Y0hvdXI7XG5leHBvcnQgdmFyIHV0Y0hvdXJzID0gdXRjSG91ci5yYW5nZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kMy10aW1lL3NyYy91dGNIb3VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsXCI7XG5pbXBvcnQge2R1cmF0aW9uTWludXRlfSBmcm9tIFwiLi9kdXJhdGlvblwiO1xuXG52YXIgdXRjTWludXRlID0gaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ1NlY29uZHMoMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbk1pbnV0ZSk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25NaW51dGU7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ01pbnV0ZXMoKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB1dGNNaW51dGU7XG5leHBvcnQgdmFyIHV0Y01pbnV0ZXMgPSB1dGNNaW51dGUucmFuZ2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZDMtdGltZS9zcmMvdXRjTWludXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsXCI7XG5cbnZhciB1dGNNb250aCA9IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENEYXRlKDEpO1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFVUQ01vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldFVUQ01vbnRoKCkgLSBzdGFydC5nZXRVVENNb250aCgpICsgKGVuZC5nZXRVVENGdWxsWWVhcigpIC0gc3RhcnQuZ2V0VVRDRnVsbFllYXIoKSkgKiAxMjtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDTW9udGgoKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB1dGNNb250aDtcbmV4cG9ydCB2YXIgdXRjTW9udGhzID0gdXRjTW9udGgucmFuZ2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZDMtdGltZS9zcmMvdXRjTW9udGguanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWxcIjtcbmltcG9ydCB7ZHVyYXRpb25XZWVrfSBmcm9tIFwiLi9kdXJhdGlvblwiO1xuXG5mdW5jdGlvbiB1dGNXZWVrZGF5KGkpIHtcbiAgcmV0dXJuIGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSAoZGF0ZS5nZXRVVENEYXkoKSArIDcgLSBpKSAlIDcpO1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwICogNyk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uV2VlaztcbiAgfSk7XG59XG5cbmV4cG9ydCB2YXIgdXRjU3VuZGF5ID0gdXRjV2Vla2RheSgwKTtcbmV4cG9ydCB2YXIgdXRjTW9uZGF5ID0gdXRjV2Vla2RheSgxKTtcbmV4cG9ydCB2YXIgdXRjVHVlc2RheSA9IHV0Y1dlZWtkYXkoMik7XG5leHBvcnQgdmFyIHV0Y1dlZG5lc2RheSA9IHV0Y1dlZWtkYXkoMyk7XG5leHBvcnQgdmFyIHV0Y1RodXJzZGF5ID0gdXRjV2Vla2RheSg0KTtcbmV4cG9ydCB2YXIgdXRjRnJpZGF5ID0gdXRjV2Vla2RheSg1KTtcbmV4cG9ydCB2YXIgdXRjU2F0dXJkYXkgPSB1dGNXZWVrZGF5KDYpO1xuXG5leHBvcnQgdmFyIHV0Y1N1bmRheXMgPSB1dGNTdW5kYXkucmFuZ2U7XG5leHBvcnQgdmFyIHV0Y01vbmRheXMgPSB1dGNNb25kYXkucmFuZ2U7XG5leHBvcnQgdmFyIHV0Y1R1ZXNkYXlzID0gdXRjVHVlc2RheS5yYW5nZTtcbmV4cG9ydCB2YXIgdXRjV2VkbmVzZGF5cyA9IHV0Y1dlZG5lc2RheS5yYW5nZTtcbmV4cG9ydCB2YXIgdXRjVGh1cnNkYXlzID0gdXRjVGh1cnNkYXkucmFuZ2U7XG5leHBvcnQgdmFyIHV0Y0ZyaWRheXMgPSB1dGNGcmlkYXkucmFuZ2U7XG5leHBvcnQgdmFyIHV0Y1NhdHVyZGF5cyA9IHV0Y1NhdHVyZGF5LnJhbmdlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2QzLXRpbWUvc3JjL3V0Y1dlZWsuanNcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWxcIjtcblxudmFyIHV0Y1llYXIgPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDTW9udGgoMCwgMSk7XG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VVRDRnVsbFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCk7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG59KTtcblxuLy8gQW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIGZvciB0aGlzIHNpbXBsZSBjYXNlLlxudXRjWWVhci5ldmVyeSA9IGZ1bmN0aW9uKGspIHtcbiAgcmV0dXJuICFpc0Zpbml0ZShrID0gTWF0aC5mbG9vcihrKSkgfHwgIShrID4gMCkgPyBudWxsIDogaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoTWF0aC5mbG9vcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgLyBrKSAqIGspO1xuICAgIGRhdGUuc2V0VVRDTW9udGgoMCwgMSk7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpICsgc3RlcCAqIGspO1xuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHV0Y1llYXI7XG5leHBvcnQgdmFyIHV0Y1llYXJzID0gdXRjWWVhci5yYW5nZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kMy10aW1lL3NyYy91dGNZZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsXCI7XG5pbXBvcnQge2R1cmF0aW9uTWludXRlLCBkdXJhdGlvbldlZWt9IGZyb20gXCIuL2R1cmF0aW9uXCI7XG5cbmZ1bmN0aW9uIHdlZWtkYXkoaSkge1xuICByZXR1cm4gaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIChkYXRlLmdldERheSgpICsgNyAtIGkpICUgNyk7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXAgKiA3KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIGR1cmF0aW9uTWludXRlKSAvIGR1cmF0aW9uV2VlaztcbiAgfSk7XG59XG5cbmV4cG9ydCB2YXIgc3VuZGF5ID0gd2Vla2RheSgwKTtcbmV4cG9ydCB2YXIgbW9uZGF5ID0gd2Vla2RheSgxKTtcbmV4cG9ydCB2YXIgdHVlc2RheSA9IHdlZWtkYXkoMik7XG5leHBvcnQgdmFyIHdlZG5lc2RheSA9IHdlZWtkYXkoMyk7XG5leHBvcnQgdmFyIHRodXJzZGF5ID0gd2Vla2RheSg0KTtcbmV4cG9ydCB2YXIgZnJpZGF5ID0gd2Vla2RheSg1KTtcbmV4cG9ydCB2YXIgc2F0dXJkYXkgPSB3ZWVrZGF5KDYpO1xuXG5leHBvcnQgdmFyIHN1bmRheXMgPSBzdW5kYXkucmFuZ2U7XG5leHBvcnQgdmFyIG1vbmRheXMgPSBtb25kYXkucmFuZ2U7XG5leHBvcnQgdmFyIHR1ZXNkYXlzID0gdHVlc2RheS5yYW5nZTtcbmV4cG9ydCB2YXIgd2VkbmVzZGF5cyA9IHdlZG5lc2RheS5yYW5nZTtcbmV4cG9ydCB2YXIgdGh1cnNkYXlzID0gdGh1cnNkYXkucmFuZ2U7XG5leHBvcnQgdmFyIGZyaWRheXMgPSBmcmlkYXkucmFuZ2U7XG5leHBvcnQgdmFyIHNhdHVyZGF5cyA9IHNhdHVyZGF5LnJhbmdlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2QzLXRpbWUvc3JjL3dlZWsuanNcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWxcIjtcblxudmFyIHllYXIgPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0TW9udGgoMCwgMSk7XG4gIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCk7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7XG59KTtcblxuLy8gQW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIGZvciB0aGlzIHNpbXBsZSBjYXNlLlxueWVhci5ldmVyeSA9IGZ1bmN0aW9uKGspIHtcbiAgcmV0dXJuICFpc0Zpbml0ZShrID0gTWF0aC5mbG9vcihrKSkgfHwgIShrID4gMCkgPyBudWxsIDogaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoTWF0aC5mbG9vcihkYXRlLmdldEZ1bGxZZWFyKCkgLyBrKSAqIGspO1xuICAgIGRhdGUuc2V0TW9udGgoMCwgMSk7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgc3RlcCAqIGspO1xuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHllYXI7XG5leHBvcnQgdmFyIHllYXJzID0geWVhci5yYW5nZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kMy10aW1lL3NyYy95ZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgoZ2xvYmFsLmZjID0gZ2xvYmFsLmZjIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlUmVib3VuZE1ldGhvZCA9IChmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gc291cmNlW25hbWVdO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdCB0byByZWJpbmQgJyArIG5hbWUgKyAnIHdoaWNoIGlzblxcJ3QgYSBmdW5jdGlvbiBvbiB0aGUgc291cmNlIG9iamVjdCcpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9IG1ldGhvZC5hcHBseShzb3VyY2UsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHNvdXJjZSA/IHRhcmdldCA6IHZhbHVlO1xuICAgIH07XG59KTtcblxudmFyIHJlYmluZCA9IChmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbmFtZXMgPSBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIG5hbWVzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gbmFtZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBjcmVhdGVSZWJvdW5kTWV0aG9kKHRhcmdldCwgc291cmNlLCBuYW1lKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbn0pO1xuXG52YXIgY3JlYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gY3JlYXRlVHJhbnNmb3JtKHRyYW5zZm9ybXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybXMucmVkdWNlKGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUgJiYgZm4obmFtZSk7XG4gICAgICAgIH0sIG5hbWUpO1xuICAgIH07XG59O1xuXG52YXIgcmViaW5kQWxsID0gKGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB0cmFuc2Zvcm1zID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICB0cmFuc2Zvcm1zW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNmb3JtID0gY3JlYXRlVHJhbnNmb3JtKHRyYW5zZm9ybXMpO1xuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBPYmplY3Qua2V5cyhzb3VyY2UpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyYW5zZm9ybShuYW1lKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbcmVzdWx0XSA9IGNyZWF0ZVJlYm91bmRNZXRob2QodGFyZ2V0LCBzb3VyY2UsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufSk7XG5cbnZhciByZWdleGlmeSA9IChmdW5jdGlvbiAoc3Ryc09yUmVnZXhlcykge1xuICAgIHJldHVybiBzdHJzT3JSZWdleGVzLm1hcChmdW5jdGlvbiAoc3RyT3JSZWdleCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHN0ck9yUmVnZXggPT09ICdzdHJpbmcnID8gbmV3IFJlZ0V4cCgnXicgKyBzdHJPclJlZ2V4ICsgJyQnKSA6IHN0ck9yUmVnZXg7XG4gICAgfSk7XG59KTtcblxudmFyIGV4Y2x1ZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBleGNsdXNpb25zID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGV4Y2x1c2lvbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgZXhjbHVzaW9ucyA9IHJlZ2V4aWZ5KGV4Y2x1c2lvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gZXhjbHVzaW9ucy5ldmVyeShmdW5jdGlvbiAoZXhjbHVzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gIWV4Y2x1c2lvbi50ZXN0KG5hbWUpO1xuICAgICAgICB9KSAmJiBuYW1lO1xuICAgIH07XG59KTtcblxudmFyIGluY2x1ZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBpbmNsdXNpb25zID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGluY2x1c2lvbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaW5jbHVzaW9ucyA9IHJlZ2V4aWZ5KGluY2x1c2lvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gaW5jbHVzaW9ucy5zb21lKGZ1bmN0aW9uIChpbmNsdXNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBpbmNsdXNpb24udGVzdChuYW1lKTtcbiAgICAgICAgfSkgJiYgbmFtZTtcbiAgICB9O1xufSk7XG5cbnZhciBpbmNsdWRlTWFwID0gKGZ1bmN0aW9uIChtYXBwaW5ncykge1xuICByZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gbWFwcGluZ3NbbmFtZV07XG4gIH07XG59KTtcblxudmFyIGNhcGl0YWxpemVGaXJzdExldHRlciA9IGZ1bmN0aW9uIGNhcGl0YWxpemVGaXJzdExldHRlcihzdHIpIHtcbiAgcmV0dXJuIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufTtcblxudmFyIHByZWZpeCA9IChmdW5jdGlvbiAocHJlZml4KSB7XG4gIHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBwcmVmaXggKyBjYXBpdGFsaXplRmlyc3RMZXR0ZXIobmFtZSk7XG4gIH07XG59KTtcblxuZXhwb3J0cy5yZWJpbmQgPSByZWJpbmQ7XG5leHBvcnRzLnJlYmluZEFsbCA9IHJlYmluZEFsbDtcbmV4cG9ydHMuZXhjbHVkZSA9IGV4Y2x1ZGU7XG5leHBvcnRzLmluY2x1ZGUgPSBpbmNsdWRlO1xuZXhwb3J0cy5pbmNsdWRlTWFwID0gaW5jbHVkZU1hcDtcbmV4cG9ydHMucHJlZml4ID0gcHJlZml4O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2QzZmMtcmViaW5kL2J1aWxkL2QzZmMtcmViaW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBkZWVwLWRpZmYuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbjsoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCc7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgLy8gbGlrZSBOb2RlLlxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgcm9vdC5EZWVwRGlmZiA9IGZhY3RvcnkoKTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciAkc2NvcGUsIGNvbmZsaWN0LCBjb25mbGljdFJlc29sdXRpb24gPSBbXTtcbiAgaWYgKHR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnICYmIGdsb2JhbCkge1xuICAgICRzY29wZSA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICRzY29wZSA9IHdpbmRvdztcbiAgfSBlbHNlIHtcbiAgICAkc2NvcGUgPSB7fTtcbiAgfVxuICBjb25mbGljdCA9ICRzY29wZS5EZWVwRGlmZjtcbiAgaWYgKGNvbmZsaWN0KSB7XG4gICAgY29uZmxpY3RSZXNvbHV0aW9uLnB1c2goXG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgY29uZmxpY3QgJiYgJHNjb3BlLkRlZXBEaWZmID09PSBhY2N1bXVsYXRlRGlmZikge1xuICAgICAgICAgICRzY29wZS5EZWVwRGlmZiA9IGNvbmZsaWN0O1xuICAgICAgICAgIGNvbmZsaWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIC8vIG5vZGVqcyBjb21wYXRpYmxlIG9uIHNlcnZlciBzaWRlIGFuZCBpbiB0aGUgYnJvd3Nlci5cbiAgZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gRGlmZihraW5kLCBwYXRoKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdraW5kJywge1xuICAgICAgdmFsdWU6IGtpbmQsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHBhdGggJiYgcGF0aC5sZW5ndGgpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncGF0aCcsIHtcbiAgICAgICAgdmFsdWU6IHBhdGgsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIERpZmZFZGl0KHBhdGgsIG9yaWdpbiwgdmFsdWUpIHtcbiAgICBEaWZmRWRpdC5zdXBlcl8uY2FsbCh0aGlzLCAnRScsIHBhdGgpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbGhzJywge1xuICAgICAgdmFsdWU6IG9yaWdpbixcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JocycsIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICBpbmhlcml0cyhEaWZmRWRpdCwgRGlmZik7XG5cbiAgZnVuY3Rpb24gRGlmZk5ldyhwYXRoLCB2YWx1ZSkge1xuICAgIERpZmZOZXcuc3VwZXJfLmNhbGwodGhpcywgJ04nLCBwYXRoKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JocycsIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICBpbmhlcml0cyhEaWZmTmV3LCBEaWZmKTtcblxuICBmdW5jdGlvbiBEaWZmRGVsZXRlZChwYXRoLCB2YWx1ZSkge1xuICAgIERpZmZEZWxldGVkLnN1cGVyXy5jYWxsKHRoaXMsICdEJywgcGF0aCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdsaHMnLCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgaW5oZXJpdHMoRGlmZkRlbGV0ZWQsIERpZmYpO1xuXG4gIGZ1bmN0aW9uIERpZmZBcnJheShwYXRoLCBpbmRleCwgaXRlbSkge1xuICAgIERpZmZBcnJheS5zdXBlcl8uY2FsbCh0aGlzLCAnQScsIHBhdGgpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaW5kZXgnLCB7XG4gICAgICB2YWx1ZTogaW5kZXgsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpdGVtJywge1xuICAgICAgdmFsdWU6IGl0ZW0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgaW5oZXJpdHMoRGlmZkFycmF5LCBEaWZmKTtcblxuICBmdW5jdGlvbiBhcnJheVJlbW92ZShhcnIsIGZyb20sIHRvKSB7XG4gICAgdmFyIHJlc3QgPSBhcnIuc2xpY2UoKHRvIHx8IGZyb20pICsgMSB8fCBhcnIubGVuZ3RoKTtcbiAgICBhcnIubGVuZ3RoID0gZnJvbSA8IDAgPyBhcnIubGVuZ3RoICsgZnJvbSA6IGZyb207XG4gICAgYXJyLnB1c2guYXBwbHkoYXJyLCByZXN0KTtcbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhbFR5cGVPZihzdWJqZWN0KSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygc3ViamVjdDtcbiAgICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIGlmIChzdWJqZWN0ID09PSBNYXRoKSB7XG4gICAgICByZXR1cm4gJ21hdGgnO1xuICAgIH0gZWxzZSBpZiAoc3ViamVjdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3ViamVjdCkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3ViamVjdC50b1N0cmluZyAhPT0gJ3VuZGVmaW5lZCcgJiYgL15cXC8uKlxcLy8udGVzdChzdWJqZWN0LnRvU3RyaW5nKCkpKSB7XG4gICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgfVxuICAgIHJldHVybiAnb2JqZWN0JztcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZXBEaWZmKGxocywgcmhzLCBjaGFuZ2VzLCBwcmVmaWx0ZXIsIHBhdGgsIGtleSwgc3RhY2spIHtcbiAgICBwYXRoID0gcGF0aCB8fCBbXTtcbiAgICB2YXIgY3VycmVudFBhdGggPSBwYXRoLnNsaWNlKDApO1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHByZWZpbHRlcikge1xuICAgICAgICBpZiAodHlwZW9mKHByZWZpbHRlcikgPT09ICdmdW5jdGlvbicgJiYgcHJlZmlsdGVyKGN1cnJlbnRQYXRoLCBrZXkpKSB7IHJldHVybjsgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YocHJlZmlsdGVyKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAocHJlZmlsdGVyLnByZWZpbHRlciAmJiBwcmVmaWx0ZXIucHJlZmlsdGVyKGN1cnJlbnRQYXRoLCBrZXkpKSB7IHJldHVybjsgfVxuICAgICAgICAgIGlmIChwcmVmaWx0ZXIubm9ybWFsaXplKSB7XG4gICAgICAgICAgICB2YXIgYWx0ID0gcHJlZmlsdGVyLm5vcm1hbGl6ZShjdXJyZW50UGF0aCwga2V5LCBsaHMsIHJocyk7XG4gICAgICAgICAgICBpZiAoYWx0KSB7XG4gICAgICAgICAgICAgIGxocyA9IGFsdFswXTtcbiAgICAgICAgICAgICAgcmhzID0gYWx0WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3VycmVudFBhdGgucHVzaChrZXkpO1xuICAgIH1cblxuICAgIC8vIFVzZSBzdHJpbmcgY29tcGFyaXNvbiBmb3IgcmVnZXhlc1xuICAgIGlmIChyZWFsVHlwZU9mKGxocykgPT09ICdyZWdleHAnICYmIHJlYWxUeXBlT2YocmhzKSA9PT0gJ3JlZ2V4cCcpIHtcbiAgICAgIGxocyA9IGxocy50b1N0cmluZygpO1xuICAgICAgcmhzID0gcmhzLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgdmFyIGx0eXBlID0gdHlwZW9mIGxocztcbiAgICB2YXIgcnR5cGUgPSB0eXBlb2YgcmhzO1xuICAgIGlmIChsdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChydHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY2hhbmdlcyhuZXcgRGlmZk5ldyhjdXJyZW50UGF0aCwgcmhzKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChydHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNoYW5nZXMobmV3IERpZmZEZWxldGVkKGN1cnJlbnRQYXRoLCBsaHMpKTtcbiAgICB9IGVsc2UgaWYgKHJlYWxUeXBlT2YobGhzKSAhPT0gcmVhbFR5cGVPZihyaHMpKSB7XG4gICAgICBjaGFuZ2VzKG5ldyBEaWZmRWRpdChjdXJyZW50UGF0aCwgbGhzLCByaHMpKTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChsaHMpID09PSAnW29iamVjdCBEYXRlXScgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJocykgPT09ICdbb2JqZWN0IERhdGVdJyAmJiAoKGxocyAtIHJocykgIT09IDApKSB7XG4gICAgICBjaGFuZ2VzKG5ldyBEaWZmRWRpdChjdXJyZW50UGF0aCwgbGhzLCByaHMpKTtcbiAgICB9IGVsc2UgaWYgKGx0eXBlID09PSAnb2JqZWN0JyAmJiBsaHMgIT09IG51bGwgJiYgcmhzICE9PSBudWxsKSB7XG4gICAgICBzdGFjayA9IHN0YWNrIHx8IFtdO1xuICAgICAgaWYgKHN0YWNrLmluZGV4T2YobGhzKSA8IDApIHtcbiAgICAgICAgc3RhY2sucHVzaChsaHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsaHMpKSB7XG4gICAgICAgICAgdmFyIGksIGxlbiA9IGxocy5sZW5ndGg7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPj0gcmhzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjaGFuZ2VzKG5ldyBEaWZmQXJyYXkoY3VycmVudFBhdGgsIGksIG5ldyBEaWZmRGVsZXRlZCh1bmRlZmluZWQsIGxoc1tpXSkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlZXBEaWZmKGxoc1tpXSwgcmhzW2ldLCBjaGFuZ2VzLCBwcmVmaWx0ZXIsIGN1cnJlbnRQYXRoLCBpLCBzdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChpIDwgcmhzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2hhbmdlcyhuZXcgRGlmZkFycmF5KGN1cnJlbnRQYXRoLCBpLCBuZXcgRGlmZk5ldyh1bmRlZmluZWQsIHJoc1tpKytdKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYWtleXMgPSBPYmplY3Qua2V5cyhsaHMpO1xuICAgICAgICAgIHZhciBwa2V5cyA9IE9iamVjdC5rZXlzKHJocyk7XG4gICAgICAgICAgYWtleXMuZm9yRWFjaChmdW5jdGlvbihrLCBpKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBwa2V5cy5pbmRleE9mKGspO1xuICAgICAgICAgICAgaWYgKG90aGVyID49IDApIHtcbiAgICAgICAgICAgICAgZGVlcERpZmYobGhzW2tdLCByaHNba10sIGNoYW5nZXMsIHByZWZpbHRlciwgY3VycmVudFBhdGgsIGssIHN0YWNrKTtcbiAgICAgICAgICAgICAgcGtleXMgPSBhcnJheVJlbW92ZShwa2V5cywgb3RoZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVlcERpZmYobGhzW2tdLCB1bmRlZmluZWQsIGNoYW5nZXMsIHByZWZpbHRlciwgY3VycmVudFBhdGgsIGssIHN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwa2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIGRlZXBEaWZmKHVuZGVmaW5lZCwgcmhzW2tdLCBjaGFuZ2VzLCBwcmVmaWx0ZXIsIGN1cnJlbnRQYXRoLCBrLCBzdGFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2subGVuZ3RoID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxocyAhPT0gcmhzKSB7XG4gICAgICBpZiAoIShsdHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4obGhzKSAmJiBpc05hTihyaHMpKSkge1xuICAgICAgICBjaGFuZ2VzKG5ldyBEaWZmRWRpdChjdXJyZW50UGF0aCwgbGhzLCByaHMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhY2N1bXVsYXRlRGlmZihsaHMsIHJocywgcHJlZmlsdGVyLCBhY2N1bSkge1xuICAgIGFjY3VtID0gYWNjdW0gfHwgW107XG4gICAgZGVlcERpZmYobGhzLCByaHMsXG4gICAgICBmdW5jdGlvbihkaWZmKSB7XG4gICAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgICAgYWNjdW0ucHVzaChkaWZmKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByZWZpbHRlcik7XG4gICAgcmV0dXJuIChhY2N1bS5sZW5ndGgpID8gYWNjdW0gOiB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseUFycmF5Q2hhbmdlKGFyciwgaW5kZXgsIGNoYW5nZSkge1xuICAgIGlmIChjaGFuZ2UucGF0aCAmJiBjaGFuZ2UucGF0aC5sZW5ndGgpIHtcbiAgICAgIHZhciBpdCA9IGFycltpbmRleF0sXG4gICAgICAgICAgaSwgdSA9IGNoYW5nZS5wYXRoLmxlbmd0aCAtIDE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdTsgaSsrKSB7XG4gICAgICAgIGl0ID0gaXRbY2hhbmdlLnBhdGhbaV1dO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjaGFuZ2Uua2luZCkge1xuICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICBhcHBseUFycmF5Q2hhbmdlKGl0W2NoYW5nZS5wYXRoW2ldXSwgY2hhbmdlLmluZGV4LCBjaGFuZ2UuaXRlbSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgIGRlbGV0ZSBpdFtjaGFuZ2UucGF0aFtpXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICBpdFtjaGFuZ2UucGF0aFtpXV0gPSBjaGFuZ2UucmhzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGNoYW5nZS5raW5kKSB7XG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIGFwcGx5QXJyYXlDaGFuZ2UoYXJyW2luZGV4XSwgY2hhbmdlLmluZGV4LCBjaGFuZ2UuaXRlbSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgIGFyciA9IGFycmF5UmVtb3ZlKGFyciwgaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgYXJyW2luZGV4XSA9IGNoYW5nZS5yaHM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseUNoYW5nZSh0YXJnZXQsIHNvdXJjZSwgY2hhbmdlKSB7XG4gICAgaWYgKHRhcmdldCAmJiBzb3VyY2UgJiYgY2hhbmdlICYmIGNoYW5nZS5raW5kKSB7XG4gICAgICB2YXIgaXQgPSB0YXJnZXQsXG4gICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgIGxhc3QgPSBjaGFuZ2UucGF0aCA/IGNoYW5nZS5wYXRoLmxlbmd0aCAtIDEgOiAwO1xuICAgICAgd2hpbGUgKCsraSA8IGxhc3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdFtjaGFuZ2UucGF0aFtpXV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaXRbY2hhbmdlLnBhdGhbaV1dID0gKHR5cGVvZiBjaGFuZ2UucGF0aFtpXSA9PT0gJ251bWJlcicpID8gW10gOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpdCA9IGl0W2NoYW5nZS5wYXRoW2ldXTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY2hhbmdlLmtpbmQpIHtcbiAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgYXBwbHlBcnJheUNoYW5nZShjaGFuZ2UucGF0aCA/IGl0W2NoYW5nZS5wYXRoW2ldXSA6IGl0LCBjaGFuZ2UuaW5kZXgsIGNoYW5nZS5pdGVtKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgZGVsZXRlIGl0W2NoYW5nZS5wYXRoW2ldXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgIGl0W2NoYW5nZS5wYXRoW2ldXSA9IGNoYW5nZS5yaHM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmV2ZXJ0QXJyYXlDaGFuZ2UoYXJyLCBpbmRleCwgY2hhbmdlKSB7XG4gICAgaWYgKGNoYW5nZS5wYXRoICYmIGNoYW5nZS5wYXRoLmxlbmd0aCkge1xuICAgICAgLy8gdGhlIHN0cnVjdHVyZSBvZiB0aGUgb2JqZWN0IGF0IHRoZSBpbmRleCBoYXMgY2hhbmdlZC4uLlxuICAgICAgdmFyIGl0ID0gYXJyW2luZGV4XSxcbiAgICAgICAgICBpLCB1ID0gY2hhbmdlLnBhdGgubGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB1OyBpKyspIHtcbiAgICAgICAgaXQgPSBpdFtjaGFuZ2UucGF0aFtpXV07XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNoYW5nZS5raW5kKSB7XG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIHJldmVydEFycmF5Q2hhbmdlKGl0W2NoYW5nZS5wYXRoW2ldXSwgY2hhbmdlLmluZGV4LCBjaGFuZ2UuaXRlbSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgIGl0W2NoYW5nZS5wYXRoW2ldXSA9IGNoYW5nZS5saHM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgIGl0W2NoYW5nZS5wYXRoW2ldXSA9IGNoYW5nZS5saHM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgIGRlbGV0ZSBpdFtjaGFuZ2UucGF0aFtpXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZSBhcnJheSBpdGVtIGlzIGRpZmZlcmVudC4uLlxuICAgICAgc3dpdGNoIChjaGFuZ2Uua2luZCkge1xuICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICByZXZlcnRBcnJheUNoYW5nZShhcnJbaW5kZXhdLCBjaGFuZ2UuaW5kZXgsIGNoYW5nZS5pdGVtKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgYXJyW2luZGV4XSA9IGNoYW5nZS5saHM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgIGFycltpbmRleF0gPSBjaGFuZ2UubGhzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICBhcnIgPSBhcnJheVJlbW92ZShhcnIsIGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldmVydENoYW5nZSh0YXJnZXQsIHNvdXJjZSwgY2hhbmdlKSB7XG4gICAgaWYgKHRhcmdldCAmJiBzb3VyY2UgJiYgY2hhbmdlICYmIGNoYW5nZS5raW5kKSB7XG4gICAgICB2YXIgaXQgPSB0YXJnZXQsXG4gICAgICAgICAgaSwgdTtcbiAgICAgIHUgPSBjaGFuZ2UucGF0aC5sZW5ndGggLSAxO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHU7IGkrKykge1xuICAgICAgICBpZiAodHlwZW9mIGl0W2NoYW5nZS5wYXRoW2ldXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpdFtjaGFuZ2UucGF0aFtpXV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpdCA9IGl0W2NoYW5nZS5wYXRoW2ldXTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY2hhbmdlLmtpbmQpIHtcbiAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgLy8gQXJyYXkgd2FzIG1vZGlmaWVkLi4uXG4gICAgICAgICAgLy8gaXQgd2lsbCBiZSBhbiBhcnJheS4uLlxuICAgICAgICAgIHJldmVydEFycmF5Q2hhbmdlKGl0W2NoYW5nZS5wYXRoW2ldXSwgY2hhbmdlLmluZGV4LCBjaGFuZ2UuaXRlbSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgIC8vIEl0ZW0gd2FzIGRlbGV0ZWQuLi5cbiAgICAgICAgICBpdFtjaGFuZ2UucGF0aFtpXV0gPSBjaGFuZ2UubGhzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAvLyBJdGVtIHdhcyBlZGl0ZWQuLi5cbiAgICAgICAgICBpdFtjaGFuZ2UucGF0aFtpXV0gPSBjaGFuZ2UubGhzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICAvLyBJdGVtIGlzIG5ldy4uLlxuICAgICAgICAgIGRlbGV0ZSBpdFtjaGFuZ2UucGF0aFtpXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlEaWZmKHRhcmdldCwgc291cmNlLCBmaWx0ZXIpIHtcbiAgICBpZiAodGFyZ2V0ICYmIHNvdXJjZSkge1xuICAgICAgdmFyIG9uQ2hhbmdlID0gZnVuY3Rpb24oY2hhbmdlKSB7XG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcih0YXJnZXQsIHNvdXJjZSwgY2hhbmdlKSkge1xuICAgICAgICAgIGFwcGx5Q2hhbmdlKHRhcmdldCwgc291cmNlLCBjaGFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZGVlcERpZmYodGFyZ2V0LCBzb3VyY2UsIG9uQ2hhbmdlKTtcbiAgICB9XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhhY2N1bXVsYXRlRGlmZiwge1xuXG4gICAgZGlmZjoge1xuICAgICAgdmFsdWU6IGFjY3VtdWxhdGVEaWZmLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgb2JzZXJ2YWJsZURpZmY6IHtcbiAgICAgIHZhbHVlOiBkZWVwRGlmZixcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9LFxuICAgIGFwcGx5RGlmZjoge1xuICAgICAgdmFsdWU6IGFwcGx5RGlmZixcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9LFxuICAgIGFwcGx5Q2hhbmdlOiB7XG4gICAgICB2YWx1ZTogYXBwbHlDaGFuZ2UsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSxcbiAgICByZXZlcnRDaGFuZ2U6IHtcbiAgICAgIHZhbHVlOiByZXZlcnRDaGFuZ2UsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSxcbiAgICBpc0NvbmZsaWN0OiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGNvbmZsaWN0O1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9LFxuICAgIG5vQ29uZmxpY3Q6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNvbmZsaWN0UmVzb2x1dGlvbikge1xuICAgICAgICAgIGNvbmZsaWN0UmVzb2x1dGlvbi5mb3JFYWNoKGZ1bmN0aW9uKGl0KSB7XG4gICAgICAgICAgICBpdCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbmZsaWN0UmVzb2x1dGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdGVEaWZmO1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBhY2N1bXVsYXRlRGlmZjtcbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kZWVwLWRpZmYvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX2h5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9mYmpzL2xpYi9jYW1lbGl6ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW1lbGl6ZSA9IHJlcXVpcmUoJy4vY2FtZWxpemUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbW96LXRyYW5zaXRpb24nKVxuICogICA8IFwiTW96VHJhbnNpdGlvblwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tcy10cmFuc2l0aW9uJylcbiAqICAgPCBcIm1zVHJhbnNpdGlvblwiXG4gKlxuICogQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICogKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBjYW1lbGl6ZShzdHJpbmcucmVwbGFjZShtc1BhdHRlcm4sICdtcy0nKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemVTdHlsZU5hbWU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZianMvbGliL2h5cGhlbmF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoeXBoZW5hdGUgPSByZXF1aXJlKCcuL2h5cGhlbmF0ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZShzdHJpbmcpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZVN0eWxlTmFtZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHZhciBkb2MgPSBvYmplY3QgPyBvYmplY3Qub3duZXJEb2N1bWVudCB8fCBvYmplY3QgOiBkb2N1bWVudDtcbiAgdmFyIGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgcmV0dXJuICEhKG9iamVjdCAmJiAodHlwZW9mIGRlZmF1bHRWaWV3Lk5vZGUgPT09ICdmdW5jdGlvbicgPyBvYmplY3QgaW5zdGFuY2VvZiBkZWZhdWx0Vmlldy5Ob2RlIDogdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05vZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZianMvbGliL2lzTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL2lzTm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZianMvbGliL2lzVGV4dE5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDEzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWZ1bmN0aW9uJylcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblxuZnVuY3Rpb24gZm9yRWFjaChsaXN0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXNGdW5jdGlvbihpdGVyYXRvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgY29udGV4dCA9IHRoaXNcbiAgICB9XG4gICAgXG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobGlzdCkgPT09ICdbb2JqZWN0IEFycmF5XScpXG4gICAgICAgIGZvckVhY2hBcnJheShsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbiAgICBlbHNlIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpXG4gICAgICAgIGZvckVhY2hTdHJpbmcobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG4gICAgZWxzZVxuICAgICAgICBmb3JFYWNoT2JqZWN0KGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBpKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBhcnJheVtpXSwgaSwgYXJyYXkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTdHJpbmcoc3RyaW5nLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmplY3Rba10sIGssIG9iamVjdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9mb3ItZWFjaC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB3aW47XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgd2luID0gc2VsZjtcbn0gZWxzZSB7XG4gICAgd2luID0ge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2dsb2JhbC93aW5kb3cuanNcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuIEhpZ2hzdG9jayBKUyB2Ni4wLjQgKDIwMTctMTItMTUpXG5cbiAoYykgMjAwOS0yMDE2IFRvcnN0ZWluIEhvbnNpXG5cbiBMaWNlbnNlOiB3d3cuaGlnaGNoYXJ0cy5jb20vbGljZW5zZVxuKi9cbihmdW5jdGlvbihRLEwpe1wib2JqZWN0XCI9PT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1RLmRvY3VtZW50P0woUSk6TDpRLkhpZ2hjaGFydHM9TChRKX0pKFwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93P3dpbmRvdzp0aGlzLGZ1bmN0aW9uKFEpe3ZhciBMPWZ1bmN0aW9uKCl7dmFyIGE9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBRP3dpbmRvdzpRLEc9YS5kb2N1bWVudCxFPWEubmF2aWdhdG9yJiZhLm5hdmlnYXRvci51c2VyQWdlbnR8fFwiXCIsSD1HJiZHLmNyZWF0ZUVsZW1lbnROUyYmISFHLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXCJzdmdcIikuY3JlYXRlU1ZHUmVjdCx2PS8oZWRnZXxtc2llfHRyaWRlbnQpL2kudGVzdChFKSYmIWEub3BlcmEsaz0vRmlyZWZveC8udGVzdChFKSxxPWsmJjQ+cGFyc2VJbnQoRS5zcGxpdChcIkZpcmVmb3gvXCIpWzFdLDEwKTtyZXR1cm4gYS5IaWdoY2hhcnRzP2EuSGlnaGNoYXJ0cy5lcnJvcigxNixcbiEwKTp7cHJvZHVjdDpcIkhpZ2hzdG9ja1wiLHZlcnNpb246XCI2LjAuNFwiLGRlZzJyYWQ6MipNYXRoLlBJLzM2MCxkb2M6RyxoYXNCaWRpQnVnOnEsaGFzVG91Y2g6RyYmdm9pZCAwIT09Ry5kb2N1bWVudEVsZW1lbnQub250b3VjaHN0YXJ0LGlzTVM6dixpc1dlYktpdDovQXBwbGVXZWJLaXQvLnRlc3QoRSksaXNGaXJlZm94OmssaXNUb3VjaERldmljZTovKE1vYmlsZXxBbmRyb2lkfFdpbmRvd3MgUGhvbmUpLy50ZXN0KEUpLFNWR19OUzpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsY2hhcnRDb3VudDowLHNlcmllc1R5cGVzOnt9LHN5bWJvbFNpemVzOnt9LHN2ZzpILHdpbjphLG1hcmdpbk5hbWVzOltcInBsb3RUb3BcIixcIm1hcmdpblJpZ2h0XCIsXCJtYXJnaW5Cb3R0b21cIixcInBsb3RMZWZ0XCJdLG5vb3A6ZnVuY3Rpb24oKXt9LGNoYXJ0czpbXX19KCk7KGZ1bmN0aW9uKGEpe2EudGltZXJzPVtdO3ZhciBHPWEuY2hhcnRzLEU9YS5kb2MsSD1hLndpbjthLmVycm9yPWZ1bmN0aW9uKHYsXG5rKXt2PWEuaXNOdW1iZXIodik/XCJIaWdoY2hhcnRzIGVycm9yICNcIit2K1wiOiB3d3cuaGlnaGNoYXJ0cy5jb20vZXJyb3JzL1wiK3Y6djtpZihrKXRocm93IEVycm9yKHYpO0guY29uc29sZSYmY29uc29sZS5sb2codil9O2EuRng9ZnVuY3Rpb24oYSxrLHEpe3RoaXMub3B0aW9ucz1rO3RoaXMuZWxlbT1hO3RoaXMucHJvcD1xfTthLkZ4LnByb3RvdHlwZT17ZFNldHRlcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMucGF0aHNbMF0saz10aGlzLnBhdGhzWzFdLHE9W10sdz10aGlzLm5vdyx0PWEubGVuZ3RoLHU7aWYoMT09PXcpcT10aGlzLnRvRDtlbHNlIGlmKHQ9PT1rLmxlbmd0aCYmMT53KWZvcig7dC0tOyl1PXBhcnNlRmxvYXQoYVt0XSkscVt0XT1pc05hTih1KT9rW3RdOncqcGFyc2VGbG9hdChrW3RdLXUpK3U7ZWxzZSBxPWs7dGhpcy5lbGVtLmF0dHIoXCJkXCIscSxudWxsLCEwKX0sdXBkYXRlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lbGVtLGs9dGhpcy5wcm9wLHE9dGhpcy5ub3csdz1cbnRoaXMub3B0aW9ucy5zdGVwO2lmKHRoaXNbaytcIlNldHRlclwiXSl0aGlzW2srXCJTZXR0ZXJcIl0oKTtlbHNlIGEuYXR0cj9hLmVsZW1lbnQmJmEuYXR0cihrLHEsbnVsbCwhMCk6YS5zdHlsZVtrXT1xK3RoaXMudW5pdDt3JiZ3LmNhbGwoYSxxLHRoaXMpfSxydW46ZnVuY3Rpb24odixrLHEpe3ZhciB3PXRoaXMsdD13Lm9wdGlvbnMsdT1mdW5jdGlvbihhKXtyZXR1cm4gdS5zdG9wcGVkPyExOncuc3RlcChhKX0sej1ILnJlcXVlc3RBbmltYXRpb25GcmFtZXx8ZnVuY3Rpb24oYSl7c2V0VGltZW91dChhLDEzKX0sbT1mdW5jdGlvbigpe2Zvcih2YXIgZz0wO2c8YS50aW1lcnMubGVuZ3RoO2crKylhLnRpbWVyc1tnXSgpfHxhLnRpbWVycy5zcGxpY2UoZy0tLDEpO2EudGltZXJzLmxlbmd0aCYmeihtKX07dj09PWs/KGRlbGV0ZSB0LmN1ckFuaW1bdGhpcy5wcm9wXSx0LmNvbXBsZXRlJiYwPT09YS5rZXlzKHQuY3VyQW5pbSkubGVuZ3RoJiZ0LmNvbXBsZXRlLmNhbGwodGhpcy5lbGVtKSk6XG4odGhpcy5zdGFydFRpbWU9K25ldyBEYXRlLHRoaXMuc3RhcnQ9dix0aGlzLmVuZD1rLHRoaXMudW5pdD1xLHRoaXMubm93PXRoaXMuc3RhcnQsdGhpcy5wb3M9MCx1LmVsZW09dGhpcy5lbGVtLHUucHJvcD10aGlzLnByb3AsdSgpJiYxPT09YS50aW1lcnMucHVzaCh1KSYmeihtKSl9LHN0ZXA6ZnVuY3Rpb24odil7dmFyIGs9K25ldyBEYXRlLHEsdz10aGlzLm9wdGlvbnMsdD10aGlzLmVsZW0sdT13LmNvbXBsZXRlLHo9dy5kdXJhdGlvbixtPXcuY3VyQW5pbTt0LmF0dHImJiF0LmVsZW1lbnQ/dj0hMTp2fHxrPj16K3RoaXMuc3RhcnRUaW1lPyh0aGlzLm5vdz10aGlzLmVuZCx0aGlzLnBvcz0xLHRoaXMudXBkYXRlKCkscT1tW3RoaXMucHJvcF09ITAsYS5vYmplY3RFYWNoKG0sZnVuY3Rpb24oYSl7ITAhPT1hJiYocT0hMSl9KSxxJiZ1JiZ1LmNhbGwodCksdj0hMSk6KHRoaXMucG9zPXcuZWFzaW5nKChrLXRoaXMuc3RhcnRUaW1lKS96KSx0aGlzLm5vdz10aGlzLnN0YXJ0Kyh0aGlzLmVuZC1cbnRoaXMuc3RhcnQpKnRoaXMucG9zLHRoaXMudXBkYXRlKCksdj0hMCk7cmV0dXJuIHZ9LGluaXRQYXRoOmZ1bmN0aW9uKHYsayxxKXtmdW5jdGlvbiB3KGEpe3ZhciBiLGM7Zm9yKHI9YS5sZW5ndGg7ci0tOyliPVwiTVwiPT09YVtyXXx8XCJMXCI9PT1hW3JdLGM9L1thLXpBLVpdLy50ZXN0KGFbciszXSksYiYmYyYmYS5zcGxpY2UocisxLDAsYVtyKzFdLGFbcisyXSxhW3IrMV0sYVtyKzJdKX1mdW5jdGlvbiB0KGEsYil7Zm9yKDthLmxlbmd0aDxjOyl7YVswXT1iW2MtYS5sZW5ndGhdO3ZhciBuPWEuc2xpY2UoMCxlKTtbXS5zcGxpY2UuYXBwbHkoYSxbMCwwXS5jb25jYXQobikpO2wmJihuPWEuc2xpY2UoYS5sZW5ndGgtZSksW10uc3BsaWNlLmFwcGx5KGEsW2EubGVuZ3RoLDBdLmNvbmNhdChuKSksci0tKX1hWzBdPVwiTVwifWZ1bmN0aW9uIHUoYSxyKXtmb3IodmFyIG49KGMtYS5sZW5ndGgpL2U7MDxuJiZuLS07KWI9YS5zbGljZSgpLnNwbGljZShhLmxlbmd0aC9DLWUsZSpDKSxiWzBdPVxucltjLWUtbiplXSxmJiYoYltlLTZdPWJbZS0yXSxiW2UtNV09YltlLTFdKSxbXS5zcGxpY2UuYXBwbHkoYSxbYS5sZW5ndGgvQywwXS5jb25jYXQoYikpLGwmJm4tLX1rPWt8fFwiXCI7dmFyIHosbT12LnN0YXJ0WCxnPXYuZW5kWCxmPS0xPGsuaW5kZXhPZihcIkNcIiksZT1mPzc6MyxjLGIscjtrPWsuc3BsaXQoXCIgXCIpO3E9cS5zbGljZSgpO3ZhciBsPXYuaXNBcmVhLEM9bD8yOjEsSTtmJiYodyhrKSx3KHEpKTtpZihtJiZnKXtmb3Iocj0wO3I8bS5sZW5ndGg7cisrKWlmKG1bcl09PT1nWzBdKXt6PXI7YnJlYWt9ZWxzZSBpZihtWzBdPT09Z1tnLmxlbmd0aC1tLmxlbmd0aCtyXSl7ej1yO0k9ITA7YnJlYWt9dm9pZCAwPT09eiYmKGs9W10pfWsubGVuZ3RoJiZhLmlzTnVtYmVyKHopJiYoYz1xLmxlbmd0aCt6KkMqZSxJPyh0KGsscSksdShxLGspKToodChxLGspLHUoayxxKSkpO3JldHVybltrLHFdfX07YS5GeC5wcm90b3R5cGUuZmlsbFNldHRlcj1hLkZ4LnByb3RvdHlwZS5zdHJva2VTZXR0ZXI9XG5mdW5jdGlvbigpe3RoaXMuZWxlbS5hdHRyKHRoaXMucHJvcCxhLmNvbG9yKHRoaXMuc3RhcnQpLnR3ZWVuVG8oYS5jb2xvcih0aGlzLmVuZCksdGhpcy5wb3MpLG51bGwsITApfTthLmV4dGVuZD1mdW5jdGlvbihhLGspe3ZhciBxO2F8fChhPXt9KTtmb3IocSBpbiBrKWFbcV09a1txXTtyZXR1cm4gYX07YS5tZXJnZT1mdW5jdGlvbigpe3ZhciB2LGs9YXJndW1lbnRzLHEsdz17fSx0PWZ1bmN0aW9uKHUscSl7XCJvYmplY3RcIiE9PXR5cGVvZiB1JiYodT17fSk7YS5vYmplY3RFYWNoKHEsZnVuY3Rpb24obSxnKXshYS5pc09iamVjdChtLCEwKXx8YS5pc0NsYXNzKG0pfHxhLmlzRE9NRWxlbWVudChtKT91W2ddPXFbZ106dVtnXT10KHVbZ118fHt9LG0pfSk7cmV0dXJuIHV9OyEwPT09a1swXSYmKHc9a1sxXSxrPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGssMikpO3E9ay5sZW5ndGg7Zm9yKHY9MDt2PHE7disrKXc9dCh3LGtbdl0pO3JldHVybiB3fTthLnBJbnQ9ZnVuY3Rpb24oYSxcbmspe3JldHVybiBwYXJzZUludChhLGt8fDEwKX07YS5pc1N0cmluZz1mdW5jdGlvbihhKXtyZXR1cm5cInN0cmluZ1wiPT09dHlwZW9mIGF9O2EuaXNBcnJheT1mdW5jdGlvbihhKXthPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKTtyZXR1cm5cIltvYmplY3QgQXJyYXldXCI9PT1hfHxcIltvYmplY3QgQXJyYXkgSXRlcmF0b3JdXCI9PT1hfTthLmlzT2JqZWN0PWZ1bmN0aW9uKHYsayl7cmV0dXJuISF2JiZcIm9iamVjdFwiPT09dHlwZW9mIHYmJigha3x8IWEuaXNBcnJheSh2KSl9O2EuaXNET01FbGVtZW50PWZ1bmN0aW9uKHYpe3JldHVybiBhLmlzT2JqZWN0KHYpJiZcIm51bWJlclwiPT09dHlwZW9mIHYubm9kZVR5cGV9O2EuaXNDbGFzcz1mdW5jdGlvbih2KXt2YXIgaz12JiZ2LmNvbnN0cnVjdG9yO3JldHVybiEoIWEuaXNPYmplY3QodiwhMCl8fGEuaXNET01FbGVtZW50KHYpfHwha3x8IWsubmFtZXx8XCJPYmplY3RcIj09PWsubmFtZSl9O2EuaXNOdW1iZXI9ZnVuY3Rpb24oYSl7cmV0dXJuXCJudW1iZXJcIj09PVxudHlwZW9mIGEmJiFpc05hTihhKSYmSW5maW5pdHk+YSYmLUluZmluaXR5PGF9O2EuZXJhc2U9ZnVuY3Rpb24oYSxrKXtmb3IodmFyIHE9YS5sZW5ndGg7cS0tOylpZihhW3FdPT09ayl7YS5zcGxpY2UocSwxKTticmVha319O2EuZGVmaW5lZD1mdW5jdGlvbihhKXtyZXR1cm4gdm9pZCAwIT09YSYmbnVsbCE9PWF9O2EuYXR0cj1mdW5jdGlvbih2LGsscSl7dmFyIHc7YS5pc1N0cmluZyhrKT9hLmRlZmluZWQocSk/di5zZXRBdHRyaWJ1dGUoayxxKTp2JiZ2LmdldEF0dHJpYnV0ZSYmKHc9di5nZXRBdHRyaWJ1dGUoaykpOmEuZGVmaW5lZChrKSYmYS5pc09iamVjdChrKSYmYS5vYmplY3RFYWNoKGssZnVuY3Rpb24oYSx1KXt2LnNldEF0dHJpYnV0ZSh1LGEpfSk7cmV0dXJuIHd9O2Euc3BsYXQ9ZnVuY3Rpb24odil7cmV0dXJuIGEuaXNBcnJheSh2KT92Olt2XX07YS5zeW5jVGltZW91dD1mdW5jdGlvbihhLGsscSl7aWYoaylyZXR1cm4gc2V0VGltZW91dChhLGsscSk7YS5jYWxsKDAsXG5xKX07YS5waWNrPWZ1bmN0aW9uKCl7dmFyIGE9YXJndW1lbnRzLGsscSx3PWEubGVuZ3RoO2ZvcihrPTA7azx3O2srKylpZihxPWFba10sdm9pZCAwIT09cSYmbnVsbCE9PXEpcmV0dXJuIHF9O2EuY3NzPWZ1bmN0aW9uKHYsayl7YS5pc01TJiYhYS5zdmcmJmsmJnZvaWQgMCE9PWsub3BhY2l0eSYmKGsuZmlsdGVyPVwiYWxwaGEob3BhY2l0eVxceDNkXCIrMTAwKmsub3BhY2l0eStcIilcIik7YS5leHRlbmQodi5zdHlsZSxrKX07YS5jcmVhdGVFbGVtZW50PWZ1bmN0aW9uKHYsayxxLHcsdCl7dj1FLmNyZWF0ZUVsZW1lbnQodik7dmFyIHU9YS5jc3M7ayYmYS5leHRlbmQodixrKTt0JiZ1KHYse3BhZGRpbmc6MCxib3JkZXI6XCJub25lXCIsbWFyZ2luOjB9KTtxJiZ1KHYscSk7dyYmdy5hcHBlbmRDaGlsZCh2KTtyZXR1cm4gdn07YS5leHRlbmRDbGFzcz1mdW5jdGlvbih2LGspe3ZhciBxPWZ1bmN0aW9uKCl7fTtxLnByb3RvdHlwZT1uZXcgdjthLmV4dGVuZChxLnByb3RvdHlwZSxrKTtyZXR1cm4gcX07XG5hLnBhZD1mdW5jdGlvbihhLGsscSl7cmV0dXJuIEFycmF5KChrfHwyKSsxLVN0cmluZyhhKS5sZW5ndGgpLmpvaW4ocXx8MCkrYX07YS5yZWxhdGl2ZUxlbmd0aD1mdW5jdGlvbihhLGsscSl7cmV0dXJuLyUkLy50ZXN0KGEpP2sqcGFyc2VGbG9hdChhKS8xMDArKHF8fDApOnBhcnNlRmxvYXQoYSl9O2Eud3JhcD1mdW5jdGlvbihhLGsscSl7dmFyIHY9YVtrXTthW2tdPWZ1bmN0aW9uKCl7dmFyIGE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSx1PWFyZ3VtZW50cyx6PXRoaXM7ei5wcm9jZWVkPWZ1bmN0aW9uKCl7di5hcHBseSh6LGFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzOnUpfTthLnVuc2hpZnQodik7YT1xLmFwcGx5KHRoaXMsYSk7ei5wcm9jZWVkPW51bGw7cmV0dXJuIGF9fTthLmdldFRaT2Zmc2V0PWZ1bmN0aW9uKHYpe3ZhciBrPWEuRGF0ZTtyZXR1cm4gNkU0KihrLmhjR2V0VGltZXpvbmVPZmZzZXQmJmsuaGNHZXRUaW1lem9uZU9mZnNldCh2KXx8XG5rLmhjVGltZXpvbmVPZmZzZXR8fDApfTthLmRhdGVGb3JtYXQ9ZnVuY3Rpb24odixrLHEpe2lmKCFhLmRlZmluZWQoayl8fGlzTmFOKGspKXJldHVybiBhLmRlZmF1bHRPcHRpb25zLmxhbmcuaW52YWxpZERhdGV8fFwiXCI7dj1hLnBpY2sodixcIiVZLSVtLSVkICVIOiVNOiVTXCIpO3ZhciB3PWEuRGF0ZSx0PW5ldyB3KGstYS5nZXRUWk9mZnNldChrKSksdT10W3cuaGNHZXRIb3Vyc10oKSx6PXRbdy5oY0dldERheV0oKSxtPXRbdy5oY0dldERhdGVdKCksZz10W3cuaGNHZXRNb250aF0oKSxmPXRbdy5oY0dldEZ1bGxZZWFyXSgpLGU9YS5kZWZhdWx0T3B0aW9ucy5sYW5nLGM9ZS53ZWVrZGF5cyxiPWUuc2hvcnRXZWVrZGF5cyxyPWEucGFkLHc9YS5leHRlbmQoe2E6Yj9iW3pdOmNbel0uc3Vic3RyKDAsMyksQTpjW3pdLGQ6cihtKSxlOnIobSwyLFwiIFwiKSx3OnosYjplLnNob3J0TW9udGhzW2ddLEI6ZS5tb250aHNbZ10sbTpyKGcrMSkseTpmLnRvU3RyaW5nKCkuc3Vic3RyKDIsMiksWTpmLFxuSDpyKHUpLGs6dSxJOnIodSUxMnx8MTIpLGw6dSUxMnx8MTIsTTpyKHRbdy5oY0dldE1pbnV0ZXNdKCkpLHA6MTI+dT9cIkFNXCI6XCJQTVwiLFA6MTI+dT9cImFtXCI6XCJwbVwiLFM6cih0LmdldFNlY29uZHMoKSksTDpyKE1hdGgucm91bmQoayUxRTMpLDMpfSxhLmRhdGVGb3JtYXRzKTthLm9iamVjdEVhY2godyxmdW5jdGlvbihhLGIpe2Zvcig7LTEhPT12LmluZGV4T2YoXCIlXCIrYik7KXY9di5yZXBsYWNlKFwiJVwiK2IsXCJmdW5jdGlvblwiPT09dHlwZW9mIGE/YShrKTphKX0pO3JldHVybiBxP3Yuc3Vic3RyKDAsMSkudG9VcHBlckNhc2UoKSt2LnN1YnN0cigxKTp2fTthLmZvcm1hdFNpbmdsZT1mdW5jdGlvbih2LGspe3ZhciBxPS9cXC4oWzAtOV0pLyx3PWEuZGVmYXVsdE9wdGlvbnMubGFuZzsvZiQvLnRlc3Qodik/KHE9KHE9di5tYXRjaChxKSk/cVsxXTotMSxudWxsIT09ayYmKGs9YS5udW1iZXJGb3JtYXQoayxxLHcuZGVjaW1hbFBvaW50LC0xPHYuaW5kZXhPZihcIixcIik/dy50aG91c2FuZHNTZXA6XG5cIlwiKSkpOms9YS5kYXRlRm9ybWF0KHYsayk7cmV0dXJuIGt9O2EuZm9ybWF0PWZ1bmN0aW9uKHYsayl7Zm9yKHZhciBxPVwie1wiLHc9ITEsdCx1LHosbSxnPVtdLGY7djspe3E9di5pbmRleE9mKHEpO2lmKC0xPT09cSlicmVhazt0PXYuc2xpY2UoMCxxKTtpZih3KXt0PXQuc3BsaXQoXCI6XCIpO3U9dC5zaGlmdCgpLnNwbGl0KFwiLlwiKTttPXUubGVuZ3RoO2Y9aztmb3Ioej0wO3o8bTt6KyspZiYmKGY9Zlt1W3pdXSk7dC5sZW5ndGgmJihmPWEuZm9ybWF0U2luZ2xlKHQuam9pbihcIjpcIiksZikpO2cucHVzaChmKX1lbHNlIGcucHVzaCh0KTt2PXYuc2xpY2UocSsxKTtxPSh3PSF3KT9cIn1cIjpcIntcIn1nLnB1c2godik7cmV0dXJuIGcuam9pbihcIlwiKX07YS5nZXRNYWduaXR1ZGU9ZnVuY3Rpb24oYSl7cmV0dXJuIE1hdGgucG93KDEwLE1hdGguZmxvb3IoTWF0aC5sb2coYSkvTWF0aC5MTjEwKSl9O2Eubm9ybWFsaXplVGlja0ludGVydmFsPWZ1bmN0aW9uKHYsayxxLHcsdCl7dmFyIHUsej12O3E9XG5hLnBpY2socSwxKTt1PXYvcTtrfHwoaz10P1sxLDEuMiwxLjUsMiwyLjUsMyw0LDUsNiw4LDEwXTpbMSwyLDIuNSw1LDEwXSwhMT09PXcmJigxPT09cT9rPWEuZ3JlcChrLGZ1bmN0aW9uKGEpe3JldHVybiAwPT09YSUxfSk6LjE+PXEmJihrPVsxL3FdKSkpO2Zvcih3PTA7dzxrLmxlbmd0aCYmISh6PWtbd10sdCYmeipxPj12fHwhdCYmdTw9KGtbd10rKGtbdysxXXx8a1t3XSkpLzIpO3crKyk7cmV0dXJuIHo9YS5jb3JyZWN0RmxvYXQoeipxLC1NYXRoLnJvdW5kKE1hdGgubG9nKC4wMDEpL01hdGguTE4xMCkpfTthLnN0YWJsZVNvcnQ9ZnVuY3Rpb24oYSxrKXt2YXIgcT1hLmxlbmd0aCx2LHQ7Zm9yKHQ9MDt0PHE7dCsrKWFbdF0uc2FmZUk9dDthLnNvcnQoZnVuY3Rpb24oYSx0KXt2PWsoYSx0KTtyZXR1cm4gMD09PXY/YS5zYWZlSS10LnNhZmVJOnZ9KTtmb3IodD0wO3Q8cTt0KyspZGVsZXRlIGFbdF0uc2FmZUl9O2EuYXJyYXlNaW49ZnVuY3Rpb24oYSl7Zm9yKHZhciBrPWEubGVuZ3RoLFxucT1hWzBdO2stLTspYVtrXTxxJiYocT1hW2tdKTtyZXR1cm4gcX07YS5hcnJheU1heD1mdW5jdGlvbihhKXtmb3IodmFyIGs9YS5sZW5ndGgscT1hWzBdO2stLTspYVtrXT5xJiYocT1hW2tdKTtyZXR1cm4gcX07YS5kZXN0cm95T2JqZWN0UHJvcGVydGllcz1mdW5jdGlvbih2LGspe2Eub2JqZWN0RWFjaCh2LGZ1bmN0aW9uKGEsdyl7YSYmYSE9PWsmJmEuZGVzdHJveSYmYS5kZXN0cm95KCk7ZGVsZXRlIHZbd119KX07YS5kaXNjYXJkRWxlbWVudD1mdW5jdGlvbih2KXt2YXIgaz1hLmdhcmJhZ2VCaW47a3x8KGs9YS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTt2JiZrLmFwcGVuZENoaWxkKHYpO2suaW5uZXJIVE1MPVwiXCJ9O2EuY29ycmVjdEZsb2F0PWZ1bmN0aW9uKGEsayl7cmV0dXJuIHBhcnNlRmxvYXQoYS50b1ByZWNpc2lvbihrfHwxNCkpfTthLnNldEFuaW1hdGlvbj1mdW5jdGlvbih2LGspe2sucmVuZGVyZXIuZ2xvYmFsQW5pbWF0aW9uPWEucGljayh2LGsub3B0aW9ucy5jaGFydC5hbmltYXRpb24sXG4hMCl9O2EuYW5pbU9iamVjdD1mdW5jdGlvbih2KXtyZXR1cm4gYS5pc09iamVjdCh2KT9hLm1lcmdlKHYpOntkdXJhdGlvbjp2PzUwMDowfX07YS50aW1lVW5pdHM9e21pbGxpc2Vjb25kOjEsc2Vjb25kOjFFMyxtaW51dGU6NkU0LGhvdXI6MzZFNSxkYXk6ODY0RTUsd2Vlazo2MDQ4RTUsbW9udGg6MjQxOTJFNSx5ZWFyOjMxNDQ5NkU1fTthLm51bWJlckZvcm1hdD1mdW5jdGlvbih2LGsscSx3KXt2PSt2fHwwO2s9K2s7dmFyIHQ9YS5kZWZhdWx0T3B0aW9ucy5sYW5nLHU9KHYudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV18fFwiXCIpLnNwbGl0KFwiZVwiKVswXS5sZW5ndGgseixtLGc9di50b1N0cmluZygpLnNwbGl0KFwiZVwiKTstMT09PWs/az1NYXRoLm1pbih1LDIwKTphLmlzTnVtYmVyKGspP2smJmdbMV0mJjA+Z1sxXSYmKHo9aysgK2dbMV0sMDw9ej8oZ1swXT0oK2dbMF0pLnRvRXhwb25lbnRpYWwoeikuc3BsaXQoXCJlXCIpWzBdLGs9eik6KGdbMF09Z1swXS5zcGxpdChcIi5cIilbMF18fDAsXG52PTIwPms/KGdbMF0qTWF0aC5wb3coMTAsZ1sxXSkpLnRvRml4ZWQoayk6MCxnWzFdPTApKTprPTI7bT0oTWF0aC5hYnMoZ1sxXT9nWzBdOnYpK01hdGgucG93KDEwLC1NYXRoLm1heChrLHUpLTEpKS50b0ZpeGVkKGspO3U9U3RyaW5nKGEucEludChtKSk7ej0zPHUubGVuZ3RoP3UubGVuZ3RoJTM6MDtxPWEucGljayhxLHQuZGVjaW1hbFBvaW50KTt3PWEucGljayh3LHQudGhvdXNhbmRzU2VwKTt2PSgwPnY/XCItXCI6XCJcIikrKHo/dS5zdWJzdHIoMCx6KSt3OlwiXCIpO3YrPXUuc3Vic3RyKHopLnJlcGxhY2UoLyhcXGR7M30pKD89XFxkKS9nLFwiJDFcIit3KTtrJiYodis9cSttLnNsaWNlKC1rKSk7Z1sxXSYmMCE9PSt2JiYodis9XCJlXCIrZ1sxXSk7cmV0dXJuIHZ9O01hdGguZWFzZUluT3V0U2luZT1mdW5jdGlvbihhKXtyZXR1cm4tLjUqKE1hdGguY29zKE1hdGguUEkqYSktMSl9O2EuZ2V0U3R5bGU9ZnVuY3Rpb24odixrLHEpe2lmKFwid2lkdGhcIj09PWspcmV0dXJuIE1hdGgubWluKHYub2Zmc2V0V2lkdGgsXG52LnNjcm9sbFdpZHRoKS1hLmdldFN0eWxlKHYsXCJwYWRkaW5nLWxlZnRcIiktYS5nZXRTdHlsZSh2LFwicGFkZGluZy1yaWdodFwiKTtpZihcImhlaWdodFwiPT09aylyZXR1cm4gTWF0aC5taW4odi5vZmZzZXRIZWlnaHQsdi5zY3JvbGxIZWlnaHQpLWEuZ2V0U3R5bGUodixcInBhZGRpbmctdG9wXCIpLWEuZ2V0U3R5bGUodixcInBhZGRpbmctYm90dG9tXCIpO0guZ2V0Q29tcHV0ZWRTdHlsZXx8YS5lcnJvcigyNywhMCk7aWYodj1ILmdldENvbXB1dGVkU3R5bGUodix2b2lkIDApKXY9di5nZXRQcm9wZXJ0eVZhbHVlKGspLGEucGljayhxLFwib3BhY2l0eVwiIT09aykmJih2PWEucEludCh2KSk7cmV0dXJuIHZ9O2EuaW5BcnJheT1mdW5jdGlvbih2LGspe3JldHVybihhLmluZGV4T2ZQb2x5ZmlsbHx8QXJyYXkucHJvdG90eXBlLmluZGV4T2YpLmNhbGwoayx2KX07YS5ncmVwPWZ1bmN0aW9uKHYsayl7cmV0dXJuKGEuZmlsdGVyUG9seWZpbGx8fEFycmF5LnByb3RvdHlwZS5maWx0ZXIpLmNhbGwodixcbmspfTthLmZpbmQ9QXJyYXkucHJvdG90eXBlLmZpbmQ/ZnVuY3Rpb24oYSxrKXtyZXR1cm4gYS5maW5kKGspfTpmdW5jdGlvbihhLGspe3ZhciBxLHc9YS5sZW5ndGg7Zm9yKHE9MDtxPHc7cSsrKWlmKGsoYVtxXSxxKSlyZXR1cm4gYVtxXX07YS5tYXA9ZnVuY3Rpb24oYSxrKXtmb3IodmFyIHE9W10sdz0wLHQ9YS5sZW5ndGg7dzx0O3crKylxW3ddPWsuY2FsbChhW3ddLGFbd10sdyxhKTtyZXR1cm4gcX07YS5rZXlzPWZ1bmN0aW9uKHYpe3JldHVybihhLmtleXNQb2x5ZmlsbHx8T2JqZWN0LmtleXMpLmNhbGwodm9pZCAwLHYpfTthLnJlZHVjZT1mdW5jdGlvbih2LGsscSl7cmV0dXJuKGEucmVkdWNlUG9seWZpbGx8fEFycmF5LnByb3RvdHlwZS5yZWR1Y2UpLmNhbGwodixrLHEpfTthLm9mZnNldD1mdW5jdGlvbihhKXt2YXIgaz1FLmRvY3VtZW50RWxlbWVudDthPWEucGFyZW50RWxlbWVudD9hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOnt0b3A6MCxsZWZ0OjB9O3JldHVybnt0b3A6YS50b3ArXG4oSC5wYWdlWU9mZnNldHx8ay5zY3JvbGxUb3ApLShrLmNsaWVudFRvcHx8MCksbGVmdDphLmxlZnQrKEgucGFnZVhPZmZzZXR8fGsuc2Nyb2xsTGVmdCktKGsuY2xpZW50TGVmdHx8MCl9fTthLnN0b3A9ZnVuY3Rpb24odixrKXtmb3IodmFyIHE9YS50aW1lcnMubGVuZ3RoO3EtLTspYS50aW1lcnNbcV0uZWxlbSE9PXZ8fGsmJmshPT1hLnRpbWVyc1txXS5wcm9wfHwoYS50aW1lcnNbcV0uc3RvcHBlZD0hMCl9O2EuZWFjaD1mdW5jdGlvbih2LGsscSl7cmV0dXJuKGEuZm9yRWFjaFBvbHlmaWxsfHxBcnJheS5wcm90b3R5cGUuZm9yRWFjaCkuY2FsbCh2LGsscSl9O2Eub2JqZWN0RWFjaD1mdW5jdGlvbihhLGsscSl7Zm9yKHZhciB3IGluIGEpYS5oYXNPd25Qcm9wZXJ0eSh3KSYmay5jYWxsKHEsYVt3XSx3LGEpfTthLmFkZEV2ZW50PWZ1bmN0aW9uKHYsayxxKXt2YXIgdyx0LHU9di5hZGRFdmVudExpc3RlbmVyfHxhLmFkZEV2ZW50TGlzdGVuZXJQb2x5ZmlsbDt2LmhjRXZlbnRzJiZcbiFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodixcImhjRXZlbnRzXCIpJiYodD17fSxhLm9iamVjdEVhY2godi5oY0V2ZW50cyxmdW5jdGlvbihhLG0pe3RbbV09YS5zbGljZSgwKX0pLHYuaGNFdmVudHM9dCk7dz12LmhjRXZlbnRzPXYuaGNFdmVudHN8fHt9O3UmJnUuY2FsbCh2LGsscSwhMSk7d1trXXx8KHdba109W10pO3dba10ucHVzaChxKTtyZXR1cm4gZnVuY3Rpb24oKXthLnJlbW92ZUV2ZW50KHYsayxxKX19O2EucmVtb3ZlRXZlbnQ9ZnVuY3Rpb24odixrLHEpe2Z1bmN0aW9uIHcoZyxmKXt2YXIgZT12LnJlbW92ZUV2ZW50TGlzdGVuZXJ8fGEucmVtb3ZlRXZlbnRMaXN0ZW5lclBvbHlmaWxsO2UmJmUuY2FsbCh2LGcsZiwhMSl9ZnVuY3Rpb24gdCgpe3ZhciBnLGY7di5ub2RlTmFtZSYmKGs/KGc9e30sZ1trXT0hMCk6Zz16LGEub2JqZWN0RWFjaChnLGZ1bmN0aW9uKGEsYyl7aWYoeltjXSlmb3IoZj16W2NdLmxlbmd0aDtmLS07KXcoYyx6W2NdW2ZdKX0pKX1cbnZhciB1LHo9di5oY0V2ZW50cyxtO3omJihrPyh1PXpba118fFtdLHE/KG09YS5pbkFycmF5KHEsdSksLTE8bSYmKHUuc3BsaWNlKG0sMSkseltrXT11KSx3KGsscSkpOih0KCkseltrXT1bXSkpOih0KCksdi5oY0V2ZW50cz17fSkpfTthLmZpcmVFdmVudD1mdW5jdGlvbih2LGsscSx3KXt2YXIgdDt0PXYuaGNFdmVudHM7dmFyIHUsejtxPXF8fHt9O2lmKEUuY3JlYXRlRXZlbnQmJih2LmRpc3BhdGNoRXZlbnR8fHYuZmlyZUV2ZW50KSl0PUUuY3JlYXRlRXZlbnQoXCJFdmVudHNcIiksdC5pbml0RXZlbnQoaywhMCwhMCksYS5leHRlbmQodCxxKSx2LmRpc3BhdGNoRXZlbnQ/di5kaXNwYXRjaEV2ZW50KHQpOnYuZmlyZUV2ZW50KGssdCk7ZWxzZSBpZih0KWZvcih0PXRba118fFtdLHU9dC5sZW5ndGgscS50YXJnZXR8fGEuZXh0ZW5kKHEse3ByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7cS5kZWZhdWx0UHJldmVudGVkPSEwfSx0YXJnZXQ6dix0eXBlOmt9KSxrPTA7azx1O2srKykoej10W2tdKSYmXG4hMT09PXouY2FsbCh2LHEpJiZxLnByZXZlbnREZWZhdWx0KCk7dyYmIXEuZGVmYXVsdFByZXZlbnRlZCYmdyhxKX07YS5hbmltYXRlPWZ1bmN0aW9uKHYsayxxKXt2YXIgdyx0PVwiXCIsdSx6LG07YS5pc09iamVjdChxKXx8KG09YXJndW1lbnRzLHE9e2R1cmF0aW9uOm1bMl0sZWFzaW5nOm1bM10sY29tcGxldGU6bVs0XX0pO2EuaXNOdW1iZXIocS5kdXJhdGlvbil8fChxLmR1cmF0aW9uPTQwMCk7cS5lYXNpbmc9XCJmdW5jdGlvblwiPT09dHlwZW9mIHEuZWFzaW5nP3EuZWFzaW5nOk1hdGhbcS5lYXNpbmddfHxNYXRoLmVhc2VJbk91dFNpbmU7cS5jdXJBbmltPWEubWVyZ2Uoayk7YS5vYmplY3RFYWNoKGssZnVuY3Rpb24oZyxmKXthLnN0b3AodixmKTt6PW5ldyBhLkZ4KHYscSxmKTt1PW51bGw7XCJkXCI9PT1mPyh6LnBhdGhzPXouaW5pdFBhdGgodix2LmQsay5kKSx6LnRvRD1rLmQsdz0wLHU9MSk6di5hdHRyP3c9di5hdHRyKGYpOih3PXBhcnNlRmxvYXQoYS5nZXRTdHlsZSh2LGYpKXx8XG4wLFwib3BhY2l0eVwiIT09ZiYmKHQ9XCJweFwiKSk7dXx8KHU9Zyk7dSYmdS5tYXRjaCYmdS5tYXRjaChcInB4XCIpJiYodT11LnJlcGxhY2UoL3B4L2csXCJcIikpO3oucnVuKHcsdSx0KX0pfTthLnNlcmllc1R5cGU9ZnVuY3Rpb24odixrLHEsdyx0KXt2YXIgdT1hLmdldE9wdGlvbnMoKSx6PWEuc2VyaWVzVHlwZXM7dS5wbG90T3B0aW9uc1t2XT1hLm1lcmdlKHUucGxvdE9wdGlvbnNba10scSk7elt2XT1hLmV4dGVuZENsYXNzKHpba118fGZ1bmN0aW9uKCl7fSx3KTt6W3ZdLnByb3RvdHlwZS50eXBlPXY7dCYmKHpbdl0ucHJvdG90eXBlLnBvaW50Q2xhc3M9YS5leHRlbmRDbGFzcyhhLlBvaW50LHQpKTtyZXR1cm4gelt2XX07YS51bmlxdWVLZXk9ZnVuY3Rpb24oKXt2YXIgYT1NYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiw5KSxrPTA7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuXCJoaWdoY2hhcnRzLVwiK2ErXCItXCIraysrfX0oKTtILmpRdWVyeSYmKEgualF1ZXJ5LmZuLmhpZ2hjaGFydHM9XG5mdW5jdGlvbigpe3ZhciB2PVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtpZih0aGlzWzBdKXJldHVybiB2WzBdPyhuZXcgKGFbYS5pc1N0cmluZyh2WzBdKT92LnNoaWZ0KCk6XCJDaGFydFwiXSkodGhpc1swXSx2WzBdLHZbMV0pLHRoaXMpOkdbYS5hdHRyKHRoaXNbMF0sXCJkYXRhLWhpZ2hjaGFydHMtY2hhcnRcIildfSl9KShMKTsoZnVuY3Rpb24oYSl7dmFyIEc9YS5lYWNoLEU9YS5pc051bWJlcixIPWEubWFwLHY9YS5tZXJnZSxrPWEucEludDthLkNvbG9yPWZ1bmN0aW9uKHEpe2lmKCEodGhpcyBpbnN0YW5jZW9mIGEuQ29sb3IpKXJldHVybiBuZXcgYS5Db2xvcihxKTt0aGlzLmluaXQocSl9O2EuQ29sb3IucHJvdG90eXBlPXtwYXJzZXJzOlt7cmVnZXg6L3JnYmFcXChcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldPyg/OlxcLlswLTldKyk/KVxccypcXCkvLHBhcnNlOmZ1bmN0aW9uKGEpe3JldHVybltrKGFbMV0pLGsoYVsyXSksXG5rKGFbM10pLHBhcnNlRmxvYXQoYVs0XSwxMCldfX0se3JlZ2V4Oi9yZ2JcXChcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKlxcKS8scGFyc2U6ZnVuY3Rpb24oYSl7cmV0dXJuW2soYVsxXSksayhhWzJdKSxrKGFbM10pLDFdfX1dLG5hbWVzOntub25lOlwicmdiYSgyNTUsMjU1LDI1NSwwKVwiLHdoaXRlOlwiI2ZmZmZmZlwiLGJsYWNrOlwiIzAwMDAwMFwifSxpbml0OmZ1bmN0aW9uKHEpe3ZhciBrLHQsdSx6O2lmKCh0aGlzLmlucHV0PXE9dGhpcy5uYW1lc1txJiZxLnRvTG93ZXJDYXNlP3EudG9Mb3dlckNhc2UoKTpcIlwiXXx8cSkmJnEuc3RvcHMpdGhpcy5zdG9wcz1IKHEuc3RvcHMsZnVuY3Rpb24obSl7cmV0dXJuIG5ldyBhLkNvbG9yKG1bMV0pfSk7ZWxzZSBpZihxJiZxLmNoYXJBdCYmXCIjXCI9PT1xLmNoYXJBdCgpJiYoaz1xLmxlbmd0aCxxPXBhcnNlSW50KHEuc3Vic3RyKDEpLDE2KSw3PT09az90PVsocSYxNjcxMTY4MCk+PjE2LChxJjY1MjgwKT4+XG44LHEmMjU1LDFdOjQ9PT1rJiYodD1bKHEmMzg0MCk+PjR8KHEmMzg0MCk+PjgsKHEmMjQwKT4+NHxxJjI0MCwocSYxNSk8PDR8cSYxNSwxXSkpLCF0KWZvcih1PXRoaXMucGFyc2Vycy5sZW5ndGg7dS0tJiYhdDspej10aGlzLnBhcnNlcnNbdV0sKGs9ei5yZWdleC5leGVjKHEpKSYmKHQ9ei5wYXJzZShrKSk7dGhpcy5yZ2JhPXR8fFtdfSxnZXQ6ZnVuY3Rpb24oYSl7dmFyIHE9dGhpcy5pbnB1dCx0PXRoaXMucmdiYSx1O3RoaXMuc3RvcHM/KHU9dihxKSx1LnN0b3BzPVtdLmNvbmNhdCh1LnN0b3BzKSxHKHRoaXMuc3RvcHMsZnVuY3Rpb24odCxtKXt1LnN0b3BzW21dPVt1LnN0b3BzW21dWzBdLHQuZ2V0KGEpXX0pKTp1PXQmJkUodFswXSk/XCJyZ2JcIj09PWF8fCFhJiYxPT09dFszXT9cInJnYihcIit0WzBdK1wiLFwiK3RbMV0rXCIsXCIrdFsyXStcIilcIjpcImFcIj09PWE/dFszXTpcInJnYmEoXCIrdC5qb2luKFwiLFwiKStcIilcIjpxO3JldHVybiB1fSxicmlnaHRlbjpmdW5jdGlvbihhKXt2YXIgcSx0PXRoaXMucmdiYTtcbmlmKHRoaXMuc3RvcHMpRyh0aGlzLnN0b3BzLGZ1bmN0aW9uKHQpe3QuYnJpZ2h0ZW4oYSl9KTtlbHNlIGlmKEUoYSkmJjAhPT1hKWZvcihxPTA7Mz5xO3ErKyl0W3FdKz1rKDI1NSphKSwwPnRbcV0mJih0W3FdPTApLDI1NTx0W3FdJiYodFtxXT0yNTUpO3JldHVybiB0aGlzfSxzZXRPcGFjaXR5OmZ1bmN0aW9uKGEpe3RoaXMucmdiYVszXT1hO3JldHVybiB0aGlzfSx0d2VlblRvOmZ1bmN0aW9uKGEsayl7dmFyIHQ9dGhpcy5yZ2JhLHU9YS5yZ2JhO3UubGVuZ3RoJiZ0JiZ0Lmxlbmd0aD8oYT0xIT09dVszXXx8MSE9PXRbM10saz0oYT9cInJnYmEoXCI6XCJyZ2IoXCIpK01hdGgucm91bmQodVswXSsodFswXS11WzBdKSooMS1rKSkrXCIsXCIrTWF0aC5yb3VuZCh1WzFdKyh0WzFdLXVbMV0pKigxLWspKStcIixcIitNYXRoLnJvdW5kKHVbMl0rKHRbMl0tdVsyXSkqKDEtaykpKyhhP1wiLFwiKyh1WzNdKyh0WzNdLXVbM10pKigxLWspKTpcIlwiKStcIilcIik6az1hLmlucHV0fHxcIm5vbmVcIjtyZXR1cm4ga319O1xuYS5jb2xvcj1mdW5jdGlvbihrKXtyZXR1cm4gbmV3IGEuQ29sb3Ioayl9fSkoTCk7KGZ1bmN0aW9uKGEpe3ZhciBHLEUsSD1hLmFkZEV2ZW50LHY9YS5hbmltYXRlLGs9YS5hdHRyLHE9YS5jaGFydHMsdz1hLmNvbG9yLHQ9YS5jc3MsdT1hLmNyZWF0ZUVsZW1lbnQsej1hLmRlZmluZWQsbT1hLmRlZzJyYWQsZz1hLmRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzLGY9YS5kb2MsZT1hLmVhY2gsYz1hLmV4dGVuZCxiPWEuZXJhc2Uscj1hLmdyZXAsbD1hLmhhc1RvdWNoLEM9YS5pbkFycmF5LEk9YS5pc0FycmF5LHg9YS5pc0ZpcmVmb3gsRj1hLmlzTVMsbj1hLmlzT2JqZWN0LEI9YS5pc1N0cmluZyxKPWEuaXNXZWJLaXQsQT1hLm1lcmdlLGQ9YS5ub29wLHA9YS5vYmplY3RFYWNoLEQ9YS5waWNrLGg9YS5wSW50LHk9YS5yZW1vdmVFdmVudCxQPWEuc3RvcCxNPWEuc3ZnLE89YS5TVkdfTlMsTj1hLnN5bWJvbFNpemVzLFI9YS53aW47Rz1hLlNWR0VsZW1lbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307XG5jKEcucHJvdG90eXBlLHtvcGFjaXR5OjEsU1ZHX05TOk8sdGV4dFByb3BzOlwiZGlyZWN0aW9uIGZvbnRTaXplIGZvbnRXZWlnaHQgZm9udEZhbWlseSBmb250U3R5bGUgY29sb3IgbGluZUhlaWdodCB3aWR0aCB0ZXh0QWxpZ24gdGV4dERlY29yYXRpb24gdGV4dE92ZXJmbG93IHRleHRPdXRsaW5lXCIuc3BsaXQoXCIgXCIpLGluaXQ6ZnVuY3Rpb24oYSxoKXt0aGlzLmVsZW1lbnQ9XCJzcGFuXCI9PT1oP3UoaCk6Zi5jcmVhdGVFbGVtZW50TlModGhpcy5TVkdfTlMsaCk7dGhpcy5yZW5kZXJlcj1hfSxhbmltYXRlOmZ1bmN0aW9uKEssaCxkKXtoPWEuYW5pbU9iamVjdChEKGgsdGhpcy5yZW5kZXJlci5nbG9iYWxBbmltYXRpb24sITApKTswIT09aC5kdXJhdGlvbj8oZCYmKGguY29tcGxldGU9ZCksdih0aGlzLEssaCkpOih0aGlzLmF0dHIoSyxudWxsLGQpLGguc3RlcCYmaC5zdGVwLmNhbGwodGhpcykpO3JldHVybiB0aGlzfSxjb2xvckdyYWRpZW50OmZ1bmN0aW9uKGgsZCx5KXt2YXIgSz1cbnRoaXMucmVuZGVyZXIsYixjLGwsbixyLGYsUyxNLEMsRCxnPVtdLEI7aC5yYWRpYWxHcmFkaWVudD9jPVwicmFkaWFsR3JhZGllbnRcIjpoLmxpbmVhckdyYWRpZW50JiYoYz1cImxpbmVhckdyYWRpZW50XCIpO2MmJihsPWhbY10scj1LLmdyYWRpZW50cyxTPWguc3RvcHMsRD15LnJhZGlhbFJlZmVyZW5jZSxJKGwpJiYoaFtjXT1sPXt4MTpsWzBdLHkxOmxbMV0seDI6bFsyXSx5MjpsWzNdLGdyYWRpZW50VW5pdHM6XCJ1c2VyU3BhY2VPblVzZVwifSksXCJyYWRpYWxHcmFkaWVudFwiPT09YyYmRCYmIXoobC5ncmFkaWVudFVuaXRzKSYmKG49bCxsPUEobCxLLmdldFJhZGlhbEF0dHIoRCxuKSx7Z3JhZGllbnRVbml0czpcInVzZXJTcGFjZU9uVXNlXCJ9KSkscChsLGZ1bmN0aW9uKGEsaCl7XCJpZFwiIT09aCYmZy5wdXNoKGgsYSl9KSxwKFMsZnVuY3Rpb24oYSl7Zy5wdXNoKGEpfSksZz1nLmpvaW4oXCIsXCIpLHJbZ10/RD1yW2ddLmF0dHIoXCJpZFwiKToobC5pZD1EPWEudW5pcXVlS2V5KCkscltnXT1mPUsuY3JlYXRlRWxlbWVudChjKS5hdHRyKGwpLmFkZChLLmRlZnMpLFxuZi5yYWRBdHRyPW4sZi5zdG9wcz1bXSxlKFMsZnVuY3Rpb24oaCl7MD09PWhbMV0uaW5kZXhPZihcInJnYmFcIik/KGI9YS5jb2xvcihoWzFdKSxNPWIuZ2V0KFwicmdiXCIpLEM9Yi5nZXQoXCJhXCIpKTooTT1oWzFdLEM9MSk7aD1LLmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIpLmF0dHIoe29mZnNldDpoWzBdLFwic3RvcC1jb2xvclwiOk0sXCJzdG9wLW9wYWNpdHlcIjpDfSkuYWRkKGYpO2Yuc3RvcHMucHVzaChoKX0pKSxCPVwidXJsKFwiK0sudXJsK1wiI1wiK0QrXCIpXCIseS5zZXRBdHRyaWJ1dGUoZCxCKSx5LmdyYWRpZW50PWcsaC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBCfSl9LGFwcGx5VGV4dE91dGxpbmU6ZnVuY3Rpb24oaCl7dmFyIEs9dGhpcy5lbGVtZW50LGQseSxjLHAsbDstMSE9PWguaW5kZXhPZihcImNvbnRyYXN0XCIpJiYoaD1oLnJlcGxhY2UoL2NvbnRyYXN0L2csdGhpcy5yZW5kZXJlci5nZXRDb250cmFzdChLLnN0eWxlLmZpbGwpKSk7aD1oLnNwbGl0KFwiIFwiKTt5PWhbaC5sZW5ndGgtMV07XG5pZigoYz1oWzBdKSYmXCJub25lXCIhPT1jJiZhLnN2Zyl7dGhpcy5mYWtlVFM9ITA7aD1bXS5zbGljZS5jYWxsKEsuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0c3BhblwiKSk7dGhpcy55U2V0dGVyPXRoaXMueFNldHRlcjtjPWMucmVwbGFjZSgvKF5bXFxkXFwuXSspKC4qPykkL2csZnVuY3Rpb24oYSxoLEspe3JldHVybiAyKmgrS30pO2ZvcihsPWgubGVuZ3RoO2wtLTspZD1oW2xdLFwiaGlnaGNoYXJ0cy10ZXh0LW91dGxpbmVcIj09PWQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikmJmIoaCxLLnJlbW92ZUNoaWxkKGQpKTtwPUsuZmlyc3RDaGlsZDtlKGgsZnVuY3Rpb24oYSxoKXswPT09aCYmKGEuc2V0QXR0cmlidXRlKFwieFwiLEsuZ2V0QXR0cmlidXRlKFwieFwiKSksaD1LLmdldEF0dHJpYnV0ZShcInlcIiksYS5zZXRBdHRyaWJ1dGUoXCJ5XCIsaHx8MCksbnVsbD09PWgmJksuc2V0QXR0cmlidXRlKFwieVwiLDApKTthPWEuY2xvbmVOb2RlKDEpO2soYSx7XCJjbGFzc1wiOlwiaGlnaGNoYXJ0cy10ZXh0LW91dGxpbmVcIixcbmZpbGw6eSxzdHJva2U6eSxcInN0cm9rZS13aWR0aFwiOmMsXCJzdHJva2UtbGluZWpvaW5cIjpcInJvdW5kXCJ9KTtLLmluc2VydEJlZm9yZShhLHApfSl9fSxhdHRyOmZ1bmN0aW9uKGEsaCxkLHkpe3ZhciBLLGI9dGhpcy5lbGVtZW50LGMsbD10aGlzLGUsbjtcInN0cmluZ1wiPT09dHlwZW9mIGEmJnZvaWQgMCE9PWgmJihLPWEsYT17fSxhW0tdPWgpO1wic3RyaW5nXCI9PT10eXBlb2YgYT9sPSh0aGlzW2ErXCJHZXR0ZXJcIl18fHRoaXMuX2RlZmF1bHRHZXR0ZXIpLmNhbGwodGhpcyxhLGIpOihwKGEsZnVuY3Rpb24oaCxLKXtlPSExO3l8fFAodGhpcyxLKTt0aGlzLnN5bWJvbE5hbWUmJi9eKHh8eXx3aWR0aHxoZWlnaHR8cnxzdGFydHxlbmR8aW5uZXJSfGFuY2hvclh8YW5jaG9yWSkkLy50ZXN0KEspJiYoY3x8KHRoaXMuc3ltYm9sQXR0cihhKSxjPSEwKSxlPSEwKTshdGhpcy5yb3RhdGlvbnx8XCJ4XCIhPT1LJiZcInlcIiE9PUt8fCh0aGlzLmRvVHJhbnNmb3JtPSEwKTtlfHwobj10aGlzW0srXCJTZXR0ZXJcIl18fFxudGhpcy5fZGVmYXVsdFNldHRlcixuLmNhbGwodGhpcyxoLEssYiksdGhpcy5zaGFkb3dzJiYvXih3aWR0aHxoZWlnaHR8dmlzaWJpbGl0eXx4fHl8ZHx0cmFuc2Zvcm18Y3h8Y3l8cikkLy50ZXN0KEspJiZ0aGlzLnVwZGF0ZVNoYWRvd3MoSyxoLG4pKX0sdGhpcyksdGhpcy5hZnRlclNldHRlcnMoKSk7ZCYmZCgpO3JldHVybiBsfSxhZnRlclNldHRlcnM6ZnVuY3Rpb24oKXt0aGlzLmRvVHJhbnNmb3JtJiYodGhpcy51cGRhdGVUcmFuc2Zvcm0oKSx0aGlzLmRvVHJhbnNmb3JtPSExKX0sdXBkYXRlU2hhZG93czpmdW5jdGlvbihhLGgsZCl7Zm9yKHZhciBLPXRoaXMuc2hhZG93cyx5PUsubGVuZ3RoO3ktLTspZC5jYWxsKEtbeV0sXCJoZWlnaHRcIj09PWE/TWF0aC5tYXgoaC0oS1t5XS5jdXRIZWlnaHR8fDApLDApOlwiZFwiPT09YT90aGlzLmQ6aCxhLEtbeV0pfSxhZGRDbGFzczpmdW5jdGlvbihhLGgpe3ZhciBLPXRoaXMuYXR0cihcImNsYXNzXCIpfHxcIlwiOy0xPT09Sy5pbmRleE9mKGEpJiZcbihofHwoYT0oSysoSz9cIiBcIjpcIlwiKSthKS5yZXBsYWNlKFwiICBcIixcIiBcIikpLHRoaXMuYXR0cihcImNsYXNzXCIsYSkpO3JldHVybiB0aGlzfSxoYXNDbGFzczpmdW5jdGlvbihhKXtyZXR1cm4tMSE9PUMoYSwodGhpcy5hdHRyKFwiY2xhc3NcIil8fFwiXCIpLnNwbGl0KFwiIFwiKSl9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmF0dHIoXCJjbGFzc1wiLCh0aGlzLmF0dHIoXCJjbGFzc1wiKXx8XCJcIikucmVwbGFjZShhLFwiXCIpKX0sc3ltYm9sQXR0cjpmdW5jdGlvbihhKXt2YXIgaD10aGlzO2UoXCJ4IHkgciBzdGFydCBlbmQgd2lkdGggaGVpZ2h0IGlubmVyUiBhbmNob3JYIGFuY2hvcllcIi5zcGxpdChcIiBcIiksZnVuY3Rpb24oSyl7aFtLXT1EKGFbS10saFtLXSl9KTtoLmF0dHIoe2Q6aC5yZW5kZXJlci5zeW1ib2xzW2guc3ltYm9sTmFtZV0oaC54LGgueSxoLndpZHRoLGguaGVpZ2h0LGgpfSl9LGNsaXA6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYXR0cihcImNsaXAtcGF0aFwiLGE/XCJ1cmwoXCIrXG50aGlzLnJlbmRlcmVyLnVybCtcIiNcIithLmlkK1wiKVwiOlwibm9uZVwiKX0sY3Jpc3A6ZnVuY3Rpb24oYSxoKXt2YXIgZDtoPWh8fGEuc3Ryb2tlV2lkdGh8fDA7ZD1NYXRoLnJvdW5kKGgpJTIvMjthLng9TWF0aC5mbG9vcihhLnh8fHRoaXMueHx8MCkrZDthLnk9TWF0aC5mbG9vcihhLnl8fHRoaXMueXx8MCkrZDthLndpZHRoPU1hdGguZmxvb3IoKGEud2lkdGh8fHRoaXMud2lkdGh8fDApLTIqZCk7YS5oZWlnaHQ9TWF0aC5mbG9vcigoYS5oZWlnaHR8fHRoaXMuaGVpZ2h0fHwwKS0yKmQpO3ooYS5zdHJva2VXaWR0aCkmJihhLnN0cm9rZVdpZHRoPWgpO3JldHVybiBhfSxjc3M6ZnVuY3Rpb24oYSl7dmFyIGQ9dGhpcy5zdHlsZXMseT17fSxLPXRoaXMuZWxlbWVudCxiLGU9XCJcIixsLG49IWQsQT1bXCJ0ZXh0T3V0bGluZVwiLFwidGV4dE92ZXJmbG93XCIsXCJ3aWR0aFwiXTthJiZhLmNvbG9yJiYoYS5maWxsPWEuY29sb3IpO2QmJnAoYSxmdW5jdGlvbihhLGgpe2EhPT1kW2hdJiYoeVtoXT1hLG49ITApfSk7XG5uJiYoZCYmKGE9YyhkLHkpKSxiPXRoaXMudGV4dFdpZHRoPWEmJmEud2lkdGgmJlwiYXV0b1wiIT09YS53aWR0aCYmXCJ0ZXh0XCI9PT1LLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkmJmgoYS53aWR0aCksdGhpcy5zdHlsZXM9YSxiJiYhTSYmdGhpcy5yZW5kZXJlci5mb3JFeHBvcnQmJmRlbGV0ZSBhLndpZHRoLEYmJiFNP3QodGhpcy5lbGVtZW50LGEpOihsPWZ1bmN0aW9uKGEsaCl7cmV0dXJuXCItXCIraC50b0xvd2VyQ2FzZSgpfSxwKGEsZnVuY3Rpb24oYSxoKXstMT09PUMoaCxBKSYmKGUrPWgucmVwbGFjZSgvKFtBLVpdKS9nLGwpK1wiOlwiK2ErXCI7XCIpfSksZSYmayhLLFwic3R5bGVcIixlKSksdGhpcy5hZGRlZCYmKFwidGV4dFwiPT09dGhpcy5lbGVtZW50Lm5vZGVOYW1lJiZ0aGlzLnJlbmRlcmVyLmJ1aWxkVGV4dCh0aGlzKSxhJiZhLnRleHRPdXRsaW5lJiZ0aGlzLmFwcGx5VGV4dE91dGxpbmUoYS50ZXh0T3V0bGluZSkpKTtyZXR1cm4gdGhpc30sc3Ryb2tlV2lkdGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tcInN0cm9rZS13aWR0aFwiXXx8XG4wfSxvbjpmdW5jdGlvbihhLGgpe3ZhciBkPXRoaXMseT1kLmVsZW1lbnQ7bCYmXCJjbGlja1wiPT09YT8oeS5vbnRvdWNoc3RhcnQ9ZnVuY3Rpb24oYSl7ZC50b3VjaEV2ZW50RmlyZWQ9RGF0ZS5ub3coKTthLnByZXZlbnREZWZhdWx0KCk7aC5jYWxsKHksYSl9LHkub25jbGljaz1mdW5jdGlvbihhKXsoLTE9PT1SLm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkFuZHJvaWRcIil8fDExMDA8RGF0ZS5ub3coKS0oZC50b3VjaEV2ZW50RmlyZWR8fDApKSYmaC5jYWxsKHksYSl9KTp5W1wib25cIithXT1oO3JldHVybiB0aGlzfSxzZXRSYWRpYWxSZWZlcmVuY2U6ZnVuY3Rpb24oYSl7dmFyIGg9dGhpcy5yZW5kZXJlci5ncmFkaWVudHNbdGhpcy5lbGVtZW50LmdyYWRpZW50XTt0aGlzLmVsZW1lbnQucmFkaWFsUmVmZXJlbmNlPWE7aCYmaC5yYWRBdHRyJiZoLmFuaW1hdGUodGhpcy5yZW5kZXJlci5nZXRSYWRpYWxBdHRyKGEsaC5yYWRBdHRyKSk7cmV0dXJuIHRoaXN9LHRyYW5zbGF0ZTpmdW5jdGlvbihhLFxuaCl7cmV0dXJuIHRoaXMuYXR0cih7dHJhbnNsYXRlWDphLHRyYW5zbGF0ZVk6aH0pfSxpbnZlcnQ6ZnVuY3Rpb24oYSl7dGhpcy5pbnZlcnRlZD1hO3RoaXMudXBkYXRlVHJhbnNmb3JtKCk7cmV0dXJuIHRoaXN9LHVwZGF0ZVRyYW5zZm9ybTpmdW5jdGlvbigpe3ZhciBhPXRoaXMudHJhbnNsYXRlWHx8MCxoPXRoaXMudHJhbnNsYXRlWXx8MCxkPXRoaXMuc2NhbGVYLHk9dGhpcy5zY2FsZVksYj10aGlzLmludmVydGVkLGM9dGhpcy5yb3RhdGlvbixwPXRoaXMubWF0cml4LGU9dGhpcy5lbGVtZW50O2ImJihhKz10aGlzLndpZHRoLGgrPXRoaXMuaGVpZ2h0KTthPVtcInRyYW5zbGF0ZShcIithK1wiLFwiK2grXCIpXCJdO3oocCkmJmEucHVzaChcIm1hdHJpeChcIitwLmpvaW4oXCIsXCIpK1wiKVwiKTtiP2EucHVzaChcInJvdGF0ZSg5MCkgc2NhbGUoLTEsMSlcIik6YyYmYS5wdXNoKFwicm90YXRlKFwiK2MrXCIgXCIrRCh0aGlzLnJvdGF0aW9uT3JpZ2luWCxlLmdldEF0dHJpYnV0ZShcInhcIiksMCkrXCIgXCIrRCh0aGlzLnJvdGF0aW9uT3JpZ2luWSxcbmUuZ2V0QXR0cmlidXRlKFwieVwiKXx8MCkrXCIpXCIpOyh6KGQpfHx6KHkpKSYmYS5wdXNoKFwic2NhbGUoXCIrRChkLDEpK1wiIFwiK0QoeSwxKStcIilcIik7YS5sZW5ndGgmJmUuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsYS5qb2luKFwiIFwiKSl9LHRvRnJvbnQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmVsZW1lbnQ7YS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGEpO3JldHVybiB0aGlzfSxhbGlnbjpmdW5jdGlvbihhLGgsZCl7dmFyIHksYyxLLHAsZT17fTtjPXRoaXMucmVuZGVyZXI7Sz1jLmFsaWduZWRPYmplY3RzO3ZhciBsLG47aWYoYSl7aWYodGhpcy5hbGlnbk9wdGlvbnM9YSx0aGlzLmFsaWduQnlUcmFuc2xhdGU9aCwhZHx8QihkKSl0aGlzLmFsaWduVG89eT1kfHxcInJlbmRlcmVyXCIsYihLLHRoaXMpLEsucHVzaCh0aGlzKSxkPW51bGx9ZWxzZSBhPXRoaXMuYWxpZ25PcHRpb25zLGg9dGhpcy5hbGlnbkJ5VHJhbnNsYXRlLHk9dGhpcy5hbGlnblRvO2Q9RChkLGNbeV0sYyk7eT1hLmFsaWduO1xuYz1hLnZlcnRpY2FsQWxpZ247Sz0oZC54fHwwKSsoYS54fHwwKTtwPShkLnl8fDApKyhhLnl8fDApO1wicmlnaHRcIj09PXk/bD0xOlwiY2VudGVyXCI9PT15JiYobD0yKTtsJiYoSys9KGQud2lkdGgtKGEud2lkdGh8fDApKS9sKTtlW2g/XCJ0cmFuc2xhdGVYXCI6XCJ4XCJdPU1hdGgucm91bmQoSyk7XCJib3R0b21cIj09PWM/bj0xOlwibWlkZGxlXCI9PT1jJiYobj0yKTtuJiYocCs9KGQuaGVpZ2h0LShhLmhlaWdodHx8MCkpL24pO2VbaD9cInRyYW5zbGF0ZVlcIjpcInlcIl09TWF0aC5yb3VuZChwKTt0aGlzW3RoaXMucGxhY2VkP1wiYW5pbWF0ZVwiOlwiYXR0clwiXShlKTt0aGlzLnBsYWNlZD0hMDt0aGlzLmFsaWduQXR0cj1lO3JldHVybiB0aGlzfSxnZXRCQm94OmZ1bmN0aW9uKGEsaCl7dmFyIGQseT10aGlzLnJlbmRlcmVyLGIscD10aGlzLmVsZW1lbnQsSz10aGlzLnN0eWxlcyxsLG49dGhpcy50ZXh0U3RyLEEscj15LmNhY2hlLGY9eS5jYWNoZUtleXMsTTtoPUQoaCx0aGlzLnJvdGF0aW9uKTtiPWgqbTtcbmw9SyYmSy5mb250U2l6ZTt6KG4pJiYoTT1uLnRvU3RyaW5nKCksLTE9PT1NLmluZGV4T2YoXCJcXHgzY1wiKSYmKE09TS5yZXBsYWNlKC9bMC05XS9nLFwiMFwiKSksTSs9W1wiXCIsaHx8MCxsLEsmJksud2lkdGgsSyYmSy50ZXh0T3ZlcmZsb3ddLmpvaW4oKSk7TSYmIWEmJihkPXJbTV0pO2lmKCFkKXtpZihwLm5hbWVzcGFjZVVSST09PXRoaXMuU1ZHX05TfHx5LmZvckV4cG9ydCl7dHJ5eyhBPXRoaXMuZmFrZVRTJiZmdW5jdGlvbihhKXtlKHAucXVlcnlTZWxlY3RvckFsbChcIi5oaWdoY2hhcnRzLXRleHQtb3V0bGluZVwiKSxmdW5jdGlvbihoKXtoLnN0eWxlLmRpc3BsYXk9YX0pfSkmJkEoXCJub25lXCIpLGQ9cC5nZXRCQm94P2Moe30scC5nZXRCQm94KCkpOnt3aWR0aDpwLm9mZnNldFdpZHRoLGhlaWdodDpwLm9mZnNldEhlaWdodH0sQSYmQShcIlwiKX1jYXRjaChUKXt9aWYoIWR8fDA+ZC53aWR0aClkPXt3aWR0aDowLGhlaWdodDowfX1lbHNlIGQ9dGhpcy5odG1sR2V0QkJveCgpO3kuaXNTVkcmJlxuKGE9ZC53aWR0aCx5PWQuaGVpZ2h0LEsmJlwiMTFweFwiPT09Sy5mb250U2l6ZSYmMTc9PT1NYXRoLnJvdW5kKHkpJiYoZC5oZWlnaHQ9eT0xNCksaCYmKGQud2lkdGg9TWF0aC5hYnMoeSpNYXRoLnNpbihiKSkrTWF0aC5hYnMoYSpNYXRoLmNvcyhiKSksZC5oZWlnaHQ9TWF0aC5hYnMoeSpNYXRoLmNvcyhiKSkrTWF0aC5hYnMoYSpNYXRoLnNpbihiKSkpKTtpZihNJiYwPGQuaGVpZ2h0KXtmb3IoOzI1MDxmLmxlbmd0aDspZGVsZXRlIHJbZi5zaGlmdCgpXTtyW01dfHxmLnB1c2goTSk7cltNXT1kfX1yZXR1cm4gZH0sc2hvdzpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5hdHRyKHt2aXNpYmlsaXR5OmE/XCJpbmhlcml0XCI6XCJ2aXNpYmxlXCJ9KX0saGlkZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmF0dHIoe3Zpc2liaWxpdHk6XCJoaWRkZW5cIn0pfSxmYWRlT3V0OmZ1bmN0aW9uKGEpe3ZhciBoPXRoaXM7aC5hbmltYXRlKHtvcGFjaXR5OjB9LHtkdXJhdGlvbjphfHwxNTAsY29tcGxldGU6ZnVuY3Rpb24oKXtoLmF0dHIoe3k6LTk5OTl9KX19KX0sXG5hZGQ6ZnVuY3Rpb24oYSl7dmFyIGg9dGhpcy5yZW5kZXJlcixkPXRoaXMuZWxlbWVudCx5O2EmJih0aGlzLnBhcmVudEdyb3VwPWEpO3RoaXMucGFyZW50SW52ZXJ0ZWQ9YSYmYS5pbnZlcnRlZDt2b2lkIDAhPT10aGlzLnRleHRTdHImJmguYnVpbGRUZXh0KHRoaXMpO3RoaXMuYWRkZWQ9ITA7aWYoIWF8fGEuaGFuZGxlWnx8dGhpcy56SW5kZXgpeT10aGlzLnpJbmRleFNldHRlcigpO3l8fChhP2EuZWxlbWVudDpoLmJveCkuYXBwZW5kQ2hpbGQoZCk7aWYodGhpcy5vbkFkZCl0aGlzLm9uQWRkKCk7cmV0dXJuIHRoaXN9LHNhZmVSZW1vdmVDaGlsZDpmdW5jdGlvbihhKXt2YXIgaD1hLnBhcmVudE5vZGU7aCYmaC5yZW1vdmVDaGlsZChhKX0sZGVzdHJveTpmdW5jdGlvbigpe3ZhciBhPXRoaXMsaD1hLmVsZW1lbnR8fHt9LGQ9YS5yZW5kZXJlci5pc1NWRyYmXCJTUEFOXCI9PT1oLm5vZGVOYW1lJiZhLnBhcmVudEdyb3VwLHk9aC5vd25lclNWR0VsZW1lbnQ7aC5vbmNsaWNrPWgub25tb3VzZW91dD1cbmgub25tb3VzZW92ZXI9aC5vbm1vdXNlbW92ZT1oLnBvaW50PW51bGw7UChhKTthLmNsaXBQYXRoJiZ5JiYoZSh5LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbY2xpcC1wYXRoXSxbQ0xJUC1QQVRIXVwiKSxmdW5jdGlvbihoKXtoLmdldEF0dHJpYnV0ZShcImNsaXAtcGF0aFwiKS5tYXRjaChSZWdFeHAoJ1soXCJdIycrYS5jbGlwUGF0aC5lbGVtZW50LmlkKydbKVwiXScpKSYmaC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGlwLXBhdGhcIil9KSxhLmNsaXBQYXRoPWEuY2xpcFBhdGguZGVzdHJveSgpKTtpZihhLnN0b3BzKXtmb3IoeT0wO3k8YS5zdG9wcy5sZW5ndGg7eSsrKWEuc3RvcHNbeV09YS5zdG9wc1t5XS5kZXN0cm95KCk7YS5zdG9wcz1udWxsfWEuc2FmZVJlbW92ZUNoaWxkKGgpO2ZvcihhLmRlc3Ryb3lTaGFkb3dzKCk7ZCYmZC5kaXYmJjA9PT1kLmRpdi5jaGlsZE5vZGVzLmxlbmd0aDspaD1kLnBhcmVudEdyb3VwLGEuc2FmZVJlbW92ZUNoaWxkKGQuZGl2KSxkZWxldGUgZC5kaXYsZD1oO2EuYWxpZ25UbyYmXG5iKGEucmVuZGVyZXIuYWxpZ25lZE9iamVjdHMsYSk7cChhLGZ1bmN0aW9uKGgsZCl7ZGVsZXRlIGFbZF19KTtyZXR1cm4gbnVsbH0sc2hhZG93OmZ1bmN0aW9uKGEsaCxkKXt2YXIgeT1bXSxiLGMscD10aGlzLmVsZW1lbnQsZSxsLEssbjtpZighYSl0aGlzLmRlc3Ryb3lTaGFkb3dzKCk7ZWxzZSBpZighdGhpcy5zaGFkb3dzKXtsPUQoYS53aWR0aCwzKTtLPShhLm9wYWNpdHl8fC4xNSkvbDtuPXRoaXMucGFyZW50SW52ZXJ0ZWQ/XCIoLTEsLTEpXCI6XCIoXCIrRChhLm9mZnNldFgsMSkrXCIsIFwiK0QoYS5vZmZzZXRZLDEpK1wiKVwiO2ZvcihiPTE7Yjw9bDtiKyspYz1wLmNsb25lTm9kZSgwKSxlPTIqbCsxLTIqYixrKGMse2lzU2hhZG93OlwidHJ1ZVwiLHN0cm9rZTphLmNvbG9yfHxcIiMwMDAwMDBcIixcInN0cm9rZS1vcGFjaXR5XCI6SypiLFwic3Ryb2tlLXdpZHRoXCI6ZSx0cmFuc2Zvcm06XCJ0cmFuc2xhdGVcIituLGZpbGw6XCJub25lXCJ9KSxkJiYoayhjLFwiaGVpZ2h0XCIsTWF0aC5tYXgoayhjLFwiaGVpZ2h0XCIpLVxuZSwwKSksYy5jdXRIZWlnaHQ9ZSksaD9oLmVsZW1lbnQuYXBwZW5kQ2hpbGQoYyk6cC5wYXJlbnROb2RlJiZwLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGMscCkseS5wdXNoKGMpO3RoaXMuc2hhZG93cz15fXJldHVybiB0aGlzfSxkZXN0cm95U2hhZG93czpmdW5jdGlvbigpe2UodGhpcy5zaGFkb3dzfHxbXSxmdW5jdGlvbihhKXt0aGlzLnNhZmVSZW1vdmVDaGlsZChhKX0sdGhpcyk7dGhpcy5zaGFkb3dzPXZvaWQgMH0seEdldHRlcjpmdW5jdGlvbihhKXtcImNpcmNsZVwiPT09dGhpcy5lbGVtZW50Lm5vZGVOYW1lJiYoXCJ4XCI9PT1hP2E9XCJjeFwiOlwieVwiPT09YSYmKGE9XCJjeVwiKSk7cmV0dXJuIHRoaXMuX2RlZmF1bHRHZXR0ZXIoYSl9LF9kZWZhdWx0R2V0dGVyOmZ1bmN0aW9uKGEpe2E9RCh0aGlzW2ErXCJWYWx1ZVwiXSx0aGlzW2FdLHRoaXMuZWxlbWVudD90aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKGEpOm51bGwsMCk7L15bXFwtMC05XFwuXSskLy50ZXN0KGEpJiYoYT1wYXJzZUZsb2F0KGEpKTtcbnJldHVybiBhfSxkU2V0dGVyOmZ1bmN0aW9uKGEsaCxkKXthJiZhLmpvaW4mJihhPWEuam9pbihcIiBcIikpOy8oTmFOfCB7Mn18XiQpLy50ZXN0KGEpJiYoYT1cIk0gMCAwXCIpO3RoaXNbaF0hPT1hJiYoZC5zZXRBdHRyaWJ1dGUoaCxhKSx0aGlzW2hdPWEpfSxkYXNoc3R5bGVTZXR0ZXI6ZnVuY3Rpb24oYSl7dmFyIGQseT10aGlzW1wic3Ryb2tlLXdpZHRoXCJdO1wiaW5oZXJpdFwiPT09eSYmKHk9MSk7aWYoYT1hJiZhLnRvTG93ZXJDYXNlKCkpe2E9YS5yZXBsYWNlKFwic2hvcnRkYXNoZG90ZG90XCIsXCIzLDEsMSwxLDEsMSxcIikucmVwbGFjZShcInNob3J0ZGFzaGRvdFwiLFwiMywxLDEsMVwiKS5yZXBsYWNlKFwic2hvcnRkb3RcIixcIjEsMSxcIikucmVwbGFjZShcInNob3J0ZGFzaFwiLFwiMywxLFwiKS5yZXBsYWNlKFwibG9uZ2Rhc2hcIixcIjgsMyxcIikucmVwbGFjZSgvZG90L2csXCIxLDMsXCIpLnJlcGxhY2UoXCJkYXNoXCIsXCI0LDMsXCIpLnJlcGxhY2UoLywkLyxcIlwiKS5zcGxpdChcIixcIik7Zm9yKGQ9YS5sZW5ndGg7ZC0tOylhW2RdPVxuaChhW2RdKSp5O2E9YS5qb2luKFwiLFwiKS5yZXBsYWNlKC9OYU4vZyxcIm5vbmVcIik7dGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcInN0cm9rZS1kYXNoYXJyYXlcIixhKX19LGFsaWduU2V0dGVyOmZ1bmN0aW9uKGEpe3RoaXMuYWxpZ25WYWx1ZT1hO3RoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0ZXh0LWFuY2hvclwiLHtsZWZ0Olwic3RhcnRcIixjZW50ZXI6XCJtaWRkbGVcIixyaWdodDpcImVuZFwifVthXSl9LG9wYWNpdHlTZXR0ZXI6ZnVuY3Rpb24oYSxoLGQpe3RoaXNbaF09YTtkLnNldEF0dHJpYnV0ZShoLGEpfSx0aXRsZVNldHRlcjpmdW5jdGlvbihhKXt2YXIgaD10aGlzLmVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0aXRsZVwiKVswXTtofHwoaD1mLmNyZWF0ZUVsZW1lbnROUyh0aGlzLlNWR19OUyxcInRpdGxlXCIpLHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChoKSk7aC5maXJzdENoaWxkJiZoLnJlbW92ZUNoaWxkKGguZmlyc3RDaGlsZCk7aC5hcHBlbmRDaGlsZChmLmNyZWF0ZVRleHROb2RlKFN0cmluZyhEKGEpLFxuXCJcIikucmVwbGFjZSgvPFtePl0qPi9nLFwiXCIpKSl9LHRleHRTZXR0ZXI6ZnVuY3Rpb24oYSl7YSE9PXRoaXMudGV4dFN0ciYmKGRlbGV0ZSB0aGlzLmJCb3gsdGhpcy50ZXh0U3RyPWEsdGhpcy5hZGRlZCYmdGhpcy5yZW5kZXJlci5idWlsZFRleHQodGhpcykpfSxmaWxsU2V0dGVyOmZ1bmN0aW9uKGEsaCxkKXtcInN0cmluZ1wiPT09dHlwZW9mIGE/ZC5zZXRBdHRyaWJ1dGUoaCxhKTphJiZ0aGlzLmNvbG9yR3JhZGllbnQoYSxoLGQpfSx2aXNpYmlsaXR5U2V0dGVyOmZ1bmN0aW9uKGEsaCxkKXtcImluaGVyaXRcIj09PWE/ZC5yZW1vdmVBdHRyaWJ1dGUoaCk6dGhpc1toXSE9PWEmJmQuc2V0QXR0cmlidXRlKGgsYSk7dGhpc1toXT1hfSx6SW5kZXhTZXR0ZXI6ZnVuY3Rpb24oYSxkKXt2YXIgeT10aGlzLnJlbmRlcmVyLGI9dGhpcy5wYXJlbnRHcm91cCxjPShifHx5KS5lbGVtZW50fHx5LmJveCxwLGU9dGhpcy5lbGVtZW50LGwsbix5PWM9PT15LmJveDtwPXRoaXMuYWRkZWQ7dmFyIEE7eihhKSYmXG4oZS56SW5kZXg9YSxhPSthLHRoaXNbZF09PT1hJiYocD0hMSksdGhpc1tkXT1hKTtpZihwKXsoYT10aGlzLnpJbmRleCkmJmImJihiLmhhbmRsZVo9ITApO2Q9Yy5jaGlsZE5vZGVzO2ZvcihBPWQubGVuZ3RoLTE7MDw9QSYmIWw7QS0tKWlmKGI9ZFtBXSxwPWIuekluZGV4LG49IXoocCksYiE9PWUpaWYoMD5hJiZuJiYheSYmIUEpYy5pbnNlcnRCZWZvcmUoZSxkW0FdKSxsPSEwO2Vsc2UgaWYoaChwKTw9YXx8biYmKCF6KGEpfHwwPD1hKSljLmluc2VydEJlZm9yZShlLGRbQSsxXXx8bnVsbCksbD0hMDtsfHwoYy5pbnNlcnRCZWZvcmUoZSxkW3k/MzowXXx8bnVsbCksbD0hMCl9cmV0dXJuIGx9LF9kZWZhdWx0U2V0dGVyOmZ1bmN0aW9uKGEsaCxkKXtkLnNldEF0dHJpYnV0ZShoLGEpfX0pO0cucHJvdG90eXBlLnlHZXR0ZXI9Ry5wcm90b3R5cGUueEdldHRlcjtHLnByb3RvdHlwZS50cmFuc2xhdGVYU2V0dGVyPUcucHJvdG90eXBlLnRyYW5zbGF0ZVlTZXR0ZXI9Ry5wcm90b3R5cGUucm90YXRpb25TZXR0ZXI9XG5HLnByb3RvdHlwZS52ZXJ0aWNhbEFsaWduU2V0dGVyPUcucHJvdG90eXBlLnJvdGF0aW9uT3JpZ2luWFNldHRlcj1HLnByb3RvdHlwZS5yb3RhdGlvbk9yaWdpbllTZXR0ZXI9Ry5wcm90b3R5cGUuc2NhbGVYU2V0dGVyPUcucHJvdG90eXBlLnNjYWxlWVNldHRlcj1HLnByb3RvdHlwZS5tYXRyaXhTZXR0ZXI9ZnVuY3Rpb24oYSxoKXt0aGlzW2hdPWE7dGhpcy5kb1RyYW5zZm9ybT0hMH07Ry5wcm90b3R5cGVbXCJzdHJva2Utd2lkdGhTZXR0ZXJcIl09Ry5wcm90b3R5cGUuc3Ryb2tlU2V0dGVyPWZ1bmN0aW9uKGEsaCxkKXt0aGlzW2hdPWE7dGhpcy5zdHJva2UmJnRoaXNbXCJzdHJva2Utd2lkdGhcIl0/KEcucHJvdG90eXBlLmZpbGxTZXR0ZXIuY2FsbCh0aGlzLHRoaXMuc3Ryb2tlLFwic3Ryb2tlXCIsZCksZC5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIix0aGlzW1wic3Ryb2tlLXdpZHRoXCJdKSx0aGlzLmhhc1N0cm9rZT0hMCk6XCJzdHJva2Utd2lkdGhcIj09PWgmJjA9PT1hJiZ0aGlzLmhhc1N0cm9rZSYmXG4oZC5yZW1vdmVBdHRyaWJ1dGUoXCJzdHJva2VcIiksdGhpcy5oYXNTdHJva2U9ITEpfTtFPWEuU1ZHUmVuZGVyZXI9ZnVuY3Rpb24oKXt0aGlzLmluaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtjKEUucHJvdG90eXBlLHtFbGVtZW50OkcsU1ZHX05TOk8saW5pdDpmdW5jdGlvbihhLGgsZCx5LGIsYyl7dmFyIHA7eT10aGlzLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIikuYXR0cih7dmVyc2lvbjpcIjEuMVwiLFwiY2xhc3NcIjpcImhpZ2hjaGFydHMtcm9vdFwifSkuY3NzKHRoaXMuZ2V0U3R5bGUoeSkpO3A9eS5lbGVtZW50O2EuYXBwZW5kQ2hpbGQocCk7ayhhLFwiZGlyXCIsXCJsdHJcIik7LTE9PT1hLmlubmVySFRNTC5pbmRleE9mKFwieG1sbnNcIikmJmsocCxcInhtbG5zXCIsdGhpcy5TVkdfTlMpO3RoaXMuaXNTVkc9ITA7dGhpcy5ib3g9cDt0aGlzLmJveFdyYXBwZXI9eTt0aGlzLmFsaWduZWRPYmplY3RzPVtdO3RoaXMudXJsPSh4fHxKKSYmZi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJhc2VcIikubGVuZ3RoP1xuUi5sb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyMuKj8kLyxcIlwiKS5yZXBsYWNlKC88W14+XSo+L2csXCJcIikucmVwbGFjZSgvKFtcXCgnXFwpXSkvZyxcIlxcXFwkMVwiKS5yZXBsYWNlKC8gL2csXCIlMjBcIik6XCJcIjt0aGlzLmNyZWF0ZUVsZW1lbnQoXCJkZXNjXCIpLmFkZCgpLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZi5jcmVhdGVUZXh0Tm9kZShcIkNyZWF0ZWQgd2l0aCBIaWdoc3RvY2sgNi4wLjRcIikpO3RoaXMuZGVmcz10aGlzLmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIpLmFkZCgpO3RoaXMuYWxsb3dIVE1MPWM7dGhpcy5mb3JFeHBvcnQ9Yjt0aGlzLmdyYWRpZW50cz17fTt0aGlzLmNhY2hlPXt9O3RoaXMuY2FjaGVLZXlzPVtdO3RoaXMuaW1nQ291bnQ9MDt0aGlzLnNldFNpemUoaCxkLCExKTt2YXIgZTt4JiZhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCYmKGg9ZnVuY3Rpb24oKXt0KGEse2xlZnQ6MCx0b3A6MH0pO2U9YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt0KGEse2xlZnQ6TWF0aC5jZWlsKGUubGVmdCktXG5lLmxlZnQrXCJweFwiLHRvcDpNYXRoLmNlaWwoZS50b3ApLWUudG9wK1wicHhcIn0pfSxoKCksdGhpcy51blN1YlBpeGVsRml4PUgoUixcInJlc2l6ZVwiLGgpKX0sZ2V0U3R5bGU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuc3R5bGU9Yyh7Zm9udEZhbWlseTonXCJMdWNpZGEgR3JhbmRlXCIsIFwiTHVjaWRhIFNhbnMgVW5pY29kZVwiLCBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmJyxmb250U2l6ZTpcIjEycHhcIn0sYSl9LHNldFN0eWxlOmZ1bmN0aW9uKGEpe3RoaXMuYm94V3JhcHBlci5jc3ModGhpcy5nZXRTdHlsZShhKSl9LGlzSGlkZGVuOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuYm94V3JhcHBlci5nZXRCQm94KCkud2lkdGh9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmRlZnM7dGhpcy5ib3g9bnVsbDt0aGlzLmJveFdyYXBwZXI9dGhpcy5ib3hXcmFwcGVyLmRlc3Ryb3koKTtnKHRoaXMuZ3JhZGllbnRzfHx7fSk7dGhpcy5ncmFkaWVudHM9bnVsbDthJiYodGhpcy5kZWZzPWEuZGVzdHJveSgpKTtcbnRoaXMudW5TdWJQaXhlbEZpeCYmdGhpcy51blN1YlBpeGVsRml4KCk7cmV0dXJuIHRoaXMuYWxpZ25lZE9iamVjdHM9bnVsbH0sY3JlYXRlRWxlbWVudDpmdW5jdGlvbihhKXt2YXIgaD1uZXcgdGhpcy5FbGVtZW50O2guaW5pdCh0aGlzLGEpO3JldHVybiBofSxkcmF3OmQsZ2V0UmFkaWFsQXR0cjpmdW5jdGlvbihhLGgpe3JldHVybntjeDphWzBdLWFbMl0vMitoLmN4KmFbMl0sY3k6YVsxXS1hWzJdLzIraC5jeSphWzJdLHI6aC5yKmFbMl19fSxnZXRTcGFuV2lkdGg6ZnVuY3Rpb24oYSxoKXt2YXIgZD1hLmdldEJCb3goITApLndpZHRoOyFNJiZ0aGlzLmZvckV4cG9ydCYmKGQ9dGhpcy5tZWFzdXJlU3BhbldpZHRoKGguZmlyc3RDaGlsZC5kYXRhLGEuc3R5bGVzKSk7cmV0dXJuIGR9LGFwcGx5RWxsaXBzaXM6ZnVuY3Rpb24oYSxoLGQseSl7dmFyIGI9YS5yb3RhdGlvbixjPWQscCxlPTAsbD1kLmxlbmd0aCxuPWZ1bmN0aW9uKGEpe2gucmVtb3ZlQ2hpbGQoaC5maXJzdENoaWxkKTtcbmEmJmguYXBwZW5kQ2hpbGQoZi5jcmVhdGVUZXh0Tm9kZShhKSl9LEE7YS5yb3RhdGlvbj0wO2M9dGhpcy5nZXRTcGFuV2lkdGgoYSxoKTtpZihBPWM+eSl7Zm9yKDtlPD1sOylwPU1hdGguY2VpbCgoZStsKS8yKSxjPWQuc3Vic3RyaW5nKDAscCkrXCJcXHUyMDI2XCIsbihjKSxjPXRoaXMuZ2V0U3BhbldpZHRoKGEsaCksZT09PWw/ZT1sKzE6Yz55P2w9cC0xOmU9cDswPT09bCYmbihcIlwiKX1hLnJvdGF0aW9uPWI7cmV0dXJuIEF9LGVzY2FwZXM6e1wiXFx4MjZcIjpcIlxceDI2YW1wO1wiLFwiXFx4M2NcIjpcIlxceDI2bHQ7XCIsXCJcXHgzZVwiOlwiXFx4MjZndDtcIixcIidcIjpcIlxceDI2IzM5O1wiLCdcIic6XCJcXHgyNnF1b3Q7XCJ9LGJ1aWxkVGV4dDpmdW5jdGlvbihhKXt2YXIgZD1hLmVsZW1lbnQseT10aGlzLGI9eS5mb3JFeHBvcnQsYz1EKGEudGV4dFN0cixcIlwiKS50b1N0cmluZygpLGw9LTEhPT1jLmluZGV4T2YoXCJcXHgzY1wiKSxuPWQuY2hpbGROb2RlcyxBLEssQyxnLEI9ayhkLFwieFwiKSx4PWEuc3R5bGVzLG09YS50ZXh0V2lkdGgsXG5OPXgmJngubGluZUhlaWdodCxQPXgmJngudGV4dE91dGxpbmUsRj14JiZcImVsbGlwc2lzXCI9PT14LnRleHRPdmVyZmxvdyxJPXgmJlwibm93cmFwXCI9PT14LndoaXRlU3BhY2UsdT14JiZ4LmZvbnRTaXplLFIscSxKPW4ubGVuZ3RoLHg9bSYmIWEuYWRkZWQmJnRoaXMuYm94LHo9ZnVuY3Rpb24oYSl7dmFyIGI7Yj0vKHB4fGVtKSQvLnRlc3QoYSYmYS5zdHlsZS5mb250U2l6ZSk/YS5zdHlsZS5mb250U2l6ZTp1fHx5LnN0eWxlLmZvbnRTaXplfHwxMjtyZXR1cm4gTj9oKE4pOnkuZm9udE1ldHJpY3MoYixhLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpP2E6ZCkuaH0sdz1mdW5jdGlvbihhKXtwKHkuZXNjYXBlcyxmdW5jdGlvbihoLGQpe2E9YS5yZXBsYWNlKG5ldyBSZWdFeHAoaCxcImdcIiksZCl9KTtyZXR1cm4gYX07Uj1bYyxGLEksTixQLHUsbV0uam9pbigpO2lmKFIhPT1hLnRleHRDYWNoZSl7Zm9yKGEudGV4dENhY2hlPVI7Si0tOylkLnJlbW92ZUNoaWxkKG5bSl0pO2x8fFB8fEZ8fG18fFxuLTEhPT1jLmluZGV4T2YoXCIgXCIpPyhBPS88LipjbGFzcz1cIihbXlwiXSspXCIuKj4vLEs9LzwuKnN0eWxlPVwiKFteXCJdKylcIi4qPi8sQz0vPC4qaHJlZj1cIihbXlwiXSspXCIuKj4vLHgmJnguYXBwZW5kQ2hpbGQoZCksYz1sP2MucmVwbGFjZSgvPChifHN0cm9uZyk+L2csJ1xceDNjc3BhbiBzdHlsZVxceDNkXCJmb250LXdlaWdodDpib2xkXCJcXHgzZScpLnJlcGxhY2UoLzwoaXxlbSk+L2csJ1xceDNjc3BhbiBzdHlsZVxceDNkXCJmb250LXN0eWxlOml0YWxpY1wiXFx4M2UnKS5yZXBsYWNlKC88YS9nLFwiXFx4M2NzcGFuXCIpLnJlcGxhY2UoLzxcXC8oYnxzdHJvbmd8aXxlbXxhKT4vZyxcIlxceDNjL3NwYW5cXHgzZVwiKS5zcGxpdCgvPGJyLio/Pi9nKTpbY10sYz1yKGMsZnVuY3Rpb24oYSl7cmV0dXJuXCJcIiE9PWF9KSxlKGMsZnVuY3Rpb24oaCxjKXt2YXIgcCxsPTA7aD1oLnJlcGxhY2UoL15cXHMrfFxccyskL2csXCJcIikucmVwbGFjZSgvPHNwYW4vZyxcInx8fFxceDNjc3BhblwiKS5yZXBsYWNlKC88XFwvc3Bhbj4vZyxcIlxceDNjL3NwYW5cXHgzZXx8fFwiKTtcbnA9aC5zcGxpdChcInx8fFwiKTtlKHAsZnVuY3Rpb24oaCl7aWYoXCJcIiE9PWh8fDE9PT1wLmxlbmd0aCl7dmFyIGU9e30sbj1mLmNyZWF0ZUVsZW1lbnROUyh5LlNWR19OUyxcInRzcGFuXCIpLHIsRDtBLnRlc3QoaCkmJihyPWgubWF0Y2goQSlbMV0sayhuLFwiY2xhc3NcIixyKSk7Sy50ZXN0KGgpJiYoRD1oLm1hdGNoKEspWzFdLnJlcGxhY2UoLyg7fCB8Xiljb2xvcihbIDpdKS8sXCIkMWZpbGwkMlwiKSxrKG4sXCJzdHlsZVwiLEQpKTtDLnRlc3QoaCkmJiFiJiYoayhuLFwib25jbGlja1wiLCdsb2NhdGlvbi5ocmVmXFx4M2RcIicraC5tYXRjaChDKVsxXSsnXCInKSxrKG4sXCJjbGFzc1wiLFwiaGlnaGNoYXJ0cy1hbmNob3JcIiksdChuLHtjdXJzb3I6XCJwb2ludGVyXCJ9KSk7aD13KGgucmVwbGFjZSgvPFthLXpBLVpcXC9dKC58XFxuKSo/Pi9nLFwiXCIpfHxcIiBcIik7aWYoXCIgXCIhPT1oKXtuLmFwcGVuZENoaWxkKGYuY3JlYXRlVGV4dE5vZGUoaCkpO2w/ZS5keD0wOmMmJm51bGwhPT1CJiYoZS54PUIpO2sobixlKTtkLmFwcGVuZENoaWxkKG4pO1xuIWwmJnEmJighTSYmYiYmdChuLHtkaXNwbGF5OlwiYmxvY2tcIn0pLGsobixcImR5XCIseihuKSkpO2lmKG0pe2U9aC5yZXBsYWNlKC8oW15cXF5dKS0vZyxcIiQxLSBcIikuc3BsaXQoXCIgXCIpO3I9MTxwLmxlbmd0aHx8Y3x8MTxlLmxlbmd0aCYmIUk7dmFyIHg9W10sTixQPXoobiksUz1hLnJvdGF0aW9uO2ZvcihGJiYoZz15LmFwcGx5RWxsaXBzaXMoYSxuLGgsbSkpOyFGJiZyJiYoZS5sZW5ndGh8fHgubGVuZ3RoKTspYS5yb3RhdGlvbj0wLE49eS5nZXRTcGFuV2lkdGgoYSxuKSxoPU4+bSx2b2lkIDA9PT1nJiYoZz1oKSxoJiYxIT09ZS5sZW5ndGg/KG4ucmVtb3ZlQ2hpbGQobi5maXJzdENoaWxkKSx4LnVuc2hpZnQoZS5wb3AoKSkpOihlPXgseD1bXSxlLmxlbmd0aCYmIUkmJihuPWYuY3JlYXRlRWxlbWVudE5TKE8sXCJ0c3BhblwiKSxrKG4se2R5OlAseDpCfSksRCYmayhuLFwic3R5bGVcIixEKSxkLmFwcGVuZENoaWxkKG4pKSxOPm0mJihtPU4pKSxlLmxlbmd0aCYmbi5hcHBlbmRDaGlsZChmLmNyZWF0ZVRleHROb2RlKGUuam9pbihcIiBcIikucmVwbGFjZSgvLSAvZyxcblwiLVwiKSkpO2Eucm90YXRpb249U31sKyt9fX0pO3E9cXx8ZC5jaGlsZE5vZGVzLmxlbmd0aH0pLGcmJmEuYXR0cihcInRpdGxlXCIsYS50ZXh0U3RyKSx4JiZ4LnJlbW92ZUNoaWxkKGQpLFAmJmEuYXBwbHlUZXh0T3V0bGluZSYmYS5hcHBseVRleHRPdXRsaW5lKFApKTpkLmFwcGVuZENoaWxkKGYuY3JlYXRlVGV4dE5vZGUodyhjKSkpfX0sZ2V0Q29udHJhc3Q6ZnVuY3Rpb24oYSl7YT13KGEpLnJnYmE7cmV0dXJuIDUxMDxhWzBdK2FbMV0rYVsyXT9cIiMwMDAwMDBcIjpcIiNGRkZGRkZcIn0sYnV0dG9uOmZ1bmN0aW9uKGEsaCxkLHksYixwLGUsbCxuKXt2YXIgcj10aGlzLmxhYmVsKGEsaCxkLG4sbnVsbCxudWxsLG51bGwsbnVsbCxcImJ1dHRvblwiKSxmPTA7ci5hdHRyKEEoe3BhZGRpbmc6OCxyOjJ9LGIpKTt2YXIgTSxDLEQsSztiPUEoe2ZpbGw6XCIjZjdmN2Y3XCIsc3Ryb2tlOlwiI2NjY2NjY1wiLFwic3Ryb2tlLXdpZHRoXCI6MSxzdHlsZTp7Y29sb3I6XCIjMzMzMzMzXCIsY3Vyc29yOlwicG9pbnRlclwiLFxuZm9udFdlaWdodDpcIm5vcm1hbFwifX0sYik7TT1iLnN0eWxlO2RlbGV0ZSBiLnN0eWxlO3A9QShiLHtmaWxsOlwiI2U2ZTZlNlwifSxwKTtDPXAuc3R5bGU7ZGVsZXRlIHAuc3R5bGU7ZT1BKGIse2ZpbGw6XCIjZTZlYmY1XCIsc3R5bGU6e2NvbG9yOlwiIzAwMDAwMFwiLGZvbnRXZWlnaHQ6XCJib2xkXCJ9fSxlKTtEPWUuc3R5bGU7ZGVsZXRlIGUuc3R5bGU7bD1BKGIse3N0eWxlOntjb2xvcjpcIiNjY2NjY2NcIn19LGwpO0s9bC5zdHlsZTtkZWxldGUgbC5zdHlsZTtIKHIuZWxlbWVudCxGP1wibW91c2VvdmVyXCI6XCJtb3VzZWVudGVyXCIsZnVuY3Rpb24oKXszIT09ZiYmci5zZXRTdGF0ZSgxKX0pO0goci5lbGVtZW50LEY/XCJtb3VzZW91dFwiOlwibW91c2VsZWF2ZVwiLGZ1bmN0aW9uKCl7MyE9PWYmJnIuc2V0U3RhdGUoZil9KTtyLnNldFN0YXRlPWZ1bmN0aW9uKGEpezEhPT1hJiYoci5zdGF0ZT1mPWEpO3IucmVtb3ZlQ2xhc3MoL2hpZ2hjaGFydHMtYnV0dG9uLShub3JtYWx8aG92ZXJ8cHJlc3NlZHxkaXNhYmxlZCkvKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtYnV0dG9uLVwiK1xuW1wibm9ybWFsXCIsXCJob3ZlclwiLFwicHJlc3NlZFwiLFwiZGlzYWJsZWRcIl1bYXx8MF0pO3IuYXR0cihbYixwLGUsbF1bYXx8MF0pLmNzcyhbTSxDLEQsS11bYXx8MF0pfTtyLmF0dHIoYikuY3NzKGMoe2N1cnNvcjpcImRlZmF1bHRcIn0sTSkpO3JldHVybiByLm9uKFwiY2xpY2tcIixmdW5jdGlvbihhKXszIT09ZiYmeS5jYWxsKHIsYSl9KX0sY3Jpc3BMaW5lOmZ1bmN0aW9uKGEsaCl7YVsxXT09PWFbNF0mJihhWzFdPWFbNF09TWF0aC5yb3VuZChhWzFdKS1oJTIvMik7YVsyXT09PWFbNV0mJihhWzJdPWFbNV09TWF0aC5yb3VuZChhWzJdKStoJTIvMik7cmV0dXJuIGF9LHBhdGg6ZnVuY3Rpb24oYSl7dmFyIGg9e2ZpbGw6XCJub25lXCJ9O0koYSk/aC5kPWE6bihhKSYmYyhoLGEpO3JldHVybiB0aGlzLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIpLmF0dHIoaCl9LGNpcmNsZTpmdW5jdGlvbihhLGgsZCl7YT1uKGEpP2E6e3g6YSx5OmgscjpkfTtoPXRoaXMuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiKTtoLnhTZXR0ZXI9XG5oLnlTZXR0ZXI9ZnVuY3Rpb24oYSxoLGQpe2Quc2V0QXR0cmlidXRlKFwiY1wiK2gsYSl9O3JldHVybiBoLmF0dHIoYSl9LGFyYzpmdW5jdGlvbihhLGgsZCx5LGIsYyl7bihhKT8oeT1hLGg9eS55LGQ9eS5yLGE9eS54KTp5PXtpbm5lclI6eSxzdGFydDpiLGVuZDpjfTthPXRoaXMuc3ltYm9sKFwiYXJjXCIsYSxoLGQsZCx5KTthLnI9ZDtyZXR1cm4gYX0scmVjdDpmdW5jdGlvbihhLGgsZCx5LGIsYyl7Yj1uKGEpP2EucjpiO3ZhciBwPXRoaXMuY3JlYXRlRWxlbWVudChcInJlY3RcIik7YT1uKGEpP2E6dm9pZCAwPT09YT97fTp7eDphLHk6aCx3aWR0aDpNYXRoLm1heChkLDApLGhlaWdodDpNYXRoLm1heCh5LDApfTt2b2lkIDAhPT1jJiYoYS5zdHJva2VXaWR0aD1jLGE9cC5jcmlzcChhKSk7YS5maWxsPVwibm9uZVwiO2ImJihhLnI9Yik7cC5yU2V0dGVyPWZ1bmN0aW9uKGEsaCxkKXtrKGQse3J4OmEscnk6YX0pfTtyZXR1cm4gcC5hdHRyKGEpfSxzZXRTaXplOmZ1bmN0aW9uKGEsaCxkKXt2YXIgeT1cbnRoaXMuYWxpZ25lZE9iamVjdHMsYj15Lmxlbmd0aDt0aGlzLndpZHRoPWE7dGhpcy5oZWlnaHQ9aDtmb3IodGhpcy5ib3hXcmFwcGVyLmFuaW1hdGUoe3dpZHRoOmEsaGVpZ2h0Omh9LHtzdGVwOmZ1bmN0aW9uKCl7dGhpcy5hdHRyKHt2aWV3Qm94OlwiMCAwIFwiK3RoaXMuYXR0cihcIndpZHRoXCIpK1wiIFwiK3RoaXMuYXR0cihcImhlaWdodFwiKX0pfSxkdXJhdGlvbjpEKGQsITApP3ZvaWQgMDowfSk7Yi0tOyl5W2JdLmFsaWduKCl9LGc6ZnVuY3Rpb24oYSl7dmFyIGg9dGhpcy5jcmVhdGVFbGVtZW50KFwiZ1wiKTtyZXR1cm4gYT9oLmF0dHIoe1wiY2xhc3NcIjpcImhpZ2hjaGFydHMtXCIrYX0pOmh9LGltYWdlOmZ1bmN0aW9uKGEsaCxkLHksYil7dmFyIHA9e3ByZXNlcnZlQXNwZWN0UmF0aW86XCJub25lXCJ9OzE8YXJndW1lbnRzLmxlbmd0aCYmYyhwLHt4OmgseTpkLHdpZHRoOnksaGVpZ2h0OmJ9KTtwPXRoaXMuY3JlYXRlRWxlbWVudChcImltYWdlXCIpLmF0dHIocCk7cC5lbGVtZW50LnNldEF0dHJpYnV0ZU5TP1xucC5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFwiaHJlZlwiLGEpOnAuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJoYy1zdmctaHJlZlwiLGEpO3JldHVybiBwfSxzeW1ib2w6ZnVuY3Rpb24oYSxoLGQseSxiLHApe3ZhciBsPXRoaXMsbixBPS9edXJsXFwoKC4qPylcXCkkLyxyPUEudGVzdChhKSxNPSFyJiYodGhpcy5zeW1ib2xzW2FdP2E6XCJjaXJjbGVcIiksQz1NJiZ0aGlzLnN5bWJvbHNbTV0sZz16KGgpJiZDJiZDLmNhbGwodGhpcy5zeW1ib2xzLE1hdGgucm91bmQoaCksTWF0aC5yb3VuZChkKSx5LGIscCkseCxCO0M/KG49dGhpcy5wYXRoKGcpLG4uYXR0cihcImZpbGxcIixcIm5vbmVcIiksYyhuLHtzeW1ib2xOYW1lOk0seDpoLHk6ZCx3aWR0aDp5LGhlaWdodDpifSkscCYmYyhuLHApKTpyJiYoeD1hLm1hdGNoKEEpWzFdLG49dGhpcy5pbWFnZSh4KSxuLmltZ3dpZHRoPUQoTlt4XSYmTlt4XS53aWR0aCxwJiZwLndpZHRoKSxuLmltZ2hlaWdodD1cbkQoTlt4XSYmTlt4XS5oZWlnaHQscCYmcC5oZWlnaHQpLEI9ZnVuY3Rpb24oKXtuLmF0dHIoe3dpZHRoOm4ud2lkdGgsaGVpZ2h0Om4uaGVpZ2h0fSl9LGUoW1wid2lkdGhcIixcImhlaWdodFwiXSxmdW5jdGlvbihhKXtuW2ErXCJTZXR0ZXJcIl09ZnVuY3Rpb24oYSxoKXt2YXIgZD17fSx5PXRoaXNbXCJpbWdcIitoXSxiPVwid2lkdGhcIj09PWg/XCJ0cmFuc2xhdGVYXCI6XCJ0cmFuc2xhdGVZXCI7dGhpc1toXT1hO3ooeSkmJih0aGlzLmVsZW1lbnQmJnRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoaCx5KSx0aGlzLmFsaWduQnlUcmFuc2xhdGV8fChkW2JdPSgodGhpc1toXXx8MCkteSkvMix0aGlzLmF0dHIoZCkpKX19KSx6KGgpJiZuLmF0dHIoe3g6aCx5OmR9KSxuLmlzSW1nPSEwLHoobi5pbWd3aWR0aCkmJnoobi5pbWdoZWlnaHQpP0IoKToobi5hdHRyKHt3aWR0aDowLGhlaWdodDowfSksdShcImltZ1wiLHtvbmxvYWQ6ZnVuY3Rpb24oKXt2YXIgYT1xW2wuY2hhcnRJbmRleF07MD09PXRoaXMud2lkdGgmJlxuKHQodGhpcyx7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpcIi05OTllbVwifSksZi5ib2R5LmFwcGVuZENoaWxkKHRoaXMpKTtOW3hdPXt3aWR0aDp0aGlzLndpZHRoLGhlaWdodDp0aGlzLmhlaWdodH07bi5pbWd3aWR0aD10aGlzLndpZHRoO24uaW1naGVpZ2h0PXRoaXMuaGVpZ2h0O24uZWxlbWVudCYmQigpO3RoaXMucGFyZW50Tm9kZSYmdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO2wuaW1nQ291bnQtLTtpZighbC5pbWdDb3VudCYmYSYmYS5vbmxvYWQpYS5vbmxvYWQoKX0sc3JjOnh9KSx0aGlzLmltZ0NvdW50KyspKTtyZXR1cm4gbn0sc3ltYm9sczp7Y2lyY2xlOmZ1bmN0aW9uKGEsaCxkLHkpe3JldHVybiB0aGlzLmFyYyhhK2QvMixoK3kvMixkLzIseS8yLHtzdGFydDowLGVuZDoyKk1hdGguUEksb3BlbjohMX0pfSxzcXVhcmU6ZnVuY3Rpb24oYSxoLGQseSl7cmV0dXJuW1wiTVwiLGEsaCxcIkxcIixhK2QsaCxhK2QsaCt5LGEsaCt5LFwiWlwiXX0sdHJpYW5nbGU6ZnVuY3Rpb24oYSxcbmgsZCx5KXtyZXR1cm5bXCJNXCIsYStkLzIsaCxcIkxcIixhK2QsaCt5LGEsaCt5LFwiWlwiXX0sXCJ0cmlhbmdsZS1kb3duXCI6ZnVuY3Rpb24oYSxoLGQseSl7cmV0dXJuW1wiTVwiLGEsaCxcIkxcIixhK2QsaCxhK2QvMixoK3ksXCJaXCJdfSxkaWFtb25kOmZ1bmN0aW9uKGEsaCxkLHkpe3JldHVybltcIk1cIixhK2QvMixoLFwiTFwiLGErZCxoK3kvMixhK2QvMixoK3ksYSxoK3kvMixcIlpcIl19LGFyYzpmdW5jdGlvbihhLGgsZCx5LGIpe3ZhciBwPWIuc3RhcnQsYz1iLnJ8fGQsZT1iLnJ8fHl8fGQsbj1iLmVuZC0uMDAxO2Q9Yi5pbm5lclI7eT1EKGIub3BlbiwuMDAxPk1hdGguYWJzKGIuZW5kLWIuc3RhcnQtMipNYXRoLlBJKSk7dmFyIGw9TWF0aC5jb3MocCksQT1NYXRoLnNpbihwKSxyPU1hdGguY29zKG4pLG49TWF0aC5zaW4obik7Yj0uMDAxPmIuZW5kLXAtTWF0aC5QST8wOjE7Yz1bXCJNXCIsYStjKmwsaCtlKkEsXCJBXCIsYyxlLDAsYiwxLGErYypyLGgrZSpuXTt6KGQpJiZjLnB1c2goeT9cIk1cIjpcIkxcIixhK2QqXG5yLGgrZCpuLFwiQVwiLGQsZCwwLGIsMCxhK2QqbCxoK2QqQSk7Yy5wdXNoKHk/XCJcIjpcIlpcIik7cmV0dXJuIGN9LGNhbGxvdXQ6ZnVuY3Rpb24oYSxoLGQseSxiKXt2YXIgcD1NYXRoLm1pbihiJiZiLnJ8fDAsZCx5KSxjPXArNixlPWImJmIuYW5jaG9yWDtiPWImJmIuYW5jaG9yWTt2YXIgbjtuPVtcIk1cIixhK3AsaCxcIkxcIixhK2QtcCxoLFwiQ1wiLGErZCxoLGErZCxoLGErZCxoK3AsXCJMXCIsYStkLGgreS1wLFwiQ1wiLGErZCxoK3ksYStkLGgreSxhK2QtcCxoK3ksXCJMXCIsYStwLGgreSxcIkNcIixhLGgreSxhLGgreSxhLGgreS1wLFwiTFwiLGEsaCtwLFwiQ1wiLGEsaCxhLGgsYStwLGhdO2UmJmU+ZD9iPmgrYyYmYjxoK3ktYz9uLnNwbGljZSgxMywzLFwiTFwiLGErZCxiLTYsYStkKzYsYixhK2QsYis2LGErZCxoK3ktcCk6bi5zcGxpY2UoMTMsMyxcIkxcIixhK2QseS8yLGUsYixhK2QseS8yLGErZCxoK3ktcCk6ZSYmMD5lP2I+aCtjJiZiPGgreS1jP24uc3BsaWNlKDMzLDMsXCJMXCIsYSxiKzYsYS02LGIsYSxiLTYsXG5hLGgrcCk6bi5zcGxpY2UoMzMsMyxcIkxcIixhLHkvMixlLGIsYSx5LzIsYSxoK3ApOmImJmI+eSYmZT5hK2MmJmU8YStkLWM/bi5zcGxpY2UoMjMsMyxcIkxcIixlKzYsaCt5LGUsaCt5KzYsZS02LGgreSxhK3AsaCt5KTpiJiYwPmImJmU+YStjJiZlPGErZC1jJiZuLnNwbGljZSgzLDMsXCJMXCIsZS02LGgsZSxoLTYsZSs2LGgsZC1wLGgpO3JldHVybiBufX0sY2xpcFJlY3Q6ZnVuY3Rpb24oaCxkLHksYil7dmFyIHA9YS51bmlxdWVLZXkoKSxjPXRoaXMuY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIpLmF0dHIoe2lkOnB9KS5hZGQodGhpcy5kZWZzKTtoPXRoaXMucmVjdChoLGQseSxiLDApLmFkZChjKTtoLmlkPXA7aC5jbGlwUGF0aD1jO2guY291bnQ9MDtyZXR1cm4gaH0sdGV4dDpmdW5jdGlvbihhLGgsZCx5KXt2YXIgYj17fTtpZih5JiYodGhpcy5hbGxvd0hUTUx8fCF0aGlzLmZvckV4cG9ydCkpcmV0dXJuIHRoaXMuaHRtbChhLGgsZCk7Yi54PU1hdGgucm91bmQoaHx8MCk7ZCYmKGIueT1cbk1hdGgucm91bmQoZCkpO2lmKGF8fDA9PT1hKWIudGV4dD1hO2E9dGhpcy5jcmVhdGVFbGVtZW50KFwidGV4dFwiKS5hdHRyKGIpO3l8fChhLnhTZXR0ZXI9ZnVuY3Rpb24oYSxoLGQpe3ZhciB5PWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0c3BhblwiKSxiLHA9ZC5nZXRBdHRyaWJ1dGUoaCksYztmb3IoYz0wO2M8eS5sZW5ndGg7YysrKWI9eVtjXSxiLmdldEF0dHJpYnV0ZShoKT09PXAmJmIuc2V0QXR0cmlidXRlKGgsYSk7ZC5zZXRBdHRyaWJ1dGUoaCxhKX0pO3JldHVybiBhfSxmb250TWV0cmljczpmdW5jdGlvbihhLGQpe2E9YXx8ZCYmZC5zdHlsZSYmZC5zdHlsZS5mb250U2l6ZXx8dGhpcy5zdHlsZSYmdGhpcy5zdHlsZS5mb250U2l6ZTthPS9weC8udGVzdChhKT9oKGEpOi9lbS8udGVzdChhKT9wYXJzZUZsb2F0KGEpKihkP3RoaXMuZm9udE1ldHJpY3MobnVsbCxkLnBhcmVudE5vZGUpLmY6MTYpOjEyO2Q9MjQ+YT9hKzM6TWF0aC5yb3VuZCgxLjIqYSk7cmV0dXJue2g6ZCxiOk1hdGgucm91bmQoLjgqXG5kKSxmOmF9fSxyb3RDb3JyOmZ1bmN0aW9uKGEsaCxkKXt2YXIgeT1hO2gmJmQmJih5PU1hdGgubWF4KHkqTWF0aC5jb3MoaCptKSw0KSk7cmV0dXJue3g6LWEvMypNYXRoLnNpbihoKm0pLHk6eX19LGxhYmVsOmZ1bmN0aW9uKGgsZCxiLHAsbixsLHIsZixNKXt2YXIgQz10aGlzLEQ9Qy5nKFwiYnV0dG9uXCIhPT1NJiZcImxhYmVsXCIpLGc9RC50ZXh0PUMudGV4dChcIlwiLDAsMCxyKS5hdHRyKHt6SW5kZXg6MX0pLHgsQixtPTAsTj0zLFA9MCxGLHQsSSx1LEssTz17fSxSLGsscT0vXnVybFxcKCguKj8pXFwpJC8udGVzdChwKSxKPXEsdyxTLHYsVztNJiZELmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIitNKTtKPXE7dz1mdW5jdGlvbigpe3JldHVybihSfHwwKSUyLzJ9O1M9ZnVuY3Rpb24oKXt2YXIgYT1nLmVsZW1lbnQuc3R5bGUsaD17fTtCPSh2b2lkIDA9PT1GfHx2b2lkIDA9PT10fHxLKSYmeihnLnRleHRTdHIpJiZnLmdldEJCb3goKTtELndpZHRoPShGfHxCLndpZHRofHwwKSsyKk4rUDtELmhlaWdodD1cbih0fHxCLmhlaWdodHx8MCkrMipOO2s9TitDLmZvbnRNZXRyaWNzKGEmJmEuZm9udFNpemUsZykuYjtKJiYoeHx8KEQuYm94PXg9Qy5zeW1ib2xzW3BdfHxxP0Muc3ltYm9sKHApOkMucmVjdCgpLHguYWRkQ2xhc3MoKFwiYnV0dG9uXCI9PT1NP1wiXCI6XCJoaWdoY2hhcnRzLWxhYmVsLWJveFwiKSsoTT9cIiBoaWdoY2hhcnRzLVwiK00rXCItYm94XCI6XCJcIikpLHguYWRkKEQpLGE9dygpLGgueD1hLGgueT0oZj8tazowKSthKSxoLndpZHRoPU1hdGgucm91bmQoRC53aWR0aCksaC5oZWlnaHQ9TWF0aC5yb3VuZChELmhlaWdodCkseC5hdHRyKGMoaCxPKSksTz17fSl9O3Y9ZnVuY3Rpb24oKXt2YXIgYT1QK04saDtoPWY/MDprO3ooRikmJkImJihcImNlbnRlclwiPT09S3x8XCJyaWdodFwiPT09SykmJihhKz17Y2VudGVyOi41LHJpZ2h0OjF9W0tdKihGLUIud2lkdGgpKTtpZihhIT09Zy54fHxoIT09Zy55KWcuYXR0cihcInhcIixhKSx2b2lkIDAhPT1oJiZnLmF0dHIoXCJ5XCIsaCk7Zy54PWE7Zy55PWh9O1c9ZnVuY3Rpb24oYSxcbmgpe3g/eC5hdHRyKGEsaCk6T1thXT1ofTtELm9uQWRkPWZ1bmN0aW9uKCl7Zy5hZGQoRCk7RC5hdHRyKHt0ZXh0Omh8fDA9PT1oP2g6XCJcIix4OmQseTpifSk7eCYmeihuKSYmRC5hdHRyKHthbmNob3JYOm4sYW5jaG9yWTpsfSl9O0Qud2lkdGhTZXR0ZXI9ZnVuY3Rpb24oaCl7Rj1hLmlzTnVtYmVyKGgpP2g6bnVsbH07RC5oZWlnaHRTZXR0ZXI9ZnVuY3Rpb24oYSl7dD1hfTtEW1widGV4dC1hbGlnblNldHRlclwiXT1mdW5jdGlvbihhKXtLPWF9O0QucGFkZGluZ1NldHRlcj1mdW5jdGlvbihhKXt6KGEpJiZhIT09TiYmKE49RC5wYWRkaW5nPWEsdigpKX07RC5wYWRkaW5nTGVmdFNldHRlcj1mdW5jdGlvbihhKXt6KGEpJiZhIT09UCYmKFA9YSx2KCkpfTtELmFsaWduU2V0dGVyPWZ1bmN0aW9uKGEpe2E9e2xlZnQ6MCxjZW50ZXI6LjUscmlnaHQ6MX1bYV07YSE9PW0mJihtPWEsQiYmRC5hdHRyKHt4Okl9KSl9O0QudGV4dFNldHRlcj1mdW5jdGlvbihhKXt2b2lkIDAhPT1hJiZnLnRleHRTZXR0ZXIoYSk7XG5TKCk7digpfTtEW1wic3Ryb2tlLXdpZHRoU2V0dGVyXCJdPWZ1bmN0aW9uKGEsaCl7YSYmKEo9ITApO1I9dGhpc1tcInN0cm9rZS13aWR0aFwiXT1hO1coaCxhKX07RC5zdHJva2VTZXR0ZXI9RC5maWxsU2V0dGVyPUQuclNldHRlcj1mdW5jdGlvbihhLGgpe1wiclwiIT09aCYmKFwiZmlsbFwiPT09aCYmYSYmKEo9ITApLERbaF09YSk7VyhoLGEpfTtELmFuY2hvclhTZXR0ZXI9ZnVuY3Rpb24oYSxoKXtuPUQuYW5jaG9yWD1hO1coaCxNYXRoLnJvdW5kKGEpLXcoKS1JKX07RC5hbmNob3JZU2V0dGVyPWZ1bmN0aW9uKGEsaCl7bD1ELmFuY2hvclk9YTtXKGgsYS11KX07RC54U2V0dGVyPWZ1bmN0aW9uKGEpe0QueD1hO20mJihhLT1tKigoRnx8Qi53aWR0aCkrMipOKSk7ST1NYXRoLnJvdW5kKGEpO0QuYXR0cihcInRyYW5zbGF0ZVhcIixJKX07RC55U2V0dGVyPWZ1bmN0aW9uKGEpe3U9RC55PU1hdGgucm91bmQoYSk7RC5hdHRyKFwidHJhbnNsYXRlWVwiLHUpfTt2YXIgYWE9RC5jc3M7cmV0dXJuIGMoRCxcbntjc3M6ZnVuY3Rpb24oYSl7aWYoYSl7dmFyIGg9e307YT1BKGEpO2UoRC50ZXh0UHJvcHMsZnVuY3Rpb24oZCl7dm9pZCAwIT09YVtkXSYmKGhbZF09YVtkXSxkZWxldGUgYVtkXSl9KTtnLmNzcyhoKX1yZXR1cm4gYWEuY2FsbChELGEpfSxnZXRCQm94OmZ1bmN0aW9uKCl7cmV0dXJue3dpZHRoOkIud2lkdGgrMipOLGhlaWdodDpCLmhlaWdodCsyKk4seDpCLngtTix5OkIueS1OfX0sc2hhZG93OmZ1bmN0aW9uKGEpe2EmJihTKCkseCYmeC5zaGFkb3coYSkpO3JldHVybiBEfSxkZXN0cm95OmZ1bmN0aW9uKCl7eShELmVsZW1lbnQsXCJtb3VzZWVudGVyXCIpO3koRC5lbGVtZW50LFwibW91c2VsZWF2ZVwiKTtnJiYoZz1nLmRlc3Ryb3koKSk7eCYmKHg9eC5kZXN0cm95KCkpO0cucHJvdG90eXBlLmRlc3Ryb3kuY2FsbChEKTtEPUM9Uz12PVc9bnVsbH19KX19KTthLlJlbmRlcmVyPUV9KShMKTsoZnVuY3Rpb24oYSl7dmFyIEc9YS5hdHRyLEU9YS5jcmVhdGVFbGVtZW50LEg9YS5jc3Msdj1cbmEuZGVmaW5lZCxrPWEuZWFjaCxxPWEuZXh0ZW5kLHc9YS5pc0ZpcmVmb3gsdD1hLmlzTVMsdT1hLmlzV2ViS2l0LHo9YS5waWNrLG09YS5wSW50LGc9YS5TVkdSZW5kZXJlcixmPWEud2luLGU9YS53cmFwO3EoYS5TVkdFbGVtZW50LnByb3RvdHlwZSx7aHRtbENzczpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmVsZW1lbnQ7aWYoYj1hJiZcIlNQQU5cIj09PWIudGFnTmFtZSYmYS53aWR0aClkZWxldGUgYS53aWR0aCx0aGlzLnRleHRXaWR0aD1iLHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7YSYmXCJlbGxpcHNpc1wiPT09YS50ZXh0T3ZlcmZsb3cmJihhLndoaXRlU3BhY2U9XCJub3dyYXBcIixhLm92ZXJmbG93PVwiaGlkZGVuXCIpO3RoaXMuc3R5bGVzPXEodGhpcy5zdHlsZXMsYSk7SCh0aGlzLmVsZW1lbnQsYSk7cmV0dXJuIHRoaXN9LGh0bWxHZXRCQm94OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lbGVtZW50O3JldHVybnt4OmEub2Zmc2V0TGVmdCx5OmEub2Zmc2V0VG9wLHdpZHRoOmEub2Zmc2V0V2lkdGgsXG5oZWlnaHQ6YS5vZmZzZXRIZWlnaHR9fSxodG1sVXBkYXRlVHJhbnNmb3JtOmZ1bmN0aW9uKCl7aWYodGhpcy5hZGRlZCl7dmFyIGE9dGhpcy5yZW5kZXJlcixiPXRoaXMuZWxlbWVudCxlPXRoaXMudHJhbnNsYXRlWHx8MCxsPXRoaXMudHJhbnNsYXRlWXx8MCxmPXRoaXMueHx8MCxnPXRoaXMueXx8MCx4PXRoaXMudGV4dEFsaWdufHxcImxlZnRcIixGPXtsZWZ0OjAsY2VudGVyOi41LHJpZ2h0OjF9W3hdLG49dGhpcy5zdHlsZXM7SChiLHttYXJnaW5MZWZ0OmUsbWFyZ2luVG9wOmx9KTt0aGlzLnNoYWRvd3MmJmsodGhpcy5zaGFkb3dzLGZ1bmN0aW9uKGEpe0goYSx7bWFyZ2luTGVmdDplKzEsbWFyZ2luVG9wOmwrMX0pfSk7dGhpcy5pbnZlcnRlZCYmayhiLmNoaWxkTm9kZXMsZnVuY3Rpb24oZCl7YS5pbnZlcnRDaGlsZChkLGIpfSk7aWYoXCJTUEFOXCI9PT1iLnRhZ05hbWUpe3ZhciBCPXRoaXMucm90YXRpb24sdD1tKHRoaXMudGV4dFdpZHRoKSxBPW4mJm4ud2hpdGVTcGFjZSxkPVtCLFxueCxiLmlubmVySFRNTCx0aGlzLnRleHRXaWR0aCx0aGlzLnRleHRBbGlnbl0uam9pbigpO2QhPT10aGlzLmNUVCYmKG49YS5mb250TWV0cmljcyhiLnN0eWxlLmZvbnRTaXplKS5iLHYoQikmJnRoaXMuc2V0U3BhblJvdGF0aW9uKEIsRixuKSxIKGIse3dpZHRoOlwiXCIsd2hpdGVTcGFjZTpBfHxcIm5vd3JhcFwifSksYi5vZmZzZXRXaWR0aD50JiYvWyBcXC1dLy50ZXN0KGIudGV4dENvbnRlbnR8fGIuaW5uZXJUZXh0KSYmSChiLHt3aWR0aDp0K1wicHhcIixkaXNwbGF5OlwiYmxvY2tcIix3aGl0ZVNwYWNlOkF8fFwibm9ybWFsXCJ9KSx0aGlzLmdldFNwYW5Db3JyZWN0aW9uKGIub2Zmc2V0V2lkdGgsbixGLEIseCkpO0goYix7bGVmdDpmKyh0aGlzLnhDb3JyfHwwKStcInB4XCIsdG9wOmcrKHRoaXMueUNvcnJ8fDApK1wicHhcIn0pO3UmJihuPWIub2Zmc2V0SGVpZ2h0KTt0aGlzLmNUVD1kfX1lbHNlIHRoaXMuYWxpZ25PbkFkZD0hMH0sc2V0U3BhblJvdGF0aW9uOmZ1bmN0aW9uKGEsYixlKXt2YXIgYz17fSxcbnI9dGhpcy5yZW5kZXJlci5nZXRUcmFuc2Zvcm1LZXkoKTtjW3JdPWMudHJhbnNmb3JtPVwicm90YXRlKFwiK2ErXCJkZWcpXCI7Y1tyKyh3P1wiT3JpZ2luXCI6XCItb3JpZ2luXCIpXT1jLnRyYW5zZm9ybU9yaWdpbj0xMDAqYitcIiUgXCIrZStcInB4XCI7SCh0aGlzLmVsZW1lbnQsYyl9LGdldFNwYW5Db3JyZWN0aW9uOmZ1bmN0aW9uKGEsYixlKXt0aGlzLnhDb3JyPS1hKmU7dGhpcy55Q29ycj0tYn19KTtxKGcucHJvdG90eXBlLHtnZXRUcmFuc2Zvcm1LZXk6ZnVuY3Rpb24oKXtyZXR1cm4gdCYmIS9FZGdlLy50ZXN0KGYubmF2aWdhdG9yLnVzZXJBZ2VudCk/XCItbXMtdHJhbnNmb3JtXCI6dT9cIi13ZWJraXQtdHJhbnNmb3JtXCI6dz9cIk1velRyYW5zZm9ybVwiOmYub3BlcmE/XCItby10cmFuc2Zvcm1cIjpcIlwifSxodG1sOmZ1bmN0aW9uKGEsYixyKXt2YXIgYz10aGlzLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpLGY9Yy5lbGVtZW50LGc9Yy5yZW5kZXJlcix4PWcuaXNTVkcsbT1mdW5jdGlvbihhLGIpe2soW1wib3BhY2l0eVwiLFxuXCJ2aXNpYmlsaXR5XCJdLGZ1bmN0aW9uKGMpe2UoYSxjK1wiU2V0dGVyXCIsZnVuY3Rpb24oYSxkLGMsZSl7YS5jYWxsKHRoaXMsZCxjLGUpO2JbY109ZH0pfSl9O2MudGV4dFNldHRlcj1mdW5jdGlvbihhKXthIT09Zi5pbm5lckhUTUwmJmRlbGV0ZSB0aGlzLmJCb3g7dGhpcy50ZXh0U3RyPWE7Zi5pbm5lckhUTUw9eihhLFwiXCIpO2MuaHRtbFVwZGF0ZVRyYW5zZm9ybSgpfTt4JiZtKGMsYy5lbGVtZW50LnN0eWxlKTtjLnhTZXR0ZXI9Yy55U2V0dGVyPWMuYWxpZ25TZXR0ZXI9Yy5yb3RhdGlvblNldHRlcj1mdW5jdGlvbihhLGIpe1wiYWxpZ25cIj09PWImJihiPVwidGV4dEFsaWduXCIpO2NbYl09YTtjLmh0bWxVcGRhdGVUcmFuc2Zvcm0oKX07Yy5hdHRyKHt0ZXh0OmEseDpNYXRoLnJvdW5kKGIpLHk6TWF0aC5yb3VuZChyKX0pLmNzcyh7Zm9udEZhbWlseTp0aGlzLnN0eWxlLmZvbnRGYW1pbHksZm9udFNpemU6dGhpcy5zdHlsZS5mb250U2l6ZSxwb3NpdGlvbjpcImFic29sdXRlXCJ9KTtmLnN0eWxlLndoaXRlU3BhY2U9XG5cIm5vd3JhcFwiO2MuY3NzPWMuaHRtbENzczt4JiYoYy5hZGQ9ZnVuY3Rpb24oYSl7dmFyIGIsZT1nLmJveC5wYXJlbnROb2RlLG49W107aWYodGhpcy5wYXJlbnRHcm91cD1hKXtpZihiPWEuZGl2LCFiKXtmb3IoO2E7KW4ucHVzaChhKSxhPWEucGFyZW50R3JvdXA7ayhuLnJldmVyc2UoKSxmdW5jdGlvbihhKXtmdW5jdGlvbiBkKGgsZCl7YVtkXT1oO3Q/bFtnLmdldFRyYW5zZm9ybUtleSgpXT1cInRyYW5zbGF0ZShcIisoYS54fHxhLnRyYW5zbGF0ZVgpK1wicHgsXCIrKGEueXx8YS50cmFuc2xhdGVZKStcInB4KVwiOlwidHJhbnNsYXRlWFwiPT09ZD9sLmxlZnQ9aCtcInB4XCI6bC50b3A9aCtcInB4XCI7YS5kb1RyYW5zZm9ybT0hMH12YXIgbCxoPUcoYS5lbGVtZW50LFwiY2xhc3NcIik7aCYmKGg9e2NsYXNzTmFtZTpofSk7Yj1hLmRpdj1hLmRpdnx8RShcImRpdlwiLGgse3Bvc2l0aW9uOlwiYWJzb2x1dGVcIixsZWZ0OihhLnRyYW5zbGF0ZVh8fDApK1wicHhcIix0b3A6KGEudHJhbnNsYXRlWXx8MCkrXCJweFwiLGRpc3BsYXk6YS5kaXNwbGF5LFxub3BhY2l0eTphLm9wYWNpdHkscG9pbnRlckV2ZW50czphLnN0eWxlcyYmYS5zdHlsZXMucG9pbnRlckV2ZW50c30sYnx8ZSk7bD1iLnN0eWxlO3EoYSx7Y2xhc3NTZXR0ZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGgpe3RoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLGgpO2EuY2xhc3NOYW1lPWh9fShiKSxvbjpmdW5jdGlvbigpe25bMF0uZGl2JiZjLm9uLmFwcGx5KHtlbGVtZW50Om5bMF0uZGl2fSxhcmd1bWVudHMpO3JldHVybiBhfSx0cmFuc2xhdGVYU2V0dGVyOmQsdHJhbnNsYXRlWVNldHRlcjpkfSk7bShhLGwpfSl9fWVsc2UgYj1lO2IuYXBwZW5kQ2hpbGQoZik7Yy5hZGRlZD0hMDtjLmFsaWduT25BZGQmJmMuaHRtbFVwZGF0ZVRyYW5zZm9ybSgpO3JldHVybiBjfSk7cmV0dXJuIGN9fSl9KShMKTsoZnVuY3Rpb24oYSl7ZnVuY3Rpb24gRygpe3ZhciB0PWEuZGVmYXVsdE9wdGlvbnMuZ2xvYmFsLHU9dy5tb21lbnQ7aWYodC50aW1lem9uZSl7aWYodSlyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJuLXUudHooYSxcbnQudGltZXpvbmUpLnV0Y09mZnNldCgpfTthLmVycm9yKDI1KX1yZXR1cm4gdC51c2VVVEMmJnQuZ2V0VGltZXpvbmVPZmZzZXR9ZnVuY3Rpb24gRSgpe3ZhciB0PWEuZGVmYXVsdE9wdGlvbnMuZ2xvYmFsLHUsaz10LnVzZVVUQyxtPWs/XCJnZXRVVENcIjpcImdldFwiLGc9az9cInNldFVUQ1wiOlwic2V0XCIsZj1cIk1pbnV0ZXMgSG91cnMgRGF5IERhdGUgTW9udGggRnVsbFllYXJcIi5zcGxpdChcIiBcIiksZT1mLmNvbmNhdChbXCJNaWxsaXNlY29uZHNcIixcIlNlY29uZHNcIl0pO2EuRGF0ZT11PXQuRGF0ZXx8dy5EYXRlO3UuaGNUaW1lem9uZU9mZnNldD1rJiZ0LnRpbWV6b25lT2Zmc2V0O3UuaGNHZXRUaW1lem9uZU9mZnNldD1HKCk7dS5oY0hhc1RpbWVab25lPSEoIXUuaGNUaW1lem9uZU9mZnNldCYmIXUuaGNHZXRUaW1lem9uZU9mZnNldCk7dS5oY01ha2VUaW1lPWZ1bmN0aW9uKGEsYixlLGwsZixnKXt2YXIgYztrPyhjPXUuVVRDLmFwcGx5KDAsYXJndW1lbnRzKSxjKz12KGMpKTpjPShuZXcgdShhLFxuYixxKGUsMSkscShsLDApLHEoZiwwKSxxKGcsMCkpKS5nZXRUaW1lKCk7cmV0dXJuIGN9O2Zvcih0PTA7dDxmLmxlbmd0aDt0KyspdVtcImhjR2V0XCIrZlt0XV09bStmW3RdO2Zvcih0PTA7dDxlLmxlbmd0aDt0KyspdVtcImhjU2V0XCIrZVt0XV09ZytlW3RdfXZhciBIPWEuY29sb3Isdj1hLmdldFRaT2Zmc2V0LGs9YS5tZXJnZSxxPWEucGljayx3PWEud2luO2EuZGVmYXVsdE9wdGlvbnM9e2NvbG9yczpcIiM3Y2I1ZWMgIzQzNDM0OCAjOTBlZDdkICNmN2EzNWMgIzgwODVlOSAjZjE1YzgwICNlNGQzNTQgIzJiOTA4ZiAjZjQ1YjViICM5MWU4ZTFcIi5zcGxpdChcIiBcIiksc3ltYm9sczpbXCJjaXJjbGVcIixcImRpYW1vbmRcIixcInNxdWFyZVwiLFwidHJpYW5nbGVcIixcInRyaWFuZ2xlLWRvd25cIl0sbGFuZzp7bG9hZGluZzpcIkxvYWRpbmcuLi5cIixtb250aHM6XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpLFxuc2hvcnRNb250aHM6XCJKYW4gRmViIE1hciBBcHIgTWF5IEp1biBKdWwgQXVnIFNlcCBPY3QgTm92IERlY1wiLnNwbGl0KFwiIFwiKSx3ZWVrZGF5czpcIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLGRlY2ltYWxQb2ludDpcIi5cIixudW1lcmljU3ltYm9sczpcImtNR1RQRVwiLnNwbGl0KFwiXCIpLHJlc2V0Wm9vbTpcIlJlc2V0IHpvb21cIixyZXNldFpvb21UaXRsZTpcIlJlc2V0IHpvb20gbGV2ZWwgMToxXCIsdGhvdXNhbmRzU2VwOlwiIFwifSxnbG9iYWw6e3VzZVVUQzohMH0sY2hhcnQ6e2JvcmRlclJhZGl1czowLGRlZmF1bHRTZXJpZXNUeXBlOlwibGluZVwiLGlnbm9yZUhpZGRlblNlcmllczohMCxzcGFjaW5nOlsxMCwxMCwxNSwxMF0scmVzZXRab29tQnV0dG9uOnt0aGVtZTp7ekluZGV4OjZ9LHBvc2l0aW9uOnthbGlnbjpcInJpZ2h0XCIseDotMTAseToxMH19LHdpZHRoOm51bGwsaGVpZ2h0Om51bGwsYm9yZGVyQ29sb3I6XCIjMzM1Y2FkXCIsXG5iYWNrZ3JvdW5kQ29sb3I6XCIjZmZmZmZmXCIscGxvdEJvcmRlckNvbG9yOlwiI2NjY2NjY1wifSx0aXRsZTp7dGV4dDpcIkNoYXJ0IHRpdGxlXCIsYWxpZ246XCJjZW50ZXJcIixtYXJnaW46MTUsd2lkdGhBZGp1c3Q6LTQ0fSxzdWJ0aXRsZTp7dGV4dDpcIlwiLGFsaWduOlwiY2VudGVyXCIsd2lkdGhBZGp1c3Q6LTQ0fSxwbG90T3B0aW9uczp7fSxsYWJlbHM6e3N0eWxlOntwb3NpdGlvbjpcImFic29sdXRlXCIsY29sb3I6XCIjMzMzMzMzXCJ9fSxsZWdlbmQ6e2VuYWJsZWQ6ITAsYWxpZ246XCJjZW50ZXJcIixsYXlvdXQ6XCJob3Jpem9udGFsXCIsbGFiZWxGb3JtYXR0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uYW1lfSxib3JkZXJDb2xvcjpcIiM5OTk5OTlcIixib3JkZXJSYWRpdXM6MCxuYXZpZ2F0aW9uOnthY3RpdmVDb2xvcjpcIiMwMDMzOTlcIixpbmFjdGl2ZUNvbG9yOlwiI2NjY2NjY1wifSxpdGVtU3R5bGU6e2NvbG9yOlwiIzMzMzMzM1wiLGZvbnRTaXplOlwiMTJweFwiLGZvbnRXZWlnaHQ6XCJib2xkXCIsdGV4dE92ZXJmbG93OlwiZWxsaXBzaXNcIn0sXG5pdGVtSG92ZXJTdHlsZTp7Y29sb3I6XCIjMDAwMDAwXCJ9LGl0ZW1IaWRkZW5TdHlsZTp7Y29sb3I6XCIjY2NjY2NjXCJ9LHNoYWRvdzohMSxpdGVtQ2hlY2tib3hTdHlsZTp7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHdpZHRoOlwiMTNweFwiLGhlaWdodDpcIjEzcHhcIn0sc3F1YXJlU3ltYm9sOiEwLHN5bWJvbFBhZGRpbmc6NSx2ZXJ0aWNhbEFsaWduOlwiYm90dG9tXCIseDowLHk6MCx0aXRsZTp7c3R5bGU6e2ZvbnRXZWlnaHQ6XCJib2xkXCJ9fX0sbG9hZGluZzp7bGFiZWxTdHlsZTp7Zm9udFdlaWdodDpcImJvbGRcIixwb3NpdGlvbjpcInJlbGF0aXZlXCIsdG9wOlwiNDUlXCJ9LHN0eWxlOntwb3NpdGlvbjpcImFic29sdXRlXCIsYmFja2dyb3VuZENvbG9yOlwiI2ZmZmZmZlwiLG9wYWNpdHk6LjUsdGV4dEFsaWduOlwiY2VudGVyXCJ9fSx0b29sdGlwOntlbmFibGVkOiEwLGFuaW1hdGlvbjphLnN2Zyxib3JkZXJSYWRpdXM6MyxkYXRlVGltZUxhYmVsRm9ybWF0czp7bWlsbGlzZWNvbmQ6XCIlQSwgJWIgJWUsICVIOiVNOiVTLiVMXCIsXG5zZWNvbmQ6XCIlQSwgJWIgJWUsICVIOiVNOiVTXCIsbWludXRlOlwiJUEsICViICVlLCAlSDolTVwiLGhvdXI6XCIlQSwgJWIgJWUsICVIOiVNXCIsZGF5OlwiJUEsICViICVlLCAlWVwiLHdlZWs6XCJXZWVrIGZyb20gJUEsICViICVlLCAlWVwiLG1vbnRoOlwiJUIgJVlcIix5ZWFyOlwiJVlcIn0sZm9vdGVyRm9ybWF0OlwiXCIscGFkZGluZzo4LHNuYXA6YS5pc1RvdWNoRGV2aWNlPzI1OjEwLGJhY2tncm91bmRDb2xvcjpIKFwiI2Y3ZjdmN1wiKS5zZXRPcGFjaXR5KC44NSkuZ2V0KCksYm9yZGVyV2lkdGg6MSxoZWFkZXJGb3JtYXQ6J1xceDNjc3BhbiBzdHlsZVxceDNkXCJmb250LXNpemU6IDEwcHhcIlxceDNle3BvaW50LmtleX1cXHgzYy9zcGFuXFx4M2VcXHgzY2JyL1xceDNlJyxwb2ludEZvcm1hdDonXFx4M2NzcGFuIHN0eWxlXFx4M2RcImNvbG9yOntwb2ludC5jb2xvcn1cIlxceDNlXFx1MjVjZlxceDNjL3NwYW5cXHgzZSB7c2VyaWVzLm5hbWV9OiBcXHgzY2JcXHgzZXtwb2ludC55fVxceDNjL2JcXHgzZVxceDNjYnIvXFx4M2UnLHNoYWRvdzohMCxcbnN0eWxlOntjb2xvcjpcIiMzMzMzMzNcIixjdXJzb3I6XCJkZWZhdWx0XCIsZm9udFNpemU6XCIxMnB4XCIscG9pbnRlckV2ZW50czpcIm5vbmVcIix3aGl0ZVNwYWNlOlwibm93cmFwXCJ9fSxjcmVkaXRzOntlbmFibGVkOiEwLGhyZWY6XCJodHRwOi8vd3d3LmhpZ2hjaGFydHMuY29tXCIscG9zaXRpb246e2FsaWduOlwicmlnaHRcIix4Oi0xMCx2ZXJ0aWNhbEFsaWduOlwiYm90dG9tXCIseTotNX0sc3R5bGU6e2N1cnNvcjpcInBvaW50ZXJcIixjb2xvcjpcIiM5OTk5OTlcIixmb250U2l6ZTpcIjlweFwifSx0ZXh0OlwiSGlnaGNoYXJ0cy5jb21cIn19O2Euc2V0T3B0aW9ucz1mdW5jdGlvbih0KXthLmRlZmF1bHRPcHRpb25zPWsoITAsYS5kZWZhdWx0T3B0aW9ucyx0KTtFKCk7cmV0dXJuIGEuZGVmYXVsdE9wdGlvbnN9O2EuZ2V0T3B0aW9ucz1mdW5jdGlvbigpe3JldHVybiBhLmRlZmF1bHRPcHRpb25zfTthLmRlZmF1bHRQbG90T3B0aW9ucz1hLmRlZmF1bHRPcHRpb25zLnBsb3RPcHRpb25zO0UoKX0pKEwpOyhmdW5jdGlvbihhKXt2YXIgRz1cbmEuY29ycmVjdEZsb2F0LEU9YS5kZWZpbmVkLEg9YS5kZXN0cm95T2JqZWN0UHJvcGVydGllcyx2PWEuaXNOdW1iZXIsaz1hLm1lcmdlLHE9YS5waWNrLHc9YS5kZWcycmFkO2EuVGljaz1mdW5jdGlvbihhLHUsayxtKXt0aGlzLmF4aXM9YTt0aGlzLnBvcz11O3RoaXMudHlwZT1rfHxcIlwiO3RoaXMuaXNOZXdMYWJlbD10aGlzLmlzTmV3PSEwO2t8fG18fHRoaXMuYWRkTGFiZWwoKX07YS5UaWNrLnByb3RvdHlwZT17YWRkTGFiZWw6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmF4aXMsdT1hLm9wdGlvbnMsej1hLmNoYXJ0LG09YS5jYXRlZ29yaWVzLGc9YS5uYW1lcyxmPXRoaXMucG9zLGU9dS5sYWJlbHMsYz1hLnRpY2tQb3NpdGlvbnMsYj1mPT09Y1swXSxyPWY9PT1jW2MubGVuZ3RoLTFdLGc9bT9xKG1bZl0sZ1tmXSxmKTpmLG09dGhpcy5sYWJlbCxjPWMuaW5mbyxsO2EuaXNEYXRldGltZUF4aXMmJmMmJihsPXUuZGF0ZVRpbWVMYWJlbEZvcm1hdHNbYy5oaWdoZXJSYW5rc1tmXXx8Yy51bml0TmFtZV0pO1xudGhpcy5pc0ZpcnN0PWI7dGhpcy5pc0xhc3Q9cjt1PWEubGFiZWxGb3JtYXR0ZXIuY2FsbCh7YXhpczphLGNoYXJ0OnosaXNGaXJzdDpiLGlzTGFzdDpyLGRhdGVUaW1lTGFiZWxGb3JtYXQ6bCx2YWx1ZTphLmlzTG9nP0coYS5saW4ybG9nKGcpKTpnLHBvczpmfSk7RShtKT9tJiZtLmF0dHIoe3RleHQ6dX0pOih0aGlzLmxhYmVsTGVuZ3RoPSh0aGlzLmxhYmVsPW09RSh1KSYmZS5lbmFibGVkP3oucmVuZGVyZXIudGV4dCh1LDAsMCxlLnVzZUhUTUwpLmNzcyhrKGUuc3R5bGUpKS5hZGQoYS5sYWJlbEdyb3VwKTpudWxsKSYmbS5nZXRCQm94KCkud2lkdGgsdGhpcy5yb3RhdGlvbj0wKX0sZ2V0TGFiZWxTaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFiZWw/dGhpcy5sYWJlbC5nZXRCQm94KClbdGhpcy5heGlzLmhvcml6P1wiaGVpZ2h0XCI6XCJ3aWR0aFwiXTowfSxoYW5kbGVPdmVyZmxvdzpmdW5jdGlvbihhKXt2YXIgdD10aGlzLmF4aXMsaz10Lm9wdGlvbnMubGFiZWxzLG09YS54LFxuZz10LmNoYXJ0LmNoYXJ0V2lkdGgsZj10LmNoYXJ0LnNwYWNpbmcsZT1xKHQubGFiZWxMZWZ0LE1hdGgubWluKHQucG9zLGZbM10pKSxmPXEodC5sYWJlbFJpZ2h0LE1hdGgubWF4KHQuaXNSYWRpYWw/MDp0LnBvcyt0LmxlbixnLWZbMV0pKSxjPXRoaXMubGFiZWwsYj10aGlzLnJvdGF0aW9uLHI9e2xlZnQ6MCxjZW50ZXI6LjUscmlnaHQ6MX1bdC5sYWJlbEFsaWdufHxjLmF0dHIoXCJhbGlnblwiKV0sbD1jLmdldEJCb3goKS53aWR0aCxDPXQuZ2V0U2xvdFdpZHRoKCksST1DLHg9MSxGLG49e307aWYoYnx8ITE9PT1rLm92ZXJmbG93KTA+YiYmbS1yKmw8ZT9GPU1hdGgucm91bmQobS9NYXRoLmNvcyhiKncpLWUpOjA8YiYmbStyKmw+ZiYmKEY9TWF0aC5yb3VuZCgoZy1tKS9NYXRoLmNvcyhiKncpKSk7ZWxzZSBpZihnPW0rKDEtcikqbCxtLXIqbDxlP0k9YS54K0kqKDEtciktZTpnPmYmJihJPWYtYS54K0kqcix4PS0xKSxJPU1hdGgubWluKEMsSSksSTxDJiZcImNlbnRlclwiPT09dC5sYWJlbEFsaWduJiZcbihhLngrPXgqKEMtSS1yKihDLU1hdGgubWluKGwsSSkpKSksbD5JfHx0LmF1dG9Sb3RhdGlvbiYmKGMuc3R5bGVzfHx7fSkud2lkdGgpRj1JO0YmJihuLndpZHRoPUYsKGsuc3R5bGV8fHt9KS50ZXh0T3ZlcmZsb3d8fChuLnRleHRPdmVyZmxvdz1cImVsbGlwc2lzXCIpLGMuY3NzKG4pKX0sZ2V0UG9zaXRpb246ZnVuY3Rpb24oYSxrLHEsbSl7dmFyIGc9dGhpcy5heGlzLGY9Zy5jaGFydCxlPW0mJmYub2xkQ2hhcnRIZWlnaHR8fGYuY2hhcnRIZWlnaHQ7cmV0dXJue3g6YT9nLnRyYW5zbGF0ZShrK3EsbnVsbCxudWxsLG0pK2cudHJhbnNCOmcubGVmdCtnLm9mZnNldCsoZy5vcHBvc2l0ZT8obSYmZi5vbGRDaGFydFdpZHRofHxmLmNoYXJ0V2lkdGgpLWcucmlnaHQtZy5sZWZ0OjApLHk6YT9lLWcuYm90dG9tK2cub2Zmc2V0LShnLm9wcG9zaXRlP2cuaGVpZ2h0OjApOmUtZy50cmFuc2xhdGUoaytxLG51bGwsbnVsbCxtKS1nLnRyYW5zQn19LGdldExhYmVsUG9zaXRpb246ZnVuY3Rpb24oYSxcbmsscSxtLGcsZixlLGMpe3ZhciBiPXRoaXMuYXhpcyxyPWIudHJhbnNBLGw9Yi5yZXZlcnNlZCxDPWIuc3RhZ2dlckxpbmVzLHQ9Yi50aWNrUm90Q29ycnx8e3g6MCx5OjB9LHg9Zy55LEY9bXx8Yi5yZXNlcnZlU3BhY2VEZWZhdWx0PzA6LWIubGFiZWxPZmZzZXQqKFwiY2VudGVyXCI9PT1iLmxhYmVsQWxpZ24/LjU6MSk7RSh4KXx8KHg9MD09PWIuc2lkZT9xLnJvdGF0aW9uPy04Oi1xLmdldEJCb3goKS5oZWlnaHQ6Mj09PWIuc2lkZT90LnkrODpNYXRoLmNvcyhxLnJvdGF0aW9uKncpKih0LnktcS5nZXRCQm94KCExLDApLmhlaWdodC8yKSk7YT1hK2cueCtGK3QueC0oZiYmbT9mKnIqKGw/LTE6MSk6MCk7az1rK3gtKGYmJiFtP2YqcioobD8xOi0xKTowKTtDJiYocT1lLyhjfHwxKSVDLGIub3Bwb3NpdGUmJihxPUMtcS0xKSxrKz1iLmxhYmVsT2Zmc2V0L0MqcSk7cmV0dXJue3g6YSx5Ok1hdGgucm91bmQoayl9fSxnZXRNYXJrUGF0aDpmdW5jdGlvbihhLGsscSxtLGcsZil7cmV0dXJuIGYuY3Jpc3BMaW5lKFtcIk1cIixcbmEsayxcIkxcIixhKyhnPzA6LXEpLGsrKGc/cTowKV0sbSl9LHJlbmRlckdyaWRMaW5lOmZ1bmN0aW9uKGEsayxxKXt2YXIgbT10aGlzLmF4aXMsZz1tLm9wdGlvbnMsZj10aGlzLmdyaWRMaW5lLGU9e30sYz10aGlzLnBvcyxiPXRoaXMudHlwZSxyPW0udGlja21hcmtPZmZzZXQsbD1tLmNoYXJ0LnJlbmRlcmVyLEM9Yj9iK1wiR3JpZFwiOlwiZ3JpZFwiLHQ9Z1tDK1wiTGluZVdpZHRoXCJdLHg9Z1tDK1wiTGluZUNvbG9yXCJdLGc9Z1tDK1wiTGluZURhc2hTdHlsZVwiXTtmfHwoZS5zdHJva2U9eCxlW1wic3Ryb2tlLXdpZHRoXCJdPXQsZyYmKGUuZGFzaHN0eWxlPWcpLGJ8fChlLnpJbmRleD0xKSxhJiYoZS5vcGFjaXR5PTApLHRoaXMuZ3JpZExpbmU9Zj1sLnBhdGgoKS5hdHRyKGUpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIisoYj9iK1wiLVwiOlwiXCIpK1wiZ3JpZC1saW5lXCIpLmFkZChtLmdyaWRHcm91cCkpO2lmKCFhJiZmJiYoYT1tLmdldFBsb3RMaW5lUGF0aChjK3IsZi5zdHJva2VXaWR0aCgpKnEsYSwhMCkpKWZbdGhpcy5pc05ldz9cblwiYXR0clwiOlwiYW5pbWF0ZVwiXSh7ZDphLG9wYWNpdHk6a30pfSxyZW5kZXJNYXJrOmZ1bmN0aW9uKGEsayx6KXt2YXIgbT10aGlzLmF4aXMsZz1tLm9wdGlvbnMsZj1tLmNoYXJ0LnJlbmRlcmVyLGU9dGhpcy50eXBlLGM9ZT9lK1wiVGlja1wiOlwidGlja1wiLGI9bS50aWNrU2l6ZShjKSxyPXRoaXMubWFyayxsPSFyLEM9YS54O2E9YS55O3ZhciB0PXEoZ1tjK1wiV2lkdGhcIl0sIWUmJm0uaXNYQXhpcz8xOjApLGc9Z1tjK1wiQ29sb3JcIl07YiYmKG0ub3Bwb3NpdGUmJihiWzBdPS1iWzBdKSxsJiYodGhpcy5tYXJrPXI9Zi5wYXRoKCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLVwiKyhlP2UrXCItXCI6XCJcIikrXCJ0aWNrXCIpLmFkZChtLmF4aXNHcm91cCksci5hdHRyKHtzdHJva2U6ZyxcInN0cm9rZS13aWR0aFwiOnR9KSkscltsP1wiYXR0clwiOlwiYW5pbWF0ZVwiXSh7ZDp0aGlzLmdldE1hcmtQYXRoKEMsYSxiWzBdLHIuc3Ryb2tlV2lkdGgoKSp6LG0uaG9yaXosZiksb3BhY2l0eTprfSkpfSxyZW5kZXJMYWJlbDpmdW5jdGlvbihhLFxuayx6LG0pe3ZhciBnPXRoaXMuYXhpcyxmPWcuaG9yaXosZT1nLm9wdGlvbnMsYz10aGlzLmxhYmVsLGI9ZS5sYWJlbHMscj1iLnN0ZXAsZz1nLnRpY2ttYXJrT2Zmc2V0LGw9ITAsQz1hLng7YT1hLnk7YyYmdihDKSYmKGMueHk9YT10aGlzLmdldExhYmVsUG9zaXRpb24oQyxhLGMsZixiLGcsbSxyKSx0aGlzLmlzRmlyc3QmJiF0aGlzLmlzTGFzdCYmIXEoZS5zaG93Rmlyc3RMYWJlbCwxKXx8dGhpcy5pc0xhc3QmJiF0aGlzLmlzRmlyc3QmJiFxKGUuc2hvd0xhc3RMYWJlbCwxKT9sPSExOiFmfHxiLnN0ZXB8fGIucm90YXRpb258fGt8fDA9PT16fHx0aGlzLmhhbmRsZU92ZXJmbG93KGEpLHImJm0lciYmKGw9ITEpLGwmJnYoYS55KT8oYS5vcGFjaXR5PXosY1t0aGlzLmlzTmV3TGFiZWw/XCJhdHRyXCI6XCJhbmltYXRlXCJdKGEpLHRoaXMuaXNOZXdMYWJlbD0hMSk6KGMuYXR0cihcInlcIiwtOTk5OSksdGhpcy5pc05ld0xhYmVsPSEwKSl9LHJlbmRlcjpmdW5jdGlvbihhLGsseil7dmFyIG09XG50aGlzLmF4aXMsZz1tLmhvcml6LGY9dGhpcy5nZXRQb3NpdGlvbihnLHRoaXMucG9zLG0udGlja21hcmtPZmZzZXQsayksZT1mLngsYz1mLnksbT1nJiZlPT09bS5wb3MrbS5sZW58fCFnJiZjPT09bS5wb3M/LTE6MTt6PXEoeiwxKTt0aGlzLmlzQWN0aXZlPSEwO3RoaXMucmVuZGVyR3JpZExpbmUoayx6LG0pO3RoaXMucmVuZGVyTWFyayhmLHosbSk7dGhpcy5yZW5kZXJMYWJlbChmLGsseixhKTt0aGlzLmlzTmV3PSExfSxkZXN0cm95OmZ1bmN0aW9uKCl7SCh0aGlzLHRoaXMuYXhpcyl9fX0pKEwpO3ZhciBaPWZ1bmN0aW9uKGEpe3ZhciBHPWEuYWRkRXZlbnQsRT1hLmFuaW1PYmplY3QsSD1hLmFycmF5TWF4LHY9YS5hcnJheU1pbixrPWEuY29sb3IscT1hLmNvcnJlY3RGbG9hdCx3PWEuZGVmYXVsdE9wdGlvbnMsdD1hLmRlZmluZWQsdT1hLmRlZzJyYWQsej1hLmRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzLG09YS5lYWNoLGc9YS5leHRlbmQsZj1hLmZpcmVFdmVudCxlPWEuZm9ybWF0LFxuYz1hLmdldE1hZ25pdHVkZSxiPWEuZ3JlcCxyPWEuaW5BcnJheSxsPWEuaXNBcnJheSxDPWEuaXNOdW1iZXIsST1hLmlzU3RyaW5nLHg9YS5tZXJnZSxGPWEubm9ybWFsaXplVGlja0ludGVydmFsLG49YS5vYmplY3RFYWNoLEI9YS5waWNrLEo9YS5yZW1vdmVFdmVudCxBPWEuc3BsYXQsZD1hLnN5bmNUaW1lb3V0LHA9YS5UaWNrLEQ9ZnVuY3Rpb24oKXt0aGlzLmluaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfTthLmV4dGVuZChELnByb3RvdHlwZSx7ZGVmYXVsdE9wdGlvbnM6e2RhdGVUaW1lTGFiZWxGb3JtYXRzOnttaWxsaXNlY29uZDpcIiVIOiVNOiVTLiVMXCIsc2Vjb25kOlwiJUg6JU06JVNcIixtaW51dGU6XCIlSDolTVwiLGhvdXI6XCIlSDolTVwiLGRheTpcIiVlLiAlYlwiLHdlZWs6XCIlZS4gJWJcIixtb250aDpcIiViICcleVwiLHllYXI6XCIlWVwifSxlbmRPblRpY2s6ITEsbGFiZWxzOntlbmFibGVkOiEwLHN0eWxlOntjb2xvcjpcIiM2NjY2NjZcIixjdXJzb3I6XCJkZWZhdWx0XCIsZm9udFNpemU6XCIxMXB4XCJ9LFxueDowfSxtYXhQYWRkaW5nOi4wMSxtaW5vclRpY2tMZW5ndGg6MixtaW5vclRpY2tQb3NpdGlvbjpcIm91dHNpZGVcIixtaW5QYWRkaW5nOi4wMSxzdGFydE9mV2VlazoxLHN0YXJ0T25UaWNrOiExLHRpY2tMZW5ndGg6MTAsdGlja21hcmtQbGFjZW1lbnQ6XCJiZXR3ZWVuXCIsdGlja1BpeGVsSW50ZXJ2YWw6MTAwLHRpY2tQb3NpdGlvbjpcIm91dHNpZGVcIix0aXRsZTp7YWxpZ246XCJtaWRkbGVcIixzdHlsZTp7Y29sb3I6XCIjNjY2NjY2XCJ9fSx0eXBlOlwibGluZWFyXCIsbWlub3JHcmlkTGluZUNvbG9yOlwiI2YyZjJmMlwiLG1pbm9yR3JpZExpbmVXaWR0aDoxLG1pbm9yVGlja0NvbG9yOlwiIzk5OTk5OVwiLGxpbmVDb2xvcjpcIiNjY2Q2ZWJcIixsaW5lV2lkdGg6MSxncmlkTGluZUNvbG9yOlwiI2U2ZTZlNlwiLHRpY2tDb2xvcjpcIiNjY2Q2ZWJcIn0sZGVmYXVsdFlBeGlzT3B0aW9uczp7ZW5kT25UaWNrOiEwLHRpY2tQaXhlbEludGVydmFsOjcyLHNob3dMYXN0TGFiZWw6ITAsbGFiZWxzOnt4Oi04fSxtYXhQYWRkaW5nOi4wNSxcbm1pblBhZGRpbmc6LjA1LHN0YXJ0T25UaWNrOiEwLHRpdGxlOntyb3RhdGlvbjoyNzAsdGV4dDpcIlZhbHVlc1wifSxzdGFja0xhYmVsczp7YWxsb3dPdmVybGFwOiExLGVuYWJsZWQ6ITEsZm9ybWF0dGVyOmZ1bmN0aW9uKCl7cmV0dXJuIGEubnVtYmVyRm9ybWF0KHRoaXMudG90YWwsLTEpfSxzdHlsZTp7Zm9udFNpemU6XCIxMXB4XCIsZm9udFdlaWdodDpcImJvbGRcIixjb2xvcjpcIiMwMDAwMDBcIix0ZXh0T3V0bGluZTpcIjFweCBjb250cmFzdFwifX0sZ3JpZExpbmVXaWR0aDoxLGxpbmVXaWR0aDowfSxkZWZhdWx0TGVmdEF4aXNPcHRpb25zOntsYWJlbHM6e3g6LTE1fSx0aXRsZTp7cm90YXRpb246MjcwfX0sZGVmYXVsdFJpZ2h0QXhpc09wdGlvbnM6e2xhYmVsczp7eDoxNX0sdGl0bGU6e3JvdGF0aW9uOjkwfX0sZGVmYXVsdEJvdHRvbUF4aXNPcHRpb25zOntsYWJlbHM6e2F1dG9Sb3RhdGlvbjpbLTQ1XSx4OjB9LHRpdGxlOntyb3RhdGlvbjowfX0sZGVmYXVsdFRvcEF4aXNPcHRpb25zOntsYWJlbHM6e2F1dG9Sb3RhdGlvbjpbLTQ1XSxcbng6MH0sdGl0bGU6e3JvdGF0aW9uOjB9fSxpbml0OmZ1bmN0aW9uKGEsZCl7dmFyIGg9ZC5pc1gseT10aGlzO3kuY2hhcnQ9YTt5Lmhvcml6PWEuaW52ZXJ0ZWQmJiF5LmlzWkF4aXM/IWg6aDt5LmlzWEF4aXM9aDt5LmNvbGw9eS5jb2xsfHwoaD9cInhBeGlzXCI6XCJ5QXhpc1wiKTt5Lm9wcG9zaXRlPWQub3Bwb3NpdGU7eS5zaWRlPWQuc2lkZXx8KHkuaG9yaXo/eS5vcHBvc2l0ZT8wOjI6eS5vcHBvc2l0ZT8xOjMpO3kuc2V0T3B0aW9ucyhkKTt2YXIgYj10aGlzLm9wdGlvbnMsYz1iLnR5cGU7eS5sYWJlbEZvcm1hdHRlcj1iLmxhYmVscy5mb3JtYXR0ZXJ8fHkuZGVmYXVsdExhYmVsRm9ybWF0dGVyO3kudXNlck9wdGlvbnM9ZDt5Lm1pblBpeGVsUGFkZGluZz0wO3kucmV2ZXJzZWQ9Yi5yZXZlcnNlZDt5LnZpc2libGU9ITEhPT1iLnZpc2libGU7eS56b29tRW5hYmxlZD0hMSE9PWIuem9vbUVuYWJsZWQ7eS5oYXNOYW1lcz1cImNhdGVnb3J5XCI9PT1jfHwhMD09PWIuY2F0ZWdvcmllczt5LmNhdGVnb3JpZXM9XG5iLmNhdGVnb3JpZXN8fHkuaGFzTmFtZXM7eS5uYW1lcz15Lm5hbWVzfHxbXTt5LnBsb3RMaW5lc0FuZEJhbmRzR3JvdXBzPXt9O3kuaXNMb2c9XCJsb2dhcml0aG1pY1wiPT09Yzt5LmlzRGF0ZXRpbWVBeGlzPVwiZGF0ZXRpbWVcIj09PWM7eS5wb3NpdGl2ZVZhbHVlc09ubHk9eS5pc0xvZyYmIXkuYWxsb3dOZWdhdGl2ZUxvZzt5LmlzTGlua2VkPXQoYi5saW5rZWRUbyk7eS50aWNrcz17fTt5LmxhYmVsRWRnZT1bXTt5Lm1pbm9yVGlja3M9e307eS5wbG90TGluZXNBbmRCYW5kcz1bXTt5LmFsdGVybmF0ZUJhbmRzPXt9O3kubGVuPTA7eS5taW5SYW5nZT15LnVzZXJNaW5SYW5nZT1iLm1pblJhbmdlfHxiLm1heFpvb207eS5yYW5nZT1iLnJhbmdlO3kub2Zmc2V0PWIub2Zmc2V0fHwwO3kuc3RhY2tzPXt9O3kub2xkU3RhY2tzPXt9O3kuc3RhY2tzVG91Y2hlZD0wO3kubWF4PW51bGw7eS5taW49bnVsbDt5LmNyb3NzaGFpcj1CKGIuY3Jvc3NoYWlyLEEoYS5vcHRpb25zLnRvb2x0aXAuY3Jvc3NoYWlycylbaD9cbjA6MV0sITEpO2Q9eS5vcHRpb25zLmV2ZW50czstMT09PXIoeSxhLmF4ZXMpJiYoaD9hLmF4ZXMuc3BsaWNlKGEueEF4aXMubGVuZ3RoLDAseSk6YS5heGVzLnB1c2goeSksYVt5LmNvbGxdLnB1c2goeSkpO3kuc2VyaWVzPXkuc2VyaWVzfHxbXTthLmludmVydGVkJiYheS5pc1pBeGlzJiZoJiZ2b2lkIDA9PT15LnJldmVyc2VkJiYoeS5yZXZlcnNlZD0hMCk7bihkLGZ1bmN0aW9uKGEsaCl7Ryh5LGgsYSl9KTt5LmxpbjJsb2c9Yi5saW5lYXJUb0xvZ0NvbnZlcnRlcnx8eS5saW4ybG9nO3kuaXNMb2cmJih5LnZhbDJsaW49eS5sb2cybGluLHkubGluMnZhbD15LmxpbjJsb2cpfSxzZXRPcHRpb25zOmZ1bmN0aW9uKGEpe3RoaXMub3B0aW9ucz14KHRoaXMuZGVmYXVsdE9wdGlvbnMsXCJ5QXhpc1wiPT09dGhpcy5jb2xsJiZ0aGlzLmRlZmF1bHRZQXhpc09wdGlvbnMsW3RoaXMuZGVmYXVsdFRvcEF4aXNPcHRpb25zLHRoaXMuZGVmYXVsdFJpZ2h0QXhpc09wdGlvbnMsdGhpcy5kZWZhdWx0Qm90dG9tQXhpc09wdGlvbnMsXG50aGlzLmRlZmF1bHRMZWZ0QXhpc09wdGlvbnNdW3RoaXMuc2lkZV0seCh3W3RoaXMuY29sbF0sYSkpfSxkZWZhdWx0TGFiZWxGb3JtYXR0ZXI6ZnVuY3Rpb24oKXt2YXIgaD10aGlzLmF4aXMsZD10aGlzLnZhbHVlLGI9aC5jYXRlZ29yaWVzLGM9dGhpcy5kYXRlVGltZUxhYmVsRm9ybWF0LHA9dy5sYW5nLG49cC5udW1lcmljU3ltYm9scyxwPXAubnVtZXJpY1N5bWJvbE1hZ25pdHVkZXx8MUUzLGw9biYmbi5sZW5ndGgsQSxyPWgub3B0aW9ucy5sYWJlbHMuZm9ybWF0LGg9aC5pc0xvZz9NYXRoLmFicyhkKTpoLnRpY2tJbnRlcnZhbDtpZihyKUE9ZShyLHRoaXMpO2Vsc2UgaWYoYilBPWQ7ZWxzZSBpZihjKUE9YS5kYXRlRm9ybWF0KGMsZCk7ZWxzZSBpZihsJiYxRTM8PWgpZm9yKDtsLS0mJnZvaWQgMD09PUE7KWI9TWF0aC5wb3cocCxsKzEpLGg+PWImJjA9PT0xMCpkJWImJm51bGwhPT1uW2xdJiYwIT09ZCYmKEE9YS5udW1iZXJGb3JtYXQoZC9iLC0xKStuW2xdKTt2b2lkIDA9PT1cbkEmJihBPTFFNDw9TWF0aC5hYnMoZCk/YS5udW1iZXJGb3JtYXQoZCwtMSk6YS5udW1iZXJGb3JtYXQoZCwtMSx2b2lkIDAsXCJcIikpO3JldHVybiBBfSxnZXRTZXJpZXNFeHRyZW1lczpmdW5jdGlvbigpe3ZhciBhPXRoaXMsZD1hLmNoYXJ0O2EuaGFzVmlzaWJsZVNlcmllcz0hMTthLmRhdGFNaW49YS5kYXRhTWF4PWEudGhyZXNob2xkPW51bGw7YS5zb2Z0VGhyZXNob2xkPSFhLmlzWEF4aXM7YS5idWlsZFN0YWNrcyYmYS5idWlsZFN0YWNrcygpO20oYS5zZXJpZXMsZnVuY3Rpb24oaCl7aWYoaC52aXNpYmxlfHwhZC5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcyl7dmFyIHk9aC5vcHRpb25zLGM9eS50aHJlc2hvbGQscDthLmhhc1Zpc2libGVTZXJpZXM9ITA7YS5wb3NpdGl2ZVZhbHVlc09ubHkmJjA+PWMmJihjPW51bGwpO2lmKGEuaXNYQXhpcyl5PWgueERhdGEseS5sZW5ndGgmJihoPXYoeSkscD1IKHkpLEMoaCl8fGggaW5zdGFuY2VvZiBEYXRlfHwoeT1iKHksQyksXG5oPXYoeSkpLGEuZGF0YU1pbj1NYXRoLm1pbihCKGEuZGF0YU1pbix5WzBdLGgpLGgpLGEuZGF0YU1heD1NYXRoLm1heChCKGEuZGF0YU1heCx5WzBdLHApLHApKTtlbHNlIGlmKGguZ2V0RXh0cmVtZXMoKSxwPWguZGF0YU1heCxoPWguZGF0YU1pbix0KGgpJiZ0KHApJiYoYS5kYXRhTWluPU1hdGgubWluKEIoYS5kYXRhTWluLGgpLGgpLGEuZGF0YU1heD1NYXRoLm1heChCKGEuZGF0YU1heCxwKSxwKSksdChjKSYmKGEudGhyZXNob2xkPWMpLCF5LnNvZnRUaHJlc2hvbGR8fGEucG9zaXRpdmVWYWx1ZXNPbmx5KWEuc29mdFRocmVzaG9sZD0hMX19KX0sdHJhbnNsYXRlOmZ1bmN0aW9uKGEsZCxiLGMscCxlKXt2YXIgaD10aGlzLmxpbmtlZFBhcmVudHx8dGhpcyx5PTEsbj0wLGw9Yz9oLm9sZFRyYW5zQTpoLnRyYW5zQTtjPWM/aC5vbGRNaW46aC5taW47dmFyIEE9aC5taW5QaXhlbFBhZGRpbmc7cD0oaC5pc09yZGluYWx8fGguaXNCcm9rZW58fGguaXNMb2cmJnApJiZoLmxpbjJ2YWw7XG5sfHwobD1oLnRyYW5zQSk7YiYmKHkqPS0xLG49aC5sZW4pO2gucmV2ZXJzZWQmJih5Kj0tMSxuLT15KihoLnNlY3Rvcnx8aC5sZW4pKTtkPyhhPShhKnkrbi1BKS9sK2MscCYmKGE9aC5saW4ydmFsKGEpKSk6KHAmJihhPWgudmFsMmxpbihhKSksYT1DKGMpP3kqKGEtYykqbCtuK3kqQSsoQyhlKT9sKmU6MCk6dm9pZCAwKTtyZXR1cm4gYX0sdG9QaXhlbHM6ZnVuY3Rpb24oYSxkKXtyZXR1cm4gdGhpcy50cmFuc2xhdGUoYSwhMSwhdGhpcy5ob3JpeixudWxsLCEwKSsoZD8wOnRoaXMucG9zKX0sdG9WYWx1ZTpmdW5jdGlvbihhLGQpe3JldHVybiB0aGlzLnRyYW5zbGF0ZShhLShkPzA6dGhpcy5wb3MpLCEwLCF0aGlzLmhvcml6LG51bGwsITApfSxnZXRQbG90TGluZVBhdGg6ZnVuY3Rpb24oYSxkLGIsYyxwKXt2YXIgaD10aGlzLmNoYXJ0LHk9dGhpcy5sZWZ0LGU9dGhpcy50b3AsbixsLEE9YiYmaC5vbGRDaGFydEhlaWdodHx8aC5jaGFydEhlaWdodCxyPWImJmgub2xkQ2hhcnRXaWR0aHx8XG5oLmNoYXJ0V2lkdGgsZjtuPXRoaXMudHJhbnNCO3ZhciBEPWZ1bmN0aW9uKGEsaCxkKXtpZihhPGh8fGE+ZCljP2E9TWF0aC5taW4oTWF0aC5tYXgoaCxhKSxkKTpmPSEwO3JldHVybiBhfTtwPUIocCx0aGlzLnRyYW5zbGF0ZShhLG51bGwsbnVsbCxiKSk7YT1iPU1hdGgucm91bmQocCtuKTtuPWw9TWF0aC5yb3VuZChBLXAtbik7QyhwKT90aGlzLmhvcml6PyhuPWUsbD1BLXRoaXMuYm90dG9tLGE9Yj1EKGEseSx5K3RoaXMud2lkdGgpKTooYT15LGI9ci10aGlzLnJpZ2h0LG49bD1EKG4sZSxlK3RoaXMuaGVpZ2h0KSk6KGY9ITAsYz0hMSk7cmV0dXJuIGYmJiFjP251bGw6aC5yZW5kZXJlci5jcmlzcExpbmUoW1wiTVwiLGEsbixcIkxcIixiLGxdLGR8fDEpfSxnZXRMaW5lYXJUaWNrUG9zaXRpb25zOmZ1bmN0aW9uKGEsZCxiKXt2YXIgaCx5PXEoTWF0aC5mbG9vcihkL2EpKmEpO2I9cShNYXRoLmNlaWwoYi9hKSphKTt2YXIgYz1bXSxwO3EoeSthKT09PXkmJihwPTIwKTtpZih0aGlzLnNpbmdsZSlyZXR1cm5bZF07XG5mb3IoZD15O2Q8PWI7KXtjLnB1c2goZCk7ZD1xKGQrYSxwKTtpZihkPT09aClicmVhaztoPWR9cmV0dXJuIGN9LGdldE1pbm9yVGlja0ludGVydmFsOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zO3JldHVybiEwPT09YS5taW5vclRpY2tzP0IoYS5taW5vclRpY2tJbnRlcnZhbCxcImF1dG9cIik6ITE9PT1hLm1pbm9yVGlja3M/bnVsbDphLm1pbm9yVGlja0ludGVydmFsfSxnZXRNaW5vclRpY2tQb3NpdGlvbnM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGQ9YS5vcHRpb25zLGI9YS50aWNrUG9zaXRpb25zLGM9YS5taW5vclRpY2tJbnRlcnZhbCxwPVtdLGU9YS5wb2ludFJhbmdlUGFkZGluZ3x8MCxuPWEubWluLWUsZT1hLm1heCtlLGw9ZS1uO2lmKGwmJmwvYzxhLmxlbi8zKWlmKGEuaXNMb2cpbSh0aGlzLnBhZGRlZFRpY2tzLGZ1bmN0aW9uKGgsZCx5KXtkJiZwLnB1c2guYXBwbHkocCxhLmdldExvZ1RpY2tQb3NpdGlvbnMoYyx5W2QtMV0seVtkXSwhMCkpfSk7ZWxzZSBpZihhLmlzRGF0ZXRpbWVBeGlzJiZcblwiYXV0b1wiPT09dGhpcy5nZXRNaW5vclRpY2tJbnRlcnZhbCgpKXA9cC5jb25jYXQoYS5nZXRUaW1lVGlja3MoYS5ub3JtYWxpemVUaW1lVGlja0ludGVydmFsKGMpLG4sZSxkLnN0YXJ0T2ZXZWVrKSk7ZWxzZSBmb3IoZD1uKyhiWzBdLW4pJWM7ZDw9ZSYmZCE9PXBbMF07ZCs9YylwLnB1c2goZCk7MCE9PXAubGVuZ3RoJiZhLnRyaW1UaWNrcyhwKTtyZXR1cm4gcH0sYWRqdXN0Rm9yTWluUmFuZ2U6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnMsZD10aGlzLm1pbixiPXRoaXMubWF4LGMscCxlLG4sbCxBLHIsZjt0aGlzLmlzWEF4aXMmJnZvaWQgMD09PXRoaXMubWluUmFuZ2UmJiF0aGlzLmlzTG9nJiYodChhLm1pbil8fHQoYS5tYXgpP3RoaXMubWluUmFuZ2U9bnVsbDoobSh0aGlzLnNlcmllcyxmdW5jdGlvbihhKXtBPWEueERhdGE7Zm9yKG49cj1hLnhJbmNyZW1lbnQ/MTpBLmxlbmd0aC0xOzA8bjtuLS0paWYobD1BW25dLUFbbi0xXSx2b2lkIDA9PT1lfHxsPGUpZT1sfSksXG50aGlzLm1pblJhbmdlPU1hdGgubWluKDUqZSx0aGlzLmRhdGFNYXgtdGhpcy5kYXRhTWluKSkpO2ItZDx0aGlzLm1pblJhbmdlJiYocD10aGlzLmRhdGFNYXgtdGhpcy5kYXRhTWluPj10aGlzLm1pblJhbmdlLGY9dGhpcy5taW5SYW5nZSxjPShmLWIrZCkvMixjPVtkLWMsQihhLm1pbixkLWMpXSxwJiYoY1syXT10aGlzLmlzTG9nP3RoaXMubG9nMmxpbih0aGlzLmRhdGFNaW4pOnRoaXMuZGF0YU1pbiksZD1IKGMpLGI9W2QrZixCKGEubWF4LGQrZildLHAmJihiWzJdPXRoaXMuaXNMb2c/dGhpcy5sb2cybGluKHRoaXMuZGF0YU1heCk6dGhpcy5kYXRhTWF4KSxiPXYoYiksYi1kPGYmJihjWzBdPWItZixjWzFdPUIoYS5taW4sYi1mKSxkPUgoYykpKTt0aGlzLm1pbj1kO3RoaXMubWF4PWJ9LGdldENsb3Nlc3Q6ZnVuY3Rpb24oKXt2YXIgYTt0aGlzLmNhdGVnb3JpZXM/YT0xOm0odGhpcy5zZXJpZXMsZnVuY3Rpb24oaCl7dmFyIGQ9aC5jbG9zZXN0UG9pbnRSYW5nZSx5PWgudmlzaWJsZXx8XG4haC5jaGFydC5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllczshaC5ub1NoYXJlZFRvb2x0aXAmJnQoZCkmJnkmJihhPXQoYSk/TWF0aC5taW4oYSxkKTpkKX0pO3JldHVybiBhfSxuYW1lVG9YOmZ1bmN0aW9uKGEpe3ZhciBoPWwodGhpcy5jYXRlZ29yaWVzKSxkPWg/dGhpcy5jYXRlZ29yaWVzOnRoaXMubmFtZXMsYj1hLm9wdGlvbnMueCxjO2Euc2VyaWVzLnJlcXVpcmVTb3J0aW5nPSExO3QoYil8fChiPSExPT09dGhpcy5vcHRpb25zLnVuaXF1ZU5hbWVzP2Euc2VyaWVzLmF1dG9JbmNyZW1lbnQoKTpyKGEubmFtZSxkKSk7LTE9PT1iP2h8fChjPWQubGVuZ3RoKTpjPWI7dm9pZCAwIT09YyYmKHRoaXMubmFtZXNbY109YS5uYW1lKTtyZXR1cm4gY30sdXBkYXRlTmFtZXM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzOzA8dGhpcy5uYW1lcy5sZW5ndGgmJih0aGlzLm5hbWVzLmxlbmd0aD0wLHRoaXMubWluUmFuZ2U9dGhpcy51c2VyTWluUmFuZ2UsbSh0aGlzLnNlcmllc3x8W10sXG5mdW5jdGlvbihoKXtoLnhJbmNyZW1lbnQ9bnVsbDtpZighaC5wb2ludHN8fGguaXNEaXJ0eURhdGEpaC5wcm9jZXNzRGF0YSgpLGguZ2VuZXJhdGVQb2ludHMoKTttKGgucG9pbnRzLGZ1bmN0aW9uKGQsYil7dmFyIHk7ZC5vcHRpb25zJiYoeT1hLm5hbWVUb1goZCksdm9pZCAwIT09eSYmeSE9PWQueCYmKGQueD15LGgueERhdGFbYl09eSkpfSl9KSl9LHNldEF4aXNUcmFuc2xhdGlvbjpmdW5jdGlvbihhKXt2YXIgaD10aGlzLGQ9aC5tYXgtaC5taW4sYj1oLmF4aXNQb2ludFJhbmdlfHwwLGMscD0wLGU9MCxuPWgubGlua2VkUGFyZW50LGw9ISFoLmNhdGVnb3JpZXMsQT1oLnRyYW5zQSxyPWguaXNYQXhpcztpZihyfHxsfHxiKWM9aC5nZXRDbG9zZXN0KCksbj8ocD1uLm1pblBvaW50T2Zmc2V0LGU9bi5wb2ludFJhbmdlUGFkZGluZyk6bShoLnNlcmllcyxmdW5jdGlvbihhKXt2YXIgZD1sPzE6cj9CKGEub3B0aW9ucy5wb2ludFJhbmdlLGMsMCk6aC5heGlzUG9pbnRSYW5nZXx8MDtcbmE9YS5vcHRpb25zLnBvaW50UGxhY2VtZW50O2I9TWF0aC5tYXgoYixkKTtoLnNpbmdsZXx8KHA9TWF0aC5tYXgocCxJKGEpPzA6ZC8yKSxlPU1hdGgubWF4KGUsXCJvblwiPT09YT8wOmQpKX0pLG49aC5vcmRpbmFsU2xvcGUmJmM/aC5vcmRpbmFsU2xvcGUvYzoxLGgubWluUG9pbnRPZmZzZXQ9cCo9bixoLnBvaW50UmFuZ2VQYWRkaW5nPWUqPW4saC5wb2ludFJhbmdlPU1hdGgubWluKGIsZCksciYmKGguY2xvc2VzdFBvaW50UmFuZ2U9Yyk7YSYmKGgub2xkVHJhbnNBPUEpO2gudHJhbnNsYXRpb25TbG9wZT1oLnRyYW5zQT1BPWgub3B0aW9ucy5zdGF0aWNTY2FsZXx8aC5sZW4vKGQrZXx8MSk7aC50cmFuc0I9aC5ob3Jpej9oLmxlZnQ6aC5ib3R0b207aC5taW5QaXhlbFBhZGRpbmc9QSpwfSxtaW5Gcm9tUmFuZ2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXgtdGhpcy5yYW5nZX0sc2V0VGlja0ludGVydmFsOmZ1bmN0aW9uKGgpe3ZhciBkPXRoaXMsYj1kLmNoYXJ0LHA9ZC5vcHRpb25zLFxuZT1kLmlzTG9nLG49ZC5sb2cybGluLGw9ZC5pc0RhdGV0aW1lQXhpcyxBPWQuaXNYQXhpcyxyPWQuaXNMaW5rZWQsRD1wLm1heFBhZGRpbmcsZz1wLm1pblBhZGRpbmcseD1wLnRpY2tJbnRlcnZhbCxrPXAudGlja1BpeGVsSW50ZXJ2YWwsST1kLmNhdGVnb3JpZXMsSj1kLnRocmVzaG9sZCx1PWQuc29mdFRocmVzaG9sZCx6LHcsdixFO2x8fEl8fHJ8fHRoaXMuZ2V0VGlja0Ftb3VudCgpO3Y9QihkLnVzZXJNaW4scC5taW4pO0U9QihkLnVzZXJNYXgscC5tYXgpO3I/KGQubGlua2VkUGFyZW50PWJbZC5jb2xsXVtwLmxpbmtlZFRvXSxiPWQubGlua2VkUGFyZW50LmdldEV4dHJlbWVzKCksZC5taW49QihiLm1pbixiLmRhdGFNaW4pLGQubWF4PUIoYi5tYXgsYi5kYXRhTWF4KSxwLnR5cGUhPT1kLmxpbmtlZFBhcmVudC5vcHRpb25zLnR5cGUmJmEuZXJyb3IoMTEsMSkpOighdSYmdChKKSYmKGQuZGF0YU1pbj49Sj8oej1KLGc9MCk6ZC5kYXRhTWF4PD1KJiYodz1KLEQ9MCkpLGQubWluPVxuQih2LHosZC5kYXRhTWluKSxkLm1heD1CKEUsdyxkLmRhdGFNYXgpKTtlJiYoZC5wb3NpdGl2ZVZhbHVlc09ubHkmJiFoJiYwPj1NYXRoLm1pbihkLm1pbixCKGQuZGF0YU1pbixkLm1pbikpJiZhLmVycm9yKDEwLDEpLGQubWluPXEobihkLm1pbiksMTUpLGQubWF4PXEobihkLm1heCksMTUpKTtkLnJhbmdlJiZ0KGQubWF4KSYmKGQudXNlck1pbj1kLm1pbj12PU1hdGgubWF4KGQuZGF0YU1pbixkLm1pbkZyb21SYW5nZSgpKSxkLnVzZXJNYXg9RT1kLm1heCxkLnJhbmdlPW51bGwpO2YoZCxcImZvdW5kRXh0cmVtZXNcIik7ZC5iZWZvcmVQYWRkaW5nJiZkLmJlZm9yZVBhZGRpbmcoKTtkLmFkanVzdEZvck1pblJhbmdlKCk7IShJfHxkLmF4aXNQb2ludFJhbmdlfHxkLnVzZVBlcmNlbnRhZ2V8fHIpJiZ0KGQubWluKSYmdChkLm1heCkmJihuPWQubWF4LWQubWluKSYmKCF0KHYpJiZnJiYoZC5taW4tPW4qZyksIXQoRSkmJkQmJihkLm1heCs9bipEKSk7QyhwLnNvZnRNaW4pJiYhQyhkLnVzZXJNaW4pJiZcbihkLm1pbj1NYXRoLm1pbihkLm1pbixwLnNvZnRNaW4pKTtDKHAuc29mdE1heCkmJiFDKGQudXNlck1heCkmJihkLm1heD1NYXRoLm1heChkLm1heCxwLnNvZnRNYXgpKTtDKHAuZmxvb3IpJiYoZC5taW49TWF0aC5tYXgoZC5taW4scC5mbG9vcikpO0MocC5jZWlsaW5nKSYmKGQubWF4PU1hdGgubWluKGQubWF4LHAuY2VpbGluZykpO3UmJnQoZC5kYXRhTWluKSYmKEo9Snx8MCwhdCh2KSYmZC5taW48SiYmZC5kYXRhTWluPj1KP2QubWluPUo6IXQoRSkmJmQubWF4PkomJmQuZGF0YU1heDw9SiYmKGQubWF4PUopKTtkLnRpY2tJbnRlcnZhbD1kLm1pbj09PWQubWF4fHx2b2lkIDA9PT1kLm1pbnx8dm9pZCAwPT09ZC5tYXg/MTpyJiYheCYmaz09PWQubGlua2VkUGFyZW50Lm9wdGlvbnMudGlja1BpeGVsSW50ZXJ2YWw/eD1kLmxpbmtlZFBhcmVudC50aWNrSW50ZXJ2YWw6Qih4LHRoaXMudGlja0Ftb3VudD8oZC5tYXgtZC5taW4pL01hdGgubWF4KHRoaXMudGlja0Ftb3VudC0xLDEpOlxudm9pZCAwLEk/MTooZC5tYXgtZC5taW4pKmsvTWF0aC5tYXgoZC5sZW4saykpO0EmJiFoJiZtKGQuc2VyaWVzLGZ1bmN0aW9uKGEpe2EucHJvY2Vzc0RhdGEoZC5taW4hPT1kLm9sZE1pbnx8ZC5tYXghPT1kLm9sZE1heCl9KTtkLnNldEF4aXNUcmFuc2xhdGlvbighMCk7ZC5iZWZvcmVTZXRUaWNrUG9zaXRpb25zJiZkLmJlZm9yZVNldFRpY2tQb3NpdGlvbnMoKTtkLnBvc3RQcm9jZXNzVGlja0ludGVydmFsJiYoZC50aWNrSW50ZXJ2YWw9ZC5wb3N0UHJvY2Vzc1RpY2tJbnRlcnZhbChkLnRpY2tJbnRlcnZhbCkpO2QucG9pbnRSYW5nZSYmIXgmJihkLnRpY2tJbnRlcnZhbD1NYXRoLm1heChkLnBvaW50UmFuZ2UsZC50aWNrSW50ZXJ2YWwpKTtoPUIocC5taW5UaWNrSW50ZXJ2YWwsZC5pc0RhdGV0aW1lQXhpcyYmZC5jbG9zZXN0UG9pbnRSYW5nZSk7IXgmJmQudGlja0ludGVydmFsPGgmJihkLnRpY2tJbnRlcnZhbD1oKTtsfHxlfHx4fHwoZC50aWNrSW50ZXJ2YWw9RihkLnRpY2tJbnRlcnZhbCxcbm51bGwsYyhkLnRpY2tJbnRlcnZhbCksQihwLmFsbG93RGVjaW1hbHMsISguNTxkLnRpY2tJbnRlcnZhbCYmNT5kLnRpY2tJbnRlcnZhbCYmMUUzPGQubWF4JiY5OTk5PmQubWF4KSksISF0aGlzLnRpY2tBbW91bnQpKTt0aGlzLnRpY2tBbW91bnR8fChkLnRpY2tJbnRlcnZhbD1kLnVuc3F1aXNoKCkpO3RoaXMuc2V0VGlja1Bvc2l0aW9ucygpfSxzZXRUaWNrUG9zaXRpb25zOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zLGQsYj1hLnRpY2tQb3NpdGlvbnM7ZD10aGlzLmdldE1pbm9yVGlja0ludGVydmFsKCk7dmFyIGM9YS50aWNrUG9zaXRpb25lcixwPWEuc3RhcnRPblRpY2ssZT1hLmVuZE9uVGljazt0aGlzLnRpY2ttYXJrT2Zmc2V0PXRoaXMuY2F0ZWdvcmllcyYmXCJiZXR3ZWVuXCI9PT1hLnRpY2ttYXJrUGxhY2VtZW50JiYxPT09dGhpcy50aWNrSW50ZXJ2YWw/LjU6MDt0aGlzLm1pbm9yVGlja0ludGVydmFsPVwiYXV0b1wiPT09ZCYmdGhpcy50aWNrSW50ZXJ2YWw/dGhpcy50aWNrSW50ZXJ2YWwvXG41OmQ7dGhpcy5zaW5nbGU9dGhpcy5taW49PT10aGlzLm1heCYmdCh0aGlzLm1pbikmJiF0aGlzLnRpY2tBbW91bnQmJihwYXJzZUludCh0aGlzLm1pbiwxMCk9PT10aGlzLm1pbnx8ITEhPT1hLmFsbG93RGVjaW1hbHMpO3RoaXMudGlja1Bvc2l0aW9ucz1kPWImJmIuc2xpY2UoKTshZCYmKGQ9dGhpcy5pc0RhdGV0aW1lQXhpcz90aGlzLmdldFRpbWVUaWNrcyh0aGlzLm5vcm1hbGl6ZVRpbWVUaWNrSW50ZXJ2YWwodGhpcy50aWNrSW50ZXJ2YWwsYS51bml0cyksdGhpcy5taW4sdGhpcy5tYXgsYS5zdGFydE9mV2Vlayx0aGlzLm9yZGluYWxQb3NpdGlvbnMsdGhpcy5jbG9zZXN0UG9pbnRSYW5nZSwhMCk6dGhpcy5pc0xvZz90aGlzLmdldExvZ1RpY2tQb3NpdGlvbnModGhpcy50aWNrSW50ZXJ2YWwsdGhpcy5taW4sdGhpcy5tYXgpOnRoaXMuZ2V0TGluZWFyVGlja1Bvc2l0aW9ucyh0aGlzLnRpY2tJbnRlcnZhbCx0aGlzLm1pbix0aGlzLm1heCksZC5sZW5ndGg+dGhpcy5sZW4mJihkPVxuW2RbMF0sZC5wb3AoKV0sZFswXT09PWRbMV0mJihkLmxlbmd0aD0xKSksdGhpcy50aWNrUG9zaXRpb25zPWQsYyYmKGM9Yy5hcHBseSh0aGlzLFt0aGlzLm1pbix0aGlzLm1heF0pKSkmJih0aGlzLnRpY2tQb3NpdGlvbnM9ZD1jKTt0aGlzLnBhZGRlZFRpY2tzPWQuc2xpY2UoMCk7dGhpcy50cmltVGlja3MoZCxwLGUpO3RoaXMuaXNMaW5rZWR8fCh0aGlzLnNpbmdsZSYmMj5kLmxlbmd0aCYmKHRoaXMubWluLT0uNSx0aGlzLm1heCs9LjUpLGJ8fGN8fHRoaXMuYWRqdXN0VGlja0Ftb3VudCgpKX0sdHJpbVRpY2tzOmZ1bmN0aW9uKGEsZCxiKXt2YXIgaD1hWzBdLGM9YVthLmxlbmd0aC0xXSxwPXRoaXMubWluUG9pbnRPZmZzZXR8fDA7aWYoIXRoaXMuaXNMaW5rZWQpe2lmKGQmJi1JbmZpbml0eSE9PWgpdGhpcy5taW49aDtlbHNlIGZvcig7dGhpcy5taW4tcD5hWzBdOylhLnNoaWZ0KCk7aWYoYil0aGlzLm1heD1jO2Vsc2UgZm9yKDt0aGlzLm1heCtwPGFbYS5sZW5ndGgtMV07KWEucG9wKCk7XG4wPT09YS5sZW5ndGgmJnQoaCkmJiF0aGlzLm9wdGlvbnMudGlja1Bvc2l0aW9ucyYmYS5wdXNoKChjK2gpLzIpfX0sYWxpZ25Ub090aGVyczpmdW5jdGlvbigpe3ZhciBhPXt9LGQsYj10aGlzLm9wdGlvbnM7ITE9PT10aGlzLmNoYXJ0Lm9wdGlvbnMuY2hhcnQuYWxpZ25UaWNrc3x8ITE9PT1iLmFsaWduVGlja3N8fHRoaXMuaXNMb2d8fG0odGhpcy5jaGFydFt0aGlzLmNvbGxdLGZ1bmN0aW9uKGgpe3ZhciBiPWgub3B0aW9ucyxiPVtoLmhvcml6P2IubGVmdDpiLnRvcCxiLndpZHRoLGIuaGVpZ2h0LGIucGFuZV0uam9pbigpO2guc2VyaWVzLmxlbmd0aCYmKGFbYl0/ZD0hMDphW2JdPTEpfSk7cmV0dXJuIGR9LGdldFRpY2tBbW91bnQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnMsZD1hLnRpY2tBbW91bnQsYj1hLnRpY2tQaXhlbEludGVydmFsOyF0KGEudGlja0ludGVydmFsKSYmdGhpcy5sZW48YiYmIXRoaXMuaXNSYWRpYWwmJiF0aGlzLmlzTG9nJiZhLnN0YXJ0T25UaWNrJiZcbmEuZW5kT25UaWNrJiYoZD0yKTshZCYmdGhpcy5hbGlnblRvT3RoZXJzKCkmJihkPU1hdGguY2VpbCh0aGlzLmxlbi9iKSsxKTs0PmQmJih0aGlzLmZpbmFsVGlja0FtdD1kLGQ9NSk7dGhpcy50aWNrQW1vdW50PWR9LGFkanVzdFRpY2tBbW91bnQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnRpY2tJbnRlcnZhbCxkPXRoaXMudGlja1Bvc2l0aW9ucyxiPXRoaXMudGlja0Ftb3VudCxjPXRoaXMuZmluYWxUaWNrQW10LHA9ZCYmZC5sZW5ndGgsZT1CKHRoaXMudGhyZXNob2xkLHRoaXMuc29mdFRocmVzaG9sZD8wOm51bGwpO2lmKHRoaXMuaGFzRGF0YSgpKXtpZihwPGIpe2Zvcig7ZC5sZW5ndGg8YjspZC5sZW5ndGglMnx8dGhpcy5taW49PT1lP2QucHVzaChxKGRbZC5sZW5ndGgtMV0rYSkpOmQudW5zaGlmdChxKGRbMF0tYSkpO3RoaXMudHJhbnNBKj0ocC0xKS8oYi0xKTt0aGlzLm1pbj1kWzBdO3RoaXMubWF4PWRbZC5sZW5ndGgtMV19ZWxzZSBwPmImJih0aGlzLnRpY2tJbnRlcnZhbCo9XG4yLHRoaXMuc2V0VGlja1Bvc2l0aW9ucygpKTtpZih0KGMpKXtmb3IoYT1iPWQubGVuZ3RoO2EtLTspKDM9PT1jJiYxPT09YSUyfHwyPj1jJiYwPGEmJmE8Yi0xKSYmZC5zcGxpY2UoYSwxKTt0aGlzLmZpbmFsVGlja0FtdD12b2lkIDB9fX0sc2V0U2NhbGU6ZnVuY3Rpb24oKXt2YXIgYSxkO3RoaXMub2xkTWluPXRoaXMubWluO3RoaXMub2xkTWF4PXRoaXMubWF4O3RoaXMub2xkQXhpc0xlbmd0aD10aGlzLmxlbjt0aGlzLnNldEF4aXNTaXplKCk7ZD10aGlzLmxlbiE9PXRoaXMub2xkQXhpc0xlbmd0aDttKHRoaXMuc2VyaWVzLGZ1bmN0aW9uKGQpe2lmKGQuaXNEaXJ0eURhdGF8fGQuaXNEaXJ0eXx8ZC54QXhpcy5pc0RpcnR5KWE9ITB9KTtkfHxhfHx0aGlzLmlzTGlua2VkfHx0aGlzLmZvcmNlUmVkcmF3fHx0aGlzLnVzZXJNaW4hPT10aGlzLm9sZFVzZXJNaW58fHRoaXMudXNlck1heCE9PXRoaXMub2xkVXNlck1heHx8dGhpcy5hbGlnblRvT3RoZXJzKCk/KHRoaXMucmVzZXRTdGFja3MmJlxudGhpcy5yZXNldFN0YWNrcygpLHRoaXMuZm9yY2VSZWRyYXc9ITEsdGhpcy5nZXRTZXJpZXNFeHRyZW1lcygpLHRoaXMuc2V0VGlja0ludGVydmFsKCksdGhpcy5vbGRVc2VyTWluPXRoaXMudXNlck1pbix0aGlzLm9sZFVzZXJNYXg9dGhpcy51c2VyTWF4LHRoaXMuaXNEaXJ0eXx8KHRoaXMuaXNEaXJ0eT1kfHx0aGlzLm1pbiE9PXRoaXMub2xkTWlufHx0aGlzLm1heCE9PXRoaXMub2xkTWF4KSk6dGhpcy5jbGVhblN0YWNrcyYmdGhpcy5jbGVhblN0YWNrcygpfSxzZXRFeHRyZW1lczpmdW5jdGlvbihhLGQsYixjLHApe3ZhciBoPXRoaXMsZT1oLmNoYXJ0O2I9QihiLCEwKTttKGguc2VyaWVzLGZ1bmN0aW9uKGEpe2RlbGV0ZSBhLmtkVHJlZX0pO3A9ZyhwLHttaW46YSxtYXg6ZH0pO2YoaCxcInNldEV4dHJlbWVzXCIscCxmdW5jdGlvbigpe2gudXNlck1pbj1hO2gudXNlck1heD1kO2guZXZlbnRBcmdzPXA7YiYmZS5yZWRyYXcoYyl9KX0sem9vbTpmdW5jdGlvbihhLGQpe3ZhciBoPXRoaXMuZGF0YU1pbixcbmI9dGhpcy5kYXRhTWF4LGM9dGhpcy5vcHRpb25zLHA9TWF0aC5taW4oaCxCKGMubWluLGgpKSxjPU1hdGgubWF4KGIsQihjLm1heCxiKSk7aWYoYSE9PXRoaXMubWlufHxkIT09dGhpcy5tYXgpdGhpcy5hbGxvd1pvb21PdXRzaWRlfHwodChoKSYmKGE8cCYmKGE9cCksYT5jJiYoYT1jKSksdChiKSYmKGQ8cCYmKGQ9cCksZD5jJiYoZD1jKSkpLHRoaXMuZGlzcGxheUJ0bj12b2lkIDAhPT1hfHx2b2lkIDAhPT1kLHRoaXMuc2V0RXh0cmVtZXMoYSxkLCExLHZvaWQgMCx7dHJpZ2dlcjpcInpvb21cIn0pO3JldHVybiEwfSxzZXRBeGlzU2l6ZTpmdW5jdGlvbigpe3ZhciBkPXRoaXMuY2hhcnQsYj10aGlzLm9wdGlvbnMsYz1iLm9mZnNldHN8fFswLDAsMCwwXSxwPXRoaXMuaG9yaXosZT10aGlzLndpZHRoPU1hdGgucm91bmQoYS5yZWxhdGl2ZUxlbmd0aChCKGIud2lkdGgsZC5wbG90V2lkdGgtY1szXStjWzFdKSxkLnBsb3RXaWR0aCkpLG49dGhpcy5oZWlnaHQ9TWF0aC5yb3VuZChhLnJlbGF0aXZlTGVuZ3RoKEIoYi5oZWlnaHQsXG5kLnBsb3RIZWlnaHQtY1swXStjWzJdKSxkLnBsb3RIZWlnaHQpKSxsPXRoaXMudG9wPU1hdGgucm91bmQoYS5yZWxhdGl2ZUxlbmd0aChCKGIudG9wLGQucGxvdFRvcCtjWzBdKSxkLnBsb3RIZWlnaHQsZC5wbG90VG9wKSksYj10aGlzLmxlZnQ9TWF0aC5yb3VuZChhLnJlbGF0aXZlTGVuZ3RoKEIoYi5sZWZ0LGQucGxvdExlZnQrY1szXSksZC5wbG90V2lkdGgsZC5wbG90TGVmdCkpO3RoaXMuYm90dG9tPWQuY2hhcnRIZWlnaHQtbi1sO3RoaXMucmlnaHQ9ZC5jaGFydFdpZHRoLWUtYjt0aGlzLmxlbj1NYXRoLm1heChwP2U6biwwKTt0aGlzLnBvcz1wP2I6bH0sZ2V0RXh0cmVtZXM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmlzTG9nLGQ9dGhpcy5saW4ybG9nO3JldHVybnttaW46YT9xKGQodGhpcy5taW4pKTp0aGlzLm1pbixtYXg6YT9xKGQodGhpcy5tYXgpKTp0aGlzLm1heCxkYXRhTWluOnRoaXMuZGF0YU1pbixkYXRhTWF4OnRoaXMuZGF0YU1heCx1c2VyTWluOnRoaXMudXNlck1pbixcbnVzZXJNYXg6dGhpcy51c2VyTWF4fX0sZ2V0VGhyZXNob2xkOmZ1bmN0aW9uKGEpe3ZhciBkPXRoaXMuaXNMb2csaD10aGlzLmxpbjJsb2csYj1kP2godGhpcy5taW4pOnRoaXMubWluLGQ9ZD9oKHRoaXMubWF4KTp0aGlzLm1heDtudWxsPT09YT9hPWI6Yj5hP2E9YjpkPGEmJihhPWQpO3JldHVybiB0aGlzLnRyYW5zbGF0ZShhLDAsMSwwLDEpfSxhdXRvTGFiZWxBbGlnbjpmdW5jdGlvbihhKXthPShCKGEsMCktOTAqdGhpcy5zaWRlKzcyMCklMzYwO3JldHVybiAxNTxhJiYxNjU+YT9cInJpZ2h0XCI6MTk1PGEmJjM0NT5hP1wibGVmdFwiOlwiY2VudGVyXCJ9LHRpY2tTaXplOmZ1bmN0aW9uKGEpe3ZhciBkPXRoaXMub3B0aW9ucyxoPWRbYStcIkxlbmd0aFwiXSxiPUIoZFthK1wiV2lkdGhcIl0sXCJ0aWNrXCI9PT1hJiZ0aGlzLmlzWEF4aXM/MTowKTtpZihiJiZoKXJldHVyblwiaW5zaWRlXCI9PT1kW2ErXCJQb3NpdGlvblwiXSYmKGg9LWgpLFtoLGJdfSxsYWJlbE1ldHJpY3M6ZnVuY3Rpb24oKXt2YXIgYT1cbnRoaXMudGlja1Bvc2l0aW9ucyYmdGhpcy50aWNrUG9zaXRpb25zWzBdfHwwO3JldHVybiB0aGlzLmNoYXJ0LnJlbmRlcmVyLmZvbnRNZXRyaWNzKHRoaXMub3B0aW9ucy5sYWJlbHMuc3R5bGUmJnRoaXMub3B0aW9ucy5sYWJlbHMuc3R5bGUuZm9udFNpemUsdGhpcy50aWNrc1thXSYmdGhpcy50aWNrc1thXS5sYWJlbCl9LHVuc3F1aXNoOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zLmxhYmVscyxkPXRoaXMuaG9yaXosYj10aGlzLnRpY2tJbnRlcnZhbCxjPWIscD10aGlzLmxlbi8oKCh0aGlzLmNhdGVnb3JpZXM/MTowKSt0aGlzLm1heC10aGlzLm1pbikvYiksZSxuPWEucm90YXRpb24sbD10aGlzLmxhYmVsTWV0cmljcygpLEEscj1OdW1iZXIuTUFYX1ZBTFVFLGYsRD1mdW5jdGlvbihhKXthLz1wfHwxO2E9MTxhP01hdGguY2VpbChhKToxO3JldHVybiBhKmJ9O2Q/KGY9IWEuc3RhZ2dlckxpbmVzJiYhYS5zdGVwJiYodChuKT9bbl06cDxCKGEuYXV0b1JvdGF0aW9uTGltaXQsXG44MCkmJmEuYXV0b1JvdGF0aW9uKSkmJm0oZixmdW5jdGlvbihhKXt2YXIgZDtpZihhPT09bnx8YSYmLTkwPD1hJiY5MD49YSlBPUQoTWF0aC5hYnMobC5oL01hdGguc2luKHUqYSkpKSxkPUErTWF0aC5hYnMoYS8zNjApLGQ8ciYmKHI9ZCxlPWEsYz1BKX0pOmEuc3RlcHx8KGM9RChsLmgpKTt0aGlzLmF1dG9Sb3RhdGlvbj1mO3RoaXMubGFiZWxSb3RhdGlvbj1CKGUsbik7cmV0dXJuIGN9LGdldFNsb3RXaWR0aDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuY2hhcnQsZD10aGlzLmhvcml6LGI9dGhpcy5vcHRpb25zLmxhYmVscyxjPU1hdGgubWF4KHRoaXMudGlja1Bvc2l0aW9ucy5sZW5ndGgtKHRoaXMuY2F0ZWdvcmllcz8wOjEpLDEpLHA9YS5tYXJnaW5bM107cmV0dXJuIGQmJjI+KGIuc3RlcHx8MCkmJiFiLnJvdGF0aW9uJiYodGhpcy5zdGFnZ2VyTGluZXN8fDEpKnRoaXMubGVuL2N8fCFkJiYoYi5zdHlsZSYmcGFyc2VJbnQoYi5zdHlsZS53aWR0aCwxMCl8fHAmJnAtYS5zcGFjaW5nWzNdfHxcbi4zMyphLmNoYXJ0V2lkdGgpfSxyZW5kZXJVbnNxdWlzaDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuY2hhcnQsZD1hLnJlbmRlcmVyLGI9dGhpcy50aWNrUG9zaXRpb25zLGM9dGhpcy50aWNrcyxwPXRoaXMub3B0aW9ucy5sYWJlbHMsZT10aGlzLmhvcml6LG49dGhpcy5nZXRTbG90V2lkdGgoKSxsPU1hdGgubWF4KDEsTWF0aC5yb3VuZChuLTIqKHAucGFkZGluZ3x8NSkpKSxBPXt9LHI9dGhpcy5sYWJlbE1ldHJpY3MoKSxmPXAuc3R5bGUmJnAuc3R5bGUudGV4dE92ZXJmbG93LEQsZz0wLEMsQjtJKHAucm90YXRpb24pfHwoQS5yb3RhdGlvbj1wLnJvdGF0aW9ufHwwKTttKGIsZnVuY3Rpb24oYSl7KGE9Y1thXSkmJmEubGFiZWxMZW5ndGg+ZyYmKGc9YS5sYWJlbExlbmd0aCl9KTt0aGlzLm1heExhYmVsTGVuZ3RoPWc7aWYodGhpcy5hdXRvUm90YXRpb24pZz5sJiZnPnIuaD9BLnJvdGF0aW9uPXRoaXMubGFiZWxSb3RhdGlvbjp0aGlzLmxhYmVsUm90YXRpb249MDtlbHNlIGlmKG4mJlxuKEQ9e3dpZHRoOmwrXCJweFwifSwhZikpZm9yKEQudGV4dE92ZXJmbG93PVwiY2xpcFwiLEM9Yi5sZW5ndGg7IWUmJkMtLTspaWYoQj1iW0NdLGw9Y1tCXS5sYWJlbClsLnN0eWxlcyYmXCJlbGxpcHNpc1wiPT09bC5zdHlsZXMudGV4dE92ZXJmbG93P2wuY3NzKHt0ZXh0T3ZlcmZsb3c6XCJjbGlwXCJ9KTpjW0JdLmxhYmVsTGVuZ3RoPm4mJmwuY3NzKHt3aWR0aDpuK1wicHhcIn0pLGwuZ2V0QkJveCgpLmhlaWdodD50aGlzLmxlbi9iLmxlbmd0aC0oci5oLXIuZikmJihsLnNwZWNDc3M9e3RleHRPdmVyZmxvdzpcImVsbGlwc2lzXCJ9KTtBLnJvdGF0aW9uJiYoRD17d2lkdGg6KGc+LjUqYS5jaGFydEhlaWdodD8uMzMqYS5jaGFydEhlaWdodDphLmNoYXJ0SGVpZ2h0KStcInB4XCJ9LGZ8fChELnRleHRPdmVyZmxvdz1cImVsbGlwc2lzXCIpKTtpZih0aGlzLmxhYmVsQWxpZ249cC5hbGlnbnx8dGhpcy5hdXRvTGFiZWxBbGlnbih0aGlzLmxhYmVsUm90YXRpb24pKUEuYWxpZ249dGhpcy5sYWJlbEFsaWduO20oYixcbmZ1bmN0aW9uKGEpe3ZhciBkPShhPWNbYV0pJiZhLmxhYmVsO2QmJihkLmF0dHIoQSksRCYmZC5jc3MoeChELGQuc3BlY0NzcykpLGRlbGV0ZSBkLnNwZWNDc3MsYS5yb3RhdGlvbj1BLnJvdGF0aW9uKX0pO3RoaXMudGlja1JvdENvcnI9ZC5yb3RDb3JyKHIuYix0aGlzLmxhYmVsUm90YXRpb258fDAsMCE9PXRoaXMuc2lkZSl9LGhhc0RhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNWaXNpYmxlU2VyaWVzfHx0KHRoaXMubWluKSYmdCh0aGlzLm1heCkmJnRoaXMudGlja1Bvc2l0aW9ucyYmMDx0aGlzLnRpY2tQb3NpdGlvbnMubGVuZ3RofSxhZGRUaXRsZTpmdW5jdGlvbihhKXt2YXIgZD10aGlzLmNoYXJ0LnJlbmRlcmVyLGg9dGhpcy5ob3JpeixiPXRoaXMub3Bwb3NpdGUsYz10aGlzLm9wdGlvbnMudGl0bGUscDt0aGlzLmF4aXNUaXRsZXx8KChwPWMudGV4dEFsaWduKXx8KHA9KGg/e2xvdzpcImxlZnRcIixtaWRkbGU6XCJjZW50ZXJcIixoaWdoOlwicmlnaHRcIn06e2xvdzpiP1wicmlnaHRcIjpcblwibGVmdFwiLG1pZGRsZTpcImNlbnRlclwiLGhpZ2g6Yj9cImxlZnRcIjpcInJpZ2h0XCJ9KVtjLmFsaWduXSksdGhpcy5heGlzVGl0bGU9ZC50ZXh0KGMudGV4dCwwLDAsYy51c2VIVE1MKS5hdHRyKHt6SW5kZXg6Nyxyb3RhdGlvbjpjLnJvdGF0aW9ufHwwLGFsaWduOnB9KS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtYXhpcy10aXRsZVwiKS5jc3MoYy5zdHlsZSkuYWRkKHRoaXMuYXhpc0dyb3VwKSx0aGlzLmF4aXNUaXRsZS5pc05ldz0hMCk7Yy5zdHlsZS53aWR0aHx8dGhpcy5pc1JhZGlhbHx8dGhpcy5heGlzVGl0bGUuY3NzKHt3aWR0aDp0aGlzLmxlbn0pO3RoaXMuYXhpc1RpdGxlW2E/XCJzaG93XCI6XCJoaWRlXCJdKCEwKX0sZ2VuZXJhdGVUaWNrOmZ1bmN0aW9uKGEpe3ZhciBkPXRoaXMudGlja3M7ZFthXT9kW2FdLmFkZExhYmVsKCk6ZFthXT1uZXcgcCh0aGlzLGEpfSxnZXRPZmZzZXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGQ9YS5jaGFydCxiPWQucmVuZGVyZXIsYz1hLm9wdGlvbnMscD1hLnRpY2tQb3NpdGlvbnMsXG5lPWEudGlja3MsbD1hLmhvcml6LEE9YS5zaWRlLHI9ZC5pbnZlcnRlZCYmIWEuaXNaQXhpcz9bMSwwLDMsMl1bQV06QSxmLEQsZz0wLHgsQz0wLEY9Yy50aXRsZSxrPWMubGFiZWxzLHE9MCxJPWQuYXhpc09mZnNldCxkPWQuY2xpcE9mZnNldCxKPVstMSwxLDEsLTFdW0FdLHU9Yy5jbGFzc05hbWUsej1hLmF4aXNQYXJlbnQsdj10aGlzLnRpY2tTaXplKFwidGlja1wiKTtmPWEuaGFzRGF0YSgpO2Euc2hvd0F4aXM9RD1mfHxCKGMuc2hvd0VtcHR5LCEwKTthLnN0YWdnZXJMaW5lcz1hLmhvcml6JiZrLnN0YWdnZXJMaW5lczthLmF4aXNHcm91cHx8KGEuZ3JpZEdyb3VwPWIuZyhcImdyaWRcIikuYXR0cih7ekluZGV4OmMuZ3JpZFpJbmRleHx8MX0pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIit0aGlzLmNvbGwudG9Mb3dlckNhc2UoKStcIi1ncmlkIFwiKyh1fHxcIlwiKSkuYWRkKHopLGEuYXhpc0dyb3VwPWIuZyhcImF4aXNcIikuYXR0cih7ekluZGV4OmMuekluZGV4fHwyfSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLVwiK1xudGhpcy5jb2xsLnRvTG93ZXJDYXNlKCkrXCIgXCIrKHV8fFwiXCIpKS5hZGQoeiksYS5sYWJlbEdyb3VwPWIuZyhcImF4aXMtbGFiZWxzXCIpLmF0dHIoe3pJbmRleDprLnpJbmRleHx8N30pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIithLmNvbGwudG9Mb3dlckNhc2UoKStcIi1sYWJlbHMgXCIrKHV8fFwiXCIpKS5hZGQoeikpO2Z8fGEuaXNMaW5rZWQ/KG0ocCxmdW5jdGlvbihkLGgpe2EuZ2VuZXJhdGVUaWNrKGQsaCl9KSxhLnJlbmRlclVuc3F1aXNoKCksYS5yZXNlcnZlU3BhY2VEZWZhdWx0PTA9PT1BfHwyPT09QXx8ezE6XCJsZWZ0XCIsMzpcInJpZ2h0XCJ9W0FdPT09YS5sYWJlbEFsaWduLEIoay5yZXNlcnZlU3BhY2UsXCJjZW50ZXJcIj09PWEubGFiZWxBbGlnbj8hMDpudWxsLGEucmVzZXJ2ZVNwYWNlRGVmYXVsdCkmJm0ocCxmdW5jdGlvbihhKXtxPU1hdGgubWF4KGVbYV0uZ2V0TGFiZWxTaXplKCkscSl9KSxhLnN0YWdnZXJMaW5lcyYmKHEqPWEuc3RhZ2dlckxpbmVzKSxhLmxhYmVsT2Zmc2V0PXEqXG4oYS5vcHBvc2l0ZT8tMToxKSk6bihlLGZ1bmN0aW9uKGEsZCl7YS5kZXN0cm95KCk7ZGVsZXRlIGVbZF19KTtGJiZGLnRleHQmJiExIT09Ri5lbmFibGVkJiYoYS5hZGRUaXRsZShEKSxEJiYhMSE9PUYucmVzZXJ2ZVNwYWNlJiYoYS50aXRsZU9mZnNldD1nPWEuYXhpc1RpdGxlLmdldEJCb3goKVtsP1wiaGVpZ2h0XCI6XCJ3aWR0aFwiXSx4PUYub2Zmc2V0LEM9dCh4KT8wOkIoRi5tYXJnaW4sbD81OjEwKSkpO2EucmVuZGVyTGluZSgpO2Eub2Zmc2V0PUoqQihjLm9mZnNldCxJW0FdKTthLnRpY2tSb3RDb3JyPWEudGlja1JvdENvcnJ8fHt4OjAseTowfTtiPTA9PT1BPy1hLmxhYmVsTWV0cmljcygpLmg6Mj09PUE/YS50aWNrUm90Q29yci55OjA7Qz1NYXRoLmFicyhxKStDO3EmJihDPUMtYitKKihsP0Ioay55LGEudGlja1JvdENvcnIueSs4KkopOmsueCkpO2EuYXhpc1RpdGxlTWFyZ2luPUIoeCxDKTtJW0FdPU1hdGgubWF4KElbQV0sYS5heGlzVGl0bGVNYXJnaW4rZytKKmEub2Zmc2V0LFxuQyxmJiZwLmxlbmd0aCYmdj92WzBdK0oqYS5vZmZzZXQ6MCk7Yz1jLm9mZnNldD8wOjIqTWF0aC5mbG9vcihhLmF4aXNMaW5lLnN0cm9rZVdpZHRoKCkvMik7ZFtyXT1NYXRoLm1heChkW3JdLGMpfSxnZXRMaW5lUGF0aDpmdW5jdGlvbihhKXt2YXIgZD10aGlzLmNoYXJ0LGg9dGhpcy5vcHBvc2l0ZSxiPXRoaXMub2Zmc2V0LGM9dGhpcy5ob3JpeixwPXRoaXMubGVmdCsoaD90aGlzLndpZHRoOjApK2IsYj1kLmNoYXJ0SGVpZ2h0LXRoaXMuYm90dG9tLShoP3RoaXMuaGVpZ2h0OjApK2I7aCYmKGEqPS0xKTtyZXR1cm4gZC5yZW5kZXJlci5jcmlzcExpbmUoW1wiTVwiLGM/dGhpcy5sZWZ0OnAsYz9iOnRoaXMudG9wLFwiTFwiLGM/ZC5jaGFydFdpZHRoLXRoaXMucmlnaHQ6cCxjP2I6ZC5jaGFydEhlaWdodC10aGlzLmJvdHRvbV0sYSl9LHJlbmRlckxpbmU6ZnVuY3Rpb24oKXt0aGlzLmF4aXNMaW5lfHwodGhpcy5heGlzTGluZT10aGlzLmNoYXJ0LnJlbmRlcmVyLnBhdGgoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtYXhpcy1saW5lXCIpLmFkZCh0aGlzLmF4aXNHcm91cCksXG50aGlzLmF4aXNMaW5lLmF0dHIoe3N0cm9rZTp0aGlzLm9wdGlvbnMubGluZUNvbG9yLFwic3Ryb2tlLXdpZHRoXCI6dGhpcy5vcHRpb25zLmxpbmVXaWR0aCx6SW5kZXg6N30pKX0sZ2V0VGl0bGVQb3NpdGlvbjpmdW5jdGlvbigpe3ZhciBhPXRoaXMuaG9yaXosZD10aGlzLmxlZnQsYj10aGlzLnRvcCxjPXRoaXMubGVuLHA9dGhpcy5vcHRpb25zLnRpdGxlLGU9YT9kOmIsbj10aGlzLm9wcG9zaXRlLGw9dGhpcy5vZmZzZXQsQT1wLnh8fDAscj1wLnl8fDAsZj10aGlzLmF4aXNUaXRsZSxEPXRoaXMuY2hhcnQucmVuZGVyZXIuZm9udE1ldHJpY3MocC5zdHlsZSYmcC5zdHlsZS5mb250U2l6ZSxmKSxmPU1hdGgubWF4KGYuZ2V0QkJveChudWxsLDApLmhlaWdodC1ELmgtMSwwKSxjPXtsb3c6ZSsoYT8wOmMpLG1pZGRsZTplK2MvMixoaWdoOmUrKGE/YzowKX1bcC5hbGlnbl0sZD0oYT9iK3RoaXMuaGVpZ2h0OmQpKyhhPzE6LTEpKihuPy0xOjEpKnRoaXMuYXhpc1RpdGxlTWFyZ2luK1stZixcbmYsRC5mLC1mXVt0aGlzLnNpZGVdO3JldHVybnt4OmE/YytBOmQrKG4/dGhpcy53aWR0aDowKStsK0EseTphP2Qrci0obj90aGlzLmhlaWdodDowKStsOmMrcn19LHJlbmRlck1pbm9yVGljazpmdW5jdGlvbihhKXt2YXIgZD10aGlzLmNoYXJ0Lmhhc1JlbmRlcmVkJiZDKHRoaXMub2xkTWluKSxiPXRoaXMubWlub3JUaWNrcztiW2FdfHwoYlthXT1uZXcgcCh0aGlzLGEsXCJtaW5vclwiKSk7ZCYmYlthXS5pc05ldyYmYlthXS5yZW5kZXIobnVsbCwhMCk7YlthXS5yZW5kZXIobnVsbCwhMSwxKX0scmVuZGVyVGljazpmdW5jdGlvbihhLGQpe3ZhciBiPXRoaXMuaXNMaW5rZWQsaD10aGlzLnRpY2tzLGM9dGhpcy5jaGFydC5oYXNSZW5kZXJlZCYmQyh0aGlzLm9sZE1pbik7aWYoIWJ8fGE+PXRoaXMubWluJiZhPD10aGlzLm1heCloW2FdfHwoaFthXT1uZXcgcCh0aGlzLGEpKSxjJiZoW2FdLmlzTmV3JiZoW2FdLnJlbmRlcihkLCEwLC4xKSxoW2FdLnJlbmRlcihkKX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGI9XG50aGlzLGM9Yi5jaGFydCxlPWIub3B0aW9ucyxsPWIuaXNMb2csQT1iLmxpbjJsb2cscj1iLmlzTGlua2VkLGY9Yi50aWNrUG9zaXRpb25zLEQ9Yi5heGlzVGl0bGUsZz1iLnRpY2tzLHg9Yi5taW5vclRpY2tzLEI9Yi5hbHRlcm5hdGVCYW5kcyxGPWUuc3RhY2tMYWJlbHMsaz1lLmFsdGVybmF0ZUdyaWRDb2xvcixxPWIudGlja21hcmtPZmZzZXQsdD1iLmF4aXNMaW5lLEk9Yi5zaG93QXhpcyxKPUUoYy5yZW5kZXJlci5nbG9iYWxBbmltYXRpb24pLHUsejtiLmxhYmVsRWRnZS5sZW5ndGg9MDtiLm92ZXJsYXA9ITE7bShbZyx4LEJdLGZ1bmN0aW9uKGEpe24oYSxmdW5jdGlvbihhKXthLmlzQWN0aXZlPSExfSl9KTtpZihiLmhhc0RhdGEoKXx8ciliLm1pbm9yVGlja0ludGVydmFsJiYhYi5jYXRlZ29yaWVzJiZtKGIuZ2V0TWlub3JUaWNrUG9zaXRpb25zKCksZnVuY3Rpb24oYSl7Yi5yZW5kZXJNaW5vclRpY2soYSl9KSxmLmxlbmd0aCYmKG0oZixmdW5jdGlvbihhLGQpe2IucmVuZGVyVGljayhhLFxuZCl9KSxxJiYoMD09PWIubWlufHxiLnNpbmdsZSkmJihnWy0xXXx8KGdbLTFdPW5ldyBwKGIsLTEsbnVsbCwhMCkpLGdbLTFdLnJlbmRlcigtMSkpKSxrJiZtKGYsZnVuY3Rpb24oZCxoKXt6PXZvaWQgMCE9PWZbaCsxXT9mW2grMV0rcTpiLm1heC1xOzA9PT1oJTImJmQ8Yi5tYXgmJno8PWIubWF4KyhjLnBvbGFyPy1xOnEpJiYoQltkXXx8KEJbZF09bmV3IGEuUGxvdExpbmVPckJhbmQoYikpLHU9ZCtxLEJbZF0ub3B0aW9ucz17ZnJvbTpsP0EodSk6dSx0bzpsP0Eoeik6eixjb2xvcjprfSxCW2RdLnJlbmRlcigpLEJbZF0uaXNBY3RpdmU9ITApfSksYi5fYWRkZWRQbG90TEJ8fChtKChlLnBsb3RMaW5lc3x8W10pLmNvbmNhdChlLnBsb3RCYW5kc3x8W10pLGZ1bmN0aW9uKGEpe2IuYWRkUGxvdEJhbmRPckxpbmUoYSl9KSxiLl9hZGRlZFBsb3RMQj0hMCk7bShbZyx4LEJdLGZ1bmN0aW9uKGEpe3ZhciBiLGg9W10scD1KLmR1cmF0aW9uO24oYSxmdW5jdGlvbihhLGQpe2EuaXNBY3RpdmV8fFxuKGEucmVuZGVyKGQsITEsMCksYS5pc0FjdGl2ZT0hMSxoLnB1c2goZCkpfSk7ZChmdW5jdGlvbigpe2ZvcihiPWgubGVuZ3RoO2ItLTspYVtoW2JdXSYmIWFbaFtiXV0uaXNBY3RpdmUmJihhW2hbYl1dLmRlc3Ryb3koKSxkZWxldGUgYVtoW2JdXSl9LGEhPT1CJiZjLmhhc1JlbmRlcmVkJiZwP3A6MCl9KTt0JiYodFt0LmlzUGxhY2VkP1wiYW5pbWF0ZVwiOlwiYXR0clwiXSh7ZDp0aGlzLmdldExpbmVQYXRoKHQuc3Ryb2tlV2lkdGgoKSl9KSx0LmlzUGxhY2VkPSEwLHRbST9cInNob3dcIjpcImhpZGVcIl0oITApKTtEJiZJJiYoZT1iLmdldFRpdGxlUG9zaXRpb24oKSxDKGUueSk/KERbRC5pc05ldz9cImF0dHJcIjpcImFuaW1hdGVcIl0oZSksRC5pc05ldz0hMSk6KEQuYXR0cihcInlcIiwtOTk5OSksRC5pc05ldz0hMCkpO0YmJkYuZW5hYmxlZCYmYi5yZW5kZXJTdGFja1RvdGFscygpO2IuaXNEaXJ0eT0hMX0scmVkcmF3OmZ1bmN0aW9uKCl7dGhpcy52aXNpYmxlJiYodGhpcy5yZW5kZXIoKSxtKHRoaXMucGxvdExpbmVzQW5kQmFuZHMsXG5mdW5jdGlvbihhKXthLnJlbmRlcigpfSkpO20odGhpcy5zZXJpZXMsZnVuY3Rpb24oYSl7YS5pc0RpcnR5PSEwfSl9LGtlZXBQcm9wczpcImV4dEtleSBoY0V2ZW50cyBuYW1lcyBzZXJpZXMgdXNlck1heCB1c2VyTWluXCIuc3BsaXQoXCIgXCIpLGRlc3Ryb3k6ZnVuY3Rpb24oYSl7dmFyIGQ9dGhpcyxiPWQuc3RhY2tzLGg9ZC5wbG90TGluZXNBbmRCYW5kcyxjO2F8fEooZCk7bihiLGZ1bmN0aW9uKGEsZCl7eihhKTtiW2RdPW51bGx9KTttKFtkLnRpY2tzLGQubWlub3JUaWNrcyxkLmFsdGVybmF0ZUJhbmRzXSxmdW5jdGlvbihhKXt6KGEpfSk7aWYoaClmb3IoYT1oLmxlbmd0aDthLS07KWhbYV0uZGVzdHJveSgpO20oXCJzdGFja1RvdGFsR3JvdXAgYXhpc0xpbmUgYXhpc1RpdGxlIGF4aXNHcm91cCBncmlkR3JvdXAgbGFiZWxHcm91cCBjcm9zc1wiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihhKXtkW2FdJiYoZFthXT1kW2FdLmRlc3Ryb3koKSl9KTtmb3IoYyBpbiBkLnBsb3RMaW5lc0FuZEJhbmRzR3JvdXBzKWQucGxvdExpbmVzQW5kQmFuZHNHcm91cHNbY109XG5kLnBsb3RMaW5lc0FuZEJhbmRzR3JvdXBzW2NdLmRlc3Ryb3koKTtuKGQsZnVuY3Rpb24oYSxiKXstMT09PXIoYixkLmtlZXBQcm9wcykmJmRlbGV0ZSBkW2JdfSl9LGRyYXdDcm9zc2hhaXI6ZnVuY3Rpb24oYSxkKXt2YXIgYixoPXRoaXMuY3Jvc3NoYWlyLGM9QihoLnNuYXAsITApLHAsZT10aGlzLmNyb3NzO2F8fChhPXRoaXMuY3Jvc3MmJnRoaXMuY3Jvc3MuZSk7dGhpcy5jcm9zc2hhaXImJiExIT09KHQoZCl8fCFjKT8oYz90KGQpJiYocD10aGlzLmlzWEF4aXM/ZC5wbG90WDp0aGlzLmxlbi1kLnBsb3RZKTpwPWEmJih0aGlzLmhvcml6P2EuY2hhcnRYLXRoaXMucG9zOnRoaXMubGVuLWEuY2hhcnRZK3RoaXMucG9zKSx0KHApJiYoYj10aGlzLmdldFBsb3RMaW5lUGF0aChkJiYodGhpcy5pc1hBeGlzP2QueDpCKGQuc3RhY2tZLGQueSkpLG51bGwsbnVsbCxudWxsLHApfHxudWxsKSx0KGIpPyhkPXRoaXMuY2F0ZWdvcmllcyYmIXRoaXMuaXNSYWRpYWwsZXx8KHRoaXMuY3Jvc3M9XG5lPXRoaXMuY2hhcnQucmVuZGVyZXIucGF0aCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1jcm9zc2hhaXIgaGlnaGNoYXJ0cy1jcm9zc2hhaXItXCIrKGQ/XCJjYXRlZ29yeSBcIjpcInRoaW4gXCIpK2guY2xhc3NOYW1lKS5hdHRyKHt6SW5kZXg6QihoLnpJbmRleCwyKX0pLmFkZCgpLGUuYXR0cih7c3Ryb2tlOmguY29sb3J8fChkP2soXCIjY2NkNmViXCIpLnNldE9wYWNpdHkoLjI1KS5nZXQoKTpcIiNjY2NjY2NcIiksXCJzdHJva2Utd2lkdGhcIjpCKGgud2lkdGgsMSl9KS5jc3Moe1wicG9pbnRlci1ldmVudHNcIjpcIm5vbmVcIn0pLGguZGFzaFN0eWxlJiZlLmF0dHIoe2Rhc2hzdHlsZTpoLmRhc2hTdHlsZX0pKSxlLnNob3coKS5hdHRyKHtkOmJ9KSxkJiYhaC53aWR0aCYmZS5hdHRyKHtcInN0cm9rZS13aWR0aFwiOnRoaXMudHJhbnNBfSksdGhpcy5jcm9zcy5lPWEpOnRoaXMuaGlkZUNyb3NzaGFpcigpKTp0aGlzLmhpZGVDcm9zc2hhaXIoKX0saGlkZUNyb3NzaGFpcjpmdW5jdGlvbigpe3RoaXMuY3Jvc3MmJlxudGhpcy5jcm9zcy5oaWRlKCl9fSk7cmV0dXJuIGEuQXhpcz1EfShMKTsoZnVuY3Rpb24oYSl7dmFyIEc9YS5BeGlzLEU9YS5EYXRlLEg9YS5kYXRlRm9ybWF0LHY9YS5kZWZhdWx0T3B0aW9ucyxrPWEuZGVmaW5lZCxxPWEuZWFjaCx3PWEuZXh0ZW5kLHQ9YS5nZXRNYWduaXR1ZGUsdT1hLmdldFRaT2Zmc2V0LHo9YS5ub3JtYWxpemVUaWNrSW50ZXJ2YWwsbT1hLnBpY2ssZz1hLnRpbWVVbml0cztHLnByb3RvdHlwZS5nZXRUaW1lVGlja3M9ZnVuY3Rpb24oYSxlLGMsYil7dmFyIHI9W10sbD17fSxmPXYuZ2xvYmFsLnVzZVVUQyx0LHg9bmV3IEUoZS1NYXRoLm1heCh1KGUpLHUoYykpKSxGPUUuaGNNYWtlVGltZSxuPWEudW5pdFJhbmdlLEI9YS5jb3VudCxKLEE7aWYoayhlKSl7eFtFLmhjU2V0TWlsbGlzZWNvbmRzXShuPj1nLnNlY29uZD8wOkIqTWF0aC5mbG9vcih4LmdldE1pbGxpc2Vjb25kcygpL0IpKTtpZihuPj1nLnNlY29uZCl4W0UuaGNTZXRTZWNvbmRzXShuPj1nLm1pbnV0ZT9cbjA6QipNYXRoLmZsb29yKHguZ2V0U2Vjb25kcygpL0IpKTtpZihuPj1nLm1pbnV0ZSl4W0UuaGNTZXRNaW51dGVzXShuPj1nLmhvdXI/MDpCKk1hdGguZmxvb3IoeFtFLmhjR2V0TWludXRlc10oKS9CKSk7aWYobj49Zy5ob3VyKXhbRS5oY1NldEhvdXJzXShuPj1nLmRheT8wOkIqTWF0aC5mbG9vcih4W0UuaGNHZXRIb3Vyc10oKS9CKSk7aWYobj49Zy5kYXkpeFtFLmhjU2V0RGF0ZV0obj49Zy5tb250aD8xOkIqTWF0aC5mbG9vcih4W0UuaGNHZXREYXRlXSgpL0IpKTtuPj1nLm1vbnRoJiYoeFtFLmhjU2V0TW9udGhdKG4+PWcueWVhcj8wOkIqTWF0aC5mbG9vcih4W0UuaGNHZXRNb250aF0oKS9CKSksdD14W0UuaGNHZXRGdWxsWWVhcl0oKSk7aWYobj49Zy55ZWFyKXhbRS5oY1NldEZ1bGxZZWFyXSh0LXQlQik7aWYobj09PWcud2Vlayl4W0UuaGNTZXREYXRlXSh4W0UuaGNHZXREYXRlXSgpLXhbRS5oY0dldERheV0oKSttKGIsMSkpO3Q9eFtFLmhjR2V0RnVsbFllYXJdKCk7Yj14W0UuaGNHZXRNb250aF0oKTtcbnZhciBkPXhbRS5oY0dldERhdGVdKCkscD14W0UuaGNHZXRIb3Vyc10oKTtlPXguZ2V0VGltZSgpO0UuaGNIYXNUaW1lWm9uZSYmKEE9KCFmfHwhIUUuaGNHZXRUaW1lem9uZU9mZnNldCkmJihjLWU+NCpnLm1vbnRofHx1KGUpIT09dShjKSksSj11KHgpLHg9bmV3IEUoZStKKSk7Zj14LmdldFRpbWUoKTtmb3IoZT0xO2Y8Yzspci5wdXNoKGYpLGY9bj09PWcueWVhcj9GKHQrZSpCLDApOm49PT1nLm1vbnRoP0YodCxiK2UqQik6IUF8fG4hPT1nLmRheSYmbiE9PWcud2Vlaz9BJiZuPT09Zy5ob3VyP0YodCxiLGQscCtlKkIsMCwwLEopLUo6ZituKkI6Rih0LGIsZCtlKkIqKG49PT1nLmRheT8xOjcpKSxlKys7ci5wdXNoKGYpO248PWcuaG91ciYmMUU0PnIubGVuZ3RoJiZxKHIsZnVuY3Rpb24oYSl7MD09PWElMThFNSYmXCIwMDAwMDAwMDBcIj09PUgoXCIlSCVNJVMlTFwiLGEpJiYobFthXT1cImRheVwiKX0pfXIuaW5mbz13KGEse2hpZ2hlclJhbmtzOmwsdG90YWxSYW5nZTpuKkJ9KTtyZXR1cm4gcn07XG5HLnByb3RvdHlwZS5ub3JtYWxpemVUaW1lVGlja0ludGVydmFsPWZ1bmN0aW9uKGEsZSl7dmFyIGM9ZXx8W1tcIm1pbGxpc2Vjb25kXCIsWzEsMiw1LDEwLDIwLDI1LDUwLDEwMCwyMDAsNTAwXV0sW1wic2Vjb25kXCIsWzEsMiw1LDEwLDE1LDMwXV0sW1wibWludXRlXCIsWzEsMiw1LDEwLDE1LDMwXV0sW1wiaG91clwiLFsxLDIsMyw0LDYsOCwxMl1dLFtcImRheVwiLFsxLDJdXSxbXCJ3ZWVrXCIsWzEsMl1dLFtcIm1vbnRoXCIsWzEsMiwzLDQsNl1dLFtcInllYXJcIixudWxsXV07ZT1jW2MubGVuZ3RoLTFdO3ZhciBiPWdbZVswXV0scj1lWzFdLGw7Zm9yKGw9MDtsPGMubGVuZ3RoJiYhKGU9Y1tsXSxiPWdbZVswXV0scj1lWzFdLGNbbCsxXSYmYTw9KGIqcltyLmxlbmd0aC0xXStnW2NbbCsxXVswXV0pLzIpO2wrKyk7Yj09PWcueWVhciYmYTw1KmImJihyPVsxLDIsNV0pO2E9eihhL2IscixcInllYXJcIj09PWVbMF0/TWF0aC5tYXgodChhL2IpLDEpOjEpO3JldHVybnt1bml0UmFuZ2U6Yixjb3VudDphLHVuaXROYW1lOmVbMF19fX0pKEwpO1xuKGZ1bmN0aW9uKGEpe3ZhciBHPWEuQXhpcyxFPWEuZ2V0TWFnbml0dWRlLEg9YS5tYXAsdj1hLm5vcm1hbGl6ZVRpY2tJbnRlcnZhbCxrPWEucGljaztHLnByb3RvdHlwZS5nZXRMb2dUaWNrUG9zaXRpb25zPWZ1bmN0aW9uKGEsdyx0LHUpe3ZhciBxPXRoaXMub3B0aW9ucyxtPXRoaXMubGVuLGc9dGhpcy5saW4ybG9nLGY9dGhpcy5sb2cybGluLGU9W107dXx8KHRoaXMuX21pbm9yQXV0b0ludGVydmFsPW51bGwpO2lmKC41PD1hKWE9TWF0aC5yb3VuZChhKSxlPXRoaXMuZ2V0TGluZWFyVGlja1Bvc2l0aW9ucyhhLHcsdCk7ZWxzZSBpZiguMDg8PWEpZm9yKHZhciBtPU1hdGguZmxvb3IodyksYyxiLHIsbCxDLHE9LjM8YT9bMSwyLDRdOi4xNTxhP1sxLDIsNCw2LDhdOlsxLDIsMyw0LDUsNiw3LDgsOV07bTx0KzEmJiFDO20rKylmb3IoYj1xLmxlbmd0aCxjPTA7YzxiJiYhQztjKyspcj1mKGcobSkqcVtjXSkscj53JiYoIXV8fGw8PXQpJiZ2b2lkIDAhPT1sJiZlLnB1c2gobCksbD50JiZcbihDPSEwKSxsPXI7ZWxzZSB3PWcodyksdD1nKHQpLGE9dT90aGlzLmdldE1pbm9yVGlja0ludGVydmFsKCk6cS50aWNrSW50ZXJ2YWwsYT1rKFwiYXV0b1wiPT09YT9udWxsOmEsdGhpcy5fbWlub3JBdXRvSW50ZXJ2YWwscS50aWNrUGl4ZWxJbnRlcnZhbC8odT81OjEpKih0LXcpLygodT9tL3RoaXMudGlja1Bvc2l0aW9ucy5sZW5ndGg6bSl8fDEpKSxhPXYoYSxudWxsLEUoYSkpLGU9SCh0aGlzLmdldExpbmVhclRpY2tQb3NpdGlvbnMoYSx3LHQpLGYpLHV8fCh0aGlzLl9taW5vckF1dG9JbnRlcnZhbD1hLzUpO3V8fCh0aGlzLnRpY2tJbnRlcnZhbD1hKTtyZXR1cm4gZX07Ry5wcm90b3R5cGUubG9nMmxpbj1mdW5jdGlvbihhKXtyZXR1cm4gTWF0aC5sb2coYSkvTWF0aC5MTjEwfTtHLnByb3RvdHlwZS5saW4ybG9nPWZ1bmN0aW9uKGEpe3JldHVybiBNYXRoLnBvdygxMCxhKX19KShMKTsoZnVuY3Rpb24oYSxHKXt2YXIgRT1hLmFycmF5TWF4LEg9YS5hcnJheU1pbix2PWEuZGVmaW5lZCxcbms9YS5kZXN0cm95T2JqZWN0UHJvcGVydGllcyxxPWEuZWFjaCx3PWEuZXJhc2UsdD1hLm1lcmdlLHU9YS5waWNrO2EuUGxvdExpbmVPckJhbmQ9ZnVuY3Rpb24oYSxtKXt0aGlzLmF4aXM9YTttJiYodGhpcy5vcHRpb25zPW0sdGhpcy5pZD1tLmlkKX07YS5QbG90TGluZU9yQmFuZC5wcm90b3R5cGU9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciBrPXRoaXMsbT1rLmF4aXMsZz1tLmhvcml6LGY9ay5vcHRpb25zLGU9Zi5sYWJlbCxjPWsubGFiZWwsYj1mLnRvLHI9Zi5mcm9tLGw9Zi52YWx1ZSxDPXYocikmJnYoYikscT12KGwpLHg9ay5zdmdFbGVtLEY9IXgsbj1bXSxCPWYuY29sb3IsSj11KGYuekluZGV4LDApLEE9Zi5ldmVudHMsbj17XCJjbGFzc1wiOlwiaGlnaGNoYXJ0cy1wbG90LVwiKyhDP1wiYmFuZCBcIjpcImxpbmUgXCIpKyhmLmNsYXNzTmFtZXx8XCJcIil9LGQ9e30scD1tLmNoYXJ0LnJlbmRlcmVyLEQ9Qz9cImJhbmRzXCI6XCJsaW5lc1wiLGg9bS5sb2cybGluO20uaXNMb2cmJihyPWgociksYj1oKGIpLFxubD1oKGwpKTtxPyhuPXtzdHJva2U6QixcInN0cm9rZS13aWR0aFwiOmYud2lkdGh9LGYuZGFzaFN0eWxlJiYobi5kYXNoc3R5bGU9Zi5kYXNoU3R5bGUpKTpDJiYoQiYmKG4uZmlsbD1CKSxmLmJvcmRlcldpZHRoJiYobi5zdHJva2U9Zi5ib3JkZXJDb2xvcixuW1wic3Ryb2tlLXdpZHRoXCJdPWYuYm9yZGVyV2lkdGgpKTtkLnpJbmRleD1KO0QrPVwiLVwiK0o7KEI9bS5wbG90TGluZXNBbmRCYW5kc0dyb3Vwc1tEXSl8fChtLnBsb3RMaW5lc0FuZEJhbmRzR3JvdXBzW0RdPUI9cC5nKFwicGxvdC1cIitEKS5hdHRyKGQpLmFkZCgpKTtGJiYoay5zdmdFbGVtPXg9cC5wYXRoKCkuYXR0cihuKS5hZGQoQikpO2lmKHEpbj1tLmdldFBsb3RMaW5lUGF0aChsLHguc3Ryb2tlV2lkdGgoKSk7ZWxzZSBpZihDKW49bS5nZXRQbG90QmFuZFBhdGgocixiLGYpO2Vsc2UgcmV0dXJuO0YmJm4mJm4ubGVuZ3RoPyh4LmF0dHIoe2Q6bn0pLEEmJmEub2JqZWN0RWFjaChBLGZ1bmN0aW9uKGEsZCl7eC5vbihkLGZ1bmN0aW9uKGEpe0FbZF0uYXBwbHkoayxcblthXSl9KX0pKTp4JiYobj8oeC5zaG93KCkseC5hbmltYXRlKHtkOm59KSk6KHguaGlkZSgpLGMmJihrLmxhYmVsPWM9Yy5kZXN0cm95KCkpKSk7ZSYmdihlLnRleHQpJiZuJiZuLmxlbmd0aCYmMDxtLndpZHRoJiYwPG0uaGVpZ2h0JiYhbi5mbGF0PyhlPXQoe2FsaWduOmcmJkMmJlwiY2VudGVyXCIseDpnPyFDJiY0OjEwLHZlcnRpY2FsQWxpZ246IWcmJkMmJlwibWlkZGxlXCIseTpnP0M/MTY6MTA6Qz82Oi00LHJvdGF0aW9uOmcmJiFDJiY5MH0sZSksdGhpcy5yZW5kZXJMYWJlbChlLG4sQyxKKSk6YyYmYy5oaWRlKCk7cmV0dXJuIGt9LHJlbmRlckxhYmVsOmZ1bmN0aW9uKGEsbSxnLGYpe3ZhciBlPXRoaXMubGFiZWwsYz10aGlzLmF4aXMuY2hhcnQucmVuZGVyZXI7ZXx8KGU9e2FsaWduOmEudGV4dEFsaWdufHxhLmFsaWduLHJvdGF0aW9uOmEucm90YXRpb24sXCJjbGFzc1wiOlwiaGlnaGNoYXJ0cy1wbG90LVwiKyhnP1wiYmFuZFwiOlwibGluZVwiKStcIi1sYWJlbCBcIisoYS5jbGFzc05hbWV8fFwiXCIpfSxcbmUuekluZGV4PWYsdGhpcy5sYWJlbD1lPWMudGV4dChhLnRleHQsMCwwLGEudXNlSFRNTCkuYXR0cihlKS5hZGQoKSxlLmNzcyhhLnN0eWxlKSk7Zj1tLnhCb3VuZHN8fFttWzFdLG1bNF0sZz9tWzZdOm1bMV1dO209bS55Qm91bmRzfHxbbVsyXSxtWzVdLGc/bVs3XTptWzJdXTtnPUgoZik7Yz1IKG0pO2UuYWxpZ24oYSwhMSx7eDpnLHk6Yyx3aWR0aDpFKGYpLWcsaGVpZ2h0OkUobSktY30pO2Uuc2hvdygpfSxkZXN0cm95OmZ1bmN0aW9uKCl7dyh0aGlzLmF4aXMucGxvdExpbmVzQW5kQmFuZHMsdGhpcyk7ZGVsZXRlIHRoaXMuYXhpcztrKHRoaXMpfX07YS5leHRlbmQoRy5wcm90b3R5cGUse2dldFBsb3RCYW5kUGF0aDpmdW5jdGlvbihhLG0pe3ZhciBnPXRoaXMuZ2V0UGxvdExpbmVQYXRoKG0sbnVsbCxudWxsLCEwKSxmPXRoaXMuZ2V0UGxvdExpbmVQYXRoKGEsbnVsbCxudWxsLCEwKSxlPVtdLGM9dGhpcy5ob3JpeixiPTEscjthPWE8dGhpcy5taW4mJm08dGhpcy5taW58fGE+dGhpcy5tYXgmJlxubT50aGlzLm1heDtpZihmJiZnKWZvcihhJiYocj1mLnRvU3RyaW5nKCk9PT1nLnRvU3RyaW5nKCksYj0wKSxhPTA7YTxmLmxlbmd0aDthKz02KWMmJmdbYSsxXT09PWZbYSsxXT8oZ1thKzFdKz1iLGdbYSs0XSs9Yik6Y3x8Z1thKzJdIT09ZlthKzJdfHwoZ1thKzJdKz1iLGdbYSs1XSs9YiksZS5wdXNoKFwiTVwiLGZbYSsxXSxmW2ErMl0sXCJMXCIsZlthKzRdLGZbYSs1XSxnW2ErNF0sZ1thKzVdLGdbYSsxXSxnW2ErMl0sXCJ6XCIpLGUuZmxhdD1yO3JldHVybiBlfSxhZGRQbG90QmFuZDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5hZGRQbG90QmFuZE9yTGluZShhLFwicGxvdEJhbmRzXCIpfSxhZGRQbG90TGluZTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5hZGRQbG90QmFuZE9yTGluZShhLFwicGxvdExpbmVzXCIpfSxhZGRQbG90QmFuZE9yTGluZTpmdW5jdGlvbihrLG0pe3ZhciBnPShuZXcgYS5QbG90TGluZU9yQmFuZCh0aGlzLGspKS5yZW5kZXIoKSxmPXRoaXMudXNlck9wdGlvbnM7ZyYmKG0mJlxuKGZbbV09ZlttXXx8W10sZlttXS5wdXNoKGspKSx0aGlzLnBsb3RMaW5lc0FuZEJhbmRzLnB1c2goZykpO3JldHVybiBnfSxyZW1vdmVQbG90QmFuZE9yTGluZTpmdW5jdGlvbihhKXtmb3IodmFyIG09dGhpcy5wbG90TGluZXNBbmRCYW5kcyxnPXRoaXMub3B0aW9ucyxmPXRoaXMudXNlck9wdGlvbnMsZT1tLmxlbmd0aDtlLS07KW1bZV0uaWQ9PT1hJiZtW2VdLmRlc3Ryb3koKTtxKFtnLnBsb3RMaW5lc3x8W10sZi5wbG90TGluZXN8fFtdLGcucGxvdEJhbmRzfHxbXSxmLnBsb3RCYW5kc3x8W11dLGZ1bmN0aW9uKGMpe2ZvcihlPWMubGVuZ3RoO2UtLTspY1tlXS5pZD09PWEmJncoYyxjW2VdKX0pfSxyZW1vdmVQbG90QmFuZDpmdW5jdGlvbihhKXt0aGlzLnJlbW92ZVBsb3RCYW5kT3JMaW5lKGEpfSxyZW1vdmVQbG90TGluZTpmdW5jdGlvbihhKXt0aGlzLnJlbW92ZVBsb3RCYW5kT3JMaW5lKGEpfX0pfSkoTCxaKTsoZnVuY3Rpb24oYSl7dmFyIEc9YS5kYXRlRm9ybWF0LEU9YS5lYWNoLFxuSD1hLmV4dGVuZCx2PWEuZm9ybWF0LGs9YS5pc051bWJlcixxPWEubWFwLHc9YS5tZXJnZSx0PWEucGljayx1PWEuc3BsYXQsej1hLnN5bmNUaW1lb3V0LG09YS50aW1lVW5pdHM7YS5Ub29sdGlwPWZ1bmN0aW9uKCl7dGhpcy5pbml0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX07YS5Ub29sdGlwLnByb3RvdHlwZT17aW5pdDpmdW5jdGlvbihhLGYpe3RoaXMuY2hhcnQ9YTt0aGlzLm9wdGlvbnM9Zjt0aGlzLmNyb3NzaGFpcnM9W107dGhpcy5ub3c9e3g6MCx5OjB9O3RoaXMuaXNIaWRkZW49ITA7dGhpcy5zcGxpdD1mLnNwbGl0JiYhYS5pbnZlcnRlZDt0aGlzLnNoYXJlZD1mLnNoYXJlZHx8dGhpcy5zcGxpdH0sY2xlYW5TcGxpdDpmdW5jdGlvbihhKXtFKHRoaXMuY2hhcnQuc2VyaWVzLGZ1bmN0aW9uKGYpe3ZhciBlPWYmJmYudHQ7ZSYmKCFlLmlzQWN0aXZlfHxhP2YudHQ9ZS5kZXN0cm95KCk6ZS5pc0FjdGl2ZT0hMSl9KX0sZ2V0TGFiZWw6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0LnJlbmRlcmVyLFxuZj10aGlzLm9wdGlvbnM7dGhpcy5sYWJlbHx8KHRoaXMuc3BsaXQ/dGhpcy5sYWJlbD1hLmcoXCJ0b29sdGlwXCIpOih0aGlzLmxhYmVsPWEubGFiZWwoXCJcIiwwLDAsZi5zaGFwZXx8XCJjYWxsb3V0XCIsbnVsbCxudWxsLGYudXNlSFRNTCxudWxsLFwidG9vbHRpcFwiKS5hdHRyKHtwYWRkaW5nOmYucGFkZGluZyxyOmYuYm9yZGVyUmFkaXVzfSksdGhpcy5sYWJlbC5hdHRyKHtmaWxsOmYuYmFja2dyb3VuZENvbG9yLFwic3Ryb2tlLXdpZHRoXCI6Zi5ib3JkZXJXaWR0aH0pLmNzcyhmLnN0eWxlKS5zaGFkb3coZi5zaGFkb3cpKSx0aGlzLmxhYmVsLmF0dHIoe3pJbmRleDo4fSkuYWRkKCkpO3JldHVybiB0aGlzLmxhYmVsfSx1cGRhdGU6ZnVuY3Rpb24oYSl7dGhpcy5kZXN0cm95KCk7dyghMCx0aGlzLmNoYXJ0Lm9wdGlvbnMudG9vbHRpcC51c2VyT3B0aW9ucyxhKTt0aGlzLmluaXQodGhpcy5jaGFydCx3KCEwLHRoaXMub3B0aW9ucyxhKSl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt0aGlzLmxhYmVsJiZcbih0aGlzLmxhYmVsPXRoaXMubGFiZWwuZGVzdHJveSgpKTt0aGlzLnNwbGl0JiZ0aGlzLnR0JiYodGhpcy5jbGVhblNwbGl0KHRoaXMuY2hhcnQsITApLHRoaXMudHQ9dGhpcy50dC5kZXN0cm95KCkpO2NsZWFyVGltZW91dCh0aGlzLmhpZGVUaW1lcik7Y2xlYXJUaW1lb3V0KHRoaXMudG9vbHRpcFRpbWVvdXQpfSxtb3ZlOmZ1bmN0aW9uKGEsZixlLGMpe3ZhciBiPXRoaXMscj1iLm5vdyxsPSExIT09Yi5vcHRpb25zLmFuaW1hdGlvbiYmIWIuaXNIaWRkZW4mJigxPE1hdGguYWJzKGEtci54KXx8MTxNYXRoLmFicyhmLXIueSkpLGc9Yi5mb2xsb3dQb2ludGVyfHwxPGIubGVuO0gocix7eDpsPygyKnIueCthKS8zOmEseTpsPyhyLnkrZikvMjpmLGFuY2hvclg6Zz92b2lkIDA6bD8oMipyLmFuY2hvclgrZSkvMzplLGFuY2hvclk6Zz92b2lkIDA6bD8oci5hbmNob3JZK2MpLzI6Y30pO2IuZ2V0TGFiZWwoKS5hdHRyKHIpO2wmJihjbGVhclRpbWVvdXQodGhpcy50b29sdGlwVGltZW91dCksXG50aGlzLnRvb2x0aXBUaW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtiJiZiLm1vdmUoYSxmLGUsYyl9LDMyKSl9LGhpZGU6ZnVuY3Rpb24oYSl7dmFyIGY9dGhpcztjbGVhclRpbWVvdXQodGhpcy5oaWRlVGltZXIpO2E9dChhLHRoaXMub3B0aW9ucy5oaWRlRGVsYXksNTAwKTt0aGlzLmlzSGlkZGVufHwodGhpcy5oaWRlVGltZXI9eihmdW5jdGlvbigpe2YuZ2V0TGFiZWwoKVthP1wiZmFkZU91dFwiOlwiaGlkZVwiXSgpO2YuaXNIaWRkZW49ITB9LGEpKX0sZ2V0QW5jaG9yOmZ1bmN0aW9uKGEsZil7dmFyIGUsYz10aGlzLmNoYXJ0LGI9Yy5pbnZlcnRlZCxyPWMucGxvdFRvcCxsPWMucGxvdExlZnQsZz0wLG09MCx4LEY7YT11KGEpO2U9YVswXS50b29sdGlwUG9zO3RoaXMuZm9sbG93UG9pbnRlciYmZiYmKHZvaWQgMD09PWYuY2hhcnRYJiYoZj1jLnBvaW50ZXIubm9ybWFsaXplKGYpKSxlPVtmLmNoYXJ0WC1jLnBsb3RMZWZ0LGYuY2hhcnRZLXJdKTtlfHwoRShhLGZ1bmN0aW9uKGEpe3g9XG5hLnNlcmllcy55QXhpcztGPWEuc2VyaWVzLnhBeGlzO2crPWEucGxvdFgrKCFiJiZGP0YubGVmdC1sOjApO20rPShhLnBsb3RMb3c/KGEucGxvdExvdythLnBsb3RIaWdoKS8yOmEucGxvdFkpKyghYiYmeD94LnRvcC1yOjApfSksZy89YS5sZW5ndGgsbS89YS5sZW5ndGgsZT1bYj9jLnBsb3RXaWR0aC1tOmcsdGhpcy5zaGFyZWQmJiFiJiYxPGEubGVuZ3RoJiZmP2YuY2hhcnRZLXI6Yj9jLnBsb3RIZWlnaHQtZzptXSk7cmV0dXJuIHEoZSxNYXRoLnJvdW5kKX0sZ2V0UG9zaXRpb246ZnVuY3Rpb24oYSxmLGUpe3ZhciBjPXRoaXMuY2hhcnQsYj10aGlzLmRpc3RhbmNlLHI9e30sbD1jLmludmVydGVkJiZlLmh8fDAsZyxtPVtcInlcIixjLmNoYXJ0SGVpZ2h0LGYsZS5wbG90WStjLnBsb3RUb3AsYy5wbG90VG9wLGMucGxvdFRvcCtjLnBsb3RIZWlnaHRdLHg9W1wieFwiLGMuY2hhcnRXaWR0aCxhLGUucGxvdFgrYy5wbG90TGVmdCxjLnBsb3RMZWZ0LGMucGxvdExlZnQrYy5wbG90V2lkdGhdLFxuRj0hdGhpcy5mb2xsb3dQb2ludGVyJiZ0KGUudHRCZWxvdywhYy5pbnZlcnRlZD09PSEhZS5uZWdhdGl2ZSksbj1mdW5jdGlvbihhLGMsZSxoLG4sQSl7dmFyIGQ9ZTxoLWIscD1oK2IrZTxjLGY9aC1iLWU7aCs9YjtpZihGJiZwKXJbYV09aDtlbHNlIGlmKCFGJiZkKXJbYV09ZjtlbHNlIGlmKGQpclthXT1NYXRoLm1pbihBLWUsMD5mLWw/ZjpmLWwpO2Vsc2UgaWYocClyW2FdPU1hdGgubWF4KG4saCtsK2U+Yz9oOmgrbCk7ZWxzZSByZXR1cm4hMX0sQj1mdW5jdGlvbihhLGMsZSxoKXt2YXIgZDtoPGJ8fGg+Yy1iP2Q9ITE6clthXT1oPGUvMj8xOmg+Yy1lLzI/Yy1lLTI6aC1lLzI7cmV0dXJuIGR9LGs9ZnVuY3Rpb24oYSl7dmFyIGQ9bTttPXg7eD1kO2c9YX0sQT1mdW5jdGlvbigpeyExIT09bi5hcHBseSgwLG0pPyExIT09Qi5hcHBseSgwLHgpfHxnfHwoayghMCksQSgpKTpnP3IueD1yLnk9MDooayghMCksQSgpKX07KGMuaW52ZXJ0ZWR8fDE8dGhpcy5sZW4pJiZrKCk7QSgpO3JldHVybiByfSxcbmRlZmF1bHRGb3JtYXR0ZXI6ZnVuY3Rpb24oYSl7dmFyIGY9dGhpcy5wb2ludHN8fHUodGhpcyksZTtlPVthLnRvb2x0aXBGb290ZXJIZWFkZXJGb3JtYXR0ZXIoZlswXSldO2U9ZS5jb25jYXQoYS5ib2R5Rm9ybWF0dGVyKGYpKTtlLnB1c2goYS50b29sdGlwRm9vdGVySGVhZGVyRm9ybWF0dGVyKGZbMF0sITApKTtyZXR1cm4gZX0scmVmcmVzaDpmdW5jdGlvbihhLGYpe3ZhciBlLGM9dGhpcy5vcHRpb25zLGIscj1hLGwsZz17fSxtPVtdO2U9Yy5mb3JtYXR0ZXJ8fHRoaXMuZGVmYXVsdEZvcm1hdHRlcjt2YXIgZz10aGlzLnNoYXJlZCx4O2MuZW5hYmxlZCYmKGNsZWFyVGltZW91dCh0aGlzLmhpZGVUaW1lciksdGhpcy5mb2xsb3dQb2ludGVyPXUocilbMF0uc2VyaWVzLnRvb2x0aXBPcHRpb25zLmZvbGxvd1BvaW50ZXIsbD10aGlzLmdldEFuY2hvcihyLGYpLGY9bFswXSxiPWxbMV0sIWd8fHIuc2VyaWVzJiZyLnNlcmllcy5ub1NoYXJlZFRvb2x0aXA/Zz1yLmdldExhYmVsQ29uZmlnKCk6XG4oRShyLGZ1bmN0aW9uKGEpe2Euc2V0U3RhdGUoXCJob3ZlclwiKTttLnB1c2goYS5nZXRMYWJlbENvbmZpZygpKX0pLGc9e3g6clswXS5jYXRlZ29yeSx5OnJbMF0ueX0sZy5wb2ludHM9bSxyPXJbMF0pLHRoaXMubGVuPW0ubGVuZ3RoLGc9ZS5jYWxsKGcsdGhpcykseD1yLnNlcmllcyx0aGlzLmRpc3RhbmNlPXQoeC50b29sdGlwT3B0aW9ucy5kaXN0YW5jZSwxNiksITE9PT1nP3RoaXMuaGlkZSgpOihlPXRoaXMuZ2V0TGFiZWwoKSx0aGlzLmlzSGlkZGVuJiZlLmF0dHIoe29wYWNpdHk6MX0pLnNob3coKSx0aGlzLnNwbGl0P3RoaXMucmVuZGVyU3BsaXQoZyx1KGEpKTooYy5zdHlsZS53aWR0aHx8ZS5jc3Moe3dpZHRoOnRoaXMuY2hhcnQuc3BhY2luZ0JveC53aWR0aH0pLGUuYXR0cih7dGV4dDpnJiZnLmpvaW4/Zy5qb2luKFwiXCIpOmd9KSxlLnJlbW92ZUNsYXNzKC9oaWdoY2hhcnRzLWNvbG9yLVtcXGRdKy9nKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtY29sb3ItXCIrdChyLmNvbG9ySW5kZXgsXG54LmNvbG9ySW5kZXgpKSxlLmF0dHIoe3N0cm9rZTpjLmJvcmRlckNvbG9yfHxyLmNvbG9yfHx4LmNvbG9yfHxcIiM2NjY2NjZcIn0pLHRoaXMudXBkYXRlUG9zaXRpb24oe3Bsb3RYOmYscGxvdFk6YixuZWdhdGl2ZTpyLm5lZ2F0aXZlLHR0QmVsb3c6ci50dEJlbG93LGg6bFsyXXx8MH0pKSx0aGlzLmlzSGlkZGVuPSExKSl9LHJlbmRlclNwbGl0OmZ1bmN0aW9uKGcsZil7dmFyIGU9dGhpcyxjPVtdLGI9dGhpcy5jaGFydCxyPWIucmVuZGVyZXIsbD0hMCxtPXRoaXMub3B0aW9ucyxrPTAseD10aGlzLmdldExhYmVsKCk7YS5pc1N0cmluZyhnKSYmKGc9WyExLGddKTtFKGcuc2xpY2UoMCxmLmxlbmd0aCsxKSxmdW5jdGlvbihhLG4pe2lmKCExIT09YSl7bj1mW24tMV18fHtpc0hlYWRlcjohMCxwbG90WDpmWzBdLnBsb3RYfTt2YXIgZz1uLnNlcmllc3x8ZSxDPWcudHQsQT1uLnNlcmllc3x8e30sZD1cImhpZ2hjaGFydHMtY29sb3ItXCIrdChuLmNvbG9ySW5kZXgsQS5jb2xvckluZGV4LFwibm9uZVwiKTtcbkN8fChnLnR0PUM9ci5sYWJlbChudWxsLG51bGwsbnVsbCxcImNhbGxvdXRcIixudWxsLG51bGwsbS51c2VIVE1MKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtdG9vbHRpcC1ib3ggXCIrZCkuYXR0cih7cGFkZGluZzptLnBhZGRpbmcscjptLmJvcmRlclJhZGl1cyxmaWxsOm0uYmFja2dyb3VuZENvbG9yLHN0cm9rZTptLmJvcmRlckNvbG9yfHxuLmNvbG9yfHxBLmNvbG9yfHxcIiMzMzMzMzNcIixcInN0cm9rZS13aWR0aFwiOm0uYm9yZGVyV2lkdGh9KS5hZGQoeCkpO0MuaXNBY3RpdmU9ITA7Qy5hdHRyKHt0ZXh0OmF9KTtDLmNzcyhtLnN0eWxlKS5zaGFkb3cobS5zaGFkb3cpO2E9Qy5nZXRCQm94KCk7QT1hLndpZHRoK0Muc3Ryb2tlV2lkdGgoKTtuLmlzSGVhZGVyPyhrPWEuaGVpZ2h0LEE9TWF0aC5tYXgoMCxNYXRoLm1pbihuLnBsb3RYK2IucGxvdExlZnQtQS8yLGIuY2hhcnRXaWR0aC1BKSkpOkE9bi5wbG90WCtiLnBsb3RMZWZ0LXQobS5kaXN0YW5jZSwxNiktQTswPkEmJihsPSExKTthPShuLnNlcmllcyYmXG5uLnNlcmllcy55QXhpcyYmbi5zZXJpZXMueUF4aXMucG9zKSsobi5wbG90WXx8MCk7YS09Yi5wbG90VG9wO2MucHVzaCh7dGFyZ2V0Om4uaXNIZWFkZXI/Yi5wbG90SGVpZ2h0K2s6YSxyYW5rOm4uaXNIZWFkZXI/MTowLHNpemU6Zy50dC5nZXRCQm94KCkuaGVpZ2h0KzEscG9pbnQ6bix4OkEsdHQ6Q30pfX0pO3RoaXMuY2xlYW5TcGxpdCgpO2EuZGlzdHJpYnV0ZShjLGIucGxvdEhlaWdodCtrKTtFKGMsZnVuY3Rpb24oYSl7dmFyIGM9YS5wb2ludCxlPWMuc2VyaWVzO2EudHQuYXR0cih7dmlzaWJpbGl0eTp2b2lkIDA9PT1hLnBvcz9cImhpZGRlblwiOlwiaW5oZXJpdFwiLHg6bHx8Yy5pc0hlYWRlcj9hLng6Yy5wbG90WCtiLnBsb3RMZWZ0K3QobS5kaXN0YW5jZSwxNikseTphLnBvcytiLnBsb3RUb3AsYW5jaG9yWDpjLmlzSGVhZGVyP2MucGxvdFgrYi5wbG90TGVmdDpjLnBsb3RYK2UueEF4aXMucG9zLGFuY2hvclk6Yy5pc0hlYWRlcj9hLnBvcytiLnBsb3RUb3AtMTU6Yy5wbG90WStlLnlBeGlzLnBvc30pfSl9LFxudXBkYXRlUG9zaXRpb246ZnVuY3Rpb24oYSl7dmFyIGY9dGhpcy5jaGFydCxlPXRoaXMuZ2V0TGFiZWwoKSxlPSh0aGlzLm9wdGlvbnMucG9zaXRpb25lcnx8dGhpcy5nZXRQb3NpdGlvbikuY2FsbCh0aGlzLGUud2lkdGgsZS5oZWlnaHQsYSk7dGhpcy5tb3ZlKE1hdGgucm91bmQoZS54KSxNYXRoLnJvdW5kKGUueXx8MCksYS5wbG90WCtmLnBsb3RMZWZ0LGEucGxvdFkrZi5wbG90VG9wKX0sZ2V0RGF0ZUZvcm1hdDpmdW5jdGlvbihhLGYsZSxjKXt2YXIgYj1HKFwiJW0tJWQgJUg6JU06JVMuJUxcIixmKSxyLGwsZz17bWlsbGlzZWNvbmQ6MTUsc2Vjb25kOjEyLG1pbnV0ZTo5LGhvdXI6NixkYXk6M30saz1cIm1pbGxpc2Vjb25kXCI7Zm9yKGwgaW4gbSl7aWYoYT09PW0ud2VlayYmK0coXCIld1wiLGYpPT09ZSYmXCIwMDowMDowMC4wMDBcIj09PWIuc3Vic3RyKDYpKXtsPVwid2Vla1wiO2JyZWFrfWlmKG1bbF0+YSl7bD1rO2JyZWFrfWlmKGdbbF0mJmIuc3Vic3RyKGdbbF0pIT09XCIwMS0wMSAwMDowMDowMC4wMDBcIi5zdWJzdHIoZ1tsXSkpYnJlYWs7XG5cIndlZWtcIiE9PWwmJihrPWwpfWwmJihyPWNbbF0pO3JldHVybiByfSxnZXRYRGF0ZUZvcm1hdDpmdW5jdGlvbihhLGYsZSl7Zj1mLmRhdGVUaW1lTGFiZWxGb3JtYXRzO3ZhciBjPWUmJmUuY2xvc2VzdFBvaW50UmFuZ2U7cmV0dXJuKGM/dGhpcy5nZXREYXRlRm9ybWF0KGMsYS54LGUub3B0aW9ucy5zdGFydE9mV2VlayxmKTpmLmRheSl8fGYueWVhcn0sdG9vbHRpcEZvb3RlckhlYWRlckZvcm1hdHRlcjpmdW5jdGlvbihhLGYpe2Y9Zj9cImZvb3RlclwiOlwiaGVhZGVyXCI7dmFyIGU9YS5zZXJpZXMsYz1lLnRvb2x0aXBPcHRpb25zLGI9Yy54RGF0ZUZvcm1hdCxyPWUueEF4aXMsbD1yJiZcImRhdGV0aW1lXCI9PT1yLm9wdGlvbnMudHlwZSYmayhhLmtleSksZz1jW2YrXCJGb3JtYXRcIl07bCYmIWImJihiPXRoaXMuZ2V0WERhdGVGb3JtYXQoYSxjLHIpKTtsJiZiJiZFKGEucG9pbnQmJmEucG9pbnQudG9vbHRpcERhdGVLZXlzfHxbXCJrZXlcIl0sZnVuY3Rpb24oYSl7Zz1nLnJlcGxhY2UoXCJ7cG9pbnQuXCIrXG5hK1wifVwiLFwie3BvaW50LlwiK2ErXCI6XCIrYitcIn1cIil9KTtyZXR1cm4gdihnLHtwb2ludDphLHNlcmllczplfSl9LGJvZHlGb3JtYXR0ZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIHEoYSxmdW5jdGlvbihhKXt2YXIgZT1hLnNlcmllcy50b29sdGlwT3B0aW9ucztyZXR1cm4oZVsoYS5wb2ludC5mb3JtYXRQcmVmaXh8fFwicG9pbnRcIikrXCJGb3JtYXR0ZXJcIl18fGEucG9pbnQudG9vbHRpcEZvcm1hdHRlcikuY2FsbChhLnBvaW50LGVbKGEucG9pbnQuZm9ybWF0UHJlZml4fHxcInBvaW50XCIpK1wiRm9ybWF0XCJdKX0pfX19KShMKTsoZnVuY3Rpb24oYSl7dmFyIEc9YS5hZGRFdmVudCxFPWEuYXR0cixIPWEuY2hhcnRzLHY9YS5jb2xvcixrPWEuY3NzLHE9YS5kZWZpbmVkLHc9YS5lYWNoLHQ9YS5leHRlbmQsdT1hLmZpbmQsej1hLmZpcmVFdmVudCxtPWEuaXNPYmplY3QsZz1hLm9mZnNldCxmPWEucGljayxlPWEuc3BsYXQsYz1hLlRvb2x0aXA7YS5Qb2ludGVyPWZ1bmN0aW9uKGEsYyl7dGhpcy5pbml0KGEsXG5jKX07YS5Qb2ludGVyLnByb3RvdHlwZT17aW5pdDpmdW5jdGlvbihhLGUpe3RoaXMub3B0aW9ucz1lO3RoaXMuY2hhcnQ9YTt0aGlzLnJ1bkNoYXJ0Q2xpY2s9ZS5jaGFydC5ldmVudHMmJiEhZS5jaGFydC5ldmVudHMuY2xpY2s7dGhpcy5waW5jaERvd249W107dGhpcy5sYXN0VmFsaWRUb3VjaD17fTtjJiYoYS50b29sdGlwPW5ldyBjKGEsZS50b29sdGlwKSx0aGlzLmZvbGxvd1RvdWNoTW92ZT1mKGUudG9vbHRpcC5mb2xsb3dUb3VjaE1vdmUsITApKTt0aGlzLnNldERPTUV2ZW50cygpfSx6b29tT3B0aW9uOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY2hhcnQsYz1iLm9wdGlvbnMuY2hhcnQsZT1jLnpvb21UeXBlfHxcIlwiLGI9Yi5pbnZlcnRlZDsvdG91Y2gvLnRlc3QoYS50eXBlKSYmKGU9ZihjLnBpbmNoVHlwZSxlKSk7dGhpcy56b29tWD1hPS94Ly50ZXN0KGUpO3RoaXMuem9vbVk9ZT0veS8udGVzdChlKTt0aGlzLnpvb21Ib3I9YSYmIWJ8fGUmJmI7dGhpcy56b29tVmVydD1lJiZcbiFifHxhJiZiO3RoaXMuaGFzWm9vbT1hfHxlfSxub3JtYWxpemU6ZnVuY3Rpb24oYSxjKXt2YXIgYjtiPWEudG91Y2hlcz9hLnRvdWNoZXMubGVuZ3RoP2EudG91Y2hlcy5pdGVtKDApOmEuY2hhbmdlZFRvdWNoZXNbMF06YTtjfHwodGhpcy5jaGFydFBvc2l0aW9uPWM9Zyh0aGlzLmNoYXJ0LmNvbnRhaW5lcikpO3JldHVybiB0KGEse2NoYXJ0WDpNYXRoLnJvdW5kKGIucGFnZVgtYy5sZWZ0KSxjaGFydFk6TWF0aC5yb3VuZChiLnBhZ2VZLWMudG9wKX0pfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbihhKXt2YXIgYj17eEF4aXM6W10seUF4aXM6W119O3codGhpcy5jaGFydC5heGVzLGZ1bmN0aW9uKGMpe2JbYy5pc1hBeGlzP1wieEF4aXNcIjpcInlBeGlzXCJdLnB1c2goe2F4aXM6Yyx2YWx1ZTpjLnRvVmFsdWUoYVtjLmhvcml6P1wiY2hhcnRYXCI6XCJjaGFydFlcIl0pfSl9KTtyZXR1cm4gYn0sZmluZE5lYXJlc3RLRFBvaW50OmZ1bmN0aW9uKGEsYyxlKXt2YXIgYjt3KGEsZnVuY3Rpb24oYSl7dmFyIGw9XG4hKGEubm9TaGFyZWRUb29sdGlwJiZjKSYmMD5hLm9wdGlvbnMuZmluZE5lYXJlc3RQb2ludEJ5LmluZGV4T2YoXCJ5XCIpO2E9YS5zZWFyY2hQb2ludChlLGwpO2lmKChsPW0oYSwhMCkpJiYhKGw9IW0oYiwhMCkpKXZhciBsPWIuZGlzdFgtYS5kaXN0WCxyPWIuZGlzdC1hLmRpc3Qsbj0oYS5zZXJpZXMuZ3JvdXAmJmEuc2VyaWVzLmdyb3VwLnpJbmRleCktKGIuc2VyaWVzLmdyb3VwJiZiLnNlcmllcy5ncm91cC56SW5kZXgpLGw9MDwoMCE9PWwmJmM/bDowIT09cj9yOjAhPT1uP246Yi5zZXJpZXMuaW5kZXg+YS5zZXJpZXMuaW5kZXg/LTE6MSk7bCYmKGI9YSl9KTtyZXR1cm4gYn0sZ2V0UG9pbnRGcm9tRXZlbnQ6ZnVuY3Rpb24oYSl7YT1hLnRhcmdldDtmb3IodmFyIGI7YSYmIWI7KWI9YS5wb2ludCxhPWEucGFyZW50Tm9kZTtyZXR1cm4gYn0sZ2V0Q2hhcnRDb29yZGluYXRlc0Zyb21Qb2ludDpmdW5jdGlvbihhLGMpe3ZhciBiPWEuc2VyaWVzLGU9Yi54QXhpcyxiPWIueUF4aXMscj1cbmYoYS5jbGllbnRYLGEucGxvdFgpO2lmKGUmJmIpcmV0dXJuIGM/e2NoYXJ0WDplLmxlbitlLnBvcy1yLGNoYXJ0WTpiLmxlbitiLnBvcy1hLnBsb3RZfTp7Y2hhcnRYOnIrZS5wb3MsY2hhcnRZOmEucGxvdFkrYi5wb3N9fSxnZXRIb3ZlckRhdGE6ZnVuY3Rpb24oYixjLGUsZyxrLHgsRil7dmFyIG4sbD1bXSxyPUYmJkYuaXNCb29zdGluZztnPSEoIWd8fCFiKTtGPWMmJiFjLnN0aWNreVRyYWNraW5nP1tjXTphLmdyZXAoZSxmdW5jdGlvbihhKXtyZXR1cm4gYS52aXNpYmxlJiYhKCFrJiZhLmRpcmVjdFRvdWNoKSYmZihhLm9wdGlvbnMuZW5hYmxlTW91c2VUcmFja2luZywhMCkmJmEuc3RpY2t5VHJhY2tpbmd9KTtjPShuPWc/Yjp0aGlzLmZpbmROZWFyZXN0S0RQb2ludChGLGsseCkpJiZuLnNlcmllcztuJiYoayYmIWMubm9TaGFyZWRUb29sdGlwPyhGPWEuZ3JlcChlLGZ1bmN0aW9uKGEpe3JldHVybiBhLnZpc2libGUmJiEoIWsmJmEuZGlyZWN0VG91Y2gpJiZmKGEub3B0aW9ucy5lbmFibGVNb3VzZVRyYWNraW5nLFxuITApJiYhYS5ub1NoYXJlZFRvb2x0aXB9KSx3KEYsZnVuY3Rpb24oYSl7dmFyIGQ9dShhLnBvaW50cyxmdW5jdGlvbihhKXtyZXR1cm4gYS54PT09bi54JiYhYS5pc051bGx9KTttKGQpJiYociYmKGQ9YS5nZXRQb2ludChkKSksbC5wdXNoKGQpKX0pKTpsLnB1c2gobikpO3JldHVybntob3ZlclBvaW50Om4saG92ZXJTZXJpZXM6Yyxob3ZlclBvaW50czpsfX0scnVuUG9pbnRBY3Rpb25zOmZ1bmN0aW9uKGIsYyl7dmFyIGU9dGhpcy5jaGFydCxyPWUudG9vbHRpcCYmZS50b29sdGlwLm9wdGlvbnMuZW5hYmxlZD9lLnRvb2x0aXA6dm9pZCAwLGc9cj9yLnNoYXJlZDohMSx4PWN8fGUuaG92ZXJQb2ludCxtPXgmJnguc2VyaWVzfHxlLmhvdmVyU2VyaWVzLG09dGhpcy5nZXRIb3ZlckRhdGEoeCxtLGUuc2VyaWVzLCEhY3x8bSYmbS5kaXJlY3RUb3VjaCYmdGhpcy5pc0RpcmVjdFRvdWNoLGcsYix7aXNCb29zdGluZzplLmlzQm9vc3Rpbmd9KSxuLHg9bS5ob3ZlclBvaW50O249bS5ob3ZlclBvaW50cztcbmM9KG09bS5ob3ZlclNlcmllcykmJm0udG9vbHRpcE9wdGlvbnMuZm9sbG93UG9pbnRlcjtnPWcmJm0mJiFtLm5vU2hhcmVkVG9vbHRpcDtpZih4JiYoeCE9PWUuaG92ZXJQb2ludHx8ciYmci5pc0hpZGRlbikpe3coZS5ob3ZlclBvaW50c3x8W10sZnVuY3Rpb24oYil7LTE9PT1hLmluQXJyYXkoYixuKSYmYi5zZXRTdGF0ZSgpfSk7dyhufHxbXSxmdW5jdGlvbihhKXthLnNldFN0YXRlKFwiaG92ZXJcIil9KTtpZihlLmhvdmVyU2VyaWVzIT09bSltLm9uTW91c2VPdmVyKCk7ZS5ob3ZlclBvaW50JiZlLmhvdmVyUG9pbnQuZmlyZVBvaW50RXZlbnQoXCJtb3VzZU91dFwiKTtpZigheC5zZXJpZXMpcmV0dXJuO3guZmlyZVBvaW50RXZlbnQoXCJtb3VzZU92ZXJcIik7ZS5ob3ZlclBvaW50cz1uO2UuaG92ZXJQb2ludD14O3ImJnIucmVmcmVzaChnP246eCxiKX1lbHNlIGMmJnImJiFyLmlzSGlkZGVuJiYoeD1yLmdldEFuY2hvcihbe31dLGIpLHIudXBkYXRlUG9zaXRpb24oe3Bsb3RYOnhbMF0scGxvdFk6eFsxXX0pKTtcbnRoaXMudW5Eb2NNb3VzZU1vdmV8fCh0aGlzLnVuRG9jTW91c2VNb3ZlPUcoZS5jb250YWluZXIub3duZXJEb2N1bWVudCxcIm1vdXNlbW92ZVwiLGZ1bmN0aW9uKGIpe3ZhciBjPUhbYS5ob3ZlckNoYXJ0SW5kZXhdO2lmKGMpYy5wb2ludGVyLm9uRG9jdW1lbnRNb3VzZU1vdmUoYil9KSk7dyhlLmF4ZXMsZnVuY3Rpb24oYyl7dmFyIGU9ZihjLmNyb3NzaGFpci5zbmFwLCEwKSxsPWU/YS5maW5kKG4sZnVuY3Rpb24oYSl7cmV0dXJuIGEuc2VyaWVzW2MuY29sbF09PT1jfSk6dm9pZCAwO2x8fCFlP2MuZHJhd0Nyb3NzaGFpcihiLGwpOmMuaGlkZUNyb3NzaGFpcigpfSl9LHJlc2V0OmZ1bmN0aW9uKGEsYyl7dmFyIGI9dGhpcy5jaGFydCxyPWIuaG92ZXJTZXJpZXMsZj1iLmhvdmVyUG9pbnQsZz1iLmhvdmVyUG9pbnRzLG09Yi50b29sdGlwLG49bSYmbS5zaGFyZWQ/ZzpmO2EmJm4mJncoZShuKSxmdW5jdGlvbihiKXtiLnNlcmllcy5pc0NhcnRlc2lhbiYmdm9pZCAwPT09Yi5wbG90WCYmXG4oYT0hMSl9KTtpZihhKW0mJm4mJihtLnJlZnJlc2gobiksZiYmKGYuc2V0U3RhdGUoZi5zdGF0ZSwhMCksdyhiLmF4ZXMsZnVuY3Rpb24oYSl7YS5jcm9zc2hhaXImJmEuZHJhd0Nyb3NzaGFpcihudWxsLGYpfSkpKTtlbHNle2lmKGYpZi5vbk1vdXNlT3V0KCk7ZyYmdyhnLGZ1bmN0aW9uKGEpe2Euc2V0U3RhdGUoKX0pO2lmKHIpci5vbk1vdXNlT3V0KCk7bSYmbS5oaWRlKGMpO3RoaXMudW5Eb2NNb3VzZU1vdmUmJih0aGlzLnVuRG9jTW91c2VNb3ZlPXRoaXMudW5Eb2NNb3VzZU1vdmUoKSk7dyhiLmF4ZXMsZnVuY3Rpb24oYSl7YS5oaWRlQ3Jvc3NoYWlyKCl9KTt0aGlzLmhvdmVyWD1iLmhvdmVyUG9pbnRzPWIuaG92ZXJQb2ludD1udWxsfX0sc2NhbGVHcm91cHM6ZnVuY3Rpb24oYSxjKXt2YXIgYj10aGlzLmNoYXJ0LGU7dyhiLnNlcmllcyxmdW5jdGlvbihsKXtlPWF8fGwuZ2V0UGxvdEJveCgpO2wueEF4aXMmJmwueEF4aXMuem9vbUVuYWJsZWQmJmwuZ3JvdXAmJihsLmdyb3VwLmF0dHIoZSksXG5sLm1hcmtlckdyb3VwJiYobC5tYXJrZXJHcm91cC5hdHRyKGUpLGwubWFya2VyR3JvdXAuY2xpcChjP2IuY2xpcFJlY3Q6bnVsbCkpLGwuZGF0YUxhYmVsc0dyb3VwJiZsLmRhdGFMYWJlbHNHcm91cC5hdHRyKGUpKX0pO2IuY2xpcFJlY3QuYXR0cihjfHxiLmNsaXBCb3gpfSxkcmFnU3RhcnQ6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydDtiLm1vdXNlSXNEb3duPWEudHlwZTtiLmNhbmNlbENsaWNrPSExO2IubW91c2VEb3duWD10aGlzLm1vdXNlRG93blg9YS5jaGFydFg7Yi5tb3VzZURvd25ZPXRoaXMubW91c2VEb3duWT1hLmNoYXJ0WX0sZHJhZzpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmNoYXJ0LGM9Yi5vcHRpb25zLmNoYXJ0LGU9YS5jaGFydFgsZj1hLmNoYXJ0WSxnPXRoaXMuem9vbUhvcixtPXRoaXMuem9vbVZlcnQsbj1iLnBsb3RMZWZ0LEI9Yi5wbG90VG9wLGs9Yi5wbG90V2lkdGgsQT1iLnBsb3RIZWlnaHQsZCxwPXRoaXMuc2VsZWN0aW9uTWFya2VyLEQ9dGhpcy5tb3VzZURvd25YLFxuaD10aGlzLm1vdXNlRG93blkseT1jLnBhbktleSYmYVtjLnBhbktleStcIktleVwiXTtwJiZwLnRvdWNofHwoZTxuP2U9bjplPm4rayYmKGU9bitrKSxmPEI/Zj1COmY+QitBJiYoZj1CK0EpLHRoaXMuaGFzRHJhZ2dlZD1NYXRoLnNxcnQoTWF0aC5wb3coRC1lLDIpK01hdGgucG93KGgtZiwyKSksMTA8dGhpcy5oYXNEcmFnZ2VkJiYoZD1iLmlzSW5zaWRlUGxvdChELW4saC1CKSxiLmhhc0NhcnRlc2lhblNlcmllcyYmKHRoaXMuem9vbVh8fHRoaXMuem9vbVkpJiZkJiYheSYmIXAmJih0aGlzLnNlbGVjdGlvbk1hcmtlcj1wPWIucmVuZGVyZXIucmVjdChuLEIsZz8xOmssbT8xOkEsMCkuYXR0cih7ZmlsbDpjLnNlbGVjdGlvbk1hcmtlckZpbGx8fHYoXCIjMzM1Y2FkXCIpLnNldE9wYWNpdHkoLjI1KS5nZXQoKSxcImNsYXNzXCI6XCJoaWdoY2hhcnRzLXNlbGVjdGlvbi1tYXJrZXJcIix6SW5kZXg6N30pLmFkZCgpKSxwJiZnJiYoZS09RCxwLmF0dHIoe3dpZHRoOk1hdGguYWJzKGUpLHg6KDA8ZT9cbjA6ZSkrRH0pKSxwJiZtJiYoZT1mLWgscC5hdHRyKHtoZWlnaHQ6TWF0aC5hYnMoZSkseTooMDxlPzA6ZSkraH0pKSxkJiYhcCYmYy5wYW5uaW5nJiZiLnBhbihhLGMucGFubmluZykpKX0sZHJvcDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9dGhpcy5jaGFydCxlPXRoaXMuaGFzUGluY2hlZDtpZih0aGlzLnNlbGVjdGlvbk1hcmtlcil7dmFyIGY9e29yaWdpbmFsRXZlbnQ6YSx4QXhpczpbXSx5QXhpczpbXX0sZz10aGlzLnNlbGVjdGlvbk1hcmtlcixtPWcuYXR0cj9nLmF0dHIoXCJ4XCIpOmcueCxuPWcuYXR0cj9nLmF0dHIoXCJ5XCIpOmcueSxCPWcuYXR0cj9nLmF0dHIoXCJ3aWR0aFwiKTpnLndpZHRoLHU9Zy5hdHRyP2cuYXR0cihcImhlaWdodFwiKTpnLmhlaWdodCxBO2lmKHRoaXMuaGFzRHJhZ2dlZHx8ZSl3KGMuYXhlcyxmdW5jdGlvbihkKXtpZihkLnpvb21FbmFibGVkJiZxKGQubWluKSYmKGV8fGJbe3hBeGlzOlwiem9vbVhcIix5QXhpczpcInpvb21ZXCJ9W2QuY29sbF1dKSl7dmFyIGM9ZC5ob3Jpeixcbmw9XCJ0b3VjaGVuZFwiPT09YS50eXBlP2QubWluUGl4ZWxQYWRkaW5nOjAsaD1kLnRvVmFsdWUoKGM/bTpuKStsKSxjPWQudG9WYWx1ZSgoYz9tK0I6bit1KS1sKTtmW2QuY29sbF0ucHVzaCh7YXhpczpkLG1pbjpNYXRoLm1pbihoLGMpLG1heDpNYXRoLm1heChoLGMpfSk7QT0hMH19KSxBJiZ6KGMsXCJzZWxlY3Rpb25cIixmLGZ1bmN0aW9uKGEpe2Muem9vbSh0KGEsZT97YW5pbWF0aW9uOiExfTpudWxsKSl9KTt0aGlzLnNlbGVjdGlvbk1hcmtlcj10aGlzLnNlbGVjdGlvbk1hcmtlci5kZXN0cm95KCk7ZSYmdGhpcy5zY2FsZUdyb3VwcygpfWMmJihrKGMuY29udGFpbmVyLHtjdXJzb3I6Yy5fY3Vyc29yfSksYy5jYW5jZWxDbGljaz0xMDx0aGlzLmhhc0RyYWdnZWQsYy5tb3VzZUlzRG93bj10aGlzLmhhc0RyYWdnZWQ9dGhpcy5oYXNQaW5jaGVkPSExLHRoaXMucGluY2hEb3duPVtdKX0sb25Db250YWluZXJNb3VzZURvd246ZnVuY3Rpb24oYSl7MiE9PWEuYnV0dG9uJiYoYT10aGlzLm5vcm1hbGl6ZShhKSxcbnRoaXMuem9vbU9wdGlvbihhKSxhLnByZXZlbnREZWZhdWx0JiZhLnByZXZlbnREZWZhdWx0KCksdGhpcy5kcmFnU3RhcnQoYSkpfSxvbkRvY3VtZW50TW91c2VVcDpmdW5jdGlvbihiKXtIW2EuaG92ZXJDaGFydEluZGV4XSYmSFthLmhvdmVyQ2hhcnRJbmRleF0ucG9pbnRlci5kcm9wKGIpfSxvbkRvY3VtZW50TW91c2VNb3ZlOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY2hhcnQsYz10aGlzLmNoYXJ0UG9zaXRpb247YT10aGlzLm5vcm1hbGl6ZShhLGMpOyFjfHx0aGlzLmluQ2xhc3MoYS50YXJnZXQsXCJoaWdoY2hhcnRzLXRyYWNrZXJcIil8fGIuaXNJbnNpZGVQbG90KGEuY2hhcnRYLWIucGxvdExlZnQsYS5jaGFydFktYi5wbG90VG9wKXx8dGhpcy5yZXNldCgpfSxvbkNvbnRhaW5lck1vdXNlTGVhdmU6ZnVuY3Rpb24oYil7dmFyIGM9SFthLmhvdmVyQ2hhcnRJbmRleF07YyYmKGIucmVsYXRlZFRhcmdldHx8Yi50b0VsZW1lbnQpJiYoYy5wb2ludGVyLnJlc2V0KCksYy5wb2ludGVyLmNoYXJ0UG9zaXRpb249XG5udWxsKX0sb25Db250YWluZXJNb3VzZU1vdmU6ZnVuY3Rpb24oYil7dmFyIGM9dGhpcy5jaGFydDtxKGEuaG92ZXJDaGFydEluZGV4KSYmSFthLmhvdmVyQ2hhcnRJbmRleF0mJkhbYS5ob3ZlckNoYXJ0SW5kZXhdLm1vdXNlSXNEb3dufHwoYS5ob3ZlckNoYXJ0SW5kZXg9Yy5pbmRleCk7Yj10aGlzLm5vcm1hbGl6ZShiKTtiLnJldHVyblZhbHVlPSExO1wibW91c2Vkb3duXCI9PT1jLm1vdXNlSXNEb3duJiZ0aGlzLmRyYWcoYik7IXRoaXMuaW5DbGFzcyhiLnRhcmdldCxcImhpZ2hjaGFydHMtdHJhY2tlclwiKSYmIWMuaXNJbnNpZGVQbG90KGIuY2hhcnRYLWMucGxvdExlZnQsYi5jaGFydFktYy5wbG90VG9wKXx8Yy5vcGVuTWVudXx8dGhpcy5ydW5Qb2ludEFjdGlvbnMoYil9LGluQ2xhc3M6ZnVuY3Rpb24oYSxjKXtmb3IodmFyIGI7YTspe2lmKGI9RShhLFwiY2xhc3NcIikpe2lmKC0xIT09Yi5pbmRleE9mKGMpKXJldHVybiEwO2lmKC0xIT09Yi5pbmRleE9mKFwiaGlnaGNoYXJ0cy1jb250YWluZXJcIikpcmV0dXJuITF9YT1cbmEucGFyZW50Tm9kZX19LG9uVHJhY2tlck1vdXNlT3V0OmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY2hhcnQuaG92ZXJTZXJpZXM7YT1hLnJlbGF0ZWRUYXJnZXR8fGEudG9FbGVtZW50O3RoaXMuaXNEaXJlY3RUb3VjaD0hMTtpZighKCFifHwhYXx8Yi5zdGlja3lUcmFja2luZ3x8dGhpcy5pbkNsYXNzKGEsXCJoaWdoY2hhcnRzLXRvb2x0aXBcIil8fHRoaXMuaW5DbGFzcyhhLFwiaGlnaGNoYXJ0cy1zZXJpZXMtXCIrYi5pbmRleCkmJnRoaXMuaW5DbGFzcyhhLFwiaGlnaGNoYXJ0cy10cmFja2VyXCIpKSliLm9uTW91c2VPdXQoKX0sb25Db250YWluZXJDbGljazpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmNoYXJ0LGM9Yi5ob3ZlclBvaW50LGU9Yi5wbG90TGVmdCxmPWIucGxvdFRvcDthPXRoaXMubm9ybWFsaXplKGEpO2IuY2FuY2VsQ2xpY2t8fChjJiZ0aGlzLmluQ2xhc3MoYS50YXJnZXQsXCJoaWdoY2hhcnRzLXRyYWNrZXJcIik/KHooYy5zZXJpZXMsXCJjbGlja1wiLHQoYSx7cG9pbnQ6Y30pKSxcbmIuaG92ZXJQb2ludCYmYy5maXJlUG9pbnRFdmVudChcImNsaWNrXCIsYSkpOih0KGEsdGhpcy5nZXRDb29yZGluYXRlcyhhKSksYi5pc0luc2lkZVBsb3QoYS5jaGFydFgtZSxhLmNoYXJ0WS1mKSYmeihiLFwiY2xpY2tcIixhKSkpfSxzZXRET01FdmVudHM6ZnVuY3Rpb24oKXt2YXIgYj10aGlzLGM9Yi5jaGFydC5jb250YWluZXIsZT1jLm93bmVyRG9jdW1lbnQ7Yy5vbm1vdXNlZG93bj1mdW5jdGlvbihhKXtiLm9uQ29udGFpbmVyTW91c2VEb3duKGEpfTtjLm9ubW91c2Vtb3ZlPWZ1bmN0aW9uKGEpe2Iub25Db250YWluZXJNb3VzZU1vdmUoYSl9O2Mub25jbGljaz1mdW5jdGlvbihhKXtiLm9uQ29udGFpbmVyQ2xpY2soYSl9O3RoaXMudW5iaW5kQ29udGFpbmVyTW91c2VMZWF2ZT1HKGMsXCJtb3VzZWxlYXZlXCIsYi5vbkNvbnRhaW5lck1vdXNlTGVhdmUpO2EudW5iaW5kRG9jdW1lbnRNb3VzZVVwfHwoYS51bmJpbmREb2N1bWVudE1vdXNlVXA9RyhlLFwibW91c2V1cFwiLGIub25Eb2N1bWVudE1vdXNlVXApKTtcbmEuaGFzVG91Y2gmJihjLm9udG91Y2hzdGFydD1mdW5jdGlvbihhKXtiLm9uQ29udGFpbmVyVG91Y2hTdGFydChhKX0sYy5vbnRvdWNobW92ZT1mdW5jdGlvbihhKXtiLm9uQ29udGFpbmVyVG91Y2hNb3ZlKGEpfSxhLnVuYmluZERvY3VtZW50VG91Y2hFbmR8fChhLnVuYmluZERvY3VtZW50VG91Y2hFbmQ9RyhlLFwidG91Y2hlbmRcIixiLm9uRG9jdW1lbnRUb3VjaEVuZCkpKX0sZGVzdHJveTpmdW5jdGlvbigpe3ZhciBiPXRoaXM7Yi51bkRvY01vdXNlTW92ZSYmYi51bkRvY01vdXNlTW92ZSgpO3RoaXMudW5iaW5kQ29udGFpbmVyTW91c2VMZWF2ZSgpO2EuY2hhcnRDb3VudHx8KGEudW5iaW5kRG9jdW1lbnRNb3VzZVVwJiYoYS51bmJpbmREb2N1bWVudE1vdXNlVXA9YS51bmJpbmREb2N1bWVudE1vdXNlVXAoKSksYS51bmJpbmREb2N1bWVudFRvdWNoRW5kJiYoYS51bmJpbmREb2N1bWVudFRvdWNoRW5kPWEudW5iaW5kRG9jdW1lbnRUb3VjaEVuZCgpKSk7Y2xlYXJJbnRlcnZhbChiLnRvb2x0aXBUaW1lb3V0KTtcbmEub2JqZWN0RWFjaChiLGZ1bmN0aW9uKGEsYyl7YltjXT1udWxsfSl9fX0pKEwpOyhmdW5jdGlvbihhKXt2YXIgRz1hLmNoYXJ0cyxFPWEuZWFjaCxIPWEuZXh0ZW5kLHY9YS5tYXAsaz1hLm5vb3AscT1hLnBpY2s7SChhLlBvaW50ZXIucHJvdG90eXBlLHtwaW5jaFRyYW5zbGF0ZTpmdW5jdGlvbihhLGsscSx2LG0sZyl7dGhpcy56b29tSG9yJiZ0aGlzLnBpbmNoVHJhbnNsYXRlRGlyZWN0aW9uKCEwLGEsayxxLHYsbSxnKTt0aGlzLnpvb21WZXJ0JiZ0aGlzLnBpbmNoVHJhbnNsYXRlRGlyZWN0aW9uKCExLGEsayxxLHYsbSxnKX0scGluY2hUcmFuc2xhdGVEaXJlY3Rpb246ZnVuY3Rpb24oYSxrLHEsdixtLGcsZixlKXt2YXIgYz10aGlzLmNoYXJ0LGI9YT9cInhcIjpcInlcIixyPWE/XCJYXCI6XCJZXCIsbD1cImNoYXJ0XCIrcixDPWE/XCJ3aWR0aFwiOlwiaGVpZ2h0XCIsdD1jW1wicGxvdFwiKyhhP1wiTGVmdFwiOlwiVG9wXCIpXSx4LEYsbj1lfHwxLEI9Yy5pbnZlcnRlZCx1PWMuYm91bmRzW2E/XCJoXCI6XCJ2XCJdLFxuQT0xPT09ay5sZW5ndGgsZD1rWzBdW2xdLHA9cVswXVtsXSxEPSFBJiZrWzFdW2xdLGg9IUEmJnFbMV1bbF0seTtxPWZ1bmN0aW9uKCl7IUEmJjIwPE1hdGguYWJzKGQtRCkmJihuPWV8fE1hdGguYWJzKHAtaCkvTWF0aC5hYnMoZC1EKSk7Rj0odC1wKS9uK2Q7eD1jW1wicGxvdFwiKyhhP1wiV2lkdGhcIjpcIkhlaWdodFwiKV0vbn07cSgpO2s9RjtrPHUubWluPyhrPXUubWluLHk9ITApOmsreD51Lm1heCYmKGs9dS5tYXgteCx5PSEwKTt5PyhwLT0uOCoocC1mW2JdWzBdKSxBfHwoaC09LjgqKGgtZltiXVsxXSkpLHEoKSk6ZltiXT1bcCxoXTtCfHwoZ1tiXT1GLXQsZ1tDXT14KTtnPUI/MS9uOm47bVtDXT14O21bYl09azt2W0I/YT9cInNjYWxlWVwiOlwic2NhbGVYXCI6XCJzY2FsZVwiK3JdPW47dltcInRyYW5zbGF0ZVwiK3JdPWcqdCsocC1nKmQpfSxwaW5jaDpmdW5jdGlvbihhKXt2YXIgdD10aGlzLHU9dC5jaGFydCx3PXQucGluY2hEb3duLG09YS50b3VjaGVzLGc9bS5sZW5ndGgsZj10Lmxhc3RWYWxpZFRvdWNoLFxuZT10Lmhhc1pvb20sYz10LnNlbGVjdGlvbk1hcmtlcixiPXt9LHI9MT09PWcmJih0LmluQ2xhc3MoYS50YXJnZXQsXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikmJnUucnVuVHJhY2tlckNsaWNrfHx0LnJ1bkNoYXJ0Q2xpY2spLGw9e307MTxnJiYodC5pbml0aWF0ZWQ9ITApO2UmJnQuaW5pdGlhdGVkJiYhciYmYS5wcmV2ZW50RGVmYXVsdCgpO3YobSxmdW5jdGlvbihhKXtyZXR1cm4gdC5ub3JtYWxpemUoYSl9KTtcInRvdWNoc3RhcnRcIj09PWEudHlwZT8oRShtLGZ1bmN0aW9uKGEsYil7d1tiXT17Y2hhcnRYOmEuY2hhcnRYLGNoYXJ0WTphLmNoYXJ0WX19KSxmLng9W3dbMF0uY2hhcnRYLHdbMV0mJndbMV0uY2hhcnRYXSxmLnk9W3dbMF0uY2hhcnRZLHdbMV0mJndbMV0uY2hhcnRZXSxFKHUuYXhlcyxmdW5jdGlvbihhKXtpZihhLnpvb21FbmFibGVkKXt2YXIgYj11LmJvdW5kc1thLmhvcml6P1wiaFwiOlwidlwiXSxjPWEubWluUGl4ZWxQYWRkaW5nLGU9YS50b1BpeGVscyhxKGEub3B0aW9ucy5taW4sXG5hLmRhdGFNaW4pKSxuPWEudG9QaXhlbHMocShhLm9wdGlvbnMubWF4LGEuZGF0YU1heCkpLGw9TWF0aC5tYXgoZSxuKTtiLm1pbj1NYXRoLm1pbihhLnBvcyxNYXRoLm1pbihlLG4pLWMpO2IubWF4PU1hdGgubWF4KGEucG9zK2EubGVuLGwrYyl9fSksdC5yZXM9ITApOnQuZm9sbG93VG91Y2hNb3ZlJiYxPT09Zz90aGlzLnJ1blBvaW50QWN0aW9ucyh0Lm5vcm1hbGl6ZShhKSk6dy5sZW5ndGgmJihjfHwodC5zZWxlY3Rpb25NYXJrZXI9Yz1IKHtkZXN0cm95OmssdG91Y2g6ITB9LHUucGxvdEJveCkpLHQucGluY2hUcmFuc2xhdGUodyxtLGIsYyxsLGYpLHQuaGFzUGluY2hlZD1lLHQuc2NhbGVHcm91cHMoYixsKSx0LnJlcyYmKHQucmVzPSExLHRoaXMucmVzZXQoITEsMCkpKX0sdG91Y2g6ZnVuY3Rpb24oayx0KXt2YXIgdT10aGlzLmNoYXJ0LHYsbTtpZih1LmluZGV4IT09YS5ob3ZlckNoYXJ0SW5kZXgpdGhpcy5vbkNvbnRhaW5lck1vdXNlTGVhdmUoe3JlbGF0ZWRUYXJnZXQ6ITB9KTtcbmEuaG92ZXJDaGFydEluZGV4PXUuaW5kZXg7MT09PWsudG91Y2hlcy5sZW5ndGg/KGs9dGhpcy5ub3JtYWxpemUoayksKG09dS5pc0luc2lkZVBsb3Qoay5jaGFydFgtdS5wbG90TGVmdCxrLmNoYXJ0WS11LnBsb3RUb3ApKSYmIXUub3Blbk1lbnU/KHQmJnRoaXMucnVuUG9pbnRBY3Rpb25zKGspLFwidG91Y2htb3ZlXCI9PT1rLnR5cGUmJih0PXRoaXMucGluY2hEb3duLHY9dFswXT80PD1NYXRoLnNxcnQoTWF0aC5wb3codFswXS5jaGFydFgtay5jaGFydFgsMikrTWF0aC5wb3codFswXS5jaGFydFktay5jaGFydFksMikpOiExKSxxKHYsITApJiZ0aGlzLnBpbmNoKGspKTp0JiZ0aGlzLnJlc2V0KCkpOjI9PT1rLnRvdWNoZXMubGVuZ3RoJiZ0aGlzLnBpbmNoKGspfSxvbkNvbnRhaW5lclRvdWNoU3RhcnQ6ZnVuY3Rpb24oYSl7dGhpcy56b29tT3B0aW9uKGEpO3RoaXMudG91Y2goYSwhMCl9LG9uQ29udGFpbmVyVG91Y2hNb3ZlOmZ1bmN0aW9uKGEpe3RoaXMudG91Y2goYSl9LG9uRG9jdW1lbnRUb3VjaEVuZDpmdW5jdGlvbihrKXtHW2EuaG92ZXJDaGFydEluZGV4XSYmXG5HW2EuaG92ZXJDaGFydEluZGV4XS5wb2ludGVyLmRyb3Aoayl9fSl9KShMKTsoZnVuY3Rpb24oYSl7dmFyIEc9YS5hZGRFdmVudCxFPWEuY2hhcnRzLEg9YS5jc3Msdj1hLmRvYyxrPWEuZXh0ZW5kLHE9YS5ub29wLHc9YS5Qb2ludGVyLHQ9YS5yZW1vdmVFdmVudCx1PWEud2luLHo9YS53cmFwO2lmKCFhLmhhc1RvdWNoJiYodS5Qb2ludGVyRXZlbnR8fHUuTVNQb2ludGVyRXZlbnQpKXt2YXIgbT17fSxnPSEhdS5Qb2ludGVyRXZlbnQsZj1mdW5jdGlvbigpe3ZhciBjPVtdO2MuaXRlbT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpc1thXX07YS5vYmplY3RFYWNoKG0sZnVuY3Rpb24oYSl7Yy5wdXNoKHtwYWdlWDphLnBhZ2VYLHBhZ2VZOmEucGFnZVksdGFyZ2V0OmEudGFyZ2V0fSl9KTtyZXR1cm4gY30sZT1mdW5jdGlvbihjLGIsZSxsKXtcInRvdWNoXCIhPT1jLnBvaW50ZXJUeXBlJiZjLnBvaW50ZXJUeXBlIT09Yy5NU1BPSU5URVJfVFlQRV9UT1VDSHx8IUVbYS5ob3ZlckNoYXJ0SW5kZXhdfHxcbihsKGMpLGw9RVthLmhvdmVyQ2hhcnRJbmRleF0ucG9pbnRlcixsW2JdKHt0eXBlOmUsdGFyZ2V0OmMuY3VycmVudFRhcmdldCxwcmV2ZW50RGVmYXVsdDpxLHRvdWNoZXM6ZigpfSkpfTtrKHcucHJvdG90eXBlLHtvbkNvbnRhaW5lclBvaW50ZXJEb3duOmZ1bmN0aW9uKGEpe2UoYSxcIm9uQ29udGFpbmVyVG91Y2hTdGFydFwiLFwidG91Y2hzdGFydFwiLGZ1bmN0aW9uKGEpe21bYS5wb2ludGVySWRdPXtwYWdlWDphLnBhZ2VYLHBhZ2VZOmEucGFnZVksdGFyZ2V0OmEuY3VycmVudFRhcmdldH19KX0sb25Db250YWluZXJQb2ludGVyTW92ZTpmdW5jdGlvbihhKXtlKGEsXCJvbkNvbnRhaW5lclRvdWNoTW92ZVwiLFwidG91Y2htb3ZlXCIsZnVuY3Rpb24oYSl7bVthLnBvaW50ZXJJZF09e3BhZ2VYOmEucGFnZVgscGFnZVk6YS5wYWdlWX07bVthLnBvaW50ZXJJZF0udGFyZ2V0fHwobVthLnBvaW50ZXJJZF0udGFyZ2V0PWEuY3VycmVudFRhcmdldCl9KX0sb25Eb2N1bWVudFBvaW50ZXJVcDpmdW5jdGlvbihhKXtlKGEsXG5cIm9uRG9jdW1lbnRUb3VjaEVuZFwiLFwidG91Y2hlbmRcIixmdW5jdGlvbihhKXtkZWxldGUgbVthLnBvaW50ZXJJZF19KX0sYmF0Y2hNU0V2ZW50czpmdW5jdGlvbihhKXthKHRoaXMuY2hhcnQuY29udGFpbmVyLGc/XCJwb2ludGVyZG93blwiOlwiTVNQb2ludGVyRG93blwiLHRoaXMub25Db250YWluZXJQb2ludGVyRG93bik7YSh0aGlzLmNoYXJ0LmNvbnRhaW5lcixnP1wicG9pbnRlcm1vdmVcIjpcIk1TUG9pbnRlck1vdmVcIix0aGlzLm9uQ29udGFpbmVyUG9pbnRlck1vdmUpO2EodixnP1wicG9pbnRlcnVwXCI6XCJNU1BvaW50ZXJVcFwiLHRoaXMub25Eb2N1bWVudFBvaW50ZXJVcCl9fSk7eih3LnByb3RvdHlwZSxcImluaXRcIixmdW5jdGlvbihhLGIsZSl7YS5jYWxsKHRoaXMsYixlKTt0aGlzLmhhc1pvb20mJkgoYi5jb250YWluZXIse1wiLW1zLXRvdWNoLWFjdGlvblwiOlwibm9uZVwiLFwidG91Y2gtYWN0aW9uXCI6XCJub25lXCJ9KX0pO3oody5wcm90b3R5cGUsXCJzZXRET01FdmVudHNcIixmdW5jdGlvbihhKXthLmFwcGx5KHRoaXMpO1xuKHRoaXMuaGFzWm9vbXx8dGhpcy5mb2xsb3dUb3VjaE1vdmUpJiZ0aGlzLmJhdGNoTVNFdmVudHMoRyl9KTt6KHcucHJvdG90eXBlLFwiZGVzdHJveVwiLGZ1bmN0aW9uKGEpe3RoaXMuYmF0Y2hNU0V2ZW50cyh0KTthLmNhbGwodGhpcyl9KX19KShMKTsoZnVuY3Rpb24oYSl7dmFyIEc9YS5hZGRFdmVudCxFPWEuY3NzLEg9YS5kaXNjYXJkRWxlbWVudCx2PWEuZGVmaW5lZCxrPWEuZWFjaCxxPWEuaXNGaXJlZm94LHc9YS5tYXJnaW5OYW1lcyx0PWEubWVyZ2UsdT1hLnBpY2ssej1hLnNldEFuaW1hdGlvbixtPWEuc3RhYmxlU29ydCxnPWEud2luLGY9YS53cmFwO2EuTGVnZW5kPWZ1bmN0aW9uKGEsYyl7dGhpcy5pbml0KGEsYyl9O2EuTGVnZW5kLnByb3RvdHlwZT17aW5pdDpmdW5jdGlvbihhLGMpe3RoaXMuY2hhcnQ9YTt0aGlzLnNldE9wdGlvbnMoYyk7Yy5lbmFibGVkJiYodGhpcy5yZW5kZXIoKSxHKHRoaXMuY2hhcnQsXCJlbmRSZXNpemVcIixmdW5jdGlvbigpe3RoaXMubGVnZW5kLnBvc2l0aW9uQ2hlY2tib3hlcygpfSkpfSxcbnNldE9wdGlvbnM6ZnVuY3Rpb24oYSl7dmFyIGM9dShhLnBhZGRpbmcsOCk7dGhpcy5vcHRpb25zPWE7dGhpcy5pdGVtU3R5bGU9YS5pdGVtU3R5bGU7dGhpcy5pdGVtSGlkZGVuU3R5bGU9dCh0aGlzLml0ZW1TdHlsZSxhLml0ZW1IaWRkZW5TdHlsZSk7dGhpcy5pdGVtTWFyZ2luVG9wPWEuaXRlbU1hcmdpblRvcHx8MDt0aGlzLnBhZGRpbmc9Yzt0aGlzLmluaXRpYWxJdGVtWT1jLTU7dGhpcy5pdGVtSGVpZ2h0PXRoaXMubWF4SXRlbVdpZHRoPTA7dGhpcy5zeW1ib2xXaWR0aD11KGEuc3ltYm9sV2lkdGgsMTYpO3RoaXMucGFnZXM9W119LHVwZGF0ZTpmdW5jdGlvbihhLGMpe3ZhciBiPXRoaXMuY2hhcnQ7dGhpcy5zZXRPcHRpb25zKHQoITAsdGhpcy5vcHRpb25zLGEpKTt0aGlzLmRlc3Ryb3koKTtiLmlzRGlydHlMZWdlbmQ9Yi5pc0RpcnR5Qm94PSEwO3UoYywhMCkmJmIucmVkcmF3KCl9LGNvbG9yaXplSXRlbTpmdW5jdGlvbihhLGMpe2EubGVnZW5kR3JvdXBbYz9cInJlbW92ZUNsYXNzXCI6XG5cImFkZENsYXNzXCJdKFwiaGlnaGNoYXJ0cy1sZWdlbmQtaXRlbS1oaWRkZW5cIik7dmFyIGI9dGhpcy5vcHRpb25zLGU9YS5sZWdlbmRJdGVtLGw9YS5sZWdlbmRMaW5lLGY9YS5sZWdlbmRTeW1ib2wsZz10aGlzLml0ZW1IaWRkZW5TdHlsZS5jb2xvcixiPWM/Yi5pdGVtU3R5bGUuY29sb3I6ZyxtPWM/YS5jb2xvcnx8ZzpnLGs9YS5vcHRpb25zJiZhLm9wdGlvbnMubWFya2VyLG49e2ZpbGw6bX07ZSYmZS5jc3Moe2ZpbGw6Yixjb2xvcjpifSk7bCYmbC5hdHRyKHtzdHJva2U6bX0pO2YmJihrJiZmLmlzTWFya2VyJiYobj1hLnBvaW50QXR0cmlicygpLGN8fChuLnN0cm9rZT1uLmZpbGw9ZykpLGYuYXR0cihuKSl9LHBvc2l0aW9uSXRlbTpmdW5jdGlvbihhKXt2YXIgYz10aGlzLm9wdGlvbnMsYj1jLnN5bWJvbFBhZGRpbmcsYz0hYy5ydGwsZT1hLl9sZWdlbmRJdGVtUG9zLGw9ZVswXSxlPWVbMV0sZj1hLmNoZWNrYm94OyhhPWEubGVnZW5kR3JvdXApJiZhLmVsZW1lbnQmJmEudHJhbnNsYXRlKGM/XG5sOnRoaXMubGVnZW5kV2lkdGgtbC0yKmItNCxlKTtmJiYoZi54PWwsZi55PWUpfSxkZXN0cm95SXRlbTpmdW5jdGlvbihhKXt2YXIgYz1hLmNoZWNrYm94O2soW1wibGVnZW5kSXRlbVwiLFwibGVnZW5kTGluZVwiLFwibGVnZW5kU3ltYm9sXCIsXCJsZWdlbmRHcm91cFwiXSxmdW5jdGlvbihiKXthW2JdJiYoYVtiXT1hW2JdLmRlc3Ryb3koKSl9KTtjJiZIKGEuY2hlY2tib3gpfSxkZXN0cm95OmZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXt0aGlzW2FdJiYodGhpc1thXT10aGlzW2FdLmRlc3Ryb3koKSl9ayh0aGlzLmdldEFsbEl0ZW1zKCksZnVuY3Rpb24oYyl7ayhbXCJsZWdlbmRJdGVtXCIsXCJsZWdlbmRHcm91cFwiXSxhLGMpfSk7ayhcImNsaXBSZWN0IHVwIGRvd24gcGFnZXIgbmF2IGJveCB0aXRsZSBncm91cFwiLnNwbGl0KFwiIFwiKSxhLHRoaXMpO3RoaXMuZGlzcGxheT1udWxsfSxwb3NpdGlvbkNoZWNrYm94ZXM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyb3VwJiZ0aGlzLmdyb3VwLmFsaWduQXR0cixcbmMsYj10aGlzLmNsaXBIZWlnaHR8fHRoaXMubGVnZW5kSGVpZ2h0LGY9dGhpcy50aXRsZUhlaWdodDthJiYoYz1hLnRyYW5zbGF0ZVksayh0aGlzLmFsbEl0ZW1zLGZ1bmN0aW9uKGUpe3ZhciBsPWUuY2hlY2tib3gsZztsJiYoZz1jK2YrbC55Kyh0aGlzLnNjcm9sbE9mZnNldHx8MCkrMyxFKGwse2xlZnQ6YS50cmFuc2xhdGVYK2UuY2hlY2tib3hPZmZzZXQrbC54LTIwK1wicHhcIix0b3A6ZytcInB4XCIsZGlzcGxheTpnPmMtNiYmZzxjK2ItNj9cIlwiOlwibm9uZVwifSkpfSx0aGlzKSl9LHJlbmRlclRpdGxlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zLGM9dGhpcy5wYWRkaW5nLGI9YS50aXRsZSxmPTA7Yi50ZXh0JiYodGhpcy50aXRsZXx8KHRoaXMudGl0bGU9dGhpcy5jaGFydC5yZW5kZXJlci5sYWJlbChiLnRleHQsYy0zLGMtNCxudWxsLG51bGwsbnVsbCxhLnVzZUhUTUwsbnVsbCxcImxlZ2VuZC10aXRsZVwiKS5hdHRyKHt6SW5kZXg6MX0pLmNzcyhiLnN0eWxlKS5hZGQodGhpcy5ncm91cCkpLFxuYT10aGlzLnRpdGxlLmdldEJCb3goKSxmPWEuaGVpZ2h0LHRoaXMub2Zmc2V0V2lkdGg9YS53aWR0aCx0aGlzLmNvbnRlbnRHcm91cC5hdHRyKHt0cmFuc2xhdGVZOmZ9KSk7dGhpcy50aXRsZUhlaWdodD1mfSxzZXRUZXh0OmZ1bmN0aW9uKGUpe3ZhciBjPXRoaXMub3B0aW9ucztlLmxlZ2VuZEl0ZW0uYXR0cih7dGV4dDpjLmxhYmVsRm9ybWF0P2EuZm9ybWF0KGMubGFiZWxGb3JtYXQsZSk6Yy5sYWJlbEZvcm1hdHRlci5jYWxsKGUpfSl9LHJlbmRlckl0ZW06ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5jaGFydCxiPWMucmVuZGVyZXIsZT10aGlzLm9wdGlvbnMsbD1cImhvcml6b250YWxcIj09PWUubGF5b3V0LGY9dGhpcy5zeW1ib2xXaWR0aCxnPWUuc3ltYm9sUGFkZGluZyxtPXRoaXMuaXRlbVN0eWxlLGs9dGhpcy5pdGVtSGlkZGVuU3R5bGUsbj10aGlzLnBhZGRpbmcsQj1sP3UoZS5pdGVtRGlzdGFuY2UsMjApOjAscT0hZS5ydGwsQT1lLndpZHRoLGQ9ZS5pdGVtTWFyZ2luQm90dG9tfHxcbjAscD10aGlzLml0ZW1NYXJnaW5Ub3AsRD1hLmxlZ2VuZEl0ZW0saD0hYS5zZXJpZXMseT0haCYmYS5zZXJpZXMuZHJhd0xlZ2VuZFN5bWJvbD9hLnNlcmllczphLHY9eS5vcHRpb25zLE09dGhpcy5jcmVhdGVDaGVja2JveEZvckl0ZW0mJnYmJnYuc2hvd0NoZWNrYm94LHY9ZitnK0IrKE0/MjA6MCksdz1lLnVzZUhUTUwsTj1hLm9wdGlvbnMuY2xhc3NOYW1lO0R8fChhLmxlZ2VuZEdyb3VwPWIuZyhcImxlZ2VuZC1pdGVtXCIpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIit5LnR5cGUrXCItc2VyaWVzIGhpZ2hjaGFydHMtY29sb3ItXCIrYS5jb2xvckluZGV4KyhOP1wiIFwiK046XCJcIikrKGg/XCIgaGlnaGNoYXJ0cy1zZXJpZXMtXCIrYS5pbmRleDpcIlwiKSkuYXR0cih7ekluZGV4OjF9KS5hZGQodGhpcy5zY3JvbGxHcm91cCksYS5sZWdlbmRJdGVtPUQ9Yi50ZXh0KFwiXCIscT9mK2c6LWcsdGhpcy5iYXNlbGluZXx8MCx3KS5jc3ModChhLnZpc2libGU/bTprKSkuYXR0cih7YWxpZ246cT9cImxlZnRcIjpcInJpZ2h0XCIsXG56SW5kZXg6Mn0pLmFkZChhLmxlZ2VuZEdyb3VwKSx0aGlzLmJhc2VsaW5lfHwoZj1tLmZvbnRTaXplLHRoaXMuZm9udE1ldHJpY3M9Yi5mb250TWV0cmljcyhmLEQpLHRoaXMuYmFzZWxpbmU9dGhpcy5mb250TWV0cmljcy5mKzMrcCxELmF0dHIoXCJ5XCIsdGhpcy5iYXNlbGluZSkpLHRoaXMuc3ltYm9sSGVpZ2h0PWUuc3ltYm9sSGVpZ2h0fHx0aGlzLmZvbnRNZXRyaWNzLmYseS5kcmF3TGVnZW5kU3ltYm9sKHRoaXMsYSksdGhpcy5zZXRJdGVtRXZlbnRzJiZ0aGlzLnNldEl0ZW1FdmVudHMoYSxELHcpLE0mJnRoaXMuY3JlYXRlQ2hlY2tib3hGb3JJdGVtKGEpKTt0aGlzLmNvbG9yaXplSXRlbShhLGEudmlzaWJsZSk7bS53aWR0aHx8RC5jc3Moe3dpZHRoOihlLml0ZW1XaWR0aHx8ZS53aWR0aHx8Yy5zcGFjaW5nQm94LndpZHRoKS12fSk7dGhpcy5zZXRUZXh0KGEpO2I9RC5nZXRCQm94KCk7bT1hLmNoZWNrYm94T2Zmc2V0PWUuaXRlbVdpZHRofHxhLmxlZ2VuZEl0ZW1XaWR0aHx8Yi53aWR0aCtcbnY7dGhpcy5pdGVtSGVpZ2h0PWI9TWF0aC5yb3VuZChhLmxlZ2VuZEl0ZW1IZWlnaHR8fGIuaGVpZ2h0fHx0aGlzLnN5bWJvbEhlaWdodCk7bCYmdGhpcy5pdGVtWC1uK20+KEF8fGMuc3BhY2luZ0JveC53aWR0aC0yKm4tZS54KSYmKHRoaXMuaXRlbVg9bix0aGlzLml0ZW1ZKz1wK3RoaXMubGFzdExpbmVIZWlnaHQrZCx0aGlzLmxhc3RMaW5lSGVpZ2h0PTApO3RoaXMubWF4SXRlbVdpZHRoPU1hdGgubWF4KHRoaXMubWF4SXRlbVdpZHRoLG0pO3RoaXMubGFzdEl0ZW1ZPXArdGhpcy5pdGVtWStkO3RoaXMubGFzdExpbmVIZWlnaHQ9TWF0aC5tYXgoYix0aGlzLmxhc3RMaW5lSGVpZ2h0KTthLl9sZWdlbmRJdGVtUG9zPVt0aGlzLml0ZW1YLHRoaXMuaXRlbVldO2w/dGhpcy5pdGVtWCs9bToodGhpcy5pdGVtWSs9cCtiK2QsdGhpcy5sYXN0TGluZUhlaWdodD1iKTt0aGlzLm9mZnNldFdpZHRoPUF8fE1hdGgubWF4KChsP3RoaXMuaXRlbVgtbi0oYS5jaGVja2JveD8wOkIpOm0pK24sdGhpcy5vZmZzZXRXaWR0aCl9LFxuZ2V0QWxsSXRlbXM6ZnVuY3Rpb24oKXt2YXIgYT1bXTtrKHRoaXMuY2hhcnQuc2VyaWVzLGZ1bmN0aW9uKGMpe3ZhciBiPWMmJmMub3B0aW9ucztjJiZ1KGIuc2hvd0luTGVnZW5kLHYoYi5saW5rZWRUbyk/ITE6dm9pZCAwLCEwKSYmKGE9YS5jb25jYXQoYy5sZWdlbmRJdGVtc3x8KFwicG9pbnRcIj09PWIubGVnZW5kVHlwZT9jLmRhdGE6YykpKX0pO3JldHVybiBhfSxnZXRBbGlnbm1lbnQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnM7cmV0dXJuIGEuZmxvYXRpbmc/XCJcIjphLmFsaWduLmNoYXJBdCgwKSthLnZlcnRpY2FsQWxpZ24uY2hhckF0KDApK2EubGF5b3V0LmNoYXJBdCgwKX0sYWRqdXN0TWFyZ2luczpmdW5jdGlvbihhLGMpe3ZhciBiPXRoaXMuY2hhcnQsZT10aGlzLm9wdGlvbnMsbD10aGlzLmdldEFsaWdubWVudCgpO2wmJmsoWy8obHRofGN0fHJ0aCkvLC8ocnR2fHJtfHJidikvLC8ocmJofGNifGxiaCkvLC8obGJ2fGxtfGx0dikvXSxmdW5jdGlvbihmLGcpe2YudGVzdChsKSYmXG4hdihhW2ddKSYmKGJbd1tnXV09TWF0aC5tYXgoYlt3W2ddXSxiLmxlZ2VuZFsoZysxKSUyP1wibGVnZW5kSGVpZ2h0XCI6XCJsZWdlbmRXaWR0aFwiXStbMSwtMSwtMSwxXVtnXSplW2clMj9cInhcIjpcInlcIl0rdShlLm1hcmdpbiwxMikrY1tnXSsoMD09PWc/Yi50aXRsZU9mZnNldCtiLm9wdGlvbnMudGl0bGUubWFyZ2luOjApKSl9KX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxjPWEuY2hhcnQsYj1jLnJlbmRlcmVyLGY9YS5ncm91cCxsLGcscSx4LEY9YS5ib3gsbj1hLm9wdGlvbnMsQj1hLnBhZGRpbmc7YS5pdGVtWD1CO2EuaXRlbVk9YS5pbml0aWFsSXRlbVk7YS5vZmZzZXRXaWR0aD0wO2EubGFzdEl0ZW1ZPTA7Znx8KGEuZ3JvdXA9Zj1iLmcoXCJsZWdlbmRcIikuYXR0cih7ekluZGV4Ojd9KS5hZGQoKSxhLmNvbnRlbnRHcm91cD1iLmcoKS5hdHRyKHt6SW5kZXg6MX0pLmFkZChmKSxhLnNjcm9sbEdyb3VwPWIuZygpLmFkZChhLmNvbnRlbnRHcm91cCkpO2EucmVuZGVyVGl0bGUoKTtcbmw9YS5nZXRBbGxJdGVtcygpO20obCxmdW5jdGlvbihhLGIpe3JldHVybihhLm9wdGlvbnMmJmEub3B0aW9ucy5sZWdlbmRJbmRleHx8MCktKGIub3B0aW9ucyYmYi5vcHRpb25zLmxlZ2VuZEluZGV4fHwwKX0pO24ucmV2ZXJzZWQmJmwucmV2ZXJzZSgpO2EuYWxsSXRlbXM9bDthLmRpc3BsYXk9Zz0hIWwubGVuZ3RoO2EubGFzdExpbmVIZWlnaHQ9MDtrKGwsZnVuY3Rpb24oYil7YS5yZW5kZXJJdGVtKGIpfSk7cT0obi53aWR0aHx8YS5vZmZzZXRXaWR0aCkrQjt4PWEubGFzdEl0ZW1ZK2EubGFzdExpbmVIZWlnaHQrYS50aXRsZUhlaWdodDt4PWEuaGFuZGxlT3ZlcmZsb3coeCk7eCs9QjtGfHwoYS5ib3g9Rj1iLnJlY3QoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtbGVnZW5kLWJveFwiKS5hdHRyKHtyOm4uYm9yZGVyUmFkaXVzfSkuYWRkKGYpLEYuaXNOZXc9ITApO0YuYXR0cih7c3Ryb2tlOm4uYm9yZGVyQ29sb3IsXCJzdHJva2Utd2lkdGhcIjpuLmJvcmRlcldpZHRofHwwLGZpbGw6bi5iYWNrZ3JvdW5kQ29sb3J8fFxuXCJub25lXCJ9KS5zaGFkb3cobi5zaGFkb3cpOzA8cSYmMDx4JiYoRltGLmlzTmV3P1wiYXR0clwiOlwiYW5pbWF0ZVwiXShGLmNyaXNwLmNhbGwoe30se3g6MCx5OjAsd2lkdGg6cSxoZWlnaHQ6eH0sRi5zdHJva2VXaWR0aCgpKSksRi5pc05ldz0hMSk7RltnP1wic2hvd1wiOlwiaGlkZVwiXSgpO2EubGVnZW5kV2lkdGg9cTthLmxlZ2VuZEhlaWdodD14O2sobCxmdW5jdGlvbihiKXthLnBvc2l0aW9uSXRlbShiKX0pO2cmJihiPWMuc3BhY2luZ0JveCwvKGx0aHxjdHxydGgpLy50ZXN0KGEuZ2V0QWxpZ25tZW50KCkpJiYoYj10KGIse3k6Yi55K2MudGl0bGVPZmZzZXQrYy5vcHRpb25zLnRpdGxlLm1hcmdpbn0pKSxmLmFsaWduKHQobix7d2lkdGg6cSxoZWlnaHQ6eH0pLCEwLGIpKTtjLmlzUmVzaXppbmd8fHRoaXMucG9zaXRpb25DaGVja2JveGVzKCl9LGhhbmRsZU92ZXJmbG93OmZ1bmN0aW9uKGEpe3ZhciBjPXRoaXMsYj10aGlzLmNoYXJ0LGU9Yi5yZW5kZXJlcixsPXRoaXMub3B0aW9ucyxmPVxubC55LGc9dGhpcy5wYWRkaW5nLGI9Yi5zcGFjaW5nQm94LmhlaWdodCsoXCJ0b3BcIj09PWwudmVydGljYWxBbGlnbj8tZjpmKS1nLGY9bC5tYXhIZWlnaHQsbSxGPXRoaXMuY2xpcFJlY3Qsbj1sLm5hdmlnYXRpb24sQj11KG4uYW5pbWF0aW9uLCEwKSxxPW4uYXJyb3dTaXplfHwxMixBPXRoaXMubmF2LGQ9dGhpcy5wYWdlcyxwLEQ9dGhpcy5hbGxJdGVtcyxoPWZ1bmN0aW9uKGEpe1wibnVtYmVyXCI9PT10eXBlb2YgYT9GLmF0dHIoe2hlaWdodDphfSk6RiYmKGMuY2xpcFJlY3Q9Ri5kZXN0cm95KCksYy5jb250ZW50R3JvdXAuY2xpcCgpKTtjLmNvbnRlbnRHcm91cC5kaXYmJihjLmNvbnRlbnRHcm91cC5kaXYuc3R5bGUuY2xpcD1hP1wicmVjdChcIitnK1wicHgsOTk5OXB4LFwiKyhnK2EpK1wicHgsMClcIjpcImF1dG9cIil9O1wiaG9yaXpvbnRhbFwiIT09bC5sYXlvdXR8fFwibWlkZGxlXCI9PT1sLnZlcnRpY2FsQWxpZ258fGwuZmxvYXRpbmd8fChiLz0yKTtmJiYoYj1NYXRoLm1pbihiLGYpKTtkLmxlbmd0aD1cbjA7YT5iJiYhMSE9PW4uZW5hYmxlZD8odGhpcy5jbGlwSGVpZ2h0PW09TWF0aC5tYXgoYi0yMC10aGlzLnRpdGxlSGVpZ2h0LWcsMCksdGhpcy5jdXJyZW50UGFnZT11KHRoaXMuY3VycmVudFBhZ2UsMSksdGhpcy5mdWxsSGVpZ2h0PWEsayhELGZ1bmN0aW9uKGEsYil7dmFyIGM9YS5fbGVnZW5kSXRlbVBvc1sxXSxoPU1hdGgucm91bmQoYS5sZWdlbmRJdGVtLmdldEJCb3goKS5oZWlnaHQpLGU9ZC5sZW5ndGg7aWYoIWV8fGMtZFtlLTFdPm0mJihwfHxjKSE9PWRbZS0xXSlkLnB1c2gocHx8YyksZSsrO2EucGFnZUl4PWUtMTtwJiYoRFtiLTFdLnBhZ2VJeD1lLTEpO2I9PT1ELmxlbmd0aC0xJiZjK2gtZFtlLTFdPm0mJihkLnB1c2goYyksYS5wYWdlSXg9ZSk7YyE9PXAmJihwPWMpfSksRnx8KEY9Yy5jbGlwUmVjdD1lLmNsaXBSZWN0KDAsZyw5OTk5LDApLGMuY29udGVudEdyb3VwLmNsaXAoRikpLGgobSksQXx8KHRoaXMubmF2PUE9ZS5nKCkuYXR0cih7ekluZGV4OjF9KS5hZGQodGhpcy5ncm91cCksXG50aGlzLnVwPWUuc3ltYm9sKFwidHJpYW5nbGVcIiwwLDAscSxxKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oKXtjLnNjcm9sbCgtMSxCKX0pLmFkZChBKSx0aGlzLnBhZ2VyPWUudGV4dChcIlwiLDE1LDEwKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtbGVnZW5kLW5hdmlnYXRpb25cIikuY3NzKG4uc3R5bGUpLmFkZChBKSx0aGlzLmRvd249ZS5zeW1ib2woXCJ0cmlhbmdsZS1kb3duXCIsMCwwLHEscSkub24oXCJjbGlja1wiLGZ1bmN0aW9uKCl7Yy5zY3JvbGwoMSxCKX0pLmFkZChBKSksYy5zY3JvbGwoMCksYT1iKTpBJiYoaCgpLHRoaXMubmF2PUEuZGVzdHJveSgpLHRoaXMuc2Nyb2xsR3JvdXAuYXR0cih7dHJhbnNsYXRlWToxfSksdGhpcy5jbGlwSGVpZ2h0PTApO3JldHVybiBhfSxzY3JvbGw6ZnVuY3Rpb24oYSxjKXt2YXIgYj10aGlzLnBhZ2VzLGU9Yi5sZW5ndGg7YT10aGlzLmN1cnJlbnRQYWdlK2E7dmFyIGw9dGhpcy5jbGlwSGVpZ2h0LGY9dGhpcy5vcHRpb25zLm5hdmlnYXRpb24sZz10aGlzLnBhZ2VyLFxubT10aGlzLnBhZGRpbmc7YT5lJiYoYT1lKTswPGEmJih2b2lkIDAhPT1jJiZ6KGMsdGhpcy5jaGFydCksdGhpcy5uYXYuYXR0cih7dHJhbnNsYXRlWDptLHRyYW5zbGF0ZVk6bCt0aGlzLnBhZGRpbmcrNyt0aGlzLnRpdGxlSGVpZ2h0LHZpc2liaWxpdHk6XCJ2aXNpYmxlXCJ9KSx0aGlzLnVwLmF0dHIoe1wiY2xhc3NcIjoxPT09YT9cImhpZ2hjaGFydHMtbGVnZW5kLW5hdi1pbmFjdGl2ZVwiOlwiaGlnaGNoYXJ0cy1sZWdlbmQtbmF2LWFjdGl2ZVwifSksZy5hdHRyKHt0ZXh0OmErXCIvXCIrZX0pLHRoaXMuZG93bi5hdHRyKHt4OjE4K3RoaXMucGFnZXIuZ2V0QkJveCgpLndpZHRoLFwiY2xhc3NcIjphPT09ZT9cImhpZ2hjaGFydHMtbGVnZW5kLW5hdi1pbmFjdGl2ZVwiOlwiaGlnaGNoYXJ0cy1sZWdlbmQtbmF2LWFjdGl2ZVwifSksdGhpcy51cC5hdHRyKHtmaWxsOjE9PT1hP2YuaW5hY3RpdmVDb2xvcjpmLmFjdGl2ZUNvbG9yfSkuY3NzKHtjdXJzb3I6MT09PWE/XCJkZWZhdWx0XCI6XCJwb2ludGVyXCJ9KSx0aGlzLmRvd24uYXR0cih7ZmlsbDphPT09XG5lP2YuaW5hY3RpdmVDb2xvcjpmLmFjdGl2ZUNvbG9yfSkuY3NzKHtjdXJzb3I6YT09PWU/XCJkZWZhdWx0XCI6XCJwb2ludGVyXCJ9KSx0aGlzLnNjcm9sbE9mZnNldD0tYlthLTFdK3RoaXMuaW5pdGlhbEl0ZW1ZLHRoaXMuc2Nyb2xsR3JvdXAuYW5pbWF0ZSh7dHJhbnNsYXRlWTp0aGlzLnNjcm9sbE9mZnNldH0pLHRoaXMuY3VycmVudFBhZ2U9YSx0aGlzLnBvc2l0aW9uQ2hlY2tib3hlcygpKX19O2EuTGVnZW5kU3ltYm9sTWl4aW49e2RyYXdSZWN0YW5nbGU6ZnVuY3Rpb24oYSxjKXt2YXIgYj1hLnN5bWJvbEhlaWdodCxlPWEub3B0aW9ucy5zcXVhcmVTeW1ib2w7Yy5sZWdlbmRTeW1ib2w9dGhpcy5jaGFydC5yZW5kZXJlci5yZWN0KGU/KGEuc3ltYm9sV2lkdGgtYikvMjowLGEuYmFzZWxpbmUtYisxLGU/YjphLnN5bWJvbFdpZHRoLGIsdShhLm9wdGlvbnMuc3ltYm9sUmFkaXVzLGIvMikpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1wb2ludFwiKS5hdHRyKHt6SW5kZXg6M30pLmFkZChjLmxlZ2VuZEdyb3VwKX0sXG5kcmF3TGluZU1hcmtlcjpmdW5jdGlvbihhKXt2YXIgYz10aGlzLm9wdGlvbnMsYj1jLm1hcmtlcixlPWEuc3ltYm9sV2lkdGgsbD1hLnN5bWJvbEhlaWdodCxmPWwvMixnPXRoaXMuY2hhcnQucmVuZGVyZXIsbT10aGlzLmxlZ2VuZEdyb3VwO2E9YS5iYXNlbGluZS1NYXRoLnJvdW5kKC4zKmEuZm9udE1ldHJpY3MuYik7dmFyIGs7az17XCJzdHJva2Utd2lkdGhcIjpjLmxpbmVXaWR0aHx8MH07Yy5kYXNoU3R5bGUmJihrLmRhc2hzdHlsZT1jLmRhc2hTdHlsZSk7dGhpcy5sZWdlbmRMaW5lPWcucGF0aChbXCJNXCIsMCxhLFwiTFwiLGUsYV0pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1ncmFwaFwiKS5hdHRyKGspLmFkZChtKTtiJiYhMSE9PWIuZW5hYmxlZCYmKGM9TWF0aC5taW4odShiLnJhZGl1cyxmKSxmKSwwPT09dGhpcy5zeW1ib2wuaW5kZXhPZihcInVybFwiKSYmKGI9dChiLHt3aWR0aDpsLGhlaWdodDpsfSksYz0wKSx0aGlzLmxlZ2VuZFN5bWJvbD1iPWcuc3ltYm9sKHRoaXMuc3ltYm9sLGUvXG4yLWMsYS1jLDIqYywyKmMsYikuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXBvaW50XCIpLmFkZChtKSxiLmlzTWFya2VyPSEwKX19OygvVHJpZGVudFxcLzdcXC4wLy50ZXN0KGcubmF2aWdhdG9yLnVzZXJBZ2VudCl8fHEpJiZmKGEuTGVnZW5kLnByb3RvdHlwZSxcInBvc2l0aW9uSXRlbVwiLGZ1bmN0aW9uKGEsYyl7dmFyIGI9dGhpcyxlPWZ1bmN0aW9uKCl7Yy5fbGVnZW5kSXRlbVBvcyYmYS5jYWxsKGIsYyl9O2UoKTtzZXRUaW1lb3V0KGUpfSl9KShMKTsoZnVuY3Rpb24oYSl7dmFyIEc9YS5hZGRFdmVudCxFPWEuYW5pbWF0ZSxIPWEuYW5pbU9iamVjdCx2PWEuYXR0cixrPWEuZG9jLHE9YS5BeGlzLHc9YS5jcmVhdGVFbGVtZW50LHQ9YS5kZWZhdWx0T3B0aW9ucyx1PWEuZGlzY2FyZEVsZW1lbnQsej1hLmNoYXJ0cyxtPWEuY3NzLGc9YS5kZWZpbmVkLGY9YS5lYWNoLGU9YS5leHRlbmQsYz1hLmZpbmQsYj1hLmZpcmVFdmVudCxyPWEuZ3JlcCxsPWEuaXNOdW1iZXIsQz1hLmlzT2JqZWN0LEk9XG5hLmlzU3RyaW5nLHg9YS5MZWdlbmQsRj1hLm1hcmdpbk5hbWVzLG49YS5tZXJnZSxCPWEub2JqZWN0RWFjaCxKPWEuUG9pbnRlcixBPWEucGljayxkPWEucEludCxwPWEucmVtb3ZlRXZlbnQsRD1hLnNlcmllc1R5cGVzLGg9YS5zcGxhdCx5PWEuc3ZnLFA9YS5zeW5jVGltZW91dCxNPWEud2luLE89YS5DaGFydD1mdW5jdGlvbigpe3RoaXMuZ2V0QXJncy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2EuY2hhcnQ9ZnVuY3Rpb24oYSxkLGIpe3JldHVybiBuZXcgTyhhLGQsYil9O2UoTy5wcm90b3R5cGUse2NhbGxiYWNrczpbXSxnZXRBcmdzOmZ1bmN0aW9uKCl7dmFyIGE9W10uc2xpY2UuY2FsbChhcmd1bWVudHMpO2lmKEkoYVswXSl8fGFbMF0ubm9kZU5hbWUpdGhpcy5yZW5kZXJUbz1hLnNoaWZ0KCk7dGhpcy5pbml0KGFbMF0sYVsxXSl9LGluaXQ6ZnVuY3Rpb24oZCxiKXt2YXIgYyxoLHA9ZC5zZXJpZXMsZT1kLnBsb3RPcHRpb25zfHx7fTtkLnNlcmllcz1udWxsO2M9bih0LGQpO2ZvcihoIGluIGMucGxvdE9wdGlvbnMpYy5wbG90T3B0aW9uc1toXS50b29sdGlwPVxuZVtoXSYmbihlW2hdLnRvb2x0aXApfHx2b2lkIDA7Yy50b29sdGlwLnVzZXJPcHRpb25zPWQuY2hhcnQmJmQuY2hhcnQuZm9yRXhwb3J0JiZkLnRvb2x0aXAudXNlck9wdGlvbnN8fGQudG9vbHRpcDtjLnNlcmllcz1kLnNlcmllcz1wO3RoaXMudXNlck9wdGlvbnM9ZDtkPWMuY2hhcnQ7aD1kLmV2ZW50czt0aGlzLm1hcmdpbj1bXTt0aGlzLnNwYWNpbmc9W107dGhpcy5ib3VuZHM9e2g6e30sdjp7fX07dGhpcy5sYWJlbENvbGxlY3RvcnM9W107dGhpcy5jYWxsYmFjaz1iO3RoaXMuaXNSZXNpemluZz0wO3RoaXMub3B0aW9ucz1jO3RoaXMuYXhlcz1bXTt0aGlzLnNlcmllcz1bXTt0aGlzLmhhc0NhcnRlc2lhblNlcmllcz1kLnNob3dBeGVzO3ZhciBsPXRoaXM7bC5pbmRleD16Lmxlbmd0aDt6LnB1c2gobCk7YS5jaGFydENvdW50Kys7aCYmQihoLGZ1bmN0aW9uKGEsZCl7RyhsLGQsYSl9KTtsLnhBeGlzPVtdO2wueUF4aXM9W107bC5wb2ludENvdW50PWwuY29sb3JDb3VudGVyPWwuc3ltYm9sQ291bnRlcj1cbjA7bC5maXJzdFJlbmRlcigpfSxpbml0U2VyaWVzOmZ1bmN0aW9uKGQpe3ZhciBiPXRoaXMub3B0aW9ucy5jaGFydDsoYj1EW2QudHlwZXx8Yi50eXBlfHxiLmRlZmF1bHRTZXJpZXNUeXBlXSl8fGEuZXJyb3IoMTcsITApO2I9bmV3IGI7Yi5pbml0KHRoaXMsZCk7cmV0dXJuIGJ9LG9yZGVyU2VyaWVzOmZ1bmN0aW9uKGEpe3ZhciBkPXRoaXMuc2VyaWVzO2ZvcihhPWF8fDA7YTxkLmxlbmd0aDthKyspZFthXSYmKGRbYV0uaW5kZXg9YSxkW2FdLm5hbWU9ZFthXS5uYW1lfHxcIlNlcmllcyBcIisoZFthXS5pbmRleCsxKSl9LGlzSW5zaWRlUGxvdDpmdW5jdGlvbihhLGQsYil7dmFyIGM9Yj9kOmE7YT1iP2E6ZDtyZXR1cm4gMDw9YyYmYzw9dGhpcy5wbG90V2lkdGgmJjA8PWEmJmE8PXRoaXMucGxvdEhlaWdodH0scmVkcmF3OmZ1bmN0aW9uKGQpe3ZhciBjPXRoaXMuYXhlcyxoPXRoaXMuc2VyaWVzLHA9dGhpcy5wb2ludGVyLG49dGhpcy5sZWdlbmQsbD10aGlzLmlzRGlydHlMZWdlbmQsXG5BLGcseT10aGlzLmhhc0NhcnRlc2lhblNlcmllcyxEPXRoaXMuaXNEaXJ0eUJveCxtLHI9dGhpcy5yZW5kZXJlcix4PXIuaXNIaWRkZW4oKSxCPVtdO3RoaXMuc2V0UmVzcG9uc2l2ZSYmdGhpcy5zZXRSZXNwb25zaXZlKCExKTthLnNldEFuaW1hdGlvbihkLHRoaXMpO3gmJnRoaXMudGVtcG9yYXJ5RGlzcGxheSgpO3RoaXMubGF5T3V0VGl0bGVzKCk7Zm9yKGQ9aC5sZW5ndGg7ZC0tOylpZihtPWhbZF0sbS5vcHRpb25zLnN0YWNraW5nJiYoQT0hMCxtLmlzRGlydHkpKXtnPSEwO2JyZWFrfWlmKGcpZm9yKGQ9aC5sZW5ndGg7ZC0tOyltPWhbZF0sbS5vcHRpb25zLnN0YWNraW5nJiYobS5pc0RpcnR5PSEwKTtmKGgsZnVuY3Rpb24oYSl7YS5pc0RpcnR5JiZcInBvaW50XCI9PT1hLm9wdGlvbnMubGVnZW5kVHlwZSYmKGEudXBkYXRlVG90YWxzJiZhLnVwZGF0ZVRvdGFscygpLGw9ITApO2EuaXNEaXJ0eURhdGEmJmIoYSxcInVwZGF0ZWREYXRhXCIpfSk7bCYmbi5vcHRpb25zLmVuYWJsZWQmJlxuKG4ucmVuZGVyKCksdGhpcy5pc0RpcnR5TGVnZW5kPSExKTtBJiZ0aGlzLmdldFN0YWNrcygpO3kmJmYoYyxmdW5jdGlvbihhKXthLnVwZGF0ZU5hbWVzKCk7YS5zZXRTY2FsZSgpfSk7dGhpcy5nZXRNYXJnaW5zKCk7eSYmKGYoYyxmdW5jdGlvbihhKXthLmlzRGlydHkmJihEPSEwKX0pLGYoYyxmdW5jdGlvbihhKXt2YXIgZD1hLm1pbitcIixcIithLm1heDthLmV4dEtleSE9PWQmJihhLmV4dEtleT1kLEIucHVzaChmdW5jdGlvbigpe2IoYSxcImFmdGVyU2V0RXh0cmVtZXNcIixlKGEuZXZlbnRBcmdzLGEuZ2V0RXh0cmVtZXMoKSkpO2RlbGV0ZSBhLmV2ZW50QXJnc30pKTsoRHx8QSkmJmEucmVkcmF3KCl9KSk7RCYmdGhpcy5kcmF3Q2hhcnRCb3goKTtiKHRoaXMsXCJwcmVkcmF3XCIpO2YoaCxmdW5jdGlvbihhKXsoRHx8YS5pc0RpcnR5KSYmYS52aXNpYmxlJiZhLnJlZHJhdygpO2EuaXNEaXJ0eURhdGE9ITF9KTtwJiZwLnJlc2V0KCEwKTtyLmRyYXcoKTtiKHRoaXMsXCJyZWRyYXdcIik7Yih0aGlzLFxuXCJyZW5kZXJcIik7eCYmdGhpcy50ZW1wb3JhcnlEaXNwbGF5KCEwKTtmKEIsZnVuY3Rpb24oYSl7YS5jYWxsKCl9KX0sZ2V0OmZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGQoZCl7cmV0dXJuIGQuaWQ9PT1hfHxkLm9wdGlvbnMmJmQub3B0aW9ucy5pZD09PWF9dmFyIGIsaD10aGlzLnNlcmllcyxwO2I9Yyh0aGlzLmF4ZXMsZCl8fGModGhpcy5zZXJpZXMsZCk7Zm9yKHA9MDshYiYmcDxoLmxlbmd0aDtwKyspYj1jKGhbcF0ucG9pbnRzfHxbXSxkKTtyZXR1cm4gYn0sZ2V0QXhlczpmdW5jdGlvbigpe3ZhciBhPXRoaXMsZD10aGlzLm9wdGlvbnMsYj1kLnhBeGlzPWgoZC54QXhpc3x8e30pLGQ9ZC55QXhpcz1oKGQueUF4aXN8fHt9KTtmKGIsZnVuY3Rpb24oYSxkKXthLmluZGV4PWQ7YS5pc1g9ITB9KTtmKGQsZnVuY3Rpb24oYSxkKXthLmluZGV4PWR9KTtiPWIuY29uY2F0KGQpO2YoYixmdW5jdGlvbihkKXtuZXcgcShhLGQpfSl9LGdldFNlbGVjdGVkUG9pbnRzOmZ1bmN0aW9uKCl7dmFyIGE9XG5bXTtmKHRoaXMuc2VyaWVzLGZ1bmN0aW9uKGQpe2E9YS5jb25jYXQocihkLmRhdGF8fFtdLGZ1bmN0aW9uKGEpe3JldHVybiBhLnNlbGVjdGVkfSkpfSk7cmV0dXJuIGF9LGdldFNlbGVjdGVkU2VyaWVzOmZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcy5zZXJpZXMsZnVuY3Rpb24oYSl7cmV0dXJuIGEuc2VsZWN0ZWR9KX0sc2V0VGl0bGU6ZnVuY3Rpb24oYSxkLGIpe3ZhciBjPXRoaXMsaD1jLm9wdGlvbnMscDtwPWgudGl0bGU9bih7c3R5bGU6e2NvbG9yOlwiIzMzMzMzM1wiLGZvbnRTaXplOmguaXNTdG9jaz9cIjE2cHhcIjpcIjE4cHhcIn19LGgudGl0bGUsYSk7aD1oLnN1YnRpdGxlPW4oe3N0eWxlOntjb2xvcjpcIiM2NjY2NjZcIn19LGguc3VidGl0bGUsZCk7ZihbW1widGl0bGVcIixhLHBdLFtcInN1YnRpdGxlXCIsZCxoXV0sZnVuY3Rpb24oYSxkKXt2YXIgYj1hWzBdLGg9Y1tiXSxwPWFbMV07YT1hWzJdO2gmJnAmJihjW2JdPWg9aC5kZXN0cm95KCkpO2EmJiFoJiYoY1tiXT1jLnJlbmRlcmVyLnRleHQoYS50ZXh0LFxuMCwwLGEudXNlSFRNTCkuYXR0cih7YWxpZ246YS5hbGlnbixcImNsYXNzXCI6XCJoaWdoY2hhcnRzLVwiK2IsekluZGV4OmEuekluZGV4fHw0fSkuYWRkKCksY1tiXS51cGRhdGU9ZnVuY3Rpb24oYSl7Yy5zZXRUaXRsZSghZCYmYSxkJiZhKX0sY1tiXS5jc3MoYS5zdHlsZSkpfSk7Yy5sYXlPdXRUaXRsZXMoYil9LGxheU91dFRpdGxlczpmdW5jdGlvbihhKXt2YXIgZD0wLGIsYz10aGlzLnJlbmRlcmVyLGg9dGhpcy5zcGFjaW5nQm94O2YoW1widGl0bGVcIixcInN1YnRpdGxlXCJdLGZ1bmN0aW9uKGEpe3ZhciBiPXRoaXNbYV0scD10aGlzLm9wdGlvbnNbYV07YT1cInRpdGxlXCI9PT1hPy0zOnAudmVydGljYWxBbGlnbj8wOmQrMjt2YXIgbjtiJiYobj1wLnN0eWxlLmZvbnRTaXplLG49Yy5mb250TWV0cmljcyhuLGIpLmIsYi5jc3Moe3dpZHRoOihwLndpZHRofHxoLndpZHRoK3Aud2lkdGhBZGp1c3QpK1wicHhcIn0pLmFsaWduKGUoe3k6YStufSxwKSwhMSxcInNwYWNpbmdCb3hcIikscC5mbG9hdGluZ3x8XG5wLnZlcnRpY2FsQWxpZ258fChkPU1hdGguY2VpbChkK2IuZ2V0QkJveChwLnVzZUhUTUwpLmhlaWdodCkpKX0sdGhpcyk7Yj10aGlzLnRpdGxlT2Zmc2V0IT09ZDt0aGlzLnRpdGxlT2Zmc2V0PWQ7IXRoaXMuaXNEaXJ0eUJveCYmYiYmKHRoaXMuaXNEaXJ0eUJveD1iLHRoaXMuaGFzUmVuZGVyZWQmJkEoYSwhMCkmJnRoaXMuaXNEaXJ0eUJveCYmdGhpcy5yZWRyYXcoKSl9LGdldENoYXJ0U2l6ZTpmdW5jdGlvbigpe3ZhciBkPXRoaXMub3B0aW9ucy5jaGFydCxiPWQud2lkdGgsZD1kLmhlaWdodCxjPXRoaXMucmVuZGVyVG87ZyhiKXx8KHRoaXMuY29udGFpbmVyV2lkdGg9YS5nZXRTdHlsZShjLFwid2lkdGhcIikpO2coZCl8fCh0aGlzLmNvbnRhaW5lckhlaWdodD1hLmdldFN0eWxlKGMsXCJoZWlnaHRcIikpO3RoaXMuY2hhcnRXaWR0aD1NYXRoLm1heCgwLGJ8fHRoaXMuY29udGFpbmVyV2lkdGh8fDYwMCk7dGhpcy5jaGFydEhlaWdodD1NYXRoLm1heCgwLGEucmVsYXRpdmVMZW5ndGgoZCxcbnRoaXMuY2hhcnRXaWR0aCl8fCgxPHRoaXMuY29udGFpbmVySGVpZ2h0P3RoaXMuY29udGFpbmVySGVpZ2h0OjQwMCkpfSx0ZW1wb3JhcnlEaXNwbGF5OmZ1bmN0aW9uKGQpe3ZhciBiPXRoaXMucmVuZGVyVG87aWYoZClmb3IoO2ImJmIuc3R5bGU7KWIuaGNPcmlnU3R5bGUmJihhLmNzcyhiLGIuaGNPcmlnU3R5bGUpLGRlbGV0ZSBiLmhjT3JpZ1N0eWxlKSxiLmhjT3JpZ0RldGFjaGVkJiYoay5ib2R5LnJlbW92ZUNoaWxkKGIpLGIuaGNPcmlnRGV0YWNoZWQ9ITEpLGI9Yi5wYXJlbnROb2RlO2Vsc2UgZm9yKDtiJiZiLnN0eWxlOyl7ay5ib2R5LmNvbnRhaW5zKGIpfHxiLnBhcmVudE5vZGV8fChiLmhjT3JpZ0RldGFjaGVkPSEwLGsuYm9keS5hcHBlbmRDaGlsZChiKSk7aWYoXCJub25lXCI9PT1hLmdldFN0eWxlKGIsXCJkaXNwbGF5XCIsITEpfHxiLmhjT3JpY0RldGFjaGVkKWIuaGNPcmlnU3R5bGU9e2Rpc3BsYXk6Yi5zdHlsZS5kaXNwbGF5LGhlaWdodDpiLnN0eWxlLmhlaWdodCxvdmVyZmxvdzpiLnN0eWxlLm92ZXJmbG93fSxcbmQ9e2Rpc3BsYXk6XCJibG9ja1wiLG92ZXJmbG93OlwiaGlkZGVuXCJ9LGIhPT10aGlzLnJlbmRlclRvJiYoZC5oZWlnaHQ9MCksYS5jc3MoYixkKSxiLm9mZnNldFdpZHRofHxiLnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLFwiYmxvY2tcIixcImltcG9ydGFudFwiKTtiPWIucGFyZW50Tm9kZTtpZihiPT09ay5ib2R5KWJyZWFrfX0sc2V0Q2xhc3NOYW1lOmZ1bmN0aW9uKGEpe3RoaXMuY29udGFpbmVyLmNsYXNzTmFtZT1cImhpZ2hjaGFydHMtY29udGFpbmVyIFwiKyhhfHxcIlwiKX0sZ2V0Q29udGFpbmVyOmZ1bmN0aW9uKCl7dmFyIGIsYz10aGlzLm9wdGlvbnMsaD1jLmNoYXJ0LHAsbjtiPXRoaXMucmVuZGVyVG87dmFyIGY9YS51bmlxdWVLZXkoKSxBO2J8fCh0aGlzLnJlbmRlclRvPWI9aC5yZW5kZXJUbyk7SShiKSYmKHRoaXMucmVuZGVyVG89Yj1rLmdldEVsZW1lbnRCeUlkKGIpKTtifHxhLmVycm9yKDEzLCEwKTtwPWQodihiLFwiZGF0YS1oaWdoY2hhcnRzLWNoYXJ0XCIpKTtsKHApJiZ6W3BdJiZcbnpbcF0uaGFzUmVuZGVyZWQmJnpbcF0uZGVzdHJveSgpO3YoYixcImRhdGEtaGlnaGNoYXJ0cy1jaGFydFwiLHRoaXMuaW5kZXgpO2IuaW5uZXJIVE1MPVwiXCI7aC5za2lwQ2xvbmV8fGIub2Zmc2V0V2lkdGh8fHRoaXMudGVtcG9yYXJ5RGlzcGxheSgpO3RoaXMuZ2V0Q2hhcnRTaXplKCk7cD10aGlzLmNoYXJ0V2lkdGg7bj10aGlzLmNoYXJ0SGVpZ2h0O0E9ZSh7cG9zaXRpb246XCJyZWxhdGl2ZVwiLG92ZXJmbG93OlwiaGlkZGVuXCIsd2lkdGg6cCtcInB4XCIsaGVpZ2h0Om4rXCJweFwiLHRleHRBbGlnbjpcImxlZnRcIixsaW5lSGVpZ2h0Olwibm9ybWFsXCIsekluZGV4OjAsXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIjpcInJnYmEoMCwwLDAsMClcIn0saC5zdHlsZSk7dGhpcy5jb250YWluZXI9Yj13KFwiZGl2XCIse2lkOmZ9LEEsYik7dGhpcy5fY3Vyc29yPWIuc3R5bGUuY3Vyc29yO3RoaXMucmVuZGVyZXI9bmV3IChhW2gucmVuZGVyZXJdfHxhLlJlbmRlcmVyKShiLHAsbixudWxsLGguZm9yRXhwb3J0LFxuYy5leHBvcnRpbmcmJmMuZXhwb3J0aW5nLmFsbG93SFRNTCk7dGhpcy5zZXRDbGFzc05hbWUoaC5jbGFzc05hbWUpO3RoaXMucmVuZGVyZXIuc2V0U3R5bGUoaC5zdHlsZSk7dGhpcy5yZW5kZXJlci5jaGFydEluZGV4PXRoaXMuaW5kZXh9LGdldE1hcmdpbnM6ZnVuY3Rpb24oYSl7dmFyIGQ9dGhpcy5zcGFjaW5nLGI9dGhpcy5tYXJnaW4sYz10aGlzLnRpdGxlT2Zmc2V0O3RoaXMucmVzZXRNYXJnaW5zKCk7YyYmIWcoYlswXSkmJih0aGlzLnBsb3RUb3A9TWF0aC5tYXgodGhpcy5wbG90VG9wLGMrdGhpcy5vcHRpb25zLnRpdGxlLm1hcmdpbitkWzBdKSk7dGhpcy5sZWdlbmQmJnRoaXMubGVnZW5kLmRpc3BsYXkmJnRoaXMubGVnZW5kLmFkanVzdE1hcmdpbnMoYixkKTt0aGlzLmV4dHJhTWFyZ2luJiYodGhpc1t0aGlzLmV4dHJhTWFyZ2luLnR5cGVdPSh0aGlzW3RoaXMuZXh0cmFNYXJnaW4udHlwZV18fDApK3RoaXMuZXh0cmFNYXJnaW4udmFsdWUpO3RoaXMuYWRqdXN0UGxvdEFyZWEmJlxudGhpcy5hZGp1c3RQbG90QXJlYSgpO2F8fHRoaXMuZ2V0QXhpc01hcmdpbnMoKX0sZ2V0QXhpc01hcmdpbnM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGQ9YS5heGlzT2Zmc2V0PVswLDAsMCwwXSxiPWEubWFyZ2luO2EuaGFzQ2FydGVzaWFuU2VyaWVzJiZmKGEuYXhlcyxmdW5jdGlvbihhKXthLnZpc2libGUmJmEuZ2V0T2Zmc2V0KCl9KTtmKEYsZnVuY3Rpb24oYyxoKXtnKGJbaF0pfHwoYVtjXSs9ZFtoXSl9KTthLnNldENoYXJ0U2l6ZSgpfSxyZWZsb3c6ZnVuY3Rpb24oZCl7dmFyIGI9dGhpcyxjPWIub3B0aW9ucy5jaGFydCxoPWIucmVuZGVyVG8scD1nKGMud2lkdGgpJiZnKGMuaGVpZ2h0KSxlPWMud2lkdGh8fGEuZ2V0U3R5bGUoaCxcIndpZHRoXCIpLGM9Yy5oZWlnaHR8fGEuZ2V0U3R5bGUoaCxcImhlaWdodFwiKSxoPWQ/ZC50YXJnZXQ6TTtpZighcCYmIWIuaXNQcmludGluZyYmZSYmYyYmKGg9PT1NfHxoPT09aykpe2lmKGUhPT1iLmNvbnRhaW5lcldpZHRofHxjIT09Yi5jb250YWluZXJIZWlnaHQpY2xlYXJUaW1lb3V0KGIucmVmbG93VGltZW91dCksXG5iLnJlZmxvd1RpbWVvdXQ9UChmdW5jdGlvbigpe2IuY29udGFpbmVyJiZiLnNldFNpemUodm9pZCAwLHZvaWQgMCwhMSl9LGQ/MTAwOjApO2IuY29udGFpbmVyV2lkdGg9ZTtiLmNvbnRhaW5lckhlaWdodD1jfX0saW5pdFJlZmxvdzpmdW5jdGlvbigpe3ZhciBhPXRoaXMsZDtkPUcoTSxcInJlc2l6ZVwiLGZ1bmN0aW9uKGQpe2EucmVmbG93KGQpfSk7RyhhLFwiZGVzdHJveVwiLGQpfSxzZXRTaXplOmZ1bmN0aW9uKGQsYyxoKXt2YXIgcD10aGlzLGU9cC5yZW5kZXJlcjtwLmlzUmVzaXppbmcrPTE7YS5zZXRBbmltYXRpb24oaCxwKTtwLm9sZENoYXJ0SGVpZ2h0PXAuY2hhcnRIZWlnaHQ7cC5vbGRDaGFydFdpZHRoPXAuY2hhcnRXaWR0aDt2b2lkIDAhPT1kJiYocC5vcHRpb25zLmNoYXJ0LndpZHRoPWQpO3ZvaWQgMCE9PWMmJihwLm9wdGlvbnMuY2hhcnQuaGVpZ2h0PWMpO3AuZ2V0Q2hhcnRTaXplKCk7ZD1lLmdsb2JhbEFuaW1hdGlvbjsoZD9FOm0pKHAuY29udGFpbmVyLHt3aWR0aDpwLmNoYXJ0V2lkdGgrXG5cInB4XCIsaGVpZ2h0OnAuY2hhcnRIZWlnaHQrXCJweFwifSxkKTtwLnNldENoYXJ0U2l6ZSghMCk7ZS5zZXRTaXplKHAuY2hhcnRXaWR0aCxwLmNoYXJ0SGVpZ2h0LGgpO2YocC5heGVzLGZ1bmN0aW9uKGEpe2EuaXNEaXJ0eT0hMDthLnNldFNjYWxlKCl9KTtwLmlzRGlydHlMZWdlbmQ9ITA7cC5pc0RpcnR5Qm94PSEwO3AubGF5T3V0VGl0bGVzKCk7cC5nZXRNYXJnaW5zKCk7cC5yZWRyYXcoaCk7cC5vbGRDaGFydEhlaWdodD1udWxsO2IocCxcInJlc2l6ZVwiKTtQKGZ1bmN0aW9uKCl7cCYmYihwLFwiZW5kUmVzaXplXCIsbnVsbCxmdW5jdGlvbigpey0tcC5pc1Jlc2l6aW5nfSl9LEgoZCkuZHVyYXRpb24pfSxzZXRDaGFydFNpemU6ZnVuY3Rpb24oYSl7dmFyIGQ9dGhpcy5pbnZlcnRlZCxiPXRoaXMucmVuZGVyZXIsYz10aGlzLmNoYXJ0V2lkdGgsaD10aGlzLmNoYXJ0SGVpZ2h0LHA9dGhpcy5vcHRpb25zLmNoYXJ0LGU9dGhpcy5zcGFjaW5nLG49dGhpcy5jbGlwT2Zmc2V0LGwsQSxnLHk7dGhpcy5wbG90TGVmdD1cbmw9TWF0aC5yb3VuZCh0aGlzLnBsb3RMZWZ0KTt0aGlzLnBsb3RUb3A9QT1NYXRoLnJvdW5kKHRoaXMucGxvdFRvcCk7dGhpcy5wbG90V2lkdGg9Zz1NYXRoLm1heCgwLE1hdGgucm91bmQoYy1sLXRoaXMubWFyZ2luUmlnaHQpKTt0aGlzLnBsb3RIZWlnaHQ9eT1NYXRoLm1heCgwLE1hdGgucm91bmQoaC1BLXRoaXMubWFyZ2luQm90dG9tKSk7dGhpcy5wbG90U2l6ZVg9ZD95Omc7dGhpcy5wbG90U2l6ZVk9ZD9nOnk7dGhpcy5wbG90Qm9yZGVyV2lkdGg9cC5wbG90Qm9yZGVyV2lkdGh8fDA7dGhpcy5zcGFjaW5nQm94PWIuc3BhY2luZ0JveD17eDplWzNdLHk6ZVswXSx3aWR0aDpjLWVbM10tZVsxXSxoZWlnaHQ6aC1lWzBdLWVbMl19O3RoaXMucGxvdEJveD1iLnBsb3RCb3g9e3g6bCx5OkEsd2lkdGg6ZyxoZWlnaHQ6eX07Yz0yKk1hdGguZmxvb3IodGhpcy5wbG90Qm9yZGVyV2lkdGgvMik7ZD1NYXRoLmNlaWwoTWF0aC5tYXgoYyxuWzNdKS8yKTtiPU1hdGguY2VpbChNYXRoLm1heChjLFxublswXSkvMik7dGhpcy5jbGlwQm94PXt4OmQseTpiLHdpZHRoOk1hdGguZmxvb3IodGhpcy5wbG90U2l6ZVgtTWF0aC5tYXgoYyxuWzFdKS8yLWQpLGhlaWdodDpNYXRoLm1heCgwLE1hdGguZmxvb3IodGhpcy5wbG90U2l6ZVktTWF0aC5tYXgoYyxuWzJdKS8yLWIpKX07YXx8Zih0aGlzLmF4ZXMsZnVuY3Rpb24oYSl7YS5zZXRBeGlzU2l6ZSgpO2Euc2V0QXhpc1RyYW5zbGF0aW9uKCl9KX0scmVzZXRNYXJnaW5zOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxkPWEub3B0aW9ucy5jaGFydDtmKFtcIm1hcmdpblwiLFwic3BhY2luZ1wiXSxmdW5jdGlvbihiKXt2YXIgYz1kW2JdLGg9QyhjKT9jOltjLGMsYyxjXTtmKFtcIlRvcFwiLFwiUmlnaHRcIixcIkJvdHRvbVwiLFwiTGVmdFwiXSxmdW5jdGlvbihjLHApe2FbYl1bcF09QShkW2IrY10saFtwXSl9KX0pO2YoRixmdW5jdGlvbihkLGIpe2FbZF09QShhLm1hcmdpbltiXSxhLnNwYWNpbmdbYl0pfSk7YS5heGlzT2Zmc2V0PVswLDAsMCwwXTthLmNsaXBPZmZzZXQ9XG5bMCwwLDAsMF19LGRyYXdDaGFydEJveDpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucy5jaGFydCxkPXRoaXMucmVuZGVyZXIsYj10aGlzLmNoYXJ0V2lkdGgsYz10aGlzLmNoYXJ0SGVpZ2h0LGg9dGhpcy5jaGFydEJhY2tncm91bmQscD10aGlzLnBsb3RCYWNrZ3JvdW5kLGU9dGhpcy5wbG90Qm9yZGVyLG4sbD10aGlzLnBsb3RCR0ltYWdlLEE9YS5iYWNrZ3JvdW5kQ29sb3IsZj1hLnBsb3RCYWNrZ3JvdW5kQ29sb3IsZz1hLnBsb3RCYWNrZ3JvdW5kSW1hZ2UseSxEPXRoaXMucGxvdExlZnQsbT10aGlzLnBsb3RUb3Ascj10aGlzLnBsb3RXaWR0aCx4PXRoaXMucGxvdEhlaWdodCxCPXRoaXMucGxvdEJveCxrPXRoaXMuY2xpcFJlY3QsRj10aGlzLmNsaXBCb3gscT1cImFuaW1hdGVcIjtofHwodGhpcy5jaGFydEJhY2tncm91bmQ9aD1kLnJlY3QoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtYmFja2dyb3VuZFwiKS5hZGQoKSxxPVwiYXR0clwiKTtuPWEuYm9yZGVyV2lkdGh8fDA7eT1uKyhhLnNoYWRvdz9cbjg6MCk7QT17ZmlsbDpBfHxcIm5vbmVcIn07aWYobnx8aFtcInN0cm9rZS13aWR0aFwiXSlBLnN0cm9rZT1hLmJvcmRlckNvbG9yLEFbXCJzdHJva2Utd2lkdGhcIl09bjtoLmF0dHIoQSkuc2hhZG93KGEuc2hhZG93KTtoW3FdKHt4OnkvMix5OnkvMix3aWR0aDpiLXktbiUyLGhlaWdodDpjLXktbiUyLHI6YS5ib3JkZXJSYWRpdXN9KTtxPVwiYW5pbWF0ZVwiO3B8fChxPVwiYXR0clwiLHRoaXMucGxvdEJhY2tncm91bmQ9cD1kLnJlY3QoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtcGxvdC1iYWNrZ3JvdW5kXCIpLmFkZCgpKTtwW3FdKEIpO3AuYXR0cih7ZmlsbDpmfHxcIm5vbmVcIn0pLnNoYWRvdyhhLnBsb3RTaGFkb3cpO2cmJihsP2wuYW5pbWF0ZShCKTp0aGlzLnBsb3RCR0ltYWdlPWQuaW1hZ2UoZyxELG0scix4KS5hZGQoKSk7az9rLmFuaW1hdGUoe3dpZHRoOkYud2lkdGgsaGVpZ2h0OkYuaGVpZ2h0fSk6dGhpcy5jbGlwUmVjdD1kLmNsaXBSZWN0KEYpO3E9XCJhbmltYXRlXCI7ZXx8KHE9XCJhdHRyXCIsdGhpcy5wbG90Qm9yZGVyPVxuZT1kLnJlY3QoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtcGxvdC1ib3JkZXJcIikuYXR0cih7ekluZGV4OjF9KS5hZGQoKSk7ZS5hdHRyKHtzdHJva2U6YS5wbG90Qm9yZGVyQ29sb3IsXCJzdHJva2Utd2lkdGhcIjphLnBsb3RCb3JkZXJXaWR0aHx8MCxmaWxsOlwibm9uZVwifSk7ZVtxXShlLmNyaXNwKHt4OkQseTptLHdpZHRoOnIsaGVpZ2h0Onh9LC1lLnN0cm9rZVdpZHRoKCkpKTt0aGlzLmlzRGlydHlCb3g9ITF9LHByb3BGcm9tU2VyaWVzOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxkPWEub3B0aW9ucy5jaGFydCxiLGM9YS5vcHRpb25zLnNlcmllcyxoLHA7ZihbXCJpbnZlcnRlZFwiLFwiYW5ndWxhclwiLFwicG9sYXJcIl0sZnVuY3Rpb24oZSl7Yj1EW2QudHlwZXx8ZC5kZWZhdWx0U2VyaWVzVHlwZV07cD1kW2VdfHxiJiZiLnByb3RvdHlwZVtlXTtmb3IoaD1jJiZjLmxlbmd0aDshcCYmaC0tOykoYj1EW2NbaF0udHlwZV0pJiZiLnByb3RvdHlwZVtlXSYmKHA9ITApO2FbZV09cH0pfSxsaW5rU2VyaWVzOmZ1bmN0aW9uKCl7dmFyIGE9XG50aGlzLGQ9YS5zZXJpZXM7ZihkLGZ1bmN0aW9uKGEpe2EubGlua2VkU2VyaWVzLmxlbmd0aD0wfSk7ZihkLGZ1bmN0aW9uKGQpe3ZhciBiPWQub3B0aW9ucy5saW5rZWRUbztJKGIpJiYoYj1cIjpwcmV2aW91c1wiPT09Yj9hLnNlcmllc1tkLmluZGV4LTFdOmEuZ2V0KGIpKSYmYi5saW5rZWRQYXJlbnQhPT1kJiYoYi5saW5rZWRTZXJpZXMucHVzaChkKSxkLmxpbmtlZFBhcmVudD1iLGQudmlzaWJsZT1BKGQub3B0aW9ucy52aXNpYmxlLGIub3B0aW9ucy52aXNpYmxlLGQudmlzaWJsZSkpfSl9LHJlbmRlclNlcmllczpmdW5jdGlvbigpe2YodGhpcy5zZXJpZXMsZnVuY3Rpb24oYSl7YS50cmFuc2xhdGUoKTthLnJlbmRlcigpfSl9LHJlbmRlckxhYmVsczpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLm9wdGlvbnMubGFiZWxzO2IuaXRlbXMmJmYoYi5pdGVtcyxmdW5jdGlvbihjKXt2YXIgaD1lKGIuc3R5bGUsYy5zdHlsZSkscD1kKGgubGVmdCkrYS5wbG90TGVmdCxuPWQoaC50b3ApK1xuYS5wbG90VG9wKzEyO2RlbGV0ZSBoLmxlZnQ7ZGVsZXRlIGgudG9wO2EucmVuZGVyZXIudGV4dChjLmh0bWwscCxuKS5hdHRyKHt6SW5kZXg6Mn0pLmNzcyhoKS5hZGQoKX0pfSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmF4ZXMsZD10aGlzLnJlbmRlcmVyLGI9dGhpcy5vcHRpb25zLGMsaCxwO3RoaXMuc2V0VGl0bGUoKTt0aGlzLmxlZ2VuZD1uZXcgeCh0aGlzLGIubGVnZW5kKTt0aGlzLmdldFN0YWNrcyYmdGhpcy5nZXRTdGFja3MoKTt0aGlzLmdldE1hcmdpbnMoITApO3RoaXMuc2V0Q2hhcnRTaXplKCk7Yj10aGlzLnBsb3RXaWR0aDtjPXRoaXMucGxvdEhlaWdodD1NYXRoLm1heCh0aGlzLnBsb3RIZWlnaHQtMjEsMCk7ZihhLGZ1bmN0aW9uKGEpe2Euc2V0U2NhbGUoKX0pO3RoaXMuZ2V0QXhpc01hcmdpbnMoKTtoPTEuMTxiL3RoaXMucGxvdFdpZHRoO3A9MS4wNTxjL3RoaXMucGxvdEhlaWdodDtpZihofHxwKWYoYSxmdW5jdGlvbihhKXsoYS5ob3JpeiYmaHx8IWEuaG9yaXomJlxucCkmJmEuc2V0VGlja0ludGVydmFsKCEwKX0pLHRoaXMuZ2V0TWFyZ2lucygpO3RoaXMuZHJhd0NoYXJ0Qm94KCk7dGhpcy5oYXNDYXJ0ZXNpYW5TZXJpZXMmJmYoYSxmdW5jdGlvbihhKXthLnZpc2libGUmJmEucmVuZGVyKCl9KTt0aGlzLnNlcmllc0dyb3VwfHwodGhpcy5zZXJpZXNHcm91cD1kLmcoXCJzZXJpZXMtZ3JvdXBcIikuYXR0cih7ekluZGV4OjN9KS5hZGQoKSk7dGhpcy5yZW5kZXJTZXJpZXMoKTt0aGlzLnJlbmRlckxhYmVscygpO3RoaXMuYWRkQ3JlZGl0cygpO3RoaXMuc2V0UmVzcG9uc2l2ZSYmdGhpcy5zZXRSZXNwb25zaXZlKCk7dGhpcy5oYXNSZW5kZXJlZD0hMH0sYWRkQ3JlZGl0czpmdW5jdGlvbihhKXt2YXIgZD10aGlzO2E9bighMCx0aGlzLm9wdGlvbnMuY3JlZGl0cyxhKTthLmVuYWJsZWQmJiF0aGlzLmNyZWRpdHMmJih0aGlzLmNyZWRpdHM9dGhpcy5yZW5kZXJlci50ZXh0KGEudGV4dCsodGhpcy5tYXBDcmVkaXRzfHxcIlwiKSwwLDApLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1jcmVkaXRzXCIpLm9uKFwiY2xpY2tcIixcbmZ1bmN0aW9uKCl7YS5ocmVmJiYoTS5sb2NhdGlvbi5ocmVmPWEuaHJlZil9KS5hdHRyKHthbGlnbjphLnBvc2l0aW9uLmFsaWduLHpJbmRleDo4fSkuY3NzKGEuc3R5bGUpLmFkZCgpLmFsaWduKGEucG9zaXRpb24pLHRoaXMuY3JlZGl0cy51cGRhdGU9ZnVuY3Rpb24oYSl7ZC5jcmVkaXRzPWQuY3JlZGl0cy5kZXN0cm95KCk7ZC5hZGRDcmVkaXRzKGEpfSl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt2YXIgZD10aGlzLGM9ZC5heGVzLGg9ZC5zZXJpZXMsZT1kLmNvbnRhaW5lcixuLGw9ZSYmZS5wYXJlbnROb2RlO2IoZCxcImRlc3Ryb3lcIik7ZC5yZW5kZXJlci5mb3JFeHBvcnQ/YS5lcmFzZSh6LGQpOnpbZC5pbmRleF09dm9pZCAwO2EuY2hhcnRDb3VudC0tO2QucmVuZGVyVG8ucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1oaWdoY2hhcnRzLWNoYXJ0XCIpO3AoZCk7Zm9yKG49Yy5sZW5ndGg7bi0tOyljW25dPWNbbl0uZGVzdHJveSgpO3RoaXMuc2Nyb2xsZXImJnRoaXMuc2Nyb2xsZXIuZGVzdHJveSYmXG50aGlzLnNjcm9sbGVyLmRlc3Ryb3koKTtmb3Iobj1oLmxlbmd0aDtuLS07KWhbbl09aFtuXS5kZXN0cm95KCk7ZihcInRpdGxlIHN1YnRpdGxlIGNoYXJ0QmFja2dyb3VuZCBwbG90QmFja2dyb3VuZCBwbG90QkdJbWFnZSBwbG90Qm9yZGVyIHNlcmllc0dyb3VwIGNsaXBSZWN0IGNyZWRpdHMgcG9pbnRlciByYW5nZVNlbGVjdG9yIGxlZ2VuZCByZXNldFpvb21CdXR0b24gdG9vbHRpcCByZW5kZXJlclwiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihhKXt2YXIgYj1kW2FdO2ImJmIuZGVzdHJveSYmKGRbYV09Yi5kZXN0cm95KCkpfSk7ZSYmKGUuaW5uZXJIVE1MPVwiXCIscChlKSxsJiZ1KGUpKTtCKGQsZnVuY3Rpb24oYSxiKXtkZWxldGUgZFtiXX0pfSxpc1JlYWR5VG9SZW5kZXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3JldHVybiB5fHxNIT1NLnRvcHx8XCJjb21wbGV0ZVwiPT09ay5yZWFkeVN0YXRlPyEwOihrLmF0dGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsZnVuY3Rpb24oKXtrLmRldGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsXG5hLmZpcnN0UmVuZGVyKTtcImNvbXBsZXRlXCI9PT1rLnJlYWR5U3RhdGUmJmEuZmlyc3RSZW5kZXIoKX0pLCExKX0sZmlyc3RSZW5kZXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGQ9YS5vcHRpb25zO2lmKGEuaXNSZWFkeVRvUmVuZGVyKCkpe2EuZ2V0Q29udGFpbmVyKCk7YihhLFwiaW5pdFwiKTthLnJlc2V0TWFyZ2lucygpO2Euc2V0Q2hhcnRTaXplKCk7YS5wcm9wRnJvbVNlcmllcygpO2EuZ2V0QXhlcygpO2YoZC5zZXJpZXN8fFtdLGZ1bmN0aW9uKGQpe2EuaW5pdFNlcmllcyhkKX0pO2EubGlua1NlcmllcygpO2IoYSxcImJlZm9yZVJlbmRlclwiKTtKJiYoYS5wb2ludGVyPW5ldyBKKGEsZCkpO2EucmVuZGVyKCk7aWYoIWEucmVuZGVyZXIuaW1nQ291bnQmJmEub25sb2FkKWEub25sb2FkKCk7YS50ZW1wb3JhcnlEaXNwbGF5KCEwKX19LG9ubG9hZDpmdW5jdGlvbigpe2YoW3RoaXMuY2FsbGJhY2tdLmNvbmNhdCh0aGlzLmNhbGxiYWNrcyksZnVuY3Rpb24oYSl7YSYmdm9pZCAwIT09dGhpcy5pbmRleCYmXG5hLmFwcGx5KHRoaXMsW3RoaXNdKX0sdGhpcyk7Yih0aGlzLFwibG9hZFwiKTtiKHRoaXMsXCJyZW5kZXJcIik7Zyh0aGlzLmluZGV4KSYmITEhPT10aGlzLm9wdGlvbnMuY2hhcnQucmVmbG93JiZ0aGlzLmluaXRSZWZsb3coKTt0aGlzLm9ubG9hZD1udWxsfX0pfSkoTCk7KGZ1bmN0aW9uKGEpe3ZhciBHLEU9YS5lYWNoLEg9YS5leHRlbmQsdj1hLmVyYXNlLGs9YS5maXJlRXZlbnQscT1hLmZvcm1hdCx3PWEuaXNBcnJheSx0PWEuaXNOdW1iZXIsdT1hLnBpY2ssej1hLnJlbW92ZUV2ZW50O2EuUG9pbnQ9Rz1mdW5jdGlvbigpe307YS5Qb2ludC5wcm90b3R5cGU9e2luaXQ6ZnVuY3Rpb24oYSxnLGYpe3RoaXMuc2VyaWVzPWE7dGhpcy5jb2xvcj1hLmNvbG9yO3RoaXMuYXBwbHlPcHRpb25zKGcsZik7YS5vcHRpb25zLmNvbG9yQnlQb2ludD8oZz1hLm9wdGlvbnMuY29sb3JzfHxhLmNoYXJ0Lm9wdGlvbnMuY29sb3JzLHRoaXMuY29sb3I9dGhpcy5jb2xvcnx8Z1thLmNvbG9yQ291bnRlcl0sXG5nPWcubGVuZ3RoLGY9YS5jb2xvckNvdW50ZXIsYS5jb2xvckNvdW50ZXIrKyxhLmNvbG9yQ291bnRlcj09PWcmJihhLmNvbG9yQ291bnRlcj0wKSk6Zj1hLmNvbG9ySW5kZXg7dGhpcy5jb2xvckluZGV4PXUodGhpcy5jb2xvckluZGV4LGYpO2EuY2hhcnQucG9pbnRDb3VudCsrO3JldHVybiB0aGlzfSxhcHBseU9wdGlvbnM6ZnVuY3Rpb24oYSxnKXt2YXIgZj10aGlzLnNlcmllcyxlPWYub3B0aW9ucy5wb2ludFZhbEtleXx8Zi5wb2ludFZhbEtleTthPUcucHJvdG90eXBlLm9wdGlvbnNUb09iamVjdC5jYWxsKHRoaXMsYSk7SCh0aGlzLGEpO3RoaXMub3B0aW9ucz10aGlzLm9wdGlvbnM/SCh0aGlzLm9wdGlvbnMsYSk6YTthLmdyb3VwJiZkZWxldGUgdGhpcy5ncm91cDtlJiYodGhpcy55PXRoaXNbZV0pO3RoaXMuaXNOdWxsPXUodGhpcy5pc1ZhbGlkJiYhdGhpcy5pc1ZhbGlkKCksbnVsbD09PXRoaXMueHx8IXQodGhpcy55LCEwKSk7dGhpcy5zZWxlY3RlZCYmKHRoaXMuc3RhdGU9XG5cInNlbGVjdFwiKTtcIm5hbWVcImluIHRoaXMmJnZvaWQgMD09PWcmJmYueEF4aXMmJmYueEF4aXMuaGFzTmFtZXMmJih0aGlzLng9Zi54QXhpcy5uYW1lVG9YKHRoaXMpKTt2b2lkIDA9PT10aGlzLngmJmYmJih0aGlzLng9dm9pZCAwPT09Zz9mLmF1dG9JbmNyZW1lbnQodGhpcyk6Zyk7cmV0dXJuIHRoaXN9LG9wdGlvbnNUb09iamVjdDpmdW5jdGlvbihhKXt2YXIgZz17fSxmPXRoaXMuc2VyaWVzLGU9Zi5vcHRpb25zLmtleXMsYz1lfHxmLnBvaW50QXJyYXlNYXB8fFtcInlcIl0sYj1jLmxlbmd0aCxtPTAsbD0wO2lmKHQoYSl8fG51bGw9PT1hKWdbY1swXV09YTtlbHNlIGlmKHcoYSkpZm9yKCFlJiZhLmxlbmd0aD5iJiYoZj10eXBlb2YgYVswXSxcInN0cmluZ1wiPT09Zj9nLm5hbWU9YVswXTpcIm51bWJlclwiPT09ZiYmKGcueD1hWzBdKSxtKyspO2w8YjspZSYmdm9pZCAwPT09YVttXXx8KGdbY1tsXV09YVttXSksbSsrLGwrKztlbHNlXCJvYmplY3RcIj09PXR5cGVvZiBhJiYoZz1hLGEuZGF0YUxhYmVscyYmXG4oZi5faGFzUG9pbnRMYWJlbHM9ITApLGEubWFya2VyJiYoZi5faGFzUG9pbnRNYXJrZXJzPSEwKSk7cmV0dXJuIGd9LGdldENsYXNzTmFtZTpmdW5jdGlvbigpe3JldHVyblwiaGlnaGNoYXJ0cy1wb2ludFwiKyh0aGlzLnNlbGVjdGVkP1wiIGhpZ2hjaGFydHMtcG9pbnQtc2VsZWN0XCI6XCJcIikrKHRoaXMubmVnYXRpdmU/XCIgaGlnaGNoYXJ0cy1uZWdhdGl2ZVwiOlwiXCIpKyh0aGlzLmlzTnVsbD9cIiBoaWdoY2hhcnRzLW51bGwtcG9pbnRcIjpcIlwiKSsodm9pZCAwIT09dGhpcy5jb2xvckluZGV4P1wiIGhpZ2hjaGFydHMtY29sb3ItXCIrdGhpcy5jb2xvckluZGV4OlwiXCIpKyh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lP1wiIFwiK3RoaXMub3B0aW9ucy5jbGFzc05hbWU6XCJcIikrKHRoaXMuem9uZSYmdGhpcy56b25lLmNsYXNzTmFtZT9cIiBcIit0aGlzLnpvbmUuY2xhc3NOYW1lLnJlcGxhY2UoXCJoaWdoY2hhcnRzLW5lZ2F0aXZlXCIsXCJcIik6XCJcIil9LGdldFpvbmU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnNlcmllcyxcbmc9YS56b25lcyxhPWEuem9uZUF4aXN8fFwieVwiLGY9MCxlO2ZvcihlPWdbZl07dGhpc1thXT49ZS52YWx1ZTspZT1nWysrZl07ZSYmZS5jb2xvciYmIXRoaXMub3B0aW9ucy5jb2xvciYmKHRoaXMuY29sb3I9ZS5jb2xvcik7cmV0dXJuIGV9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnNlcmllcy5jaGFydCxnPWEuaG92ZXJQb2ludHMsZjthLnBvaW50Q291bnQtLTtnJiYodGhpcy5zZXRTdGF0ZSgpLHYoZyx0aGlzKSxnLmxlbmd0aHx8KGEuaG92ZXJQb2ludHM9bnVsbCkpO2lmKHRoaXM9PT1hLmhvdmVyUG9pbnQpdGhpcy5vbk1vdXNlT3V0KCk7aWYodGhpcy5ncmFwaGljfHx0aGlzLmRhdGFMYWJlbCl6KHRoaXMpLHRoaXMuZGVzdHJveUVsZW1lbnRzKCk7dGhpcy5sZWdlbmRJdGVtJiZhLmxlZ2VuZC5kZXN0cm95SXRlbSh0aGlzKTtmb3IoZiBpbiB0aGlzKXRoaXNbZl09bnVsbH0sZGVzdHJveUVsZW1lbnRzOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPVtcImdyYXBoaWNcIixcImRhdGFMYWJlbFwiLFxuXCJkYXRhTGFiZWxVcHBlclwiLFwiY29ubmVjdG9yXCIsXCJzaGFkb3dHcm91cFwiXSxnLGY9NjtmLS07KWc9YVtmXSx0aGlzW2ddJiYodGhpc1tnXT10aGlzW2ddLmRlc3Ryb3koKSl9LGdldExhYmVsQ29uZmlnOmZ1bmN0aW9uKCl7cmV0dXJue3g6dGhpcy5jYXRlZ29yeSx5OnRoaXMueSxjb2xvcjp0aGlzLmNvbG9yLGNvbG9ySW5kZXg6dGhpcy5jb2xvckluZGV4LGtleTp0aGlzLm5hbWV8fHRoaXMuY2F0ZWdvcnksc2VyaWVzOnRoaXMuc2VyaWVzLHBvaW50OnRoaXMscGVyY2VudGFnZTp0aGlzLnBlcmNlbnRhZ2UsdG90YWw6dGhpcy50b3RhbHx8dGhpcy5zdGFja1RvdGFsfX0sdG9vbHRpcEZvcm1hdHRlcjpmdW5jdGlvbihhKXt2YXIgZz10aGlzLnNlcmllcyxmPWcudG9vbHRpcE9wdGlvbnMsZT11KGYudmFsdWVEZWNpbWFscyxcIlwiKSxjPWYudmFsdWVQcmVmaXh8fFwiXCIsYj1mLnZhbHVlU3VmZml4fHxcIlwiO0UoZy5wb2ludEFycmF5TWFwfHxbXCJ5XCJdLGZ1bmN0aW9uKGYpe2Y9XCJ7cG9pbnQuXCIrXG5mO2lmKGN8fGIpYT1hLnJlcGxhY2UoZitcIn1cIixjK2YrXCJ9XCIrYik7YT1hLnJlcGxhY2UoZitcIn1cIixmK1wiOiwuXCIrZStcImZ9XCIpfSk7cmV0dXJuIHEoYSx7cG9pbnQ6dGhpcyxzZXJpZXM6dGhpcy5zZXJpZXN9KX0sZmlyZVBvaW50RXZlbnQ6ZnVuY3Rpb24oYSxnLGYpe3ZhciBlPXRoaXMsYz10aGlzLnNlcmllcy5vcHRpb25zOyhjLnBvaW50LmV2ZW50c1thXXx8ZS5vcHRpb25zJiZlLm9wdGlvbnMuZXZlbnRzJiZlLm9wdGlvbnMuZXZlbnRzW2FdKSYmdGhpcy5pbXBvcnRFdmVudHMoKTtcImNsaWNrXCI9PT1hJiZjLmFsbG93UG9pbnRTZWxlY3QmJihmPWZ1bmN0aW9uKGEpe2Uuc2VsZWN0JiZlLnNlbGVjdChudWxsLGEuY3RybEtleXx8YS5tZXRhS2V5fHxhLnNoaWZ0S2V5KX0pO2sodGhpcyxhLGcsZil9LHZpc2libGU6ITB9fSkoTCk7KGZ1bmN0aW9uKGEpe3ZhciBHPWEuYWRkRXZlbnQsRT1hLmFuaW1PYmplY3QsSD1hLmFycmF5TWF4LHY9YS5hcnJheU1pbixrPWEuY29ycmVjdEZsb2F0LFxucT1hLkRhdGUsdz1hLmRlZmF1bHRPcHRpb25zLHQ9YS5kZWZhdWx0UGxvdE9wdGlvbnMsdT1hLmRlZmluZWQsej1hLmVhY2gsbT1hLmVyYXNlLGc9YS5leHRlbmQsZj1hLmZpcmVFdmVudCxlPWEuZ3JlcCxjPWEuaXNBcnJheSxiPWEuaXNOdW1iZXIscj1hLmlzU3RyaW5nLGw9YS5tZXJnZSxDPWEub2JqZWN0RWFjaCxJPWEucGljayx4PWEucmVtb3ZlRXZlbnQsRj1hLnNwbGF0LG49YS5TVkdFbGVtZW50LEI9YS5zeW5jVGltZW91dCxKPWEud2luO2EuU2VyaWVzPWEuc2VyaWVzVHlwZShcImxpbmVcIixudWxsLHtsaW5lV2lkdGg6MixhbGxvd1BvaW50U2VsZWN0OiExLHNob3dDaGVja2JveDohMSxhbmltYXRpb246e2R1cmF0aW9uOjFFM30sZXZlbnRzOnt9LG1hcmtlcjp7bGluZVdpZHRoOjAsbGluZUNvbG9yOlwiI2ZmZmZmZlwiLHJhZGl1czo0LHN0YXRlczp7aG92ZXI6e2FuaW1hdGlvbjp7ZHVyYXRpb246NTB9LGVuYWJsZWQ6ITAscmFkaXVzUGx1czoyLGxpbmVXaWR0aFBsdXM6MX0sc2VsZWN0OntmaWxsQ29sb3I6XCIjY2NjY2NjXCIsXG5saW5lQ29sb3I6XCIjMDAwMDAwXCIsbGluZVdpZHRoOjJ9fX0scG9pbnQ6e2V2ZW50czp7fX0sZGF0YUxhYmVsczp7YWxpZ246XCJjZW50ZXJcIixmb3JtYXR0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMueT9cIlwiOmEubnVtYmVyRm9ybWF0KHRoaXMueSwtMSl9LHN0eWxlOntmb250U2l6ZTpcIjExcHhcIixmb250V2VpZ2h0OlwiYm9sZFwiLGNvbG9yOlwiY29udHJhc3RcIix0ZXh0T3V0bGluZTpcIjFweCBjb250cmFzdFwifSx2ZXJ0aWNhbEFsaWduOlwiYm90dG9tXCIseDowLHk6MCxwYWRkaW5nOjV9LGNyb3BUaHJlc2hvbGQ6MzAwLHBvaW50UmFuZ2U6MCxzb2Z0VGhyZXNob2xkOiEwLHN0YXRlczp7aG92ZXI6e2FuaW1hdGlvbjp7ZHVyYXRpb246NTB9LGxpbmVXaWR0aFBsdXM6MSxtYXJrZXI6e30saGFsbzp7c2l6ZToxMCxvcGFjaXR5Oi4yNX19LHNlbGVjdDp7bWFya2VyOnt9fX0sc3RpY2t5VHJhY2tpbmc6ITAsdHVyYm9UaHJlc2hvbGQ6MUUzLGZpbmROZWFyZXN0UG9pbnRCeTpcInhcIn0sXG57aXNDYXJ0ZXNpYW46ITAscG9pbnRDbGFzczphLlBvaW50LHNvcnRlZDohMCxyZXF1aXJlU29ydGluZzohMCxkaXJlY3RUb3VjaDohMSxheGlzVHlwZXM6W1wieEF4aXNcIixcInlBeGlzXCJdLGNvbG9yQ291bnRlcjowLHBhcmFsbGVsQXJyYXlzOltcInhcIixcInlcIl0sY29sbDpcInNlcmllc1wiLGluaXQ6ZnVuY3Rpb24oYSxkKXt2YXIgYj10aGlzLGMsaD1hLnNlcmllcyxlO2IuY2hhcnQ9YTtiLm9wdGlvbnM9ZD1iLnNldE9wdGlvbnMoZCk7Yi5saW5rZWRTZXJpZXM9W107Yi5iaW5kQXhlcygpO2coYix7bmFtZTpkLm5hbWUsc3RhdGU6XCJcIix2aXNpYmxlOiExIT09ZC52aXNpYmxlLHNlbGVjdGVkOiEwPT09ZC5zZWxlY3RlZH0pO2M9ZC5ldmVudHM7QyhjLGZ1bmN0aW9uKGEsZCl7RyhiLGQsYSl9KTtpZihjJiZjLmNsaWNrfHxkLnBvaW50JiZkLnBvaW50LmV2ZW50cyYmZC5wb2ludC5ldmVudHMuY2xpY2t8fGQuYWxsb3dQb2ludFNlbGVjdClhLnJ1blRyYWNrZXJDbGljaz0hMDtiLmdldENvbG9yKCk7XG5iLmdldFN5bWJvbCgpO3ooYi5wYXJhbGxlbEFycmF5cyxmdW5jdGlvbihhKXtiW2ErXCJEYXRhXCJdPVtdfSk7Yi5zZXREYXRhKGQuZGF0YSwhMSk7Yi5pc0NhcnRlc2lhbiYmKGEuaGFzQ2FydGVzaWFuU2VyaWVzPSEwKTtoLmxlbmd0aCYmKGU9aFtoLmxlbmd0aC0xXSk7Yi5faT1JKGUmJmUuX2ksLTEpKzE7YS5vcmRlclNlcmllcyh0aGlzLmluc2VydChoKSl9LGluc2VydDpmdW5jdGlvbihhKXt2YXIgZD10aGlzLm9wdGlvbnMuaW5kZXgsYztpZihiKGQpKXtmb3IoYz1hLmxlbmd0aDtjLS07KWlmKGQ+PUkoYVtjXS5vcHRpb25zLmluZGV4LGFbY10uX2kpKXthLnNwbGljZShjKzEsMCx0aGlzKTticmVha30tMT09PWMmJmEudW5zaGlmdCh0aGlzKTtjKz0xfWVsc2UgYS5wdXNoKHRoaXMpO3JldHVybiBJKGMsYS5sZW5ndGgtMSl9LGJpbmRBeGVzOmZ1bmN0aW9uKCl7dmFyIGI9dGhpcyxkPWIub3B0aW9ucyxjPWIuY2hhcnQsZTt6KGIuYXhpc1R5cGVzfHxbXSxmdW5jdGlvbihoKXt6KGNbaF0sXG5mdW5jdGlvbihhKXtlPWEub3B0aW9ucztpZihkW2hdPT09ZS5pbmRleHx8dm9pZCAwIT09ZFtoXSYmZFtoXT09PWUuaWR8fHZvaWQgMD09PWRbaF0mJjA9PT1lLmluZGV4KWIuaW5zZXJ0KGEuc2VyaWVzKSxiW2hdPWEsYS5pc0RpcnR5PSEwfSk7YltoXXx8Yi5vcHRpb25hbEF4aXM9PT1ofHxhLmVycm9yKDE4LCEwKX0pfSx1cGRhdGVQYXJhbGxlbEFycmF5czpmdW5jdGlvbihhLGQpe3ZhciBjPWEuc2VyaWVzLGU9YXJndW1lbnRzLGg9YihkKT9mdW5jdGlvbihiKXt2YXIgaD1cInlcIj09PWImJmMudG9ZRGF0YT9jLnRvWURhdGEoYSk6YVtiXTtjW2IrXCJEYXRhXCJdW2RdPWh9OmZ1bmN0aW9uKGEpe0FycmF5LnByb3RvdHlwZVtkXS5hcHBseShjW2ErXCJEYXRhXCJdLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUsMikpfTt6KGMucGFyYWxsZWxBcnJheXMsaCl9LGF1dG9JbmNyZW1lbnQ6ZnVuY3Rpb24oKXt2YXIgYj10aGlzLm9wdGlvbnMsZD10aGlzLnhJbmNyZW1lbnQsYyxlPWIucG9pbnRJbnRlcnZhbFVuaXQsXG5oPTAsZD1JKGQsYi5wb2ludFN0YXJ0LDApO3RoaXMucG9pbnRJbnRlcnZhbD1jPUkodGhpcy5wb2ludEludGVydmFsLGIucG9pbnRJbnRlcnZhbCwxKTtlJiYoYj1uZXcgcShkKSxcImRheVwiPT09ZT9iPStiW3EuaGNTZXREYXRlXShiW3EuaGNHZXREYXRlXSgpK2MpOlwibW9udGhcIj09PWU/Yj0rYltxLmhjU2V0TW9udGhdKGJbcS5oY0dldE1vbnRoXSgpK2MpOlwieWVhclwiPT09ZSYmKGI9K2JbcS5oY1NldEZ1bGxZZWFyXShiW3EuaGNHZXRGdWxsWWVhcl0oKStjKSkscS5oY0hhc1RpbWVab25lJiYoaD1hLmdldFRaT2Zmc2V0KGIpLWEuZ2V0VFpPZmZzZXQoZCkpLGM9Yi1kK2gpO3RoaXMueEluY3JlbWVudD1kK2M7cmV0dXJuIGR9LHNldE9wdGlvbnM6ZnVuY3Rpb24oYSl7dmFyIGQ9dGhpcy5jaGFydCxiPWQub3B0aW9ucyxjPWIucGxvdE9wdGlvbnMsaD0oZC51c2VyT3B0aW9uc3x8e30pLnBsb3RPcHRpb25zfHx7fSxlPWNbdGhpcy50eXBlXTt0aGlzLnVzZXJPcHRpb25zPWE7ZD1sKGUsXG5jLnNlcmllcyxhKTt0aGlzLnRvb2x0aXBPcHRpb25zPWwody50b29sdGlwLHcucGxvdE9wdGlvbnMuc2VyaWVzJiZ3LnBsb3RPcHRpb25zLnNlcmllcy50b29sdGlwLHcucGxvdE9wdGlvbnNbdGhpcy50eXBlXS50b29sdGlwLGIudG9vbHRpcC51c2VyT3B0aW9ucyxjLnNlcmllcyYmYy5zZXJpZXMudG9vbHRpcCxjW3RoaXMudHlwZV0udG9vbHRpcCxhLnRvb2x0aXApO3RoaXMuc3RpY2t5VHJhY2tpbmc9SShhLnN0aWNreVRyYWNraW5nLGhbdGhpcy50eXBlXSYmaFt0aGlzLnR5cGVdLnN0aWNreVRyYWNraW5nLGguc2VyaWVzJiZoLnNlcmllcy5zdGlja3lUcmFja2luZyx0aGlzLnRvb2x0aXBPcHRpb25zLnNoYXJlZCYmIXRoaXMubm9TaGFyZWRUb29sdGlwPyEwOmQuc3RpY2t5VHJhY2tpbmcpO251bGw9PT1lLm1hcmtlciYmZGVsZXRlIGQubWFya2VyO3RoaXMuem9uZUF4aXM9ZC56b25lQXhpczthPXRoaXMuem9uZXM9KGQuem9uZXN8fFtdKS5zbGljZSgpOyFkLm5lZ2F0aXZlQ29sb3ImJlxuIWQubmVnYXRpdmVGaWxsQ29sb3J8fGQuem9uZXN8fGEucHVzaCh7dmFsdWU6ZFt0aGlzLnpvbmVBeGlzK1wiVGhyZXNob2xkXCJdfHxkLnRocmVzaG9sZHx8MCxjbGFzc05hbWU6XCJoaWdoY2hhcnRzLW5lZ2F0aXZlXCIsY29sb3I6ZC5uZWdhdGl2ZUNvbG9yLGZpbGxDb2xvcjpkLm5lZ2F0aXZlRmlsbENvbG9yfSk7YS5sZW5ndGgmJnUoYVthLmxlbmd0aC0xXS52YWx1ZSkmJmEucHVzaCh7Y29sb3I6dGhpcy5jb2xvcixmaWxsQ29sb3I6dGhpcy5maWxsQ29sb3J9KTtyZXR1cm4gZH0sZ2V0Q3ljbGljOmZ1bmN0aW9uKGEsZCxiKXt2YXIgYyxoPXRoaXMuY2hhcnQscD10aGlzLnVzZXJPcHRpb25zLGU9YStcIkluZGV4XCIsbj1hK1wiQ291bnRlclwiLGw9Yj9iLmxlbmd0aDpJKGgub3B0aW9ucy5jaGFydFthK1wiQ291bnRcIl0saFthK1wiQ291bnRcIl0pO2R8fChjPUkocFtlXSxwW1wiX1wiK2VdKSx1KGMpfHwoaC5zZXJpZXMubGVuZ3RofHwoaFtuXT0wKSxwW1wiX1wiK2VdPWM9aFtuXSVsLGhbbl0rPTEpLFxuYiYmKGQ9YltjXSkpO3ZvaWQgMCE9PWMmJih0aGlzW2VdPWMpO3RoaXNbYV09ZH0sZ2V0Q29sb3I6ZnVuY3Rpb24oKXt0aGlzLm9wdGlvbnMuY29sb3JCeVBvaW50P3RoaXMub3B0aW9ucy5jb2xvcj1udWxsOnRoaXMuZ2V0Q3ljbGljKFwiY29sb3JcIix0aGlzLm9wdGlvbnMuY29sb3J8fHRbdGhpcy50eXBlXS5jb2xvcix0aGlzLmNoYXJ0Lm9wdGlvbnMuY29sb3JzKX0sZ2V0U3ltYm9sOmZ1bmN0aW9uKCl7dGhpcy5nZXRDeWNsaWMoXCJzeW1ib2xcIix0aGlzLm9wdGlvbnMubWFya2VyLnN5bWJvbCx0aGlzLmNoYXJ0Lm9wdGlvbnMuc3ltYm9scyl9LGRyYXdMZWdlbmRTeW1ib2w6YS5MZWdlbmRTeW1ib2xNaXhpbi5kcmF3TGluZU1hcmtlcixzZXREYXRhOmZ1bmN0aW9uKGUsZCxwLG4pe3ZhciBoPXRoaXMsbD1oLnBvaW50cyxmPWwmJmwubGVuZ3RofHwwLGcsQT1oLm9wdGlvbnMsRD1oLmNoYXJ0LG09bnVsbCx4PWgueEF4aXMsQj1BLnR1cmJvVGhyZXNob2xkLGs9dGhpcy54RGF0YSxxPVxudGhpcy55RGF0YSxGPShnPWgucG9pbnRBcnJheU1hcCkmJmcubGVuZ3RoO2U9ZXx8W107Zz1lLmxlbmd0aDtkPUkoZCwhMCk7aWYoITEhPT1uJiZnJiZmPT09ZyYmIWguY3JvcHBlZCYmIWguaGFzR3JvdXBlZERhdGEmJmgudmlzaWJsZSl6KGUsZnVuY3Rpb24oYSxkKXtsW2RdLnVwZGF0ZSYmYSE9PUEuZGF0YVtkXSYmbFtkXS51cGRhdGUoYSwhMSxudWxsLCExKX0pO2Vsc2V7aC54SW5jcmVtZW50PW51bGw7aC5jb2xvckNvdW50ZXI9MDt6KHRoaXMucGFyYWxsZWxBcnJheXMsZnVuY3Rpb24oYSl7aFthK1wiRGF0YVwiXS5sZW5ndGg9MH0pO2lmKEImJmc+Qil7Zm9yKHA9MDtudWxsPT09bSYmcDxnOyltPWVbcF0scCsrO2lmKGIobSkpZm9yKHA9MDtwPGc7cCsrKWtbcF09dGhpcy5hdXRvSW5jcmVtZW50KCkscVtwXT1lW3BdO2Vsc2UgaWYoYyhtKSlpZihGKWZvcihwPTA7cDxnO3ArKyltPWVbcF0sa1twXT1tWzBdLHFbcF09bS5zbGljZSgxLEYrMSk7ZWxzZSBmb3IocD0wO3A8ZztwKyspbT1cbmVbcF0sa1twXT1tWzBdLHFbcF09bVsxXTtlbHNlIGEuZXJyb3IoMTIpfWVsc2UgZm9yKHA9MDtwPGc7cCsrKXZvaWQgMCE9PWVbcF0mJihtPXtzZXJpZXM6aH0saC5wb2ludENsYXNzLnByb3RvdHlwZS5hcHBseU9wdGlvbnMuYXBwbHkobSxbZVtwXV0pLGgudXBkYXRlUGFyYWxsZWxBcnJheXMobSxwKSk7cSYmcihxWzBdKSYmYS5lcnJvcigxNCwhMCk7aC5kYXRhPVtdO2gub3B0aW9ucy5kYXRhPWgudXNlck9wdGlvbnMuZGF0YT1lO2ZvcihwPWY7cC0tOylsW3BdJiZsW3BdLmRlc3Ryb3kmJmxbcF0uZGVzdHJveSgpO3gmJih4Lm1pblJhbmdlPXgudXNlck1pblJhbmdlKTtoLmlzRGlydHk9RC5pc0RpcnR5Qm94PSEwO2guaXNEaXJ0eURhdGE9ISFsO3A9ITF9XCJwb2ludFwiPT09QS5sZWdlbmRUeXBlJiYodGhpcy5wcm9jZXNzRGF0YSgpLHRoaXMuZ2VuZXJhdGVQb2ludHMoKSk7ZCYmRC5yZWRyYXcocCl9LHByb2Nlc3NEYXRhOmZ1bmN0aW9uKGIpe3ZhciBkPXRoaXMueERhdGEsYz10aGlzLnlEYXRhLFxuZT1kLmxlbmd0aCxoO2g9MDt2YXIgbixsLGY9dGhpcy54QXhpcyxnLEE9dGhpcy5vcHRpb25zO2c9QS5jcm9wVGhyZXNob2xkO3ZhciBtPXRoaXMuZ2V0RXh0cmVtZXNGcm9tQWxsfHxBLmdldEV4dHJlbWVzRnJvbUFsbCx4PXRoaXMuaXNDYXJ0ZXNpYW4sQT1mJiZmLnZhbDJsaW4sQj1mJiZmLmlzTG9nLHI9dGhpcy5yZXF1aXJlU29ydGluZyxrLHE7aWYoeCYmIXRoaXMuaXNEaXJ0eSYmIWYuaXNEaXJ0eSYmIXRoaXMueUF4aXMuaXNEaXJ0eSYmIWIpcmV0dXJuITE7ZiYmKGI9Zi5nZXRFeHRyZW1lcygpLGs9Yi5taW4scT1iLm1heCk7aWYoeCYmdGhpcy5zb3J0ZWQmJiFtJiYoIWd8fGU+Z3x8dGhpcy5mb3JjZUNyb3ApKWlmKGRbZS0xXTxrfHxkWzBdPnEpZD1bXSxjPVtdO2Vsc2UgaWYoZFswXTxrfHxkW2UtMV0+cSloPXRoaXMuY3JvcERhdGEodGhpcy54RGF0YSx0aGlzLnlEYXRhLGsscSksZD1oLnhEYXRhLGM9aC55RGF0YSxoPWguc3RhcnQsbj0hMDtmb3IoZz1kLmxlbmd0aHx8XG4xOy0tZzspZT1CP0EoZFtnXSktQShkW2ctMV0pOmRbZ10tZFtnLTFdLDA8ZSYmKHZvaWQgMD09PWx8fGU8bCk/bD1lOjA+ZSYmciYmKGEuZXJyb3IoMTUpLHI9ITEpO3RoaXMuY3JvcHBlZD1uO3RoaXMuY3JvcFN0YXJ0PWg7dGhpcy5wcm9jZXNzZWRYRGF0YT1kO3RoaXMucHJvY2Vzc2VkWURhdGE9Yzt0aGlzLmNsb3Nlc3RQb2ludFJhbmdlPWx9LGNyb3BEYXRhOmZ1bmN0aW9uKGEsZCxiLGMpe3ZhciBoPWEubGVuZ3RoLHA9MCxlPWgsbj1JKHRoaXMuY3JvcFNob3VsZGVyLDEpLGw7Zm9yKGw9MDtsPGg7bCsrKWlmKGFbbF0+PWIpe3A9TWF0aC5tYXgoMCxsLW4pO2JyZWFrfWZvcihiPWw7YjxoO2IrKylpZihhW2JdPmMpe2U9YituO2JyZWFrfXJldHVybnt4RGF0YTphLnNsaWNlKHAsZSkseURhdGE6ZC5zbGljZShwLGUpLHN0YXJ0OnAsZW5kOmV9fSxnZW5lcmF0ZVBvaW50czpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucyxkPWEuZGF0YSxiPXRoaXMuZGF0YSxjLGg9dGhpcy5wcm9jZXNzZWRYRGF0YSxcbmU9dGhpcy5wcm9jZXNzZWRZRGF0YSxuPXRoaXMucG9pbnRDbGFzcyxsPWgubGVuZ3RoLGY9dGhpcy5jcm9wU3RhcnR8fDAsZyxtPXRoaXMuaGFzR3JvdXBlZERhdGEsYT1hLmtleXMseCxCPVtdLHI7Ynx8bXx8KGI9W10sYi5sZW5ndGg9ZC5sZW5ndGgsYj10aGlzLmRhdGE9Yik7YSYmbSYmKHRoaXMub3B0aW9ucy5rZXlzPSExKTtmb3Iocj0wO3I8bDtyKyspZz1mK3IsbT8oeD0obmV3IG4pLmluaXQodGhpcyxbaFtyXV0uY29uY2F0KEYoZVtyXSkpKSx4LmRhdGFHcm91cD10aGlzLmdyb3VwTWFwW3JdKTooeD1iW2ddKXx8dm9pZCAwPT09ZFtnXXx8KGJbZ109eD0obmV3IG4pLmluaXQodGhpcyxkW2ddLGhbcl0pKSx4JiYoeC5pbmRleD1nLEJbcl09eCk7dGhpcy5vcHRpb25zLmtleXM9YTtpZihiJiYobCE9PShjPWIubGVuZ3RoKXx8bSkpZm9yKHI9MDtyPGM7cisrKXIhPT1mfHxtfHwocis9bCksYltyXSYmKGJbcl0uZGVzdHJveUVsZW1lbnRzKCksYltyXS5wbG90WD12b2lkIDApO1xudGhpcy5kYXRhPWI7dGhpcy5wb2ludHM9Qn0sZ2V0RXh0cmVtZXM6ZnVuY3Rpb24oYSl7dmFyIGQ9dGhpcy55QXhpcyxwPXRoaXMucHJvY2Vzc2VkWERhdGEsZSxoPVtdLG49MDtlPXRoaXMueEF4aXMuZ2V0RXh0cmVtZXMoKTt2YXIgbD1lLm1pbixmPWUubWF4LGcsQSxtLHI7YT1hfHx0aGlzLnN0YWNrZWRZRGF0YXx8dGhpcy5wcm9jZXNzZWRZRGF0YXx8W107ZT1hLmxlbmd0aDtmb3Iocj0wO3I8ZTtyKyspaWYoQT1wW3JdLG09YVtyXSxnPShiKG0sITApfHxjKG0pKSYmKCFkLnBvc2l0aXZlVmFsdWVzT25seXx8bS5sZW5ndGh8fDA8bSksQT10aGlzLmdldEV4dHJlbWVzRnJvbUFsbHx8dGhpcy5vcHRpb25zLmdldEV4dHJlbWVzRnJvbUFsbHx8dGhpcy5jcm9wcGVkfHwocFtyKzFdfHxBKT49bCYmKHBbci0xXXx8QSk8PWYsZyYmQSlpZihnPW0ubGVuZ3RoKWZvcig7Zy0tOylcIm51bWJlclwiPT09dHlwZW9mIG1bZ10mJihoW24rK109bVtnXSk7ZWxzZSBoW24rK109bTt0aGlzLmRhdGFNaW49XG52KGgpO3RoaXMuZGF0YU1heD1IKGgpfSx0cmFuc2xhdGU6ZnVuY3Rpb24oKXt0aGlzLnByb2Nlc3NlZFhEYXRhfHx0aGlzLnByb2Nlc3NEYXRhKCk7dGhpcy5nZW5lcmF0ZVBvaW50cygpO3ZhciBhPXRoaXMub3B0aW9ucyxkPWEuc3RhY2tpbmcsYz10aGlzLnhBeGlzLGU9Yy5jYXRlZ29yaWVzLGg9dGhpcy55QXhpcyxuPXRoaXMucG9pbnRzLGw9bi5sZW5ndGgsZj0hIXRoaXMubW9kaWZ5VmFsdWUsZz1hLnBvaW50UGxhY2VtZW50LG09XCJiZXR3ZWVuXCI9PT1nfHxiKGcpLHI9YS50aHJlc2hvbGQseD1hLnN0YXJ0RnJvbVRocmVzaG9sZD9yOjAsQixxLEYsdCxDPU51bWJlci5NQVhfVkFMVUU7XCJiZXR3ZWVuXCI9PT1nJiYoZz0uNSk7YihnKSYmKGcqPUkoYS5wb2ludFJhbmdlfHxjLnBvaW50UmFuZ2UpKTtmb3IoYT0wO2E8bDthKyspe3ZhciBKPW5bYV0sdj1KLngsdz1KLnk7cT1KLmxvdzt2YXIgej1kJiZoLnN0YWNrc1sodGhpcy5uZWdTdGFja3MmJnc8KHg/MDpyKT9cIi1cIjpcIlwiKSt0aGlzLnN0YWNrS2V5XSxcbkU7aC5wb3NpdGl2ZVZhbHVlc09ubHkmJm51bGwhPT13JiYwPj13JiYoSi5pc051bGw9ITApO0oucGxvdFg9Qj1rKE1hdGgubWluKE1hdGgubWF4KC0xRTUsYy50cmFuc2xhdGUodiwwLDAsMCwxLGcsXCJmbGFnc1wiPT09dGhpcy50eXBlKSksMUU1KSk7ZCYmdGhpcy52aXNpYmxlJiYhSi5pc051bGwmJnomJnpbdl0mJih0PXRoaXMuZ2V0U3RhY2tJbmRpY2F0b3IodCx2LHRoaXMuaW5kZXgpLEU9elt2XSx3PUUucG9pbnRzW3Qua2V5XSxxPXdbMF0sdz13WzFdLHE9PT14JiZ0LmtleT09PXpbdl0uYmFzZSYmKHE9SShyLGgubWluKSksaC5wb3NpdGl2ZVZhbHVlc09ubHkmJjA+PXEmJihxPW51bGwpLEoudG90YWw9Si5zdGFja1RvdGFsPUUudG90YWwsSi5wZXJjZW50YWdlPUUudG90YWwmJkoueS9FLnRvdGFsKjEwMCxKLnN0YWNrWT13LEUuc2V0T2Zmc2V0KHRoaXMucG9pbnRYT2Zmc2V0fHwwLHRoaXMuYmFyV3x8MCkpO0oueUJvdHRvbT11KHEpP2gudHJhbnNsYXRlKHEsMCwxLDAsMSk6XG5udWxsO2YmJih3PXRoaXMubW9kaWZ5VmFsdWUodyxKKSk7Si5wbG90WT1xPVwibnVtYmVyXCI9PT10eXBlb2YgdyYmSW5maW5pdHkhPT13P01hdGgubWluKE1hdGgubWF4KC0xRTUsaC50cmFuc2xhdGUodywwLDEsMCwxKSksMUU1KTp2b2lkIDA7Si5pc0luc2lkZT12b2lkIDAhPT1xJiYwPD1xJiZxPD1oLmxlbiYmMDw9QiYmQjw9Yy5sZW47Si5jbGllbnRYPW0/ayhjLnRyYW5zbGF0ZSh2LDAsMCwwLDEsZykpOkI7Si5uZWdhdGl2ZT1KLnk8KHJ8fDApO0ouY2F0ZWdvcnk9ZSYmdm9pZCAwIT09ZVtKLnhdP2VbSi54XTpKLng7Si5pc051bGx8fCh2b2lkIDAhPT1GJiYoQz1NYXRoLm1pbihDLE1hdGguYWJzKEItRikpKSxGPUIpO0ouem9uZT10aGlzLnpvbmVzLmxlbmd0aCYmSi5nZXRab25lKCl9dGhpcy5jbG9zZXN0UG9pbnRSYW5nZVB4PUN9LGdldFZhbGlkUG9pbnRzOmZ1bmN0aW9uKGEsZCl7dmFyIGI9dGhpcy5jaGFydDtyZXR1cm4gZShhfHx0aGlzLnBvaW50c3x8W10sZnVuY3Rpb24oYSl7cmV0dXJuIGQmJlxuIWIuaXNJbnNpZGVQbG90KGEucGxvdFgsYS5wbG90WSxiLmludmVydGVkKT8hMTohYS5pc051bGx9KX0sc2V0Q2xpcDpmdW5jdGlvbihhKXt2YXIgZD10aGlzLmNoYXJ0LGI9dGhpcy5vcHRpb25zLGM9ZC5yZW5kZXJlcixoPWQuaW52ZXJ0ZWQsZT10aGlzLmNsaXBCb3gsbj1lfHxkLmNsaXBCb3gsbD10aGlzLnNoYXJlZENsaXBLZXl8fFtcIl9zaGFyZWRDbGlwXCIsYSYmYS5kdXJhdGlvbixhJiZhLmVhc2luZyxuLmhlaWdodCxiLnhBeGlzLGIueUF4aXNdLmpvaW4oKSxmPWRbbF0sZz1kW2wrXCJtXCJdO2Z8fChhJiYobi53aWR0aD0wLGgmJihuLng9ZC5wbG90U2l6ZVgpLGRbbCtcIm1cIl09Zz1jLmNsaXBSZWN0KGg/ZC5wbG90U2l6ZVgrOTk6LTk5LGg/LWQucGxvdExlZnQ6LWQucGxvdFRvcCw5OSxoP2QuY2hhcnRXaWR0aDpkLmNoYXJ0SGVpZ2h0KSksZFtsXT1mPWMuY2xpcFJlY3QobiksZi5jb3VudD17bGVuZ3RoOjB9KTthJiYhZi5jb3VudFt0aGlzLmluZGV4XSYmKGYuY291bnRbdGhpcy5pbmRleF09XG4hMCxmLmNvdW50Lmxlbmd0aCs9MSk7ITEhPT1iLmNsaXAmJih0aGlzLmdyb3VwLmNsaXAoYXx8ZT9mOmQuY2xpcFJlY3QpLHRoaXMubWFya2VyR3JvdXAuY2xpcChnKSx0aGlzLnNoYXJlZENsaXBLZXk9bCk7YXx8KGYuY291bnRbdGhpcy5pbmRleF0mJihkZWxldGUgZi5jb3VudFt0aGlzLmluZGV4XSwtLWYuY291bnQubGVuZ3RoKSwwPT09Zi5jb3VudC5sZW5ndGgmJmwmJmRbbF0mJihlfHwoZFtsXT1kW2xdLmRlc3Ryb3koKSksZFtsK1wibVwiXSYmKGRbbCtcIm1cIl09ZFtsK1wibVwiXS5kZXN0cm95KCkpKSl9LGFuaW1hdGU6ZnVuY3Rpb24oYSl7dmFyIGQ9dGhpcy5jaGFydCxiPUUodGhpcy5vcHRpb25zLmFuaW1hdGlvbiksYzthP3RoaXMuc2V0Q2xpcChiKTooYz10aGlzLnNoYXJlZENsaXBLZXksKGE9ZFtjXSkmJmEuYW5pbWF0ZSh7d2lkdGg6ZC5wbG90U2l6ZVgseDowfSxiKSxkW2MrXCJtXCJdJiZkW2MrXCJtXCJdLmFuaW1hdGUoe3dpZHRoOmQucGxvdFNpemVYKzk5LHg6MH0sYiksdGhpcy5hbmltYXRlPVxubnVsbCl9LGFmdGVyQW5pbWF0ZTpmdW5jdGlvbigpe3RoaXMuc2V0Q2xpcCgpO2YodGhpcyxcImFmdGVyQW5pbWF0ZVwiKTt0aGlzLmZpbmlzaGVkQW5pbWF0aW5nPSEwfSxkcmF3UG9pbnRzOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5wb2ludHMsZD10aGlzLmNoYXJ0LGIsYyxoLGUsbj10aGlzLm9wdGlvbnMubWFya2VyLGwsZixnLG09dGhpc1t0aGlzLnNwZWNpYWxHcm91cF18fHRoaXMubWFya2VyR3JvdXAscix4PUkobi5lbmFibGVkLHRoaXMueEF4aXMuaXNSYWRpYWw/ITA6bnVsbCx0aGlzLmNsb3Nlc3RQb2ludFJhbmdlUHg+PTIqbi5yYWRpdXMpO2lmKCExIT09bi5lbmFibGVkfHx0aGlzLl9oYXNQb2ludE1hcmtlcnMpZm9yKGI9MDtiPGEubGVuZ3RoO2IrKyljPWFbYl0sZT1jLmdyYXBoaWMsbD1jLm1hcmtlcnx8e30sZj0hIWMubWFya2VyLGg9eCYmdm9pZCAwPT09bC5lbmFibGVkfHxsLmVuYWJsZWQsZz1jLmlzSW5zaWRlLGgmJiFjLmlzTnVsbD8oaD1JKGwuc3ltYm9sLHRoaXMuc3ltYm9sKSxcbmMuaGFzSW1hZ2U9MD09PWguaW5kZXhPZihcInVybFwiKSxyPXRoaXMubWFya2VyQXR0cmlicyhjLGMuc2VsZWN0ZWQmJlwic2VsZWN0XCIpLGU/ZVtnP1wic2hvd1wiOlwiaGlkZVwiXSghMCkuYW5pbWF0ZShyKTpnJiYoMDxyLndpZHRofHxjLmhhc0ltYWdlKSYmKGMuZ3JhcGhpYz1lPWQucmVuZGVyZXIuc3ltYm9sKGgsci54LHIueSxyLndpZHRoLHIuaGVpZ2h0LGY/bDpuKS5hZGQobSkpLGUmJmUuYXR0cih0aGlzLnBvaW50QXR0cmlicyhjLGMuc2VsZWN0ZWQmJlwic2VsZWN0XCIpKSxlJiZlLmFkZENsYXNzKGMuZ2V0Q2xhc3NOYW1lKCksITApKTplJiYoYy5ncmFwaGljPWUuZGVzdHJveSgpKX0sbWFya2VyQXR0cmliczpmdW5jdGlvbihhLGQpe3ZhciBiPXRoaXMub3B0aW9ucy5tYXJrZXIsYz1hLm1hcmtlcnx8e30saD1JKGMucmFkaXVzLGIucmFkaXVzKTtkJiYoYj1iLnN0YXRlc1tkXSxkPWMuc3RhdGVzJiZjLnN0YXRlc1tkXSxoPUkoZCYmZC5yYWRpdXMsYiYmYi5yYWRpdXMsaCsoYiYmYi5yYWRpdXNQbHVzfHxcbjApKSk7YS5oYXNJbWFnZSYmKGg9MCk7YT17eDpNYXRoLmZsb29yKGEucGxvdFgpLWgseTphLnBsb3RZLWh9O2gmJihhLndpZHRoPWEuaGVpZ2h0PTIqaCk7cmV0dXJuIGF9LHBvaW50QXR0cmliczpmdW5jdGlvbihhLGQpe3ZhciBiPXRoaXMub3B0aW9ucy5tYXJrZXIsYz1hJiZhLm9wdGlvbnMsaD1jJiZjLm1hcmtlcnx8e30sZT10aGlzLmNvbG9yLG49YyYmYy5jb2xvcixsPWEmJmEuY29sb3IsYz1JKGgubGluZVdpZHRoLGIubGluZVdpZHRoKTthPWEmJmEuem9uZSYmYS56b25lLmNvbG9yO2U9bnx8YXx8bHx8ZTthPWguZmlsbENvbG9yfHxiLmZpbGxDb2xvcnx8ZTtlPWgubGluZUNvbG9yfHxiLmxpbmVDb2xvcnx8ZTtkJiYoYj1iLnN0YXRlc1tkXSxkPWguc3RhdGVzJiZoLnN0YXRlc1tkXXx8e30sYz1JKGQubGluZVdpZHRoLGIubGluZVdpZHRoLGMrSShkLmxpbmVXaWR0aFBsdXMsYi5saW5lV2lkdGhQbHVzLDApKSxhPWQuZmlsbENvbG9yfHxiLmZpbGxDb2xvcnx8YSxlPWQubGluZUNvbG9yfHxcbmIubGluZUNvbG9yfHxlKTtyZXR1cm57c3Ryb2tlOmUsXCJzdHJva2Utd2lkdGhcIjpjLGZpbGw6YX19LGRlc3Ryb3k6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGQ9YS5jaGFydCxiPS9BcHBsZVdlYktpdFxcLzUzMy8udGVzdChKLm5hdmlnYXRvci51c2VyQWdlbnQpLGMsaCxlPWEuZGF0YXx8W10sbCxnO2YoYSxcImRlc3Ryb3lcIik7eChhKTt6KGEuYXhpc1R5cGVzfHxbXSxmdW5jdGlvbihkKXsoZz1hW2RdKSYmZy5zZXJpZXMmJihtKGcuc2VyaWVzLGEpLGcuaXNEaXJ0eT1nLmZvcmNlUmVkcmF3PSEwKX0pO2EubGVnZW5kSXRlbSYmYS5jaGFydC5sZWdlbmQuZGVzdHJveUl0ZW0oYSk7Zm9yKGg9ZS5sZW5ndGg7aC0tOykobD1lW2hdKSYmbC5kZXN0cm95JiZsLmRlc3Ryb3koKTthLnBvaW50cz1udWxsO2NsZWFyVGltZW91dChhLmFuaW1hdGlvblRpbWVvdXQpO0MoYSxmdW5jdGlvbihhLGQpe2EgaW5zdGFuY2VvZiBuJiYhYS5zdXJ2aXZlJiYoYz1iJiZcImdyb3VwXCI9PT1kP1wiaGlkZVwiOlwiZGVzdHJveVwiLFxuYVtjXSgpKX0pO2QuaG92ZXJTZXJpZXM9PT1hJiYoZC5ob3ZlclNlcmllcz1udWxsKTttKGQuc2VyaWVzLGEpO2Qub3JkZXJTZXJpZXMoKTtDKGEsZnVuY3Rpb24oZCxiKXtkZWxldGUgYVtiXX0pfSxnZXRHcmFwaFBhdGg6ZnVuY3Rpb24oYSxkLGIpe3ZhciBjPXRoaXMsaD1jLm9wdGlvbnMsZT1oLnN0ZXAscCxuPVtdLGw9W10sZjthPWF8fGMucG9pbnRzOyhwPWEucmV2ZXJzZWQpJiZhLnJldmVyc2UoKTsoZT17cmlnaHQ6MSxjZW50ZXI6Mn1bZV18fGUmJjMpJiZwJiYoZT00LWUpOyFoLmNvbm5lY3ROdWxsc3x8ZHx8Ynx8KGE9dGhpcy5nZXRWYWxpZFBvaW50cyhhKSk7eihhLGZ1bmN0aW9uKHAsZyl7dmFyIG09cC5wbG90WCxyPXAucGxvdFksQT1hW2ctMV07KHAubGVmdENsaWZmfHxBJiZBLnJpZ2h0Q2xpZmYpJiYhYiYmKGY9ITApO3AuaXNOdWxsJiYhdShkKSYmMDxnP2Y9IWguY29ubmVjdE51bGxzOnAuaXNOdWxsJiYhZD9mPSEwOigwPT09Z3x8Zj9nPVtcIk1cIixwLnBsb3RYLHAucGxvdFldOlxuYy5nZXRQb2ludFNwbGluZT9nPWMuZ2V0UG9pbnRTcGxpbmUoYSxwLGcpOmU/KGc9MT09PWU/W1wiTFwiLEEucGxvdFgscl06Mj09PWU/W1wiTFwiLChBLnBsb3RYK20pLzIsQS5wbG90WSxcIkxcIiwoQS5wbG90WCttKS8yLHJdOltcIkxcIixtLEEucGxvdFldLGcucHVzaChcIkxcIixtLHIpKTpnPVtcIkxcIixtLHJdLGwucHVzaChwLngpLGUmJmwucHVzaChwLngpLG4ucHVzaC5hcHBseShuLGcpLGY9ITEpfSk7bi54TWFwPWw7cmV0dXJuIGMuZ3JhcGhQYXRoPW59LGRyYXdHcmFwaDpmdW5jdGlvbigpe3ZhciBhPXRoaXMsZD10aGlzLm9wdGlvbnMsYj0odGhpcy5nYXBwZWRQYXRofHx0aGlzLmdldEdyYXBoUGF0aCkuY2FsbCh0aGlzKSxjPVtbXCJncmFwaFwiLFwiaGlnaGNoYXJ0cy1ncmFwaFwiLGQubGluZUNvbG9yfHx0aGlzLmNvbG9yLGQuZGFzaFN0eWxlXV07eih0aGlzLnpvbmVzLGZ1bmN0aW9uKGIsZSl7Yy5wdXNoKFtcInpvbmUtZ3JhcGgtXCIrZSxcImhpZ2hjaGFydHMtZ3JhcGggaGlnaGNoYXJ0cy16b25lLWdyYXBoLVwiK1xuZStcIiBcIisoYi5jbGFzc05hbWV8fFwiXCIpLGIuY29sb3J8fGEuY29sb3IsYi5kYXNoU3R5bGV8fGQuZGFzaFN0eWxlXSl9KTt6KGMsZnVuY3Rpb24oYyxlKXt2YXIgaD1jWzBdLHA9YVtoXTtwPyhwLmVuZFg9YS5wcmV2ZW50R3JhcGhBbmltYXRpb24/bnVsbDpiLnhNYXAscC5hbmltYXRlKHtkOmJ9KSk6Yi5sZW5ndGgmJihhW2hdPWEuY2hhcnQucmVuZGVyZXIucGF0aChiKS5hZGRDbGFzcyhjWzFdKS5hdHRyKHt6SW5kZXg6MX0pLmFkZChhLmdyb3VwKSxwPXtzdHJva2U6Y1syXSxcInN0cm9rZS13aWR0aFwiOmQubGluZVdpZHRoLGZpbGw6YS5maWxsR3JhcGgmJmEuY29sb3J8fFwibm9uZVwifSxjWzNdP3AuZGFzaHN0eWxlPWNbM106XCJzcXVhcmVcIiE9PWQubGluZWNhcCYmKHBbXCJzdHJva2UtbGluZWNhcFwiXT1wW1wic3Ryb2tlLWxpbmVqb2luXCJdPVwicm91bmRcIikscD1hW2hdLmF0dHIocCkuc2hhZG93KDI+ZSYmZC5zaGFkb3cpKTtwJiYocC5zdGFydFg9Yi54TWFwLHAuaXNBcmVhPWIuaXNBcmVhKX0pfSxcbmFwcGx5Wm9uZXM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGQ9dGhpcy5jaGFydCxiPWQucmVuZGVyZXIsYz10aGlzLnpvbmVzLGgsZSxuPXRoaXMuY2xpcHN8fFtdLGwsZj10aGlzLmdyYXBoLGc9dGhpcy5hcmVhLG09TWF0aC5tYXgoZC5jaGFydFdpZHRoLGQuY2hhcnRIZWlnaHQpLHI9dGhpc1sodGhpcy56b25lQXhpc3x8XCJ5XCIpK1wiQXhpc1wiXSx4LEIsaz1kLmludmVydGVkLHEsRix0LEMsdT0hMTtjLmxlbmd0aCYmKGZ8fGcpJiZyJiZ2b2lkIDAhPT1yLm1pbiYmKEI9ci5yZXZlcnNlZCxxPXIuaG9yaXosZiYmZi5oaWRlKCksZyYmZy5oaWRlKCkseD1yLmdldEV4dHJlbWVzKCkseihjLGZ1bmN0aW9uKGMscCl7aD1CP3E/ZC5wbG90V2lkdGg6MDpxPzA6ci50b1BpeGVscyh4Lm1pbik7aD1NYXRoLm1pbihNYXRoLm1heChJKGUsaCksMCksbSk7ZT1NYXRoLm1pbihNYXRoLm1heChNYXRoLnJvdW5kKHIudG9QaXhlbHMoSShjLnZhbHVlLHgubWF4KSwhMCkpLDApLG0pO3UmJihoPWU9ci50b1BpeGVscyh4Lm1heCkpO1xuRj1NYXRoLmFicyhoLWUpO3Q9TWF0aC5taW4oaCxlKTtDPU1hdGgubWF4KGgsZSk7ci5pc1hBeGlzPyhsPXt4Oms/Qzp0LHk6MCx3aWR0aDpGLGhlaWdodDptfSxxfHwobC54PWQucGxvdEhlaWdodC1sLngpKToobD17eDowLHk6az9DOnQsd2lkdGg6bSxoZWlnaHQ6Rn0scSYmKGwueT1kLnBsb3RXaWR0aC1sLnkpKTtrJiZiLmlzVk1MJiYobD1yLmlzWEF4aXM/e3g6MCx5OkI/dDpDLGhlaWdodDpsLndpZHRoLHdpZHRoOmQuY2hhcnRXaWR0aH06e3g6bC55LWQucGxvdExlZnQtZC5zcGFjaW5nQm94LngseTowLHdpZHRoOmwuaGVpZ2h0LGhlaWdodDpkLmNoYXJ0SGVpZ2h0fSk7bltwXT9uW3BdLmFuaW1hdGUobCk6KG5bcF09Yi5jbGlwUmVjdChsKSxmJiZhW1wiem9uZS1ncmFwaC1cIitwXS5jbGlwKG5bcF0pLGcmJmFbXCJ6b25lLWFyZWEtXCIrcF0uY2xpcChuW3BdKSk7dT1jLnZhbHVlPngubWF4fSksdGhpcy5jbGlwcz1uKX0saW52ZXJ0R3JvdXBzOmZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGQoKXt6KFtcImdyb3VwXCIsXG5cIm1hcmtlckdyb3VwXCJdLGZ1bmN0aW9uKGQpe2JbZF0mJihjLnJlbmRlcmVyLmlzVk1MJiZiW2RdLmF0dHIoe3dpZHRoOmIueUF4aXMubGVuLGhlaWdodDpiLnhBeGlzLmxlbn0pLGJbZF0ud2lkdGg9Yi55QXhpcy5sZW4sYltkXS5oZWlnaHQ9Yi54QXhpcy5sZW4sYltkXS5pbnZlcnQoYSkpfSl9dmFyIGI9dGhpcyxjPWIuY2hhcnQsaDtiLnhBeGlzJiYoaD1HKGMsXCJyZXNpemVcIixkKSxHKGIsXCJkZXN0cm95XCIsaCksZChhKSxiLmludmVydEdyb3Vwcz1kKX0scGxvdEdyb3VwOmZ1bmN0aW9uKGEsZCxiLGMsaCl7dmFyIGU9dGhpc1thXSxwPSFlO3AmJih0aGlzW2FdPWU9dGhpcy5jaGFydC5yZW5kZXJlci5nKCkuYXR0cih7ekluZGV4OmN8fC4xfSkuYWRkKGgpKTtlLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIitkK1wiIGhpZ2hjaGFydHMtc2VyaWVzLVwiK3RoaXMuaW5kZXgrXCIgaGlnaGNoYXJ0cy1cIit0aGlzLnR5cGUrXCItc2VyaWVzIFwiKyh1KHRoaXMuY29sb3JJbmRleCk/XCJoaWdoY2hhcnRzLWNvbG9yLVwiK1xudGhpcy5jb2xvckluZGV4K1wiIFwiOlwiXCIpKyh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lfHxcIlwiKSsoZS5oYXNDbGFzcyhcImhpZ2hjaGFydHMtdHJhY2tlclwiKT9cIiBoaWdoY2hhcnRzLXRyYWNrZXJcIjpcIlwiKSwhMCk7ZS5hdHRyKHt2aXNpYmlsaXR5OmJ9KVtwP1wiYXR0clwiOlwiYW5pbWF0ZVwiXSh0aGlzLmdldFBsb3RCb3goKSk7cmV0dXJuIGV9LGdldFBsb3RCb3g6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0LGQ9dGhpcy54QXhpcyxiPXRoaXMueUF4aXM7YS5pbnZlcnRlZCYmKGQ9YixiPXRoaXMueEF4aXMpO3JldHVybnt0cmFuc2xhdGVYOmQ/ZC5sZWZ0OmEucGxvdExlZnQsdHJhbnNsYXRlWTpiP2IudG9wOmEucGxvdFRvcCxzY2FsZVg6MSxzY2FsZVk6MX19LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMsZD1hLmNoYXJ0LGIsYz1hLm9wdGlvbnMsaD0hIWEuYW5pbWF0ZSYmZC5yZW5kZXJlci5pc1NWRyYmRShjLmFuaW1hdGlvbikuZHVyYXRpb24sZT1hLnZpc2libGU/XCJpbmhlcml0XCI6XG5cImhpZGRlblwiLG49Yy56SW5kZXgsbD1hLmhhc1JlbmRlcmVkLGY9ZC5zZXJpZXNHcm91cCxnPWQuaW52ZXJ0ZWQ7Yj1hLnBsb3RHcm91cChcImdyb3VwXCIsXCJzZXJpZXNcIixlLG4sZik7YS5tYXJrZXJHcm91cD1hLnBsb3RHcm91cChcIm1hcmtlckdyb3VwXCIsXCJtYXJrZXJzXCIsZSxuLGYpO2gmJmEuYW5pbWF0ZSghMCk7Yi5pbnZlcnRlZD1hLmlzQ2FydGVzaWFuP2c6ITE7YS5kcmF3R3JhcGgmJihhLmRyYXdHcmFwaCgpLGEuYXBwbHlab25lcygpKTthLmRyYXdEYXRhTGFiZWxzJiZhLmRyYXdEYXRhTGFiZWxzKCk7YS52aXNpYmxlJiZhLmRyYXdQb2ludHMoKTthLmRyYXdUcmFja2VyJiYhMSE9PWEub3B0aW9ucy5lbmFibGVNb3VzZVRyYWNraW5nJiZhLmRyYXdUcmFja2VyKCk7YS5pbnZlcnRHcm91cHMoZyk7ITE9PT1jLmNsaXB8fGEuc2hhcmVkQ2xpcEtleXx8bHx8Yi5jbGlwKGQuY2xpcFJlY3QpO2gmJmEuYW5pbWF0ZSgpO2x8fChhLmFuaW1hdGlvblRpbWVvdXQ9QihmdW5jdGlvbigpe2EuYWZ0ZXJBbmltYXRlKCl9LFxuaCkpO2EuaXNEaXJ0eT0hMTthLmhhc1JlbmRlcmVkPSEwfSxyZWRyYXc6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0LGQ9dGhpcy5pc0RpcnR5fHx0aGlzLmlzRGlydHlEYXRhLGI9dGhpcy5ncm91cCxjPXRoaXMueEF4aXMsaD10aGlzLnlBeGlzO2ImJihhLmludmVydGVkJiZiLmF0dHIoe3dpZHRoOmEucGxvdFdpZHRoLGhlaWdodDphLnBsb3RIZWlnaHR9KSxiLmFuaW1hdGUoe3RyYW5zbGF0ZVg6SShjJiZjLmxlZnQsYS5wbG90TGVmdCksdHJhbnNsYXRlWTpJKGgmJmgudG9wLGEucGxvdFRvcCl9KSk7dGhpcy50cmFuc2xhdGUoKTt0aGlzLnJlbmRlcigpO2QmJmRlbGV0ZSB0aGlzLmtkVHJlZX0sa2RBeGlzQXJyYXk6W1wiY2xpZW50WFwiLFwicGxvdFlcIl0sc2VhcmNoUG9pbnQ6ZnVuY3Rpb24oYSxkKXt2YXIgYj10aGlzLnhBeGlzLGM9dGhpcy55QXhpcyxoPXRoaXMuY2hhcnQuaW52ZXJ0ZWQ7cmV0dXJuIHRoaXMuc2VhcmNoS0RUcmVlKHtjbGllbnRYOmg/Yi5sZW4tYS5jaGFydFkrXG5iLnBvczphLmNoYXJ0WC1iLnBvcyxwbG90WTpoP2MubGVuLWEuY2hhcnRYK2MucG9zOmEuY2hhcnRZLWMucG9zfSxkKX0sYnVpbGRLRFRyZWU6ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGIsYyxlKXt2YXIgaCxwO2lmKHA9YiYmYi5sZW5ndGgpcmV0dXJuIGg9ZC5rZEF4aXNBcnJheVtjJWVdLGIuc29ydChmdW5jdGlvbihhLGQpe3JldHVybiBhW2hdLWRbaF19KSxwPU1hdGguZmxvb3IocC8yKSx7cG9pbnQ6YltwXSxsZWZ0OmEoYi5zbGljZSgwLHApLGMrMSxlKSxyaWdodDphKGIuc2xpY2UocCsxKSxjKzEsZSl9fXRoaXMuYnVpbGRpbmdLZFRyZWU9ITA7dmFyIGQ9dGhpcyxiPS0xPGQub3B0aW9ucy5maW5kTmVhcmVzdFBvaW50QnkuaW5kZXhPZihcInlcIik/MjoxO2RlbGV0ZSBkLmtkVHJlZTtCKGZ1bmN0aW9uKCl7ZC5rZFRyZWU9YShkLmdldFZhbGlkUG9pbnRzKG51bGwsIWQuZGlyZWN0VG91Y2gpLGIsYik7ZC5idWlsZGluZ0tkVHJlZT0hMX0sZC5vcHRpb25zLmtkTm93PzA6MSl9LFxuc2VhcmNoS0RUcmVlOmZ1bmN0aW9uKGEsZCl7ZnVuY3Rpb24gYihhLGQscCxsKXt2YXIgZj1kLnBvaW50LGc9Yy5rZEF4aXNBcnJheVtwJWxdLG0scix4PWY7cj11KGFbaF0pJiZ1KGZbaF0pP01hdGgucG93KGFbaF0tZltoXSwyKTpudWxsO209dShhW2VdKSYmdShmW2VdKT9NYXRoLnBvdyhhW2VdLWZbZV0sMik6bnVsbDttPShyfHwwKSsobXx8MCk7Zi5kaXN0PXUobSk/TWF0aC5zcXJ0KG0pOk51bWJlci5NQVhfVkFMVUU7Zi5kaXN0WD11KHIpP01hdGguc3FydChyKTpOdW1iZXIuTUFYX1ZBTFVFO2c9YVtnXS1mW2ddO209MD5nP1wibGVmdFwiOlwicmlnaHRcIjtyPTA+Zz9cInJpZ2h0XCI6XCJsZWZ0XCI7ZFttXSYmKG09YihhLGRbbV0scCsxLGwpLHg9bVtuXTx4W25dP206Zik7ZFtyXSYmTWF0aC5zcXJ0KGcqZyk8eFtuXSYmKGE9YihhLGRbcl0scCsxLGwpLHg9YVtuXTx4W25dP2E6eCk7cmV0dXJuIHh9dmFyIGM9dGhpcyxoPXRoaXMua2RBeGlzQXJyYXlbMF0sZT10aGlzLmtkQXhpc0FycmF5WzFdLFxubj1kP1wiZGlzdFhcIjpcImRpc3RcIjtkPS0xPGMub3B0aW9ucy5maW5kTmVhcmVzdFBvaW50QnkuaW5kZXhPZihcInlcIik/MjoxO3RoaXMua2RUcmVlfHx0aGlzLmJ1aWxkaW5nS2RUcmVlfHx0aGlzLmJ1aWxkS0RUcmVlKCk7aWYodGhpcy5rZFRyZWUpcmV0dXJuIGIoYSx0aGlzLmtkVHJlZSxkLGQpfX0pfSkoTCk7KGZ1bmN0aW9uKGEpe3ZhciBHPWEuQXhpcyxFPWEuQ2hhcnQsSD1hLmNvcnJlY3RGbG9hdCx2PWEuZGVmaW5lZCxrPWEuZGVzdHJveU9iamVjdFByb3BlcnRpZXMscT1hLmVhY2gsdz1hLmZvcm1hdCx0PWEub2JqZWN0RWFjaCx1PWEucGljayx6PWEuU2VyaWVzO2EuU3RhY2tJdGVtPWZ1bmN0aW9uKGEsZyxmLGUsYyl7dmFyIGI9YS5jaGFydC5pbnZlcnRlZDt0aGlzLmF4aXM9YTt0aGlzLmlzTmVnYXRpdmU9Zjt0aGlzLm9wdGlvbnM9Zzt0aGlzLng9ZTt0aGlzLnRvdGFsPW51bGw7dGhpcy5wb2ludHM9e307dGhpcy5zdGFjaz1jO3RoaXMucmlnaHRDbGlmZj10aGlzLmxlZnRDbGlmZj1cbjA7dGhpcy5hbGlnbk9wdGlvbnM9e2FsaWduOmcuYWxpZ258fChiP2Y/XCJsZWZ0XCI6XCJyaWdodFwiOlwiY2VudGVyXCIpLHZlcnRpY2FsQWxpZ246Zy52ZXJ0aWNhbEFsaWdufHwoYj9cIm1pZGRsZVwiOmY/XCJib3R0b21cIjpcInRvcFwiKSx5OnUoZy55LGI/NDpmPzE0Oi02KSx4OnUoZy54LGI/Zj8tNjo2OjApfTt0aGlzLnRleHRBbGlnbj1nLnRleHRBbGlnbnx8KGI/Zj9cInJpZ2h0XCI6XCJsZWZ0XCI6XCJjZW50ZXJcIil9O2EuU3RhY2tJdGVtLnByb3RvdHlwZT17ZGVzdHJveTpmdW5jdGlvbigpe2sodGhpcyx0aGlzLmF4aXMpfSxyZW5kZXI6ZnVuY3Rpb24oYSl7dmFyIGc9dGhpcy5vcHRpb25zLGY9Zy5mb3JtYXQsZj1mP3coZix0aGlzKTpnLmZvcm1hdHRlci5jYWxsKHRoaXMpO3RoaXMubGFiZWw/dGhpcy5sYWJlbC5hdHRyKHt0ZXh0OmYsdmlzaWJpbGl0eTpcImhpZGRlblwifSk6dGhpcy5sYWJlbD10aGlzLmF4aXMuY2hhcnQucmVuZGVyZXIudGV4dChmLG51bGwsbnVsbCxnLnVzZUhUTUwpLmNzcyhnLnN0eWxlKS5hdHRyKHthbGlnbjp0aGlzLnRleHRBbGlnbixcbnJvdGF0aW9uOmcucm90YXRpb24sdmlzaWJpbGl0eTpcImhpZGRlblwifSkuYWRkKGEpfSxzZXRPZmZzZXQ6ZnVuY3Rpb24oYSxnKXt2YXIgZj10aGlzLmF4aXMsZT1mLmNoYXJ0LGM9Zi50cmFuc2xhdGUoZi51c2VQZXJjZW50YWdlPzEwMDp0aGlzLnRvdGFsLDAsMCwwLDEpLGY9Zi50cmFuc2xhdGUoMCksZj1NYXRoLmFicyhjLWYpO2E9ZS54QXhpc1swXS50cmFuc2xhdGUodGhpcy54KSthO2M9dGhpcy5nZXRTdGFja0JveChlLHRoaXMsYSxjLGcsZik7aWYoZz10aGlzLmxhYmVsKWcuYWxpZ24odGhpcy5hbGlnbk9wdGlvbnMsbnVsbCxjKSxjPWcuYWxpZ25BdHRyLGdbITE9PT10aGlzLm9wdGlvbnMuY3JvcHx8ZS5pc0luc2lkZVBsb3QoYy54LGMueSk/XCJzaG93XCI6XCJoaWRlXCJdKCEwKX0sZ2V0U3RhY2tCb3g6ZnVuY3Rpb24oYSxnLGYsZSxjLGIpe3ZhciBtPWcuYXhpcy5yZXZlcnNlZCxsPWEuaW52ZXJ0ZWQ7YT1hLnBsb3RIZWlnaHQ7Zz1nLmlzTmVnYXRpdmUmJiFtfHwhZy5pc05lZ2F0aXZlJiZcbm07cmV0dXJue3g6bD9nP2U6ZS1iOmYseTpsP2EtZi1jOmc/YS1lLWI6YS1lLHdpZHRoOmw/YjpjLGhlaWdodDpsP2M6Yn19fTtFLnByb3RvdHlwZS5nZXRTdGFja3M9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3EoYS55QXhpcyxmdW5jdGlvbihhKXthLnN0YWNrcyYmYS5oYXNWaXNpYmxlU2VyaWVzJiYoYS5vbGRTdGFja3M9YS5zdGFja3MpfSk7cShhLnNlcmllcyxmdW5jdGlvbihnKXshZy5vcHRpb25zLnN0YWNraW5nfHwhMCE9PWcudmlzaWJsZSYmITEhPT1hLm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzfHwoZy5zdGFja0tleT1nLnR5cGUrdShnLm9wdGlvbnMuc3RhY2ssXCJcIikpfSl9O0cucHJvdG90eXBlLmJ1aWxkU3RhY2tzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5zZXJpZXMsZz11KHRoaXMub3B0aW9ucy5yZXZlcnNlZFN0YWNrcywhMCksZj1hLmxlbmd0aCxlO2lmKCF0aGlzLmlzWEF4aXMpe3RoaXMudXNlUGVyY2VudGFnZT0hMTtmb3IoZT1mO2UtLTspYVtnP2U6XG5mLWUtMV0uc2V0U3RhY2tlZFBvaW50cygpO2ZvcihlPTA7ZTxmO2UrKylhW2VdLm1vZGlmeVN0YWNrcygpfX07Ry5wcm90b3R5cGUucmVuZGVyU3RhY2tUb3RhbHM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0LGc9YS5yZW5kZXJlcixmPXRoaXMuc3RhY2tzLGU9dGhpcy5zdGFja1RvdGFsR3JvdXA7ZXx8KHRoaXMuc3RhY2tUb3RhbEdyb3VwPWU9Zy5nKFwic3RhY2stbGFiZWxzXCIpLmF0dHIoe3Zpc2liaWxpdHk6XCJ2aXNpYmxlXCIsekluZGV4OjZ9KS5hZGQoKSk7ZS50cmFuc2xhdGUoYS5wbG90TGVmdCxhLnBsb3RUb3ApO3QoZixmdW5jdGlvbihhKXt0KGEsZnVuY3Rpb24oYSl7YS5yZW5kZXIoZSl9KX0pfTtHLnByb3RvdHlwZS5yZXNldFN0YWNrcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMsZz1hLnN0YWNrczthLmlzWEF4aXN8fHQoZyxmdW5jdGlvbihmKXt0KGYsZnVuY3Rpb24oZSxjKXtlLnRvdWNoZWQ8YS5zdGFja3NUb3VjaGVkPyhlLmRlc3Ryb3koKSxkZWxldGUgZltjXSk6XG4oZS50b3RhbD1udWxsLGUuY3VtdWxhdGl2ZT1udWxsKX0pfSl9O0cucHJvdG90eXBlLmNsZWFuU3RhY2tzPWZ1bmN0aW9uKCl7dmFyIGE7dGhpcy5pc1hBeGlzfHwodGhpcy5vbGRTdGFja3MmJihhPXRoaXMuc3RhY2tzPXRoaXMub2xkU3RhY2tzKSx0KGEsZnVuY3Rpb24oYSl7dChhLGZ1bmN0aW9uKGEpe2EuY3VtdWxhdGl2ZT1hLnRvdGFsfSl9KSl9O3oucHJvdG90eXBlLnNldFN0YWNrZWRQb2ludHM9ZnVuY3Rpb24oKXtpZih0aGlzLm9wdGlvbnMuc3RhY2tpbmcmJighMD09PXRoaXMudmlzaWJsZXx8ITE9PT10aGlzLmNoYXJ0Lm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzKSl7dmFyIG09dGhpcy5wcm9jZXNzZWRYRGF0YSxnPXRoaXMucHJvY2Vzc2VkWURhdGEsZj1bXSxlPWcubGVuZ3RoLGM9dGhpcy5vcHRpb25zLGI9Yy50aHJlc2hvbGQscj11KGMuc3RhcnRGcm9tVGhyZXNob2xkJiZiLDApLGw9Yy5zdGFjayxjPWMuc3RhY2tpbmcsaz10aGlzLnN0YWNrS2V5LHE9XG5cIi1cIitrLHg9dGhpcy5uZWdTdGFja3MsRj10aGlzLnlBeGlzLG49Ri5zdGFja3MsQj1GLm9sZFN0YWNrcyx0LEEsZCxwLEQsaCx5O0Yuc3RhY2tzVG91Y2hlZCs9MTtmb3IoRD0wO0Q8ZTtEKyspaD1tW0RdLHk9Z1tEXSx0PXRoaXMuZ2V0U3RhY2tJbmRpY2F0b3IodCxoLHRoaXMuaW5kZXgpLHA9dC5rZXksZD0oQT14JiZ5PChyPzA6YikpP3E6ayxuW2RdfHwobltkXT17fSksbltkXVtoXXx8KEJbZF0mJkJbZF1baF0/KG5bZF1baF09QltkXVtoXSxuW2RdW2hdLnRvdGFsPW51bGwpOm5bZF1baF09bmV3IGEuU3RhY2tJdGVtKEYsRi5vcHRpb25zLnN0YWNrTGFiZWxzLEEsaCxsKSksZD1uW2RdW2hdLG51bGwhPT15PyhkLnBvaW50c1twXT1kLnBvaW50c1t0aGlzLmluZGV4XT1bdShkLmN1bXVsYXRpdmUscildLHYoZC5jdW11bGF0aXZlKXx8KGQuYmFzZT1wKSxkLnRvdWNoZWQ9Ri5zdGFja3NUb3VjaGVkLDA8dC5pbmRleCYmITE9PT10aGlzLnNpbmdsZVN0YWNrcyYmKGQucG9pbnRzW3BdWzBdPVxuZC5wb2ludHNbdGhpcy5pbmRleCtcIixcIitoK1wiLDBcIl1bMF0pKTpkLnBvaW50c1twXT1kLnBvaW50c1t0aGlzLmluZGV4XT1udWxsLFwicGVyY2VudFwiPT09Yz8oQT1BP2s6cSx4JiZuW0FdJiZuW0FdW2hdPyhBPW5bQV1baF0sZC50b3RhbD1BLnRvdGFsPU1hdGgubWF4KEEudG90YWwsZC50b3RhbCkrTWF0aC5hYnMoeSl8fDApOmQudG90YWw9SChkLnRvdGFsKyhNYXRoLmFicyh5KXx8MCkpKTpkLnRvdGFsPUgoZC50b3RhbCsoeXx8MCkpLGQuY3VtdWxhdGl2ZT11KGQuY3VtdWxhdGl2ZSxyKSsoeXx8MCksbnVsbCE9PXkmJihkLnBvaW50c1twXS5wdXNoKGQuY3VtdWxhdGl2ZSksZltEXT1kLmN1bXVsYXRpdmUpO1wicGVyY2VudFwiPT09YyYmKEYudXNlUGVyY2VudGFnZT0hMCk7dGhpcy5zdGFja2VkWURhdGE9ZjtGLm9sZFN0YWNrcz17fX19O3oucHJvdG90eXBlLm1vZGlmeVN0YWNrcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMsZz1hLnN0YWNrS2V5LGY9YS55QXhpcy5zdGFja3MsZT1hLnByb2Nlc3NlZFhEYXRhLFxuYyxiPWEub3B0aW9ucy5zdGFja2luZzthW2IrXCJTdGFja2VyXCJdJiZxKFtnLFwiLVwiK2ddLGZ1bmN0aW9uKGcpe2Zvcih2YXIgbD1lLmxlbmd0aCxyLG07bC0tOylpZihyPWVbbF0sYz1hLmdldFN0YWNrSW5kaWNhdG9yKGMscixhLmluZGV4LGcpLG09KHI9ZltnXSYmZltnXVtyXSkmJnIucG9pbnRzW2Mua2V5XSlhW2IrXCJTdGFja2VyXCJdKG0scixsKX0pfTt6LnByb3RvdHlwZS5wZXJjZW50U3RhY2tlcj1mdW5jdGlvbihhLGcsZil7Zz1nLnRvdGFsPzEwMC9nLnRvdGFsOjA7YVswXT1IKGFbMF0qZyk7YVsxXT1IKGFbMV0qZyk7dGhpcy5zdGFja2VkWURhdGFbZl09YVsxXX07ei5wcm90b3R5cGUuZ2V0U3RhY2tJbmRpY2F0b3I9ZnVuY3Rpb24oYSxnLGYsZSl7IXYoYSl8fGEueCE9PWd8fGUmJmEua2V5IT09ZT9hPXt4OmcsaW5kZXg6MCxrZXk6ZX06YS5pbmRleCsrO2Eua2V5PVtmLGcsYS5pbmRleF0uam9pbigpO3JldHVybiBhfX0pKEwpOyhmdW5jdGlvbihhKXt2YXIgRz1hLmFkZEV2ZW50LFxuRT1hLmFuaW1hdGUsSD1hLkF4aXMsdj1hLmNyZWF0ZUVsZW1lbnQsaz1hLmNzcyxxPWEuZGVmaW5lZCx3PWEuZWFjaCx0PWEuZXJhc2UsdT1hLmV4dGVuZCx6PWEuZmlyZUV2ZW50LG09YS5pbkFycmF5LGc9YS5pc051bWJlcixmPWEuaXNPYmplY3QsZT1hLmlzQXJyYXksYz1hLm1lcmdlLGI9YS5vYmplY3RFYWNoLHI9YS5waWNrLGw9YS5Qb2ludCxDPWEuU2VyaWVzLEk9YS5zZXJpZXNUeXBlcyx4PWEuc2V0QW5pbWF0aW9uLEY9YS5zcGxhdDt1KGEuQ2hhcnQucHJvdG90eXBlLHthZGRTZXJpZXM6ZnVuY3Rpb24oYSxiLGMpe3ZhciBlLGQ9dGhpczthJiYoYj1yKGIsITApLHooZCxcImFkZFNlcmllc1wiLHtvcHRpb25zOmF9LGZ1bmN0aW9uKCl7ZT1kLmluaXRTZXJpZXMoYSk7ZC5pc0RpcnR5TGVnZW5kPSEwO2QubGlua1NlcmllcygpO2ImJmQucmVkcmF3KGMpfSkpO3JldHVybiBlfSxhZGRBeGlzOmZ1bmN0aW9uKGEsYixlLGwpe3ZhciBkPWI/XCJ4QXhpc1wiOlwieUF4aXNcIixwPXRoaXMub3B0aW9ucztcbmE9YyhhLHtpbmRleDp0aGlzW2RdLmxlbmd0aCxpc1g6Yn0pO2I9bmV3IEgodGhpcyxhKTtwW2RdPUYocFtkXXx8e30pO3BbZF0ucHVzaChhKTtyKGUsITApJiZ0aGlzLnJlZHJhdyhsKTtyZXR1cm4gYn0sc2hvd0xvYWRpbmc6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPWIub3B0aW9ucyxlPWIubG9hZGluZ0RpdixkPWMubG9hZGluZyxwPWZ1bmN0aW9uKCl7ZSYmayhlLHtsZWZ0OmIucGxvdExlZnQrXCJweFwiLHRvcDpiLnBsb3RUb3ArXCJweFwiLHdpZHRoOmIucGxvdFdpZHRoK1wicHhcIixoZWlnaHQ6Yi5wbG90SGVpZ2h0K1wicHhcIn0pfTtlfHwoYi5sb2FkaW5nRGl2PWU9dihcImRpdlwiLHtjbGFzc05hbWU6XCJoaWdoY2hhcnRzLWxvYWRpbmcgaGlnaGNoYXJ0cy1sb2FkaW5nLWhpZGRlblwifSxudWxsLGIuY29udGFpbmVyKSxiLmxvYWRpbmdTcGFuPXYoXCJzcGFuXCIse2NsYXNzTmFtZTpcImhpZ2hjaGFydHMtbG9hZGluZy1pbm5lclwifSxudWxsLGUpLEcoYixcInJlZHJhd1wiLHApKTtlLmNsYXNzTmFtZT1cblwiaGlnaGNoYXJ0cy1sb2FkaW5nXCI7Yi5sb2FkaW5nU3Bhbi5pbm5lckhUTUw9YXx8Yy5sYW5nLmxvYWRpbmc7ayhlLHUoZC5zdHlsZSx7ekluZGV4OjEwfSkpO2soYi5sb2FkaW5nU3BhbixkLmxhYmVsU3R5bGUpO2IubG9hZGluZ1Nob3dufHwoayhlLHtvcGFjaXR5OjAsZGlzcGxheTpcIlwifSksRShlLHtvcGFjaXR5OmQuc3R5bGUub3BhY2l0eXx8LjV9LHtkdXJhdGlvbjpkLnNob3dEdXJhdGlvbnx8MH0pKTtiLmxvYWRpbmdTaG93bj0hMDtwKCl9LGhpZGVMb2FkaW5nOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zLGI9dGhpcy5sb2FkaW5nRGl2O2ImJihiLmNsYXNzTmFtZT1cImhpZ2hjaGFydHMtbG9hZGluZyBoaWdoY2hhcnRzLWxvYWRpbmctaGlkZGVuXCIsRShiLHtvcGFjaXR5OjB9LHtkdXJhdGlvbjphLmxvYWRpbmcuaGlkZUR1cmF0aW9ufHwxMDAsY29tcGxldGU6ZnVuY3Rpb24oKXtrKGIse2Rpc3BsYXk6XCJub25lXCJ9KX19KSk7dGhpcy5sb2FkaW5nU2hvd249ITF9LHByb3BzUmVxdWlyZURpcnR5Qm94OlwiYmFja2dyb3VuZENvbG9yIGJvcmRlckNvbG9yIGJvcmRlcldpZHRoIG1hcmdpbiBtYXJnaW5Ub3AgbWFyZ2luUmlnaHQgbWFyZ2luQm90dG9tIG1hcmdpbkxlZnQgc3BhY2luZyBzcGFjaW5nVG9wIHNwYWNpbmdSaWdodCBzcGFjaW5nQm90dG9tIHNwYWNpbmdMZWZ0IGJvcmRlclJhZGl1cyBwbG90QmFja2dyb3VuZENvbG9yIHBsb3RCYWNrZ3JvdW5kSW1hZ2UgcGxvdEJvcmRlckNvbG9yIHBsb3RCb3JkZXJXaWR0aCBwbG90U2hhZG93IHNoYWRvd1wiLnNwbGl0KFwiIFwiKSxcbnByb3BzUmVxdWlyZVVwZGF0ZVNlcmllczpcImNoYXJ0LmludmVydGVkIGNoYXJ0LnBvbGFyIGNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcyBjaGFydC50eXBlIGNvbG9ycyBwbG90T3B0aW9ucyB0b29sdGlwXCIuc3BsaXQoXCIgXCIpLHVwZGF0ZTpmdW5jdGlvbihhLGUsbCl7dmFyIG49dGhpcyxkPXtjcmVkaXRzOlwiYWRkQ3JlZGl0c1wiLHRpdGxlOlwic2V0VGl0bGVcIixzdWJ0aXRsZTpcInNldFN1YnRpdGxlXCJ9LHA9YS5jaGFydCxmLGgseD1bXTtpZihwKXtjKCEwLG4ub3B0aW9ucy5jaGFydCxwKTtcImNsYXNzTmFtZVwiaW4gcCYmbi5zZXRDbGFzc05hbWUocC5jbGFzc05hbWUpO2lmKFwiaW52ZXJ0ZWRcImluIHB8fFwicG9sYXJcImluIHApbi5wcm9wRnJvbVNlcmllcygpLGY9ITA7XCJhbGlnblRpY2tzXCJpbiBwJiYoZj0hMCk7YihwLGZ1bmN0aW9uKGEsZCl7LTEhPT1tKFwiY2hhcnQuXCIrZCxuLnByb3BzUmVxdWlyZVVwZGF0ZVNlcmllcykmJihoPSEwKTstMSE9PW0oZCxuLnByb3BzUmVxdWlyZURpcnR5Qm94KSYmXG4obi5pc0RpcnR5Qm94PSEwKX0pO1wic3R5bGVcImluIHAmJm4ucmVuZGVyZXIuc2V0U3R5bGUocC5zdHlsZSl9YS5jb2xvcnMmJih0aGlzLm9wdGlvbnMuY29sb3JzPWEuY29sb3JzKTthLnBsb3RPcHRpb25zJiZjKCEwLHRoaXMub3B0aW9ucy5wbG90T3B0aW9ucyxhLnBsb3RPcHRpb25zKTtiKGEsZnVuY3Rpb24oYSxiKXtpZihuW2JdJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgbltiXS51cGRhdGUpbltiXS51cGRhdGUoYSwhMSk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgbltkW2JdXSluW2RbYl1dKGEpO1wiY2hhcnRcIiE9PWImJi0xIT09bShiLG4ucHJvcHNSZXF1aXJlVXBkYXRlU2VyaWVzKSYmKGg9ITApfSk7dyhcInhBeGlzIHlBeGlzIHpBeGlzIHNlcmllcyBjb2xvckF4aXMgcGFuZVwiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihkKXthW2RdJiYodyhGKGFbZF0pLGZ1bmN0aW9uKGEsYil7KGI9cShhLmlkKSYmbi5nZXQoYS5pZCl8fG5bZF1bYl0pJiZiLmNvbGw9PT1kJiYoYi51cGRhdGUoYSxcbiExKSxsJiYoYi50b3VjaGVkPSEwKSk7aWYoIWImJmwpaWYoXCJzZXJpZXNcIj09PWQpbi5hZGRTZXJpZXMoYSwhMSkudG91Y2hlZD0hMDtlbHNlIGlmKFwieEF4aXNcIj09PWR8fFwieUF4aXNcIj09PWQpbi5hZGRBeGlzKGEsXCJ4QXhpc1wiPT09ZCwhMSkudG91Y2hlZD0hMH0pLGwmJncobltkXSxmdW5jdGlvbihhKXthLnRvdWNoZWQ/ZGVsZXRlIGEudG91Y2hlZDp4LnB1c2goYSl9KSl9KTt3KHgsZnVuY3Rpb24oYSl7YS5yZW1vdmUoITEpfSk7ZiYmdyhuLmF4ZXMsZnVuY3Rpb24oYSl7YS51cGRhdGUoe30sITEpfSk7aCYmdyhuLnNlcmllcyxmdW5jdGlvbihhKXthLnVwZGF0ZSh7fSwhMSl9KTthLmxvYWRpbmcmJmMoITAsbi5vcHRpb25zLmxvYWRpbmcsYS5sb2FkaW5nKTtmPXAmJnAud2lkdGg7cD1wJiZwLmhlaWdodDtnKGYpJiZmIT09bi5jaGFydFdpZHRofHxnKHApJiZwIT09bi5jaGFydEhlaWdodD9uLnNldFNpemUoZixwKTpyKGUsITApJiZuLnJlZHJhdygpfSxzZXRTdWJ0aXRsZTpmdW5jdGlvbihhKXt0aGlzLnNldFRpdGxlKHZvaWQgMCxcbmEpfX0pO3UobC5wcm90b3R5cGUse3VwZGF0ZTpmdW5jdGlvbihhLGIsYyxlKXtmdW5jdGlvbiBkKCl7cC5hcHBseU9wdGlvbnMoYSk7bnVsbD09PXAueSYmaCYmKHAuZ3JhcGhpYz1oLmRlc3Ryb3koKSk7ZihhLCEwKSYmKGgmJmguZWxlbWVudCYmYSYmYS5tYXJrZXImJnZvaWQgMCE9PWEubWFya2VyLnN5bWJvbCYmKHAuZ3JhcGhpYz1oLmRlc3Ryb3koKSksYSYmYS5kYXRhTGFiZWxzJiZwLmRhdGFMYWJlbCYmKHAuZGF0YUxhYmVsPXAuZGF0YUxhYmVsLmRlc3Ryb3koKSkscC5jb25uZWN0b3ImJihwLmNvbm5lY3Rvcj1wLmNvbm5lY3Rvci5kZXN0cm95KCkpKTtsPXAuaW5kZXg7bi51cGRhdGVQYXJhbGxlbEFycmF5cyhwLGwpO20uZGF0YVtsXT1mKG0uZGF0YVtsXSwhMCl8fGYoYSwhMCk/cC5vcHRpb25zOmE7bi5pc0RpcnR5PW4uaXNEaXJ0eURhdGE9ITA7IW4uZml4ZWRCb3gmJm4uaGFzQ2FydGVzaWFuU2VyaWVzJiYoZy5pc0RpcnR5Qm94PSEwKTtcInBvaW50XCI9PT1tLmxlZ2VuZFR5cGUmJlxuKGcuaXNEaXJ0eUxlZ2VuZD0hMCk7YiYmZy5yZWRyYXcoYyl9dmFyIHA9dGhpcyxuPXAuc2VyaWVzLGg9cC5ncmFwaGljLGwsZz1uLmNoYXJ0LG09bi5vcHRpb25zO2I9cihiLCEwKTshMT09PWU/ZCgpOnAuZmlyZVBvaW50RXZlbnQoXCJ1cGRhdGVcIix7b3B0aW9uczphfSxkKX0scmVtb3ZlOmZ1bmN0aW9uKGEsYil7dGhpcy5zZXJpZXMucmVtb3ZlUG9pbnQobSh0aGlzLHRoaXMuc2VyaWVzLmRhdGEpLGEsYil9fSk7dShDLnByb3RvdHlwZSx7YWRkUG9pbnQ6ZnVuY3Rpb24oYSxiLGMsZSl7dmFyIGQ9dGhpcy5vcHRpb25zLHA9dGhpcy5kYXRhLG49dGhpcy5jaGFydCxoPXRoaXMueEF4aXMsaD1oJiZoLmhhc05hbWVzJiZoLm5hbWVzLGw9ZC5kYXRhLGYsZyxtPXRoaXMueERhdGEseCxrO2I9cihiLCEwKTtmPXtzZXJpZXM6dGhpc307dGhpcy5wb2ludENsYXNzLnByb3RvdHlwZS5hcHBseU9wdGlvbnMuYXBwbHkoZixbYV0pO2s9Zi54O3g9bS5sZW5ndGg7aWYodGhpcy5yZXF1aXJlU29ydGluZyYmXG5rPG1beC0xXSlmb3IoZz0hMDt4JiZtW3gtMV0+azspeC0tO3RoaXMudXBkYXRlUGFyYWxsZWxBcnJheXMoZixcInNwbGljZVwiLHgsMCwwKTt0aGlzLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKGYseCk7aCYmZi5uYW1lJiYoaFtrXT1mLm5hbWUpO2wuc3BsaWNlKHgsMCxhKTtnJiYodGhpcy5kYXRhLnNwbGljZSh4LDAsbnVsbCksdGhpcy5wcm9jZXNzRGF0YSgpKTtcInBvaW50XCI9PT1kLmxlZ2VuZFR5cGUmJnRoaXMuZ2VuZXJhdGVQb2ludHMoKTtjJiYocFswXSYmcFswXS5yZW1vdmU/cFswXS5yZW1vdmUoITEpOihwLnNoaWZ0KCksdGhpcy51cGRhdGVQYXJhbGxlbEFycmF5cyhmLFwic2hpZnRcIiksbC5zaGlmdCgpKSk7dGhpcy5pc0RpcnR5RGF0YT10aGlzLmlzRGlydHk9ITA7YiYmbi5yZWRyYXcoZSl9LHJlbW92ZVBvaW50OmZ1bmN0aW9uKGEsYixjKXt2YXIgZT10aGlzLGQ9ZS5kYXRhLHA9ZFthXSxuPWUucG9pbnRzLGg9ZS5jaGFydCxsPWZ1bmN0aW9uKCl7biYmbi5sZW5ndGg9PT1kLmxlbmd0aCYmXG5uLnNwbGljZShhLDEpO2Quc3BsaWNlKGEsMSk7ZS5vcHRpb25zLmRhdGEuc3BsaWNlKGEsMSk7ZS51cGRhdGVQYXJhbGxlbEFycmF5cyhwfHx7c2VyaWVzOmV9LFwic3BsaWNlXCIsYSwxKTtwJiZwLmRlc3Ryb3koKTtlLmlzRGlydHk9ITA7ZS5pc0RpcnR5RGF0YT0hMDtiJiZoLnJlZHJhdygpfTt4KGMsaCk7Yj1yKGIsITApO3A/cC5maXJlUG9pbnRFdmVudChcInJlbW92ZVwiLG51bGwsbCk6bCgpfSxyZW1vdmU6ZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGUoKXtkLmRlc3Ryb3koKTtwLmlzRGlydHlMZWdlbmQ9cC5pc0RpcnR5Qm94PSEwO3AubGlua1NlcmllcygpO3IoYSwhMCkmJnAucmVkcmF3KGIpfXZhciBkPXRoaXMscD1kLmNoYXJ0OyExIT09Yz96KGQsXCJyZW1vdmVcIixudWxsLGUpOmUoKX0sdXBkYXRlOmZ1bmN0aW9uKGEsYil7dmFyIGU9dGhpcyxuPWUuY2hhcnQsZD1lLnVzZXJPcHRpb25zLHA9ZS5vbGRUeXBlfHxlLnR5cGUsbD1hLnR5cGV8fGQudHlwZXx8bi5vcHRpb25zLmNoYXJ0LnR5cGUsXG5oPUlbcF0ucHJvdG90eXBlLGYsZz1bXCJncm91cFwiLFwibWFya2VyR3JvdXBcIixcImRhdGFMYWJlbHNHcm91cFwiXSxtPVtcIm5hdmlnYXRvclNlcmllc1wiLFwiYmFzZVNlcmllc1wiXSx4PWUuZmluaXNoZWRBbmltYXRpbmcmJnthbmltYXRpb246ITF9O2lmKE9iamVjdC5rZXlzJiZcImRhdGFcIj09PU9iamVjdC5rZXlzKGEpLnRvU3RyaW5nKCkpcmV0dXJuIHRoaXMuc2V0RGF0YShhLmRhdGEsYik7bT1nLmNvbmNhdChtKTt3KG0sZnVuY3Rpb24oYSl7bVthXT1lW2FdO2RlbGV0ZSBlW2FdfSk7YT1jKGQseCx7aW5kZXg6ZS5pbmRleCxwb2ludFN0YXJ0OmUueERhdGFbMF19LHtkYXRhOmUub3B0aW9ucy5kYXRhfSxhKTtlLnJlbW92ZSghMSxudWxsLCExKTtmb3IoZiBpbiBoKWVbZl09dm9pZCAwO3UoZSxJW2x8fHBdLnByb3RvdHlwZSk7dyhtLGZ1bmN0aW9uKGEpe2VbYV09bVthXX0pO2UuaW5pdChuLGEpO2EuekluZGV4IT09ZC56SW5kZXgmJncoZyxmdW5jdGlvbihkKXtlW2RdJiZlW2RdLmF0dHIoe3pJbmRleDphLnpJbmRleH0pfSk7XG5lLm9sZFR5cGU9cDtuLmxpbmtTZXJpZXMoKTtyKGIsITApJiZuLnJlZHJhdyghMSl9fSk7dShILnByb3RvdHlwZSx7dXBkYXRlOmZ1bmN0aW9uKGEsYil7dmFyIGU9dGhpcy5jaGFydDthPWUub3B0aW9uc1t0aGlzLmNvbGxdW3RoaXMub3B0aW9ucy5pbmRleF09Yyh0aGlzLnVzZXJPcHRpb25zLGEpO3RoaXMuZGVzdHJveSghMCk7dGhpcy5pbml0KGUsdShhLHtldmVudHM6dm9pZCAwfSkpO2UuaXNEaXJ0eUJveD0hMDtyKGIsITApJiZlLnJlZHJhdygpfSxyZW1vdmU6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXMuY2hhcnQsYz10aGlzLmNvbGwsbj10aGlzLnNlcmllcyxkPW4ubGVuZ3RoO2QtLTspbltkXSYmbltkXS5yZW1vdmUoITEpO3QoYi5heGVzLHRoaXMpO3QoYltjXSx0aGlzKTtlKGIub3B0aW9uc1tjXSk/Yi5vcHRpb25zW2NdLnNwbGljZSh0aGlzLm9wdGlvbnMuaW5kZXgsMSk6ZGVsZXRlIGIub3B0aW9uc1tjXTt3KGJbY10sZnVuY3Rpb24oYSxkKXthLm9wdGlvbnMuaW5kZXg9XG5kfSk7dGhpcy5kZXN0cm95KCk7Yi5pc0RpcnR5Qm94PSEwO3IoYSwhMCkmJmIucmVkcmF3KCl9LHNldFRpdGxlOmZ1bmN0aW9uKGEsYil7dGhpcy51cGRhdGUoe3RpdGxlOmF9LGIpfSxzZXRDYXRlZ29yaWVzOmZ1bmN0aW9uKGEsYil7dGhpcy51cGRhdGUoe2NhdGVnb3JpZXM6YX0sYil9fSl9KShMKTsoZnVuY3Rpb24oYSl7dmFyIEc9YS5jb2xvcixFPWEuZWFjaCxIPWEubWFwLHY9YS5waWNrLGs9YS5TZXJpZXMscT1hLnNlcmllc1R5cGU7cShcImFyZWFcIixcImxpbmVcIix7c29mdFRocmVzaG9sZDohMSx0aHJlc2hvbGQ6MH0se3NpbmdsZVN0YWNrczohMSxnZXRTdGFja1BvaW50czpmdW5jdGlvbihrKXt2YXIgcT1bXSx1PVtdLHc9dGhpcy54QXhpcyxtPXRoaXMueUF4aXMsZz1tLnN0YWNrc1t0aGlzLnN0YWNrS2V5XSxmPXt9LGU9dGhpcy5pbmRleCxjPW0uc2VyaWVzLGI9Yy5sZW5ndGgscixsPXYobS5vcHRpb25zLnJldmVyc2VkU3RhY2tzLCEwKT8xOi0xLEM7az1rfHx0aGlzLnBvaW50cztcbmlmKHRoaXMub3B0aW9ucy5zdGFja2luZyl7Zm9yKEM9MDtDPGsubGVuZ3RoO0MrKylrW0NdLmxlZnROdWxsPWtbQ10ucmlnaHROdWxsPW51bGwsZltrW0NdLnhdPWtbQ107YS5vYmplY3RFYWNoKGcsZnVuY3Rpb24oYSxiKXtudWxsIT09YS50b3RhbCYmdS5wdXNoKGIpfSk7dS5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEtYn0pO3I9SChjLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlzaWJsZX0pO0UodSxmdW5jdGlvbihhLGMpe3ZhciB4PTAsbixrO2lmKGZbYV0mJiFmW2FdLmlzTnVsbClxLnB1c2goZlthXSksRShbLTEsMV0sZnVuY3Rpb24obSl7dmFyIHg9MT09PW0/XCJyaWdodE51bGxcIjpcImxlZnROdWxsXCIsZD0wLHA9Z1t1W2MrbV1dO2lmKHApZm9yKEM9ZTswPD1DJiZDPGI7KW49cC5wb2ludHNbQ10sbnx8KEM9PT1lP2ZbYV1beF09ITA6cltDXSYmKGs9Z1thXS5wb2ludHNbQ10pJiYoZC09a1sxXS1rWzBdKSksQys9bDtmW2FdWzE9PT1tP1wicmlnaHRDbGlmZlwiOlwibGVmdENsaWZmXCJdPVxuZH0pO2Vsc2V7Zm9yKEM9ZTswPD1DJiZDPGI7KXtpZihuPWdbYV0ucG9pbnRzW0NdKXt4PW5bMV07YnJlYWt9Qys9bH14PW0udHJhbnNsYXRlKHgsMCwxLDAsMSk7cS5wdXNoKHtpc051bGw6ITAscGxvdFg6dy50cmFuc2xhdGUoYSwwLDAsMCwxKSx4OmEscGxvdFk6eCx5Qm90dG9tOnh9KX19KX1yZXR1cm4gcX0sZ2V0R3JhcGhQYXRoOmZ1bmN0aW9uKGEpe3ZhciBxPWsucHJvdG90eXBlLmdldEdyYXBoUGF0aCx1PXRoaXMub3B0aW9ucyx3PXUuc3RhY2tpbmcsbT10aGlzLnlBeGlzLGcsZixlPVtdLGM9W10sYj10aGlzLmluZGV4LHIsbD1tLnN0YWNrc1t0aGlzLnN0YWNrS2V5XSxDPXUudGhyZXNob2xkLEk9bS5nZXRUaHJlc2hvbGQodS50aHJlc2hvbGQpLHgsdT11LmNvbm5lY3ROdWxsc3x8XCJwZXJjZW50XCI9PT13LEY9ZnVuY3Rpb24obixmLGcpe3ZhciB4PWFbbl07bj13JiZsW3gueF0ucG9pbnRzW2JdO3ZhciBkPXhbZytcIk51bGxcIl18fDA7Zz14W2crXCJDbGlmZlwiXXx8MDt2YXIgcCxcbmsseD0hMDtnfHxkPyhwPShkP25bMF06blsxXSkrZyxrPW5bMF0rZyx4PSEhZCk6IXcmJmFbZl0mJmFbZl0uaXNOdWxsJiYocD1rPUMpO3ZvaWQgMCE9PXAmJihjLnB1c2goe3Bsb3RYOnIscGxvdFk6bnVsbD09PXA/STptLmdldFRocmVzaG9sZChwKSxpc051bGw6eCxpc0NsaWZmOiEwfSksZS5wdXNoKHtwbG90WDpyLHBsb3RZOm51bGw9PT1rP0k6bS5nZXRUaHJlc2hvbGQoayksZG9DdXJ2ZTohMX0pKX07YT1hfHx0aGlzLnBvaW50czt3JiYoYT10aGlzLmdldFN0YWNrUG9pbnRzKGEpKTtmb3IoZz0wO2c8YS5sZW5ndGg7ZysrKWlmKGY9YVtnXS5pc051bGwscj12KGFbZ10ucmVjdFBsb3RYLGFbZ10ucGxvdFgpLHg9dihhW2ddLnlCb3R0b20sSSksIWZ8fHUpdXx8RihnLGctMSxcImxlZnRcIiksZiYmIXcmJnV8fChjLnB1c2goYVtnXSksZS5wdXNoKHt4OmcscGxvdFg6cixwbG90WTp4fSkpLHV8fEYoZyxnKzEsXCJyaWdodFwiKTtnPXEuY2FsbCh0aGlzLGMsITAsITApO2UucmV2ZXJzZWQ9XG4hMDtmPXEuY2FsbCh0aGlzLGUsITAsITApO2YubGVuZ3RoJiYoZlswXT1cIkxcIik7Zj1nLmNvbmNhdChmKTtxPXEuY2FsbCh0aGlzLGMsITEsdSk7Zi54TWFwPWcueE1hcDt0aGlzLmFyZWFQYXRoPWY7cmV0dXJuIHF9LGRyYXdHcmFwaDpmdW5jdGlvbigpe3RoaXMuYXJlYVBhdGg9W107ay5wcm90b3R5cGUuZHJhd0dyYXBoLmFwcGx5KHRoaXMpO3ZhciBhPXRoaXMscT10aGlzLmFyZWFQYXRoLHU9dGhpcy5vcHRpb25zLHo9W1tcImFyZWFcIixcImhpZ2hjaGFydHMtYXJlYVwiLHRoaXMuY29sb3IsdS5maWxsQ29sb3JdXTtFKHRoaXMuem9uZXMsZnVuY3Rpb24obSxnKXt6LnB1c2goW1wiem9uZS1hcmVhLVwiK2csXCJoaWdoY2hhcnRzLWFyZWEgaGlnaGNoYXJ0cy16b25lLWFyZWEtXCIrZytcIiBcIittLmNsYXNzTmFtZSxtLmNvbG9yfHxhLmNvbG9yLG0uZmlsbENvbG9yfHx1LmZpbGxDb2xvcl0pfSk7RSh6LGZ1bmN0aW9uKG0pe3ZhciBnPW1bMF0sZj1hW2ddO2Y/KGYuZW5kWD1hLnByZXZlbnRHcmFwaEFuaW1hdGlvbj9cbm51bGw6cS54TWFwLGYuYW5pbWF0ZSh7ZDpxfSkpOihmPWFbZ109YS5jaGFydC5yZW5kZXJlci5wYXRoKHEpLmFkZENsYXNzKG1bMV0pLmF0dHIoe2ZpbGw6dihtWzNdLEcobVsyXSkuc2V0T3BhY2l0eSh2KHUuZmlsbE9wYWNpdHksLjc1KSkuZ2V0KCkpLHpJbmRleDowfSkuYWRkKGEuZ3JvdXApLGYuaXNBcmVhPSEwKTtmLnN0YXJ0WD1xLnhNYXA7Zi5zaGlmdFVuaXQ9dS5zdGVwPzI6MX0pfSxkcmF3TGVnZW5kU3ltYm9sOmEuTGVnZW5kU3ltYm9sTWl4aW4uZHJhd1JlY3RhbmdsZX0pfSkoTCk7KGZ1bmN0aW9uKGEpe3ZhciBHPWEucGljazthPWEuc2VyaWVzVHlwZTthKFwic3BsaW5lXCIsXCJsaW5lXCIse30se2dldFBvaW50U3BsaW5lOmZ1bmN0aW9uKGEsSCx2KXt2YXIgaz1ILnBsb3RYLHE9SC5wbG90WSx3PWFbdi0xXTt2PWFbdisxXTt2YXIgdCx1LHosbTtpZih3JiYhdy5pc051bGwmJiExIT09dy5kb0N1cnZlJiYhSC5pc0NsaWZmJiZ2JiYhdi5pc051bGwmJiExIT09di5kb0N1cnZlJiZcbiFILmlzQ2xpZmYpe2E9dy5wbG90WTt6PXYucGxvdFg7dj12LnBsb3RZO3ZhciBnPTA7dD0oMS41Kmsrdy5wbG90WCkvMi41O3U9KDEuNSpxK2EpLzIuNTt6PSgxLjUqayt6KS8yLjU7bT0oMS41KnErdikvMi41O3ohPT10JiYoZz0obS11KSooei1rKS8oei10KStxLW0pO3UrPWc7bSs9Zzt1PmEmJnU+cT8odT1NYXRoLm1heChhLHEpLG09MipxLXUpOnU8YSYmdTxxJiYodT1NYXRoLm1pbihhLHEpLG09MipxLXUpO20+diYmbT5xPyhtPU1hdGgubWF4KHYscSksdT0yKnEtbSk6bTx2JiZtPHEmJihtPU1hdGgubWluKHYscSksdT0yKnEtbSk7SC5yaWdodENvbnRYPXo7SC5yaWdodENvbnRZPW19SD1bXCJDXCIsRyh3LnJpZ2h0Q29udFgsdy5wbG90WCksRyh3LnJpZ2h0Q29udFksdy5wbG90WSksRyh0LGspLEcodSxxKSxrLHFdO3cucmlnaHRDb250WD13LnJpZ2h0Q29udFk9bnVsbDtyZXR1cm4gSH19KX0pKEwpOyhmdW5jdGlvbihhKXt2YXIgRz1hLnNlcmllc1R5cGVzLmFyZWEucHJvdG90eXBlLFxuRT1hLnNlcmllc1R5cGU7RShcImFyZWFzcGxpbmVcIixcInNwbGluZVwiLGEuZGVmYXVsdFBsb3RPcHRpb25zLmFyZWEse2dldFN0YWNrUG9pbnRzOkcuZ2V0U3RhY2tQb2ludHMsZ2V0R3JhcGhQYXRoOkcuZ2V0R3JhcGhQYXRoLGRyYXdHcmFwaDpHLmRyYXdHcmFwaCxkcmF3TGVnZW5kU3ltYm9sOmEuTGVnZW5kU3ltYm9sTWl4aW4uZHJhd1JlY3RhbmdsZX0pfSkoTCk7KGZ1bmN0aW9uKGEpe3ZhciBHPWEuYW5pbU9iamVjdCxFPWEuY29sb3IsSD1hLmVhY2gsdj1hLmV4dGVuZCxrPWEuaXNOdW1iZXIscT1hLm1lcmdlLHc9YS5waWNrLHQ9YS5TZXJpZXMsdT1hLnNlcmllc1R5cGUsej1hLnN2Zzt1KFwiY29sdW1uXCIsXCJsaW5lXCIse2JvcmRlclJhZGl1czowLGNyaXNwOiEwLGdyb3VwUGFkZGluZzouMixtYXJrZXI6bnVsbCxwb2ludFBhZGRpbmc6LjEsbWluUG9pbnRMZW5ndGg6MCxjcm9wVGhyZXNob2xkOjUwLHBvaW50UmFuZ2U6bnVsbCxzdGF0ZXM6e2hvdmVyOntoYWxvOiExLGJyaWdodG5lc3M6LjF9LFxuc2VsZWN0Ontjb2xvcjpcIiNjY2NjY2NcIixib3JkZXJDb2xvcjpcIiMwMDAwMDBcIn19LGRhdGFMYWJlbHM6e2FsaWduOm51bGwsdmVydGljYWxBbGlnbjpudWxsLHk6bnVsbH0sc29mdFRocmVzaG9sZDohMSxzdGFydEZyb21UaHJlc2hvbGQ6ITAsc3RpY2t5VHJhY2tpbmc6ITEsdG9vbHRpcDp7ZGlzdGFuY2U6Nn0sdGhyZXNob2xkOjAsYm9yZGVyQ29sb3I6XCIjZmZmZmZmXCJ9LHtjcm9wU2hvdWxkZXI6MCxkaXJlY3RUb3VjaDohMCx0cmFja2VyR3JvdXBzOltcImdyb3VwXCIsXCJkYXRhTGFiZWxzR3JvdXBcIl0sbmVnU3RhY2tzOiEwLGluaXQ6ZnVuY3Rpb24oKXt0LnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgYT10aGlzLGc9YS5jaGFydDtnLmhhc1JlbmRlcmVkJiZIKGcuc2VyaWVzLGZ1bmN0aW9uKGYpe2YudHlwZT09PWEudHlwZSYmKGYuaXNEaXJ0eT0hMCl9KX0sZ2V0Q29sdW1uTWV0cmljczpmdW5jdGlvbigpe3ZhciBhPXRoaXMsZz1hLm9wdGlvbnMsZj1hLnhBeGlzLFxuZT1hLnlBeGlzLGM9Zi5yZXZlcnNlZCxiLHI9e30sbD0wOyExPT09Zy5ncm91cGluZz9sPTE6SChhLmNoYXJ0LnNlcmllcyxmdW5jdGlvbihjKXt2YXIgbj1jLm9wdGlvbnMsZj1jLnlBeGlzLGc7Yy50eXBlIT09YS50eXBlfHwhYy52aXNpYmxlJiZhLmNoYXJ0Lm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzfHxlLmxlbiE9PWYubGVufHxlLnBvcyE9PWYucG9zfHwobi5zdGFja2luZz8oYj1jLnN0YWNrS2V5LHZvaWQgMD09PXJbYl0mJihyW2JdPWwrKyksZz1yW2JdKTohMSE9PW4uZ3JvdXBpbmcmJihnPWwrKyksYy5jb2x1bW5JbmRleD1nKX0pO3ZhciBrPU1hdGgubWluKE1hdGguYWJzKGYudHJhbnNBKSooZi5vcmRpbmFsU2xvcGV8fGcucG9pbnRSYW5nZXx8Zi5jbG9zZXN0UG9pbnRSYW5nZXx8Zi50aWNrSW50ZXJ2YWx8fDEpLGYubGVuKSxxPWsqZy5ncm91cFBhZGRpbmcseD0oay0yKnEpLyhsfHwxKSxnPU1hdGgubWluKGcubWF4UG9pbnRXaWR0aHx8Zi5sZW4sdyhnLnBvaW50V2lkdGgsXG54KigxLTIqZy5wb2ludFBhZGRpbmcpKSk7YS5jb2x1bW5NZXRyaWNzPXt3aWR0aDpnLG9mZnNldDooeC1nKS8yKyhxKygoYS5jb2x1bW5JbmRleHx8MCkrKGM/MTowKSkqeC1rLzIpKihjPy0xOjEpfTtyZXR1cm4gYS5jb2x1bW5NZXRyaWNzfSxjcmlzcENvbDpmdW5jdGlvbihhLGcsZixlKXt2YXIgYz10aGlzLmNoYXJ0LGI9dGhpcy5ib3JkZXJXaWR0aCxyPS0oYiUyPy41OjApLGI9YiUyPy41OjE7Yy5pbnZlcnRlZCYmYy5yZW5kZXJlci5pc1ZNTCYmKGIrPTEpO3RoaXMub3B0aW9ucy5jcmlzcCYmKGY9TWF0aC5yb3VuZChhK2YpK3IsYT1NYXRoLnJvdW5kKGEpK3IsZi09YSk7ZT1NYXRoLnJvdW5kKGcrZSkrYjtyPS41Pj1NYXRoLmFicyhnKSYmLjU8ZTtnPU1hdGgucm91bmQoZykrYjtlLT1nO3ImJmUmJigtLWcsZSs9MSk7cmV0dXJue3g6YSx5Omcsd2lkdGg6ZixoZWlnaHQ6ZX19LHRyYW5zbGF0ZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMsZz1hLmNoYXJ0LGY9YS5vcHRpb25zLGU9XG5hLmRlbnNlPTI+YS5jbG9zZXN0UG9pbnRSYW5nZSphLnhBeGlzLnRyYW5zQSxlPWEuYm9yZGVyV2lkdGg9dyhmLmJvcmRlcldpZHRoLGU/MDoxKSxjPWEueUF4aXMsYj1mLnRocmVzaG9sZCxyPWEudHJhbnNsYXRlZFRocmVzaG9sZD1jLmdldFRocmVzaG9sZChiKSxsPXcoZi5taW5Qb2ludExlbmd0aCw1KSxrPWEuZ2V0Q29sdW1uTWV0cmljcygpLHE9ay53aWR0aCx4PWEuYmFyVz1NYXRoLm1heChxLDErMiplKSxGPWEucG9pbnRYT2Zmc2V0PWsub2Zmc2V0O2cuaW52ZXJ0ZWQmJihyLT0uNSk7Zi5wb2ludFBhZGRpbmcmJih4PU1hdGguY2VpbCh4KSk7dC5wcm90b3R5cGUudHJhbnNsYXRlLmFwcGx5KGEpO0goYS5wb2ludHMsZnVuY3Rpb24oZSl7dmFyIG49dyhlLnlCb3R0b20sciksZj05OTkrTWF0aC5hYnMobiksZj1NYXRoLm1pbihNYXRoLm1heCgtZixlLnBsb3RZKSxjLmxlbitmKSxrPWUucGxvdFgrRixkPXgscD1NYXRoLm1pbihmLG4pLG0saD1NYXRoLm1heChmLG4pLXA7bCYmXG5NYXRoLmFicyhoKTxsJiYoaD1sLG09IWMucmV2ZXJzZWQmJiFlLm5lZ2F0aXZlfHxjLnJldmVyc2VkJiZlLm5lZ2F0aXZlLGUueT09PWImJmEuZGF0YU1heDw9YiYmYy5taW48YiYmKG09IW0pLHA9TWF0aC5hYnMocC1yKT5sP24tbDpyLShtP2w6MCkpO2UuYmFyWD1rO2UucG9pbnRXaWR0aD1xO2UudG9vbHRpcFBvcz1nLmludmVydGVkP1tjLmxlbitjLnBvcy1nLnBsb3RMZWZ0LWYsYS54QXhpcy5sZW4tay1kLzIsaF06W2srZC8yLGYrYy5wb3MtZy5wbG90VG9wLGhdO2Uuc2hhcGVUeXBlPVwicmVjdFwiO2Uuc2hhcGVBcmdzPWEuY3Jpc3BDb2wuYXBwbHkoYSxlLmlzTnVsbD9bayxyLGQsMF06W2sscCxkLGhdKX0pfSxnZXRTeW1ib2w6YS5ub29wLGRyYXdMZWdlbmRTeW1ib2w6YS5MZWdlbmRTeW1ib2xNaXhpbi5kcmF3UmVjdGFuZ2xlLGRyYXdHcmFwaDpmdW5jdGlvbigpe3RoaXMuZ3JvdXBbdGhpcy5kZW5zZT9cImFkZENsYXNzXCI6XCJyZW1vdmVDbGFzc1wiXShcImhpZ2hjaGFydHMtZGVuc2UtZGF0YVwiKX0sXG5wb2ludEF0dHJpYnM6ZnVuY3Rpb24oYSxnKXt2YXIgZj10aGlzLm9wdGlvbnMsZSxjPXRoaXMucG9pbnRBdHRyVG9PcHRpb25zfHx7fTtlPWMuc3Ryb2tlfHxcImJvcmRlckNvbG9yXCI7dmFyIGI9Y1tcInN0cm9rZS13aWR0aFwiXXx8XCJib3JkZXJXaWR0aFwiLHI9YSYmYS5jb2xvcnx8dGhpcy5jb2xvcixsPWEmJmFbZV18fGZbZV18fHRoaXMuY29sb3J8fHIsaz1hJiZhW2JdfHxmW2JdfHx0aGlzW2JdfHwwLGM9Zi5kYXNoU3R5bGU7YSYmdGhpcy56b25lcy5sZW5ndGgmJihyPWEuZ2V0Wm9uZSgpLHI9YS5vcHRpb25zLmNvbG9yfHxyJiZyLmNvbG9yfHx0aGlzLmNvbG9yKTtnJiYoYT1xKGYuc3RhdGVzW2ddLGEub3B0aW9ucy5zdGF0ZXMmJmEub3B0aW9ucy5zdGF0ZXNbZ118fHt9KSxnPWEuYnJpZ2h0bmVzcyxyPWEuY29sb3J8fHZvaWQgMCE9PWcmJkUocikuYnJpZ2h0ZW4oYS5icmlnaHRuZXNzKS5nZXQoKXx8cixsPWFbZV18fGwsaz1hW2JdfHxrLGM9YS5kYXNoU3R5bGV8fGMpO2U9e2ZpbGw6cixcbnN0cm9rZTpsLFwic3Ryb2tlLXdpZHRoXCI6a307YyYmKGUuZGFzaHN0eWxlPWMpO3JldHVybiBlfSxkcmF3UG9pbnRzOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxnPXRoaXMuY2hhcnQsZj1hLm9wdGlvbnMsZT1nLnJlbmRlcmVyLGM9Zi5hbmltYXRpb25MaW1pdHx8MjUwLGI7SChhLnBvaW50cyxmdW5jdGlvbihyKXt2YXIgbD1yLmdyYXBoaWM7aWYoayhyLnBsb3RZKSYmbnVsbCE9PXIueSl7Yj1yLnNoYXBlQXJncztpZihsKWxbZy5wb2ludENvdW50PGM/XCJhbmltYXRlXCI6XCJhdHRyXCJdKHEoYikpO2Vsc2Ugci5ncmFwaGljPWw9ZVtyLnNoYXBlVHlwZV0oYikuYWRkKHIuZ3JvdXB8fGEuZ3JvdXApO2YuYm9yZGVyUmFkaXVzJiZsLmF0dHIoe3I6Zi5ib3JkZXJSYWRpdXN9KTtsLmF0dHIoYS5wb2ludEF0dHJpYnMocixyLnNlbGVjdGVkJiZcInNlbGVjdFwiKSkuc2hhZG93KGYuc2hhZG93LG51bGwsZi5zdGFja2luZyYmIWYuYm9yZGVyUmFkaXVzKTtsLmFkZENsYXNzKHIuZ2V0Q2xhc3NOYW1lKCksXG4hMCl9ZWxzZSBsJiYoci5ncmFwaGljPWwuZGVzdHJveSgpKX0pfSxhbmltYXRlOmZ1bmN0aW9uKGEpe3ZhciBnPXRoaXMsZj10aGlzLnlBeGlzLGU9Zy5vcHRpb25zLGM9dGhpcy5jaGFydC5pbnZlcnRlZCxiPXt9LHI9Yz9cInRyYW5zbGF0ZVhcIjpcInRyYW5zbGF0ZVlcIixsO3omJihhPyhiLnNjYWxlWT0uMDAxLGE9TWF0aC5taW4oZi5wb3MrZi5sZW4sTWF0aC5tYXgoZi5wb3MsZi50b1BpeGVscyhlLnRocmVzaG9sZCkpKSxjP2IudHJhbnNsYXRlWD1hLWYubGVuOmIudHJhbnNsYXRlWT1hLGcuZ3JvdXAuYXR0cihiKSk6KGw9Zy5ncm91cC5hdHRyKHIpLGcuZ3JvdXAuYW5pbWF0ZSh7c2NhbGVZOjF9LHYoRyhnLm9wdGlvbnMuYW5pbWF0aW9uKSx7c3RlcDpmdW5jdGlvbihhLGMpe2Jbcl09bCtjLnBvcyooZi5wb3MtbCk7Zy5ncm91cC5hdHRyKGIpfX0pKSxnLmFuaW1hdGU9bnVsbCkpfSxyZW1vdmU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGc9YS5jaGFydDtnLmhhc1JlbmRlcmVkJiZIKGcuc2VyaWVzLFxuZnVuY3Rpb24oZil7Zi50eXBlPT09YS50eXBlJiYoZi5pc0RpcnR5PSEwKX0pO3QucHJvdG90eXBlLnJlbW92ZS5hcHBseShhLGFyZ3VtZW50cyl9fSl9KShMKTsoZnVuY3Rpb24oYSl7YT1hLnNlcmllc1R5cGU7YShcImJhclwiLFwiY29sdW1uXCIsbnVsbCx7aW52ZXJ0ZWQ6ITB9KX0pKEwpOyhmdW5jdGlvbihhKXt2YXIgRz1hLlNlcmllczthPWEuc2VyaWVzVHlwZTthKFwic2NhdHRlclwiLFwibGluZVwiLHtsaW5lV2lkdGg6MCxmaW5kTmVhcmVzdFBvaW50Qnk6XCJ4eVwiLG1hcmtlcjp7ZW5hYmxlZDohMH0sdG9vbHRpcDp7aGVhZGVyRm9ybWF0OidcXHgzY3NwYW4gc3R5bGVcXHgzZFwiY29sb3I6e3BvaW50LmNvbG9yfVwiXFx4M2VcXHUyNWNmXFx4M2Mvc3BhblxceDNlIFxceDNjc3BhbiBzdHlsZVxceDNkXCJmb250LXNpemU6IDAuODVlbVwiXFx4M2Uge3Nlcmllcy5uYW1lfVxceDNjL3NwYW5cXHgzZVxceDNjYnIvXFx4M2UnLHBvaW50Rm9ybWF0OlwieDogXFx4M2NiXFx4M2V7cG9pbnQueH1cXHgzYy9iXFx4M2VcXHgzY2JyL1xceDNleTogXFx4M2NiXFx4M2V7cG9pbnQueX1cXHgzYy9iXFx4M2VcXHgzY2JyL1xceDNlXCJ9fSxcbntzb3J0ZWQ6ITEscmVxdWlyZVNvcnRpbmc6ITEsbm9TaGFyZWRUb29sdGlwOiEwLHRyYWNrZXJHcm91cHM6W1wiZ3JvdXBcIixcIm1hcmtlckdyb3VwXCIsXCJkYXRhTGFiZWxzR3JvdXBcIl0sdGFrZU9yZGluYWxQb3NpdGlvbjohMSxkcmF3R3JhcGg6ZnVuY3Rpb24oKXt0aGlzLm9wdGlvbnMubGluZVdpZHRoJiZHLnByb3RvdHlwZS5kcmF3R3JhcGguY2FsbCh0aGlzKX19KX0pKEwpOyhmdW5jdGlvbihhKXt2YXIgRz1hLmRlZzJyYWQsRT1hLmlzTnVtYmVyLEg9YS5waWNrLHY9YS5yZWxhdGl2ZUxlbmd0aDthLkNlbnRlcmVkU2VyaWVzTWl4aW49e2dldENlbnRlcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucyxxPXRoaXMuY2hhcnQsdz0yKihhLnNsaWNlZE9mZnNldHx8MCksdD1xLnBsb3RXaWR0aC0yKncscT1xLnBsb3RIZWlnaHQtMip3LHU9YS5jZW50ZXIsdT1bSCh1WzBdLFwiNTAlXCIpLEgodVsxXSxcIjUwJVwiKSxhLnNpemV8fFwiMTAwJVwiLGEuaW5uZXJTaXplfHwwXSx6PU1hdGgubWluKHQsXG5xKSxtLGc7Zm9yKG09MDs0Pm07KyttKWc9dVttXSxhPTI+bXx8Mj09PW0mJi8lJC8udGVzdChnKSx1W21dPXYoZyxbdCxxLHosdVsyXV1bbV0pKyhhP3c6MCk7dVszXT51WzJdJiYodVszXT11WzJdKTtyZXR1cm4gdX0sZ2V0U3RhcnRBbmRFbmRSYWRpYW5zOmZ1bmN0aW9uKGEscSl7YT1FKGEpP2E6MDtxPUUocSkmJnE+YSYmMzYwPnEtYT9xOmErMzYwO3JldHVybntzdGFydDpHKihhKy05MCksZW5kOkcqKHErLTkwKX19fX0pKEwpOyhmdW5jdGlvbihhKXt2YXIgRz1hLmFkZEV2ZW50LEU9YS5DZW50ZXJlZFNlcmllc01peGluLEg9YS5kZWZpbmVkLHY9YS5lYWNoLGs9YS5leHRlbmQscT1FLmdldFN0YXJ0QW5kRW5kUmFkaWFucyx3PWEuaW5BcnJheSx0PWEubm9vcCx1PWEucGljayx6PWEuUG9pbnQsbT1hLlNlcmllcyxnPWEuc2VyaWVzVHlwZSxmPWEuc2V0QW5pbWF0aW9uO2coXCJwaWVcIixcImxpbmVcIix7Y2VudGVyOltudWxsLG51bGxdLGNsaXA6ITEsY29sb3JCeVBvaW50OiEwLGRhdGFMYWJlbHM6e2Rpc3RhbmNlOjMwLFxuZW5hYmxlZDohMCxmb3JtYXR0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb2ludC5pc051bGw/dm9pZCAwOnRoaXMucG9pbnQubmFtZX0seDowfSxpZ25vcmVIaWRkZW5Qb2ludDohMCxsZWdlbmRUeXBlOlwicG9pbnRcIixtYXJrZXI6bnVsbCxzaXplOm51bGwsc2hvd0luTGVnZW5kOiExLHNsaWNlZE9mZnNldDoxMCxzdGlja3lUcmFja2luZzohMSx0b29sdGlwOntmb2xsb3dQb2ludGVyOiEwfSxib3JkZXJDb2xvcjpcIiNmZmZmZmZcIixib3JkZXJXaWR0aDoxLHN0YXRlczp7aG92ZXI6e2JyaWdodG5lc3M6LjEsc2hhZG93OiExfX19LHtpc0NhcnRlc2lhbjohMSxyZXF1aXJlU29ydGluZzohMSxkaXJlY3RUb3VjaDohMCxub1NoYXJlZFRvb2x0aXA6ITAsdHJhY2tlckdyb3VwczpbXCJncm91cFwiLFwiZGF0YUxhYmVsc0dyb3VwXCJdLGF4aXNUeXBlczpbXSxwb2ludEF0dHJpYnM6YS5zZXJpZXNUeXBlcy5jb2x1bW4ucHJvdG90eXBlLnBvaW50QXR0cmlicyxhbmltYXRlOmZ1bmN0aW9uKGEpe3ZhciBjPVxudGhpcyxiPWMucG9pbnRzLGU9Yy5zdGFydEFuZ2xlUmFkO2F8fCh2KGIsZnVuY3Rpb24oYSl7dmFyIGI9YS5ncmFwaGljLGw9YS5zaGFwZUFyZ3M7YiYmKGIuYXR0cih7cjphLnN0YXJ0Unx8Yy5jZW50ZXJbM10vMixzdGFydDplLGVuZDplfSksYi5hbmltYXRlKHtyOmwucixzdGFydDpsLnN0YXJ0LGVuZDpsLmVuZH0sYy5vcHRpb25zLmFuaW1hdGlvbikpfSksYy5hbmltYXRlPW51bGwpfSx1cGRhdGVUb3RhbHM6ZnVuY3Rpb24oKXt2YXIgYSxjPTAsYj10aGlzLnBvaW50cyxmPWIubGVuZ3RoLGwsZz10aGlzLm9wdGlvbnMuaWdub3JlSGlkZGVuUG9pbnQ7Zm9yKGE9MDthPGY7YSsrKWw9YlthXSxjKz1nJiYhbC52aXNpYmxlPzA6bC5pc051bGw/MDpsLnk7dGhpcy50b3RhbD1jO2ZvcihhPTA7YTxmO2ErKylsPWJbYV0sbC5wZXJjZW50YWdlPTA8YyYmKGwudmlzaWJsZXx8IWcpP2wueS9jKjEwMDowLGwudG90YWw9Y30sZ2VuZXJhdGVQb2ludHM6ZnVuY3Rpb24oKXttLnByb3RvdHlwZS5nZW5lcmF0ZVBvaW50cy5jYWxsKHRoaXMpO1xudGhpcy51cGRhdGVUb3RhbHMoKX0sdHJhbnNsYXRlOmZ1bmN0aW9uKGEpe3RoaXMuZ2VuZXJhdGVQb2ludHMoKTt2YXIgYz0wLGI9dGhpcy5vcHRpb25zLGU9Yi5zbGljZWRPZmZzZXQsbD1lKyhiLmJvcmRlcldpZHRofHwwKSxmLGcseCxrPXEoYi5zdGFydEFuZ2xlLGIuZW5kQW5nbGUpLG49dGhpcy5zdGFydEFuZ2xlUmFkPWsuc3RhcnQsaz0odGhpcy5lbmRBbmdsZVJhZD1rLmVuZCktbixtPXRoaXMucG9pbnRzLHQsQT1iLmRhdGFMYWJlbHMuZGlzdGFuY2UsYj1iLmlnbm9yZUhpZGRlblBvaW50LGQscD1tLmxlbmd0aCxEO2F8fCh0aGlzLmNlbnRlcj1hPXRoaXMuZ2V0Q2VudGVyKCkpO3RoaXMuZ2V0WD1mdW5jdGlvbihkLGIsYyl7eD1NYXRoLmFzaW4oTWF0aC5taW4oKGQtYVsxXSkvKGFbMl0vMitjLmxhYmVsRGlzdGFuY2UpLDEpKTtyZXR1cm4gYVswXSsoYj8tMToxKSpNYXRoLmNvcyh4KSooYVsyXS8yK2MubGFiZWxEaXN0YW5jZSl9O2ZvcihkPTA7ZDxwO2QrKyl7RD1tW2RdO1xuRC5sYWJlbERpc3RhbmNlPXUoRC5vcHRpb25zLmRhdGFMYWJlbHMmJkQub3B0aW9ucy5kYXRhTGFiZWxzLmRpc3RhbmNlLEEpO3RoaXMubWF4TGFiZWxEaXN0YW5jZT1NYXRoLm1heCh0aGlzLm1heExhYmVsRGlzdGFuY2V8fDAsRC5sYWJlbERpc3RhbmNlKTtmPW4rYyprO2lmKCFifHxELnZpc2libGUpYys9RC5wZXJjZW50YWdlLzEwMDtnPW4rYyprO0Quc2hhcGVUeXBlPVwiYXJjXCI7RC5zaGFwZUFyZ3M9e3g6YVswXSx5OmFbMV0scjphWzJdLzIsaW5uZXJSOmFbM10vMixzdGFydDpNYXRoLnJvdW5kKDFFMypmKS8xRTMsZW5kOk1hdGgucm91bmQoMUUzKmcpLzFFM307eD0oZytmKS8yO3g+MS41Kk1hdGguUEk/eC09MipNYXRoLlBJOng8LU1hdGguUEkvMiYmKHgrPTIqTWF0aC5QSSk7RC5zbGljZWRUcmFuc2xhdGlvbj17dHJhbnNsYXRlWDpNYXRoLnJvdW5kKE1hdGguY29zKHgpKmUpLHRyYW5zbGF0ZVk6TWF0aC5yb3VuZChNYXRoLnNpbih4KSplKX07Zz1NYXRoLmNvcyh4KSphWzJdL1xuMjt0PU1hdGguc2luKHgpKmFbMl0vMjtELnRvb2x0aXBQb3M9W2FbMF0rLjcqZyxhWzFdKy43KnRdO0QuaGFsZj14PC1NYXRoLlBJLzJ8fHg+TWF0aC5QSS8yPzE6MDtELmFuZ2xlPXg7Zj1NYXRoLm1pbihsLEQubGFiZWxEaXN0YW5jZS81KTtELmxhYmVsUG9zPVthWzBdK2crTWF0aC5jb3MoeCkqRC5sYWJlbERpc3RhbmNlLGFbMV0rdCtNYXRoLnNpbih4KSpELmxhYmVsRGlzdGFuY2UsYVswXStnK01hdGguY29zKHgpKmYsYVsxXSt0K01hdGguc2luKHgpKmYsYVswXStnLGFbMV0rdCwwPkQubGFiZWxEaXN0YW5jZT9cImNlbnRlclwiOkQuaGFsZj9cInJpZ2h0XCI6XCJsZWZ0XCIseF19fSxkcmF3R3JhcGg6bnVsbCxkcmF3UG9pbnRzOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxjPWEuY2hhcnQucmVuZGVyZXIsYixmLGwsZyxtPWEub3B0aW9ucy5zaGFkb3c7bSYmIWEuc2hhZG93R3JvdXAmJihhLnNoYWRvd0dyb3VwPWMuZyhcInNoYWRvd1wiKS5hZGQoYS5ncm91cCkpO3YoYS5wb2ludHMsZnVuY3Rpb24oZSl7Zj1cbmUuZ3JhcGhpYztpZihlLmlzTnVsbClmJiYoZS5ncmFwaGljPWYuZGVzdHJveSgpKTtlbHNle2c9ZS5zaGFwZUFyZ3M7Yj1lLmdldFRyYW5zbGF0ZSgpO3ZhciByPWUuc2hhZG93R3JvdXA7bSYmIXImJihyPWUuc2hhZG93R3JvdXA9Yy5nKFwic2hhZG93XCIpLmFkZChhLnNoYWRvd0dyb3VwKSk7ciYmci5hdHRyKGIpO2w9YS5wb2ludEF0dHJpYnMoZSxlLnNlbGVjdGVkJiZcInNlbGVjdFwiKTtmP2Yuc2V0UmFkaWFsUmVmZXJlbmNlKGEuY2VudGVyKS5hdHRyKGwpLmFuaW1hdGUoayhnLGIpKTooZS5ncmFwaGljPWY9Y1tlLnNoYXBlVHlwZV0oZykuc2V0UmFkaWFsUmVmZXJlbmNlKGEuY2VudGVyKS5hdHRyKGIpLmFkZChhLmdyb3VwKSxlLnZpc2libGV8fGYuYXR0cih7dmlzaWJpbGl0eTpcImhpZGRlblwifSksZi5hdHRyKGwpLmF0dHIoe1wic3Ryb2tlLWxpbmVqb2luXCI6XCJyb3VuZFwifSkuc2hhZG93KG0scikpO2YuYWRkQ2xhc3MoZS5nZXRDbGFzc05hbWUoKSl9fSl9LHNlYXJjaFBvaW50OnQsXG5zb3J0QnlBbmdsZTpmdW5jdGlvbihhLGMpe2Euc29ydChmdW5jdGlvbihhLGUpe3JldHVybiB2b2lkIDAhPT1hLmFuZ2xlJiYoZS5hbmdsZS1hLmFuZ2xlKSpjfSl9LGRyYXdMZWdlbmRTeW1ib2w6YS5MZWdlbmRTeW1ib2xNaXhpbi5kcmF3UmVjdGFuZ2xlLGdldENlbnRlcjpFLmdldENlbnRlcixnZXRTeW1ib2w6dH0se2luaXQ6ZnVuY3Rpb24oKXt6LnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgYT10aGlzLGM7YS5uYW1lPXUoYS5uYW1lLFwiU2xpY2VcIik7Yz1mdW5jdGlvbihiKXthLnNsaWNlKFwic2VsZWN0XCI9PT1iLnR5cGUpfTtHKGEsXCJzZWxlY3RcIixjKTtHKGEsXCJ1bnNlbGVjdFwiLGMpO3JldHVybiBhfSxpc1ZhbGlkOmZ1bmN0aW9uKCl7cmV0dXJuIGEuaXNOdW1iZXIodGhpcy55LCEwKSYmMDw9dGhpcy55fSxzZXRWaXNpYmxlOmZ1bmN0aW9uKGEsYyl7dmFyIGI9dGhpcyxlPWIuc2VyaWVzLGw9ZS5jaGFydCxmPWUub3B0aW9ucy5pZ25vcmVIaWRkZW5Qb2ludDtcbmM9dShjLGYpO2EhPT1iLnZpc2libGUmJihiLnZpc2libGU9Yi5vcHRpb25zLnZpc2libGU9YT12b2lkIDA9PT1hPyFiLnZpc2libGU6YSxlLm9wdGlvbnMuZGF0YVt3KGIsZS5kYXRhKV09Yi5vcHRpb25zLHYoW1wiZ3JhcGhpY1wiLFwiZGF0YUxhYmVsXCIsXCJjb25uZWN0b3JcIixcInNoYWRvd0dyb3VwXCJdLGZ1bmN0aW9uKGMpe2lmKGJbY10pYltjXVthP1wic2hvd1wiOlwiaGlkZVwiXSghMCl9KSxiLmxlZ2VuZEl0ZW0mJmwubGVnZW5kLmNvbG9yaXplSXRlbShiLGEpLGF8fFwiaG92ZXJcIiE9PWIuc3RhdGV8fGIuc2V0U3RhdGUoXCJcIiksZiYmKGUuaXNEaXJ0eT0hMCksYyYmbC5yZWRyYXcoKSl9LHNsaWNlOmZ1bmN0aW9uKGEsYyxiKXt2YXIgZT10aGlzLnNlcmllcztmKGIsZS5jaGFydCk7dShjLCEwKTt0aGlzLnNsaWNlZD10aGlzLm9wdGlvbnMuc2xpY2VkPUgoYSk/YTohdGhpcy5zbGljZWQ7ZS5vcHRpb25zLmRhdGFbdyh0aGlzLGUuZGF0YSldPXRoaXMub3B0aW9uczt0aGlzLmdyYXBoaWMuYW5pbWF0ZSh0aGlzLmdldFRyYW5zbGF0ZSgpKTtcbnRoaXMuc2hhZG93R3JvdXAmJnRoaXMuc2hhZG93R3JvdXAuYW5pbWF0ZSh0aGlzLmdldFRyYW5zbGF0ZSgpKX0sZ2V0VHJhbnNsYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2xpY2VkP3RoaXMuc2xpY2VkVHJhbnNsYXRpb246e3RyYW5zbGF0ZVg6MCx0cmFuc2xhdGVZOjB9fSxoYWxvUGF0aDpmdW5jdGlvbihhKXt2YXIgYz10aGlzLnNoYXBlQXJncztyZXR1cm4gdGhpcy5zbGljZWR8fCF0aGlzLnZpc2libGU/W106dGhpcy5zZXJpZXMuY2hhcnQucmVuZGVyZXIuc3ltYm9scy5hcmMoYy54LGMueSxjLnIrYSxjLnIrYSx7aW5uZXJSOnRoaXMuc2hhcGVBcmdzLnItMSxzdGFydDpjLnN0YXJ0LGVuZDpjLmVuZH0pfX0pfSkoTCk7KGZ1bmN0aW9uKGEpe3ZhciBHPWEuYWRkRXZlbnQsRT1hLmFycmF5TWF4LEg9YS5kZWZpbmVkLHY9YS5lYWNoLGs9YS5leHRlbmQscT1hLmZvcm1hdCx3PWEubWFwLHQ9YS5tZXJnZSx1PWEubm9vcCx6PWEucGljayxtPWEucmVsYXRpdmVMZW5ndGgsZz1cbmEuU2VyaWVzLGY9YS5zZXJpZXNUeXBlcyxlPWEuc3RhYmxlU29ydDthLmRpc3RyaWJ1dGU9ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEsYil7cmV0dXJuIGEudGFyZ2V0LWIudGFyZ2V0fXZhciBsLGY9ITAsZz1hLHg9W10saztrPTA7Zm9yKGw9YS5sZW5ndGg7bC0tOylrKz1hW2xdLnNpemU7aWYoaz5iKXtlKGEsZnVuY3Rpb24oYSxiKXtyZXR1cm4oYi5yYW5rfHwwKS0oYS5yYW5rfHwwKX0pO2ZvcihrPWw9MDtrPD1iOylrKz1hW2xdLnNpemUsbCsrO3g9YS5zcGxpY2UobC0xLGEubGVuZ3RoKX1lKGEsYyk7Zm9yKGE9dyhhLGZ1bmN0aW9uKGEpe3JldHVybntzaXplOmEuc2l6ZSx0YXJnZXRzOlthLnRhcmdldF0sYWxpZ246eihhLmFsaWduLC41KX19KTtmOyl7Zm9yKGw9YS5sZW5ndGg7bC0tOylmPWFbbF0saz0oTWF0aC5taW4uYXBwbHkoMCxmLnRhcmdldHMpK01hdGgubWF4LmFwcGx5KDAsZi50YXJnZXRzKSkvMixmLnBvcz1NYXRoLm1pbihNYXRoLm1heCgwLGstZi5zaXplKlxuZi5hbGlnbiksYi1mLnNpemUpO2w9YS5sZW5ndGg7Zm9yKGY9ITE7bC0tOykwPGwmJmFbbC0xXS5wb3MrYVtsLTFdLnNpemU+YVtsXS5wb3MmJihhW2wtMV0uc2l6ZSs9YVtsXS5zaXplLGFbbC0xXS50YXJnZXRzPWFbbC0xXS50YXJnZXRzLmNvbmNhdChhW2xdLnRhcmdldHMpLGFbbC0xXS5hbGlnbj0uNSxhW2wtMV0ucG9zK2FbbC0xXS5zaXplPmImJihhW2wtMV0ucG9zPWItYVtsLTFdLnNpemUpLGEuc3BsaWNlKGwsMSksZj0hMCl9bD0wO3YoYSxmdW5jdGlvbihhKXt2YXIgYj0wO3YoYS50YXJnZXRzLGZ1bmN0aW9uKCl7Z1tsXS5wb3M9YS5wb3MrYjtiKz1nW2xdLnNpemU7bCsrfSl9KTtnLnB1c2guYXBwbHkoZyx4KTtlKGcsYyl9O2cucHJvdG90eXBlLmRyYXdEYXRhTGFiZWxzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYyhhLGIpe3ZhciBkPWIuZmlsdGVyO3JldHVybiBkPyhiPWQub3BlcmF0b3IsYT1hW2QucHJvcGVydHldLGQ9ZC52YWx1ZSxcIlxceDNlXCI9PT1iJiZhPmR8fFwiXFx4M2NcIj09PVxuYiYmYTxkfHxcIlxceDNlXFx4M2RcIj09PWImJmE+PWR8fFwiXFx4M2NcXHgzZFwiPT09YiYmYTw9ZHx8XCJcXHgzZFxceDNkXCI9PT1iJiZhPT1kfHxcIlxceDNkXFx4M2RcXHgzZFwiPT09YiYmYT09PWQ/ITA6ITEpOiEwfXZhciBiPXRoaXMsZT1iLm9wdGlvbnMsZj1lLmRhdGFMYWJlbHMsZz1iLnBvaW50cyxrLHgsbT1iLmhhc1JlbmRlcmVkfHwwLG4sQix1PXooZi5kZWZlciwhIWUuYW5pbWF0aW9uKSxBPWIuY2hhcnQucmVuZGVyZXI7aWYoZi5lbmFibGVkfHxiLl9oYXNQb2ludExhYmVscyliLmRsUHJvY2Vzc09wdGlvbnMmJmIuZGxQcm9jZXNzT3B0aW9ucyhmKSxCPWIucGxvdEdyb3VwKFwiZGF0YUxhYmVsc0dyb3VwXCIsXCJkYXRhLWxhYmVsc1wiLHUmJiFtP1wiaGlkZGVuXCI6XCJ2aXNpYmxlXCIsZi56SW5kZXh8fDYpLHUmJihCLmF0dHIoe29wYWNpdHk6K219KSxtfHxHKGIsXCJhZnRlckFuaW1hdGVcIixmdW5jdGlvbigpe2IudmlzaWJsZSYmQi5zaG93KCEwKTtCW2UuYW5pbWF0aW9uP1wiYW5pbWF0ZVwiOlwiYXR0clwiXSh7b3BhY2l0eToxfSxcbntkdXJhdGlvbjoyMDB9KX0pKSx4PWYsdihnLGZ1bmN0aW9uKGQpe3ZhciBwLGw9ZC5kYXRhTGFiZWwsaCxnLHI9ZC5jb25uZWN0b3IsbT0hbCxGO2s9ZC5kbE9wdGlvbnN8fGQub3B0aW9ucyYmZC5vcHRpb25zLmRhdGFMYWJlbHM7KHA9eihrJiZrLmVuYWJsZWQseC5lbmFibGVkKSYmIWQuaXNOdWxsKSYmKHA9ITA9PT1jKGQsa3x8ZikpO3AmJihmPXQoeCxrKSxoPWQuZ2V0TGFiZWxDb25maWcoKSxGPWZbZC5mb3JtYXRQcmVmaXgrXCJGb3JtYXRcIl18fGYuZm9ybWF0LG49SChGKT9xKEYsaCk6KGZbZC5mb3JtYXRQcmVmaXgrXCJGb3JtYXR0ZXJcIl18fGYuZm9ybWF0dGVyKS5jYWxsKGgsZiksRj1mLnN0eWxlLGg9Zi5yb3RhdGlvbixGLmNvbG9yPXooZi5jb2xvcixGLmNvbG9yLGIuY29sb3IsXCIjMDAwMDAwXCIpLFwiY29udHJhc3RcIj09PUYuY29sb3ImJihkLmNvbnRyYXN0Q29sb3I9QS5nZXRDb250cmFzdChkLmNvbG9yfHxiLmNvbG9yKSxGLmNvbG9yPWYuaW5zaWRlfHwwPnooZC5sYWJlbERpc3RhbmNlLFxuZi5kaXN0YW5jZSl8fGUuc3RhY2tpbmc/ZC5jb250cmFzdENvbG9yOlwiIzAwMDAwMFwiKSxlLmN1cnNvciYmKEYuY3Vyc29yPWUuY3Vyc29yKSxnPXtmaWxsOmYuYmFja2dyb3VuZENvbG9yLHN0cm9rZTpmLmJvcmRlckNvbG9yLFwic3Ryb2tlLXdpZHRoXCI6Zi5ib3JkZXJXaWR0aCxyOmYuYm9yZGVyUmFkaXVzfHwwLHJvdGF0aW9uOmgscGFkZGluZzpmLnBhZGRpbmcsekluZGV4OjF9LGEub2JqZWN0RWFjaChnLGZ1bmN0aW9uKGEsZCl7dm9pZCAwPT09YSYmZGVsZXRlIGdbZF19KSk7IWx8fHAmJkgobik/cCYmSChuKSYmKGw/Zy50ZXh0PW46KGw9ZC5kYXRhTGFiZWw9aD9BLnRleHQobiwwLC05OTk5KS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtZGF0YS1sYWJlbFwiKTpBLmxhYmVsKG4sMCwtOTk5OSxmLnNoYXBlLG51bGwsbnVsbCxmLnVzZUhUTUwsbnVsbCxcImRhdGEtbGFiZWxcIiksbC5hZGRDbGFzcyhcIiBoaWdoY2hhcnRzLWRhdGEtbGFiZWwtY29sb3ItXCIrZC5jb2xvckluZGV4K1wiIFwiKyhmLmNsYXNzTmFtZXx8XG5cIlwiKSsoZi51c2VIVE1MP1wiaGlnaGNoYXJ0cy10cmFja2VyXCI6XCJcIikpKSxsLmF0dHIoZyksbC5jc3MoRikuc2hhZG93KGYuc2hhZG93KSxsLmFkZGVkfHxsLmFkZChCKSxiLmFsaWduRGF0YUxhYmVsKGQsbCxmLG51bGwsbSkpOihkLmRhdGFMYWJlbD1sPWwuZGVzdHJveSgpLHImJihkLmNvbm5lY3Rvcj1yLmRlc3Ryb3koKSkpfSl9O2cucHJvdG90eXBlLmFsaWduRGF0YUxhYmVsPWZ1bmN0aW9uKGEsYixlLGYsZyl7dmFyIGM9dGhpcy5jaGFydCxsPWMuaW52ZXJ0ZWQscj16KGEuZGxCb3gmJmEuZGxCb3guY2VudGVyWCxhLnBsb3RYLC05OTk5KSxuPXooYS5wbG90WSwtOTk5OSksbT1iLmdldEJCb3goKSxxLHQ9ZS5yb3RhdGlvbixkPWUuYWxpZ24scD10aGlzLnZpc2libGUmJihhLnNlcmllcy5mb3JjZURMfHxjLmlzSW5zaWRlUGxvdChyLE1hdGgucm91bmQobiksbCl8fGYmJmMuaXNJbnNpZGVQbG90KHIsbD9mLngrMTpmLnkrZi5oZWlnaHQtMSxsKSksRD1cImp1c3RpZnlcIj09PXooZS5vdmVyZmxvdyxcblwianVzdGlmeVwiKTtpZihwJiYocT1lLnN0eWxlLmZvbnRTaXplLHE9Yy5yZW5kZXJlci5mb250TWV0cmljcyhxLGIpLmIsZj1rKHt4Omw/dGhpcy55QXhpcy5sZW4tbjpyLHk6TWF0aC5yb3VuZChsP3RoaXMueEF4aXMubGVuLXI6biksd2lkdGg6MCxoZWlnaHQ6MH0sZiksayhlLHt3aWR0aDptLndpZHRoLGhlaWdodDptLmhlaWdodH0pLHQ/KEQ9ITEscj1jLnJlbmRlcmVyLnJvdENvcnIocSx0KSxyPXt4OmYueCtlLngrZi53aWR0aC8yK3IueCx5OmYueStlLnkre3RvcDowLG1pZGRsZTouNSxib3R0b206MX1bZS52ZXJ0aWNhbEFsaWduXSpmLmhlaWdodH0sYltnP1wiYXR0clwiOlwiYW5pbWF0ZVwiXShyKS5hdHRyKHthbGlnbjpkfSksbj0odCs3MjApJTM2MCxuPTE4MDxuJiYzNjA+bixcImxlZnRcIj09PWQ/ci55LT1uP20uaGVpZ2h0OjA6XCJjZW50ZXJcIj09PWQ/KHIueC09bS53aWR0aC8yLHIueS09bS5oZWlnaHQvMik6XCJyaWdodFwiPT09ZCYmKHIueC09bS53aWR0aCxyLnktPW4/MDptLmhlaWdodCkpOlxuKGIuYWxpZ24oZSxudWxsLGYpLHI9Yi5hbGlnbkF0dHIpLEQ/YS5pc0xhYmVsSnVzdGlmaWVkPXRoaXMuanVzdGlmeURhdGFMYWJlbChiLGUscixtLGYsZyk6eihlLmNyb3AsITApJiYocD1jLmlzSW5zaWRlUGxvdChyLngsci55KSYmYy5pc0luc2lkZVBsb3Qoci54K20ud2lkdGgsci55K20uaGVpZ2h0KSksZS5zaGFwZSYmIXQpKWJbZz9cImF0dHJcIjpcImFuaW1hdGVcIl0oe2FuY2hvclg6bD9jLnBsb3RXaWR0aC1hLnBsb3RZOmEucGxvdFgsYW5jaG9yWTpsP2MucGxvdEhlaWdodC1hLnBsb3RYOmEucGxvdFl9KTtwfHwoYi5hdHRyKHt5Oi05OTk5fSksYi5wbGFjZWQ9ITEpfTtnLnByb3RvdHlwZS5qdXN0aWZ5RGF0YUxhYmVsPWZ1bmN0aW9uKGEsYixlLGYsZyxrKXt2YXIgYz10aGlzLmNoYXJ0LGw9Yi5hbGlnbixuPWIudmVydGljYWxBbGlnbixyLG0scT1hLmJveD8wOmEucGFkZGluZ3x8MDtyPWUueCtxOzA+ciYmKFwicmlnaHRcIj09PWw/Yi5hbGlnbj1cImxlZnRcIjpiLng9LXIsbT0hMCk7XG5yPWUueCtmLndpZHRoLXE7cj5jLnBsb3RXaWR0aCYmKFwibGVmdFwiPT09bD9iLmFsaWduPVwicmlnaHRcIjpiLng9Yy5wbG90V2lkdGgtcixtPSEwKTtyPWUueStxOzA+ciYmKFwiYm90dG9tXCI9PT1uP2IudmVydGljYWxBbGlnbj1cInRvcFwiOmIueT0tcixtPSEwKTtyPWUueStmLmhlaWdodC1xO3I+Yy5wbG90SGVpZ2h0JiYoXCJ0b3BcIj09PW4/Yi52ZXJ0aWNhbEFsaWduPVwiYm90dG9tXCI6Yi55PWMucGxvdEhlaWdodC1yLG09ITApO20mJihhLnBsYWNlZD0hayxhLmFsaWduKGIsbnVsbCxnKSk7cmV0dXJuIG19O2YucGllJiYoZi5waWUucHJvdG90eXBlLmRyYXdEYXRhTGFiZWxzPWZ1bmN0aW9uKCl7dmFyIGM9dGhpcyxiPWMuZGF0YSxlLGY9Yy5jaGFydCxrPWMub3B0aW9ucy5kYXRhTGFiZWxzLG09eihrLmNvbm5lY3RvclBhZGRpbmcsMTApLHg9eihrLmNvbm5lY3RvcldpZHRoLDEpLHE9Zi5wbG90V2lkdGgsbj1mLnBsb3RIZWlnaHQsdCx1PWMuY2VudGVyLEE9dVsyXS8yLGQ9dVsxXSxwLEQsXG5oLHksdz1bW10sW11dLE0sTyxOLEcsSz1bMCwwLDAsMF07Yy52aXNpYmxlJiYoay5lbmFibGVkfHxjLl9oYXNQb2ludExhYmVscykmJih2KGIsZnVuY3Rpb24oYSl7YS5kYXRhTGFiZWwmJmEudmlzaWJsZSYmYS5kYXRhTGFiZWwuc2hvcnRlbmVkJiYoYS5kYXRhTGFiZWwuYXR0cih7d2lkdGg6XCJhdXRvXCJ9KS5jc3Moe3dpZHRoOlwiYXV0b1wiLHRleHRPdmVyZmxvdzpcImNsaXBcIn0pLGEuZGF0YUxhYmVsLnNob3J0ZW5lZD0hMSl9KSxnLnByb3RvdHlwZS5kcmF3RGF0YUxhYmVscy5hcHBseShjKSx2KGIsZnVuY3Rpb24oYSl7YS5kYXRhTGFiZWwmJmEudmlzaWJsZSYmKHdbYS5oYWxmXS5wdXNoKGEpLGEuZGF0YUxhYmVsLl9wb3M9bnVsbCl9KSx2KHcsZnVuY3Rpb24oYixsKXt2YXIgZyxyLHg9Yi5sZW5ndGgsdD1bXSxCO2lmKHgpZm9yKGMuc29ydEJ5QW5nbGUoYixsLS41KSwwPGMubWF4TGFiZWxEaXN0YW5jZSYmKGc9TWF0aC5tYXgoMCxkLUEtYy5tYXhMYWJlbERpc3RhbmNlKSxyPU1hdGgubWluKGQrXG5BK2MubWF4TGFiZWxEaXN0YW5jZSxmLnBsb3RIZWlnaHQpLHYoYixmdW5jdGlvbihhKXswPGEubGFiZWxEaXN0YW5jZSYmYS5kYXRhTGFiZWwmJihhLnRvcD1NYXRoLm1heCgwLGQtQS1hLmxhYmVsRGlzdGFuY2UpLGEuYm90dG9tPU1hdGgubWluKGQrQSthLmxhYmVsRGlzdGFuY2UsZi5wbG90SGVpZ2h0KSxCPWEuZGF0YUxhYmVsLmdldEJCb3goKS5oZWlnaHR8fDIxLGEucG9zaXRpb25zSW5kZXg9dC5wdXNoKHt0YXJnZXQ6YS5sYWJlbFBvc1sxXS1hLnRvcCtCLzIsc2l6ZTpCLHJhbms6YS55fSktMSl9KSxhLmRpc3RyaWJ1dGUodCxyK0ItZykpLEc9MDtHPHg7RysrKWU9YltHXSxyPWUucG9zaXRpb25zSW5kZXgsaD1lLmxhYmVsUG9zLHA9ZS5kYXRhTGFiZWwsTj0hMT09PWUudmlzaWJsZT9cImhpZGRlblwiOlwiaW5oZXJpdFwiLE89Zz1oWzFdLHQmJkgodFtyXSkmJih2b2lkIDA9PT10W3JdLnBvcz9OPVwiaGlkZGVuXCI6KHk9dFtyXS5zaXplLE89ZS50b3ArdFtyXS5wb3MpKSxkZWxldGUgZS5wb3NpdGlvbkluZGV4LFxuTT1rLmp1c3RpZnk/dVswXSsobD8tMToxKSooQStlLmxhYmVsRGlzdGFuY2UpOmMuZ2V0WChPPGUudG9wKzJ8fE8+ZS5ib3R0b20tMj9nOk8sbCxlKSxwLl9hdHRyPXt2aXNpYmlsaXR5Ok4sYWxpZ246aFs2XX0scC5fcG9zPXt4Ok0ray54Kyh7bGVmdDptLHJpZ2h0Oi1tfVtoWzZdXXx8MCkseTpPK2sueS0xMH0saC54PU0saC55PU8seihrLmNyb3AsITApJiYoRD1wLmdldEJCb3goKS53aWR0aCxnPW51bGwsTS1EPG0/KGc9TWF0aC5yb3VuZChELU0rbSksS1szXT1NYXRoLm1heChnLEtbM10pKTpNK0Q+cS1tJiYoZz1NYXRoLnJvdW5kKE0rRC1xK20pLEtbMV09TWF0aC5tYXgoZyxLWzFdKSksMD5PLXkvMj9LWzBdPU1hdGgubWF4KE1hdGgucm91bmQoLU8reS8yKSxLWzBdKTpPK3kvMj5uJiYoS1syXT1NYXRoLm1heChNYXRoLnJvdW5kKE8reS8yLW4pLEtbMl0pKSxwLnNpZGVPdmVyZmxvdz1nKX0pLDA9PT1FKEspfHx0aGlzLnZlcmlmeURhdGFMYWJlbE92ZXJmbG93KEspKSYmKHRoaXMucGxhY2VEYXRhTGFiZWxzKCksXG54JiZ2KHRoaXMucG9pbnRzLGZ1bmN0aW9uKGEpe3ZhciBkO3Q9YS5jb25uZWN0b3I7aWYoKHA9YS5kYXRhTGFiZWwpJiZwLl9wb3MmJmEudmlzaWJsZSYmMDxhLmxhYmVsRGlzdGFuY2Upe049cC5fYXR0ci52aXNpYmlsaXR5O2lmKGQ9IXQpYS5jb25uZWN0b3I9dD1mLnJlbmRlcmVyLnBhdGgoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtZGF0YS1sYWJlbC1jb25uZWN0b3IgIGhpZ2hjaGFydHMtY29sb3ItXCIrYS5jb2xvckluZGV4KS5hZGQoYy5kYXRhTGFiZWxzR3JvdXApLHQuYXR0cih7XCJzdHJva2Utd2lkdGhcIjp4LHN0cm9rZTprLmNvbm5lY3RvckNvbG9yfHxhLmNvbG9yfHxcIiM2NjY2NjZcIn0pO3RbZD9cImF0dHJcIjpcImFuaW1hdGVcIl0oe2Q6Yy5jb25uZWN0b3JQYXRoKGEubGFiZWxQb3MpfSk7dC5hdHRyKFwidmlzaWJpbGl0eVwiLE4pfWVsc2UgdCYmKGEuY29ubmVjdG9yPXQuZGVzdHJveSgpKX0pKX0sZi5waWUucHJvdG90eXBlLmNvbm5lY3RvclBhdGg9ZnVuY3Rpb24oYSl7dmFyIGI9XG5hLngsYz1hLnk7cmV0dXJuIHoodGhpcy5vcHRpb25zLmRhdGFMYWJlbHMuc29mdENvbm5lY3RvciwhMCk/W1wiTVwiLGIrKFwibGVmdFwiPT09YVs2XT81Oi01KSxjLFwiQ1wiLGIsYywyKmFbMl0tYVs0XSwyKmFbM10tYVs1XSxhWzJdLGFbM10sXCJMXCIsYVs0XSxhWzVdXTpbXCJNXCIsYisoXCJsZWZ0XCI9PT1hWzZdPzU6LTUpLGMsXCJMXCIsYVsyXSxhWzNdLFwiTFwiLGFbNF0sYVs1XV19LGYucGllLnByb3RvdHlwZS5wbGFjZURhdGFMYWJlbHM9ZnVuY3Rpb24oKXt2KHRoaXMucG9pbnRzLGZ1bmN0aW9uKGEpe3ZhciBiPWEuZGF0YUxhYmVsO2ImJmEudmlzaWJsZSYmKChhPWIuX3Bvcyk/KGIuc2lkZU92ZXJmbG93JiYoYi5fYXR0ci53aWR0aD1iLmdldEJCb3goKS53aWR0aC1iLnNpZGVPdmVyZmxvdyxiLmNzcyh7d2lkdGg6Yi5fYXR0ci53aWR0aCtcInB4XCIsdGV4dE92ZXJmbG93OlwiZWxsaXBzaXNcIn0pLGIuc2hvcnRlbmVkPSEwKSxiLmF0dHIoYi5fYXR0ciksYltiLm1vdmVkP1wiYW5pbWF0ZVwiOlwiYXR0clwiXShhKSxcbmIubW92ZWQ9ITApOmImJmIuYXR0cih7eTotOTk5OX0pKX0sdGhpcyl9LGYucGllLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbD11LGYucGllLnByb3RvdHlwZS52ZXJpZnlEYXRhTGFiZWxPdmVyZmxvdz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmNlbnRlcixjPXRoaXMub3B0aW9ucyxlPWMuY2VudGVyLGY9Yy5taW5TaXplfHw4MCxnLGs9bnVsbCE9PWMuc2l6ZTtrfHwobnVsbCE9PWVbMF0/Zz1NYXRoLm1heChiWzJdLU1hdGgubWF4KGFbMV0sYVszXSksZik6KGc9TWF0aC5tYXgoYlsyXS1hWzFdLWFbM10sZiksYlswXSs9KGFbM10tYVsxXSkvMiksbnVsbCE9PWVbMV0/Zz1NYXRoLm1heChNYXRoLm1pbihnLGJbMl0tTWF0aC5tYXgoYVswXSxhWzJdKSksZik6KGc9TWF0aC5tYXgoTWF0aC5taW4oZyxiWzJdLWFbMF0tYVsyXSksZiksYlsxXSs9KGFbMF0tYVsyXSkvMiksZzxiWzJdPyhiWzJdPWcsYlszXT1NYXRoLm1pbihtKGMuaW5uZXJTaXplfHwwLGcpLGcpLHRoaXMudHJhbnNsYXRlKGIpLFxudGhpcy5kcmF3RGF0YUxhYmVscyYmdGhpcy5kcmF3RGF0YUxhYmVscygpKTprPSEwKTtyZXR1cm4ga30pO2YuY29sdW1uJiYoZi5jb2x1bW4ucHJvdG90eXBlLmFsaWduRGF0YUxhYmVsPWZ1bmN0aW9uKGEsYixlLGYsayl7dmFyIGM9dGhpcy5jaGFydC5pbnZlcnRlZCxsPWEuc2VyaWVzLHI9YS5kbEJveHx8YS5zaGFwZUFyZ3Msbj16KGEuYmVsb3csYS5wbG90WT56KHRoaXMudHJhbnNsYXRlZFRocmVzaG9sZCxsLnlBeGlzLmxlbikpLG09eihlLmluc2lkZSwhIXRoaXMub3B0aW9ucy5zdGFja2luZyk7ciYmKGY9dChyKSwwPmYueSYmKGYuaGVpZ2h0Kz1mLnksZi55PTApLHI9Zi55K2YuaGVpZ2h0LWwueUF4aXMubGVuLDA8ciYmKGYuaGVpZ2h0LT1yKSxjJiYoZj17eDpsLnlBeGlzLmxlbi1mLnktZi5oZWlnaHQseTpsLnhBeGlzLmxlbi1mLngtZi53aWR0aCx3aWR0aDpmLmhlaWdodCxoZWlnaHQ6Zi53aWR0aH0pLG18fChjPyhmLngrPW4/MDpmLndpZHRoLGYud2lkdGg9MCk6KGYueSs9XG5uP2YuaGVpZ2h0OjAsZi5oZWlnaHQ9MCkpKTtlLmFsaWduPXooZS5hbGlnbiwhY3x8bT9cImNlbnRlclwiOm4/XCJyaWdodFwiOlwibGVmdFwiKTtlLnZlcnRpY2FsQWxpZ249eihlLnZlcnRpY2FsQWxpZ24sY3x8bT9cIm1pZGRsZVwiOm4/XCJ0b3BcIjpcImJvdHRvbVwiKTtnLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbC5jYWxsKHRoaXMsYSxiLGUsZixrKTthLmlzTGFiZWxKdXN0aWZpZWQmJmEuY29udHJhc3RDb2xvciYmYS5kYXRhTGFiZWwuY3NzKHtjb2xvcjphLmNvbnRyYXN0Q29sb3J9KX0pfSkoTCk7KGZ1bmN0aW9uKGEpe3ZhciBHPWEuQ2hhcnQsRT1hLmVhY2gsSD1hLm9iamVjdEVhY2gsdj1hLnBpY2s7YT1hLmFkZEV2ZW50O2EoRy5wcm90b3R5cGUsXCJyZW5kZXJcIixmdW5jdGlvbigpe3ZhciBhPVtdO0UodGhpcy5sYWJlbENvbGxlY3RvcnN8fFtdLGZ1bmN0aW9uKGspe2E9YS5jb25jYXQoaygpKX0pO0UodGhpcy55QXhpc3x8W10sZnVuY3Rpb24oayl7ay5vcHRpb25zLnN0YWNrTGFiZWxzJiZcbiFrLm9wdGlvbnMuc3RhY2tMYWJlbHMuYWxsb3dPdmVybGFwJiZIKGsuc3RhY2tzLGZ1bmN0aW9uKGspe0goayxmdW5jdGlvbihrKXthLnB1c2goay5sYWJlbCl9KX0pfSk7RSh0aGlzLnNlcmllc3x8W10sZnVuY3Rpb24oayl7dmFyIHE9ay5vcHRpb25zLmRhdGFMYWJlbHMsdD1rLmRhdGFMYWJlbENvbGxlY3Rpb25zfHxbXCJkYXRhTGFiZWxcIl07KHEuZW5hYmxlZHx8ay5faGFzUG9pbnRMYWJlbHMpJiYhcS5hbGxvd092ZXJsYXAmJmsudmlzaWJsZSYmRSh0LGZ1bmN0aW9uKHEpe0Uoay5wb2ludHMsZnVuY3Rpb24oayl7a1txXSYmKGtbcV0ubGFiZWxyYW5rPXYoay5sYWJlbHJhbmssay5zaGFwZUFyZ3MmJmsuc2hhcGVBcmdzLmhlaWdodCksYS5wdXNoKGtbcV0pKX0pfSl9KTt0aGlzLmhpZGVPdmVybGFwcGluZ0xhYmVscyhhKX0pO0cucHJvdG90eXBlLmhpZGVPdmVybGFwcGluZ0xhYmVscz1mdW5jdGlvbihhKXt2YXIgaz1hLmxlbmd0aCx2LHQsdSx6LG0sZyxmLGUsYyxiPWZ1bmN0aW9uKGEsXG5iLGMsZSxmLGcsbixrKXtyZXR1cm4hKGY+YStjfHxmK248YXx8Zz5iK2V8fGcrazxiKX07Zm9yKHQ9MDt0PGs7dCsrKWlmKHY9YVt0XSl2Lm9sZE9wYWNpdHk9di5vcGFjaXR5LHYubmV3T3BhY2l0eT0xLHYud2lkdGh8fCh1PXYuZ2V0QkJveCgpLHYud2lkdGg9dS53aWR0aCx2LmhlaWdodD11LmhlaWdodCk7YS5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuKGIubGFiZWxyYW5rfHwwKS0oYS5sYWJlbHJhbmt8fDApfSk7Zm9yKHQ9MDt0PGs7dCsrKWZvcih1PWFbdF0sdj10KzE7djxrOysrdilpZih6PWFbdl0sdSYmeiYmdSE9PXomJnUucGxhY2VkJiZ6LnBsYWNlZCYmMCE9PXUubmV3T3BhY2l0eSYmMCE9PXoubmV3T3BhY2l0eSYmKG09dS5hbGlnbkF0dHIsZz16LmFsaWduQXR0cixmPXUucGFyZW50R3JvdXAsZT16LnBhcmVudEdyb3VwLGM9MioodS5ib3g/MDp1LnBhZGRpbmd8fDApLG09YihtLngrZi50cmFuc2xhdGVYLG0ueStmLnRyYW5zbGF0ZVksdS53aWR0aC1jLHUuaGVpZ2h0LVxuYyxnLngrZS50cmFuc2xhdGVYLGcueStlLnRyYW5zbGF0ZVksei53aWR0aC1jLHouaGVpZ2h0LWMpKSkodS5sYWJlbHJhbms8ei5sYWJlbHJhbms/dTp6KS5uZXdPcGFjaXR5PTA7RShhLGZ1bmN0aW9uKGEpe3ZhciBiLGM7YSYmKGM9YS5uZXdPcGFjaXR5LGEub2xkT3BhY2l0eSE9PWMmJmEucGxhY2VkJiYoYz9hLnNob3coITApOmI9ZnVuY3Rpb24oKXthLmhpZGUoKX0sYS5hbGlnbkF0dHIub3BhY2l0eT1jLGFbYS5pc09sZD9cImFuaW1hdGVcIjpcImF0dHJcIl0oYS5hbGlnbkF0dHIsbnVsbCxiKSksYS5pc09sZD0hMCl9KX19KShMKTsoZnVuY3Rpb24oYSl7dmFyIEc9YS5hZGRFdmVudCxFPWEuQ2hhcnQsSD1hLmNyZWF0ZUVsZW1lbnQsdj1hLmNzcyxrPWEuZGVmYXVsdE9wdGlvbnMscT1hLmRlZmF1bHRQbG90T3B0aW9ucyx3PWEuZWFjaCx0PWEuZXh0ZW5kLHU9YS5maXJlRXZlbnQsej1hLmhhc1RvdWNoLG09YS5pbkFycmF5LGc9YS5pc09iamVjdCxmPWEuTGVnZW5kLGU9YS5tZXJnZSxcbmM9YS5waWNrLGI9YS5Qb2ludCxyPWEuU2VyaWVzLGw9YS5zZXJpZXNUeXBlcyxDPWEuc3ZnLEk7ST1hLlRyYWNrZXJNaXhpbj17ZHJhd1RyYWNrZXJQb2ludDpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLmNoYXJ0LnBvaW50ZXIsYz1mdW5jdGlvbihhKXt2YXIgYz1iLmdldFBvaW50RnJvbUV2ZW50KGEpO3ZvaWQgMCE9PWMmJihiLmlzRGlyZWN0VG91Y2g9ITAsYy5vbk1vdXNlT3ZlcihhKSl9O3coYS5wb2ludHMsZnVuY3Rpb24oYSl7YS5ncmFwaGljJiYoYS5ncmFwaGljLmVsZW1lbnQucG9pbnQ9YSk7YS5kYXRhTGFiZWwmJihhLmRhdGFMYWJlbC5kaXY/YS5kYXRhTGFiZWwuZGl2LnBvaW50PWE6YS5kYXRhTGFiZWwuZWxlbWVudC5wb2ludD1hKX0pO2EuX2hhc1RyYWNraW5nfHwodyhhLnRyYWNrZXJHcm91cHMsZnVuY3Rpb24oZSl7aWYoYVtlXSl7YVtlXS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtdHJhY2tlclwiKS5vbihcIm1vdXNlb3ZlclwiLGMpLm9uKFwibW91c2VvdXRcIixmdW5jdGlvbihhKXtiLm9uVHJhY2tlck1vdXNlT3V0KGEpfSk7XG5pZih6KWFbZV0ub24oXCJ0b3VjaHN0YXJ0XCIsYyk7YS5vcHRpb25zLmN1cnNvciYmYVtlXS5jc3ModikuY3NzKHtjdXJzb3I6YS5vcHRpb25zLmN1cnNvcn0pfX0pLGEuX2hhc1RyYWNraW5nPSEwKX0sZHJhd1RyYWNrZXJHcmFwaDpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLm9wdGlvbnMsYz1iLnRyYWNrQnlBcmVhLGU9W10uY29uY2F0KGM/YS5hcmVhUGF0aDphLmdyYXBoUGF0aCksZj1lLmxlbmd0aCxnPWEuY2hhcnQsZD1nLnBvaW50ZXIscD1nLnJlbmRlcmVyLGw9Zy5vcHRpb25zLnRvb2x0aXAuc25hcCxoPWEudHJhY2tlcixrLG09ZnVuY3Rpb24oKXtpZihnLmhvdmVyU2VyaWVzIT09YSlhLm9uTW91c2VPdmVyKCl9LHI9XCJyZ2JhKDE5MiwxOTIsMTkyLFwiKyhDPy4wMDAxOi4wMDIpK1wiKVwiO2lmKGYmJiFjKWZvcihrPWYrMTtrLS07KVwiTVwiPT09ZVtrXSYmZS5zcGxpY2UoaysxLDAsZVtrKzFdLWwsZVtrKzJdLFwiTFwiKSwoayYmXCJNXCI9PT1lW2tdfHxrPT09ZikmJmUuc3BsaWNlKGssXG4wLFwiTFwiLGVbay0yXStsLGVbay0xXSk7aD9oLmF0dHIoe2Q6ZX0pOmEuZ3JhcGgmJihhLnRyYWNrZXI9cC5wYXRoKGUpLmF0dHIoe1wic3Ryb2tlLWxpbmVqb2luXCI6XCJyb3VuZFwiLHZpc2liaWxpdHk6YS52aXNpYmxlP1widmlzaWJsZVwiOlwiaGlkZGVuXCIsc3Ryb2tlOnIsZmlsbDpjP3I6XCJub25lXCIsXCJzdHJva2Utd2lkdGhcIjphLmdyYXBoLnN0cm9rZVdpZHRoKCkrKGM/MDoyKmwpLHpJbmRleDoyfSkuYWRkKGEuZ3JvdXApLHcoW2EudHJhY2tlcixhLm1hcmtlckdyb3VwXSxmdW5jdGlvbihhKXthLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy10cmFja2VyXCIpLm9uKFwibW91c2VvdmVyXCIsbSkub24oXCJtb3VzZW91dFwiLGZ1bmN0aW9uKGEpe2Qub25UcmFja2VyTW91c2VPdXQoYSl9KTtiLmN1cnNvciYmYS5jc3Moe2N1cnNvcjpiLmN1cnNvcn0pO2lmKHopYS5vbihcInRvdWNoc3RhcnRcIixtKX0pKX19O2wuY29sdW1uJiYobC5jb2x1bW4ucHJvdG90eXBlLmRyYXdUcmFja2VyPUkuZHJhd1RyYWNrZXJQb2ludCk7XG5sLnBpZSYmKGwucGllLnByb3RvdHlwZS5kcmF3VHJhY2tlcj1JLmRyYXdUcmFja2VyUG9pbnQpO2wuc2NhdHRlciYmKGwuc2NhdHRlci5wcm90b3R5cGUuZHJhd1RyYWNrZXI9SS5kcmF3VHJhY2tlclBvaW50KTt0KGYucHJvdG90eXBlLHtzZXRJdGVtRXZlbnRzOmZ1bmN0aW9uKGEsYyxmKXt2YXIgbj10aGlzLGc9bi5jaGFydC5yZW5kZXJlci5ib3hXcmFwcGVyLGw9XCJoaWdoY2hhcnRzLWxlZ2VuZC1cIisoYSBpbnN0YW5jZW9mIGI/XCJwb2ludFwiOlwic2VyaWVzXCIpK1wiLWFjdGl2ZVwiOyhmP2M6YS5sZWdlbmRHcm91cCkub24oXCJtb3VzZW92ZXJcIixmdW5jdGlvbigpe2Euc2V0U3RhdGUoXCJob3ZlclwiKTtnLmFkZENsYXNzKGwpO2MuY3NzKG4ub3B0aW9ucy5pdGVtSG92ZXJTdHlsZSl9KS5vbihcIm1vdXNlb3V0XCIsZnVuY3Rpb24oKXtjLmNzcyhlKGEudmlzaWJsZT9uLml0ZW1TdHlsZTpuLml0ZW1IaWRkZW5TdHlsZSkpO2cucmVtb3ZlQ2xhc3MobCk7YS5zZXRTdGF0ZSgpfSkub24oXCJjbGlja1wiLFxuZnVuY3Rpb24oZCl7dmFyIGI9ZnVuY3Rpb24oKXthLnNldFZpc2libGUmJmEuc2V0VmlzaWJsZSgpfTtnLnJlbW92ZUNsYXNzKGwpO2Q9e2Jyb3dzZXJFdmVudDpkfTthLmZpcmVQb2ludEV2ZW50P2EuZmlyZVBvaW50RXZlbnQoXCJsZWdlbmRJdGVtQ2xpY2tcIixkLGIpOnUoYSxcImxlZ2VuZEl0ZW1DbGlja1wiLGQsYil9KX0sY3JlYXRlQ2hlY2tib3hGb3JJdGVtOmZ1bmN0aW9uKGEpe2EuY2hlY2tib3g9SChcImlucHV0XCIse3R5cGU6XCJjaGVja2JveFwiLGNoZWNrZWQ6YS5zZWxlY3RlZCxkZWZhdWx0Q2hlY2tlZDphLnNlbGVjdGVkfSx0aGlzLm9wdGlvbnMuaXRlbUNoZWNrYm94U3R5bGUsdGhpcy5jaGFydC5jb250YWluZXIpO0coYS5jaGVja2JveCxcImNsaWNrXCIsZnVuY3Rpb24oYil7dShhLnNlcmllc3x8YSxcImNoZWNrYm94Q2xpY2tcIix7Y2hlY2tlZDpiLnRhcmdldC5jaGVja2VkLGl0ZW06YX0sZnVuY3Rpb24oKXthLnNlbGVjdCgpfSl9KX19KTtrLmxlZ2VuZC5pdGVtU3R5bGUuY3Vyc29yPVxuXCJwb2ludGVyXCI7dChFLnByb3RvdHlwZSx7c2hvd1Jlc2V0Wm9vbTpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1rLmxhbmcsYz1hLm9wdGlvbnMuY2hhcnQucmVzZXRab29tQnV0dG9uLGU9Yy50aGVtZSxmPWUuc3RhdGVzLGc9XCJjaGFydFwiPT09Yy5yZWxhdGl2ZVRvP251bGw6XCJwbG90Qm94XCI7dGhpcy5yZXNldFpvb21CdXR0b249YS5yZW5kZXJlci5idXR0b24oYi5yZXNldFpvb20sbnVsbCxudWxsLGZ1bmN0aW9uKCl7YS56b29tT3V0KCl9LGUsZiYmZi5ob3ZlcikuYXR0cih7YWxpZ246Yy5wb3NpdGlvbi5hbGlnbix0aXRsZTpiLnJlc2V0Wm9vbVRpdGxlfSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXJlc2V0LXpvb21cIikuYWRkKCkuYWxpZ24oYy5wb3NpdGlvbiwhMSxnKX0sem9vbU91dDpmdW5jdGlvbigpe3ZhciBhPXRoaXM7dShhLFwic2VsZWN0aW9uXCIse3Jlc2V0U2VsZWN0aW9uOiEwfSxmdW5jdGlvbigpe2Euem9vbSgpfSl9LHpvb206ZnVuY3Rpb24oYSl7dmFyIGIsZT10aGlzLnBvaW50ZXIsXG5mPSExLGw7IWF8fGEucmVzZXRTZWxlY3Rpb24/KHcodGhpcy5heGVzLGZ1bmN0aW9uKGEpe2I9YS56b29tKCl9KSxlLmluaXRpYXRlZD0hMSk6dyhhLnhBeGlzLmNvbmNhdChhLnlBeGlzKSxmdW5jdGlvbihhKXt2YXIgZD1hLmF4aXM7ZVtkLmlzWEF4aXM/XCJ6b29tWFwiOlwiem9vbVlcIl0mJihiPWQuem9vbShhLm1pbixhLm1heCksZC5kaXNwbGF5QnRuJiYoZj0hMCkpfSk7bD10aGlzLnJlc2V0Wm9vbUJ1dHRvbjtmJiYhbD90aGlzLnNob3dSZXNldFpvb20oKTohZiYmZyhsKSYmKHRoaXMucmVzZXRab29tQnV0dG9uPWwuZGVzdHJveSgpKTtiJiZ0aGlzLnJlZHJhdyhjKHRoaXMub3B0aW9ucy5jaGFydC5hbmltYXRpb24sYSYmYS5hbmltYXRpb24sMTAwPnRoaXMucG9pbnRDb3VudCkpfSxwYW46ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGU9Yy5ob3ZlclBvaW50cyxmO2UmJncoZSxmdW5jdGlvbihhKXthLnNldFN0YXRlKCl9KTt3KFwieHlcIj09PWI/WzEsMF06WzFdLGZ1bmN0aW9uKGIpe2I9XG5jW2I/XCJ4QXhpc1wiOlwieUF4aXNcIl1bMF07dmFyIGQ9Yi5ob3JpeixlPWFbZD9cImNoYXJ0WFwiOlwiY2hhcnRZXCJdLGQ9ZD9cIm1vdXNlRG93blhcIjpcIm1vdXNlRG93bllcIixnPWNbZF0saD0oYi5wb2ludFJhbmdlfHwwKS8yLG49Yi5nZXRFeHRyZW1lcygpLGw9Yi50b1ZhbHVlKGctZSwhMCkraCxrPWIudG9WYWx1ZShnK2IubGVuLWUsITApLWgsbT1rPGwsZz1tP2s6bCxsPW0/bDprLGs9TWF0aC5taW4obi5kYXRhTWluLGg/bi5taW46Yi50b1ZhbHVlKGIudG9QaXhlbHMobi5taW4pLWIubWluUGl4ZWxQYWRkaW5nKSksaD1NYXRoLm1heChuLmRhdGFNYXgsaD9uLm1heDpiLnRvVmFsdWUoYi50b1BpeGVscyhuLm1heCkrYi5taW5QaXhlbFBhZGRpbmcpKSxtPWstZzswPG0mJihsKz1tLGc9ayk7bT1sLWg7MDxtJiYobD1oLGctPW0pO2Iuc2VyaWVzLmxlbmd0aCYmZyE9PW4ubWluJiZsIT09bi5tYXgmJihiLnNldEV4dHJlbWVzKGcsbCwhMSwhMSx7dHJpZ2dlcjpcInBhblwifSksZj0hMCk7Y1tkXT1cbmV9KTtmJiZjLnJlZHJhdyghMSk7dihjLmNvbnRhaW5lcix7Y3Vyc29yOlwibW92ZVwifSl9fSk7dChiLnByb3RvdHlwZSx7c2VsZWN0OmZ1bmN0aW9uKGEsYil7dmFyIGU9dGhpcyxmPWUuc2VyaWVzLGc9Zi5jaGFydDthPWMoYSwhZS5zZWxlY3RlZCk7ZS5maXJlUG9pbnRFdmVudChhP1wic2VsZWN0XCI6XCJ1bnNlbGVjdFwiLHthY2N1bXVsYXRlOmJ9LGZ1bmN0aW9uKCl7ZS5zZWxlY3RlZD1lLm9wdGlvbnMuc2VsZWN0ZWQ9YTtmLm9wdGlvbnMuZGF0YVttKGUsZi5kYXRhKV09ZS5vcHRpb25zO2Uuc2V0U3RhdGUoYSYmXCJzZWxlY3RcIik7Ynx8dyhnLmdldFNlbGVjdGVkUG9pbnRzKCksZnVuY3Rpb24oYSl7YS5zZWxlY3RlZCYmYSE9PWUmJihhLnNlbGVjdGVkPWEub3B0aW9ucy5zZWxlY3RlZD0hMSxmLm9wdGlvbnMuZGF0YVttKGEsZi5kYXRhKV09YS5vcHRpb25zLGEuc2V0U3RhdGUoXCJcIiksYS5maXJlUG9pbnRFdmVudChcInVuc2VsZWN0XCIpKX0pfSl9LG9uTW91c2VPdmVyOmZ1bmN0aW9uKGEpe3ZhciBiPVxudGhpcy5zZXJpZXMuY2hhcnQsYz1iLnBvaW50ZXI7YT1hP2Mubm9ybWFsaXplKGEpOmMuZ2V0Q2hhcnRDb29yZGluYXRlc0Zyb21Qb2ludCh0aGlzLGIuaW52ZXJ0ZWQpO2MucnVuUG9pbnRBY3Rpb25zKGEsdGhpcyl9LG9uTW91c2VPdXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnNlcmllcy5jaGFydDt0aGlzLmZpcmVQb2ludEV2ZW50KFwibW91c2VPdXRcIik7dyhhLmhvdmVyUG9pbnRzfHxbXSxmdW5jdGlvbihhKXthLnNldFN0YXRlKCl9KTthLmhvdmVyUG9pbnRzPWEuaG92ZXJQb2ludD1udWxsfSxpbXBvcnRFdmVudHM6ZnVuY3Rpb24oKXtpZighdGhpcy5oYXNJbXBvcnRlZEV2ZW50cyl7dmFyIGI9dGhpcyxjPWUoYi5zZXJpZXMub3B0aW9ucy5wb2ludCxiLm9wdGlvbnMpLmV2ZW50cztiLmV2ZW50cz1jO2Eub2JqZWN0RWFjaChjLGZ1bmN0aW9uKGEsYyl7RyhiLGMsYSl9KTt0aGlzLmhhc0ltcG9ydGVkRXZlbnRzPSEwfX0sc2V0U3RhdGU6ZnVuY3Rpb24oYSxiKXt2YXIgZT1NYXRoLmZsb29yKHRoaXMucGxvdFgpLFxuZj10aGlzLnBsb3RZLGc9dGhpcy5zZXJpZXMsbD1nLm9wdGlvbnMuc3RhdGVzW2FdfHx7fSxkPXFbZy50eXBlXS5tYXJrZXImJmcub3B0aW9ucy5tYXJrZXIscD1kJiYhMT09PWQuZW5hYmxlZCxrPWQmJmQuc3RhdGVzJiZkLnN0YXRlc1thXXx8e30saD0hMT09PWsuZW5hYmxlZCxtPWcuc3RhdGVNYXJrZXJHcmFwaGljLHI9dGhpcy5tYXJrZXJ8fHt9LHg9Zy5jaGFydCx1PWcuaGFsbyx2LEY9ZCYmZy5tYXJrZXJBdHRyaWJzO2E9YXx8XCJcIjtpZighKGE9PT10aGlzLnN0YXRlJiYhYnx8dGhpcy5zZWxlY3RlZCYmXCJzZWxlY3RcIiE9PWF8fCExPT09bC5lbmFibGVkfHxhJiYoaHx8cCYmITE9PT1rLmVuYWJsZWQpfHxhJiZyLnN0YXRlcyYmci5zdGF0ZXNbYV0mJiExPT09ci5zdGF0ZXNbYV0uZW5hYmxlZCkpe0YmJih2PWcubWFya2VyQXR0cmlicyh0aGlzLGEpKTtpZih0aGlzLmdyYXBoaWMpdGhpcy5zdGF0ZSYmdGhpcy5ncmFwaGljLnJlbW92ZUNsYXNzKFwiaGlnaGNoYXJ0cy1wb2ludC1cIitcbnRoaXMuc3RhdGUpLGEmJnRoaXMuZ3JhcGhpYy5hZGRDbGFzcyhcImhpZ2hjaGFydHMtcG9pbnQtXCIrYSksdGhpcy5ncmFwaGljLmFuaW1hdGUoZy5wb2ludEF0dHJpYnModGhpcyxhKSxjKHgub3B0aW9ucy5jaGFydC5hbmltYXRpb24sbC5hbmltYXRpb24pKSx2JiZ0aGlzLmdyYXBoaWMuYW5pbWF0ZSh2LGMoeC5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbixrLmFuaW1hdGlvbixkLmFuaW1hdGlvbikpLG0mJm0uaGlkZSgpO2Vsc2V7aWYoYSYmayl7ZD1yLnN5bWJvbHx8Zy5zeW1ib2w7bSYmbS5jdXJyZW50U3ltYm9sIT09ZCYmKG09bS5kZXN0cm95KCkpO2lmKG0pbVtiP1wiYW5pbWF0ZVwiOlwiYXR0clwiXSh7eDp2LngseTp2Lnl9KTtlbHNlIGQmJihnLnN0YXRlTWFya2VyR3JhcGhpYz1tPXgucmVuZGVyZXIuc3ltYm9sKGQsdi54LHYueSx2LndpZHRoLHYuaGVpZ2h0KS5hZGQoZy5tYXJrZXJHcm91cCksbS5jdXJyZW50U3ltYm9sPWQpO20mJm0uYXR0cihnLnBvaW50QXR0cmlicyh0aGlzLFxuYSkpfW0mJihtW2EmJnguaXNJbnNpZGVQbG90KGUsZix4LmludmVydGVkKT9cInNob3dcIjpcImhpZGVcIl0oKSxtLmVsZW1lbnQucG9pbnQ9dGhpcyl9KGU9bC5oYWxvKSYmZS5zaXplPyh1fHwoZy5oYWxvPXU9eC5yZW5kZXJlci5wYXRoKCkuYWRkKCh0aGlzLmdyYXBoaWN8fG0pLnBhcmVudEdyb3VwKSksdVtiP1wiYW5pbWF0ZVwiOlwiYXR0clwiXSh7ZDp0aGlzLmhhbG9QYXRoKGUuc2l6ZSl9KSx1LmF0dHIoe1wiY2xhc3NcIjpcImhpZ2hjaGFydHMtaGFsbyBoaWdoY2hhcnRzLWNvbG9yLVwiK2ModGhpcy5jb2xvckluZGV4LGcuY29sb3JJbmRleCl9KSx1LnBvaW50PXRoaXMsdS5hdHRyKHQoe2ZpbGw6dGhpcy5jb2xvcnx8Zy5jb2xvcixcImZpbGwtb3BhY2l0eVwiOmUub3BhY2l0eSx6SW5kZXg6LTF9LGUuYXR0cmlidXRlcykpKTp1JiZ1LnBvaW50JiZ1LnBvaW50LmhhbG9QYXRoJiZ1LmFuaW1hdGUoe2Q6dS5wb2ludC5oYWxvUGF0aCgwKX0pO3RoaXMuc3RhdGU9YX19LGhhbG9QYXRoOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnNlcmllcy5jaGFydC5yZW5kZXJlci5zeW1ib2xzLmNpcmNsZShNYXRoLmZsb29yKHRoaXMucGxvdFgpLVxuYSx0aGlzLnBsb3RZLWEsMiphLDIqYSl9fSk7dChyLnByb3RvdHlwZSx7b25Nb3VzZU92ZXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0LGI9YS5ob3ZlclNlcmllcztpZihiJiZiIT09dGhpcyliLm9uTW91c2VPdXQoKTt0aGlzLm9wdGlvbnMuZXZlbnRzLm1vdXNlT3ZlciYmdSh0aGlzLFwibW91c2VPdmVyXCIpO3RoaXMuc2V0U3RhdGUoXCJob3ZlclwiKTthLmhvdmVyU2VyaWVzPXRoaXN9LG9uTW91c2VPdXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnMsYj10aGlzLmNoYXJ0LGM9Yi50b29sdGlwLGU9Yi5ob3ZlclBvaW50O2IuaG92ZXJTZXJpZXM9bnVsbDtpZihlKWUub25Nb3VzZU91dCgpO3RoaXMmJmEuZXZlbnRzLm1vdXNlT3V0JiZ1KHRoaXMsXCJtb3VzZU91dFwiKTshY3x8dGhpcy5zdGlja3lUcmFja2luZ3x8Yy5zaGFyZWQmJiF0aGlzLm5vU2hhcmVkVG9vbHRpcHx8Yy5oaWRlKCk7dGhpcy5zZXRTdGF0ZSgpfSxzZXRTdGF0ZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLFxuZT1iLm9wdGlvbnMsZj1iLmdyYXBoLGc9ZS5zdGF0ZXMsbD1lLmxpbmVXaWR0aCxlPTA7YT1hfHxcIlwiO2lmKGIuc3RhdGUhPT1hJiYodyhbYi5ncm91cCxiLm1hcmtlckdyb3VwLGIuZGF0YUxhYmVsc0dyb3VwXSxmdW5jdGlvbihkKXtkJiYoYi5zdGF0ZSYmZC5yZW1vdmVDbGFzcyhcImhpZ2hjaGFydHMtc2VyaWVzLVwiK2Iuc3RhdGUpLGEmJmQuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXNlcmllcy1cIithKSl9KSxiLnN0YXRlPWEsIWdbYV18fCExIT09Z1thXS5lbmFibGVkKSYmKGEmJihsPWdbYV0ubGluZVdpZHRofHxsKyhnW2FdLmxpbmVXaWR0aFBsdXN8fDApKSxmJiYhZi5kYXNoc3R5bGUpKWZvcihsPXtcInN0cm9rZS13aWR0aFwiOmx9LGYuYW5pbWF0ZShsLGMoYi5jaGFydC5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbixnW2FdJiZnW2FdLmFuaW1hdGlvbikpO2JbXCJ6b25lLWdyYXBoLVwiK2VdOyliW1wiem9uZS1ncmFwaC1cIitlXS5hdHRyKGwpLGUrPTF9LHNldFZpc2libGU6ZnVuY3Rpb24oYSxcbmIpe3ZhciBjPXRoaXMsZT1jLmNoYXJ0LGY9Yy5sZWdlbmRJdGVtLGcsZD1lLm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzLHA9Yy52aXNpYmxlO2c9KGMudmlzaWJsZT1hPWMub3B0aW9ucy52aXNpYmxlPWMudXNlck9wdGlvbnMudmlzaWJsZT12b2lkIDA9PT1hPyFwOmEpP1wic2hvd1wiOlwiaGlkZVwiO3coW1wiZ3JvdXBcIixcImRhdGFMYWJlbHNHcm91cFwiLFwibWFya2VyR3JvdXBcIixcInRyYWNrZXJcIixcInR0XCJdLGZ1bmN0aW9uKGEpe2lmKGNbYV0pY1thXVtnXSgpfSk7aWYoZS5ob3ZlclNlcmllcz09PWN8fChlLmhvdmVyUG9pbnQmJmUuaG92ZXJQb2ludC5zZXJpZXMpPT09YyljLm9uTW91c2VPdXQoKTtmJiZlLmxlZ2VuZC5jb2xvcml6ZUl0ZW0oYyxhKTtjLmlzRGlydHk9ITA7Yy5vcHRpb25zLnN0YWNraW5nJiZ3KGUuc2VyaWVzLGZ1bmN0aW9uKGEpe2Eub3B0aW9ucy5zdGFja2luZyYmYS52aXNpYmxlJiYoYS5pc0RpcnR5PSEwKX0pO3coYy5saW5rZWRTZXJpZXMsZnVuY3Rpb24oYil7Yi5zZXRWaXNpYmxlKGEsXG4hMSl9KTtkJiYoZS5pc0RpcnR5Qm94PSEwKTshMSE9PWImJmUucmVkcmF3KCk7dShjLGcpfSxzaG93OmZ1bmN0aW9uKCl7dGhpcy5zZXRWaXNpYmxlKCEwKX0saGlkZTpmdW5jdGlvbigpe3RoaXMuc2V0VmlzaWJsZSghMSl9LHNlbGVjdDpmdW5jdGlvbihhKXt0aGlzLnNlbGVjdGVkPWE9dm9pZCAwPT09YT8hdGhpcy5zZWxlY3RlZDphO3RoaXMuY2hlY2tib3gmJih0aGlzLmNoZWNrYm94LmNoZWNrZWQ9YSk7dSh0aGlzLGE/XCJzZWxlY3RcIjpcInVuc2VsZWN0XCIpfSxkcmF3VHJhY2tlcjpJLmRyYXdUcmFja2VyR3JhcGh9KX0pKEwpOyhmdW5jdGlvbihhKXt2YXIgRz1hLkNoYXJ0LEU9YS5lYWNoLEg9YS5pbkFycmF5LHY9YS5pc0FycmF5LGs9YS5pc09iamVjdCxxPWEucGljayx3PWEuc3BsYXQ7Ry5wcm90b3R5cGUuc2V0UmVzcG9uc2l2ZT1mdW5jdGlvbihrKXt2YXIgcT10aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSx0PVtdLG09dGhpcy5jdXJyZW50UmVzcG9uc2l2ZTtxJiZxLnJ1bGVzJiZcbkUocS5ydWxlcyxmdW5jdGlvbihmKXt2b2lkIDA9PT1mLl9pZCYmKGYuX2lkPWEudW5pcXVlS2V5KCkpO3RoaXMubWF0Y2hSZXNwb25zaXZlUnVsZShmLHQsayl9LHRoaXMpO3ZhciBnPWEubWVyZ2UuYXBwbHkoMCxhLm1hcCh0LGZ1bmN0aW9uKGYpe3JldHVybiBhLmZpbmQocS5ydWxlcyxmdW5jdGlvbihhKXtyZXR1cm4gYS5faWQ9PT1mfSkuY2hhcnRPcHRpb25zfSkpLHQ9dC50b1N0cmluZygpfHx2b2lkIDA7dCE9PShtJiZtLnJ1bGVJZHMpJiYobSYmdGhpcy51cGRhdGUobS51bmRvT3B0aW9ucyxrKSx0Pyh0aGlzLmN1cnJlbnRSZXNwb25zaXZlPXtydWxlSWRzOnQsbWVyZ2VkT3B0aW9uczpnLHVuZG9PcHRpb25zOnRoaXMuY3VycmVudE9wdGlvbnMoZyl9LHRoaXMudXBkYXRlKGcsaykpOnRoaXMuY3VycmVudFJlc3BvbnNpdmU9dm9pZCAwKX07Ry5wcm90b3R5cGUubWF0Y2hSZXNwb25zaXZlUnVsZT1mdW5jdGlvbihhLGspe3ZhciB0PWEuY29uZGl0aW9uOyh0LmNhbGxiYWNrfHxcbmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2hhcnRXaWR0aDw9cSh0Lm1heFdpZHRoLE51bWJlci5NQVhfVkFMVUUpJiZ0aGlzLmNoYXJ0SGVpZ2h0PD1xKHQubWF4SGVpZ2h0LE51bWJlci5NQVhfVkFMVUUpJiZ0aGlzLmNoYXJ0V2lkdGg+PXEodC5taW5XaWR0aCwwKSYmdGhpcy5jaGFydEhlaWdodD49cSh0Lm1pbkhlaWdodCwwKX0pLmNhbGwodGhpcykmJmsucHVzaChhLl9pZCl9O0cucHJvdG90eXBlLmN1cnJlbnRPcHRpb25zPWZ1bmN0aW9uKHEpe2Z1bmN0aW9uIHQobSxnLGYsZSl7dmFyIGM7YS5vYmplY3RFYWNoKG0sZnVuY3Rpb24oYSxtKXtpZighZSYmLTE8SChtLFtcInNlcmllc1wiLFwieEF4aXNcIixcInlBeGlzXCJdKSlmb3IoYT13KGEpLGZbbV09W10sYz0wO2M8YS5sZW5ndGg7YysrKWdbbV1bY10mJihmW21dW2NdPXt9LHQoYVtjXSxnW21dW2NdLGZbbV1bY10sZSsxKSk7ZWxzZSBrKGEpPyhmW21dPXYoYSk/W106e30sdChhLGdbbV18fHt9LGZbbV0sZSsxKSk6ZlttXT1nW21dfHxcbm51bGx9KX12YXIgej17fTt0KHEsdGhpcy5vcHRpb25zLHosMCk7cmV0dXJuIHp9fSkoTCk7KGZ1bmN0aW9uKGEpe3ZhciBHPWEuYWRkRXZlbnQsRT1hLkF4aXMsSD1hLkNoYXJ0LHY9YS5jc3Msaz1hLmRhdGVGb3JtYXQscT1hLmRlZmluZWQsdz1hLmVhY2gsdD1hLmV4dGVuZCx1PWEubm9vcCx6PWEucGljayxtPWEudGltZVVuaXRzLGc9YS53cmFwO2coYS5TZXJpZXMucHJvdG90eXBlLFwiaW5pdFwiLGZ1bmN0aW9uKGEpe3ZhciBlO2EuYXBwbHkodGhpcyxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpOyhlPXRoaXMueEF4aXMpJiZlLm9wdGlvbnMub3JkaW5hbCYmRyh0aGlzLFwidXBkYXRlZERhdGFcIixmdW5jdGlvbigpe2RlbGV0ZSBlLm9yZGluYWxJbmRleH0pfSk7ZyhFLnByb3RvdHlwZSxcImdldFRpbWVUaWNrc1wiLGZ1bmN0aW9uKGEsZSxjLGIsZyxsLHQsdSl7dmFyIGY9MCxyLG4sdj17fSxDLEEsZCxwPVtdLEQ9LU51bWJlci5NQVhfVkFMVUUsaD10aGlzLm9wdGlvbnMudGlja1BpeGVsSW50ZXJ2YWw7XG5pZighdGhpcy5vcHRpb25zLm9yZGluYWwmJiF0aGlzLm9wdGlvbnMuYnJlYWtzfHwhbHx8Mz5sLmxlbmd0aHx8dm9pZCAwPT09YylyZXR1cm4gYS5jYWxsKHRoaXMsZSxjLGIsZyk7QT1sLmxlbmd0aDtmb3Iocj0wO3I8QTtyKyspe2Q9ciYmbFtyLTFdPmI7bFtyXTxjJiYoZj1yKTtpZihyPT09QS0xfHxsW3IrMV0tbFtyXT41KnR8fGQpe2lmKGxbcl0+RCl7Zm9yKG49YS5jYWxsKHRoaXMsZSxsW2ZdLGxbcl0sZyk7bi5sZW5ndGgmJm5bMF08PUQ7KW4uc2hpZnQoKTtuLmxlbmd0aCYmKEQ9bltuLmxlbmd0aC0xXSk7cD1wLmNvbmNhdChuKX1mPXIrMX1pZihkKWJyZWFrfWE9bi5pbmZvO2lmKHUmJmEudW5pdFJhbmdlPD1tLmhvdXIpe3I9cC5sZW5ndGgtMTtmb3IoZj0xO2Y8cjtmKyspayhcIiVkXCIscFtmXSkhPT1rKFwiJWRcIixwW2YtMV0pJiYodltwW2ZdXT1cImRheVwiLEM9ITApO0MmJih2W3BbMF1dPVwiZGF5XCIpO2EuaGlnaGVyUmFua3M9dn1wLmluZm89YTtpZih1JiZxKGgpKXt1PWE9cC5sZW5ndGg7XG5yPVtdO3ZhciB5O2ZvcihDPVtdO3UtLTspZj10aGlzLnRyYW5zbGF0ZShwW3VdKSx5JiYoQ1t1XT15LWYpLHJbdV09eT1mO0Muc29ydCgpO0M9Q1tNYXRoLmZsb29yKEMubGVuZ3RoLzIpXTtDPC42KmgmJihDPW51bGwpO3U9cFthLTFdPmI/YS0xOmE7Zm9yKHk9dm9pZCAwO3UtLTspZj1yW3VdLGI9TWF0aC5hYnMoeS1mKSx5JiZiPC44KmgmJihudWxsPT09Q3x8YjwuOCpDKT8odltwW3VdXSYmIXZbcFt1KzFdXT8oYj11KzEseT1mKTpiPXUscC5zcGxpY2UoYiwxKSk6eT1mfXJldHVybiBwfSk7dChFLnByb3RvdHlwZSx7YmVmb3JlU2V0VGlja1Bvc2l0aW9uczpmdW5jdGlvbigpe3ZhciBhLGU9W10sYz0hMSxiLGc9dGhpcy5nZXRFeHRyZW1lcygpLGw9Zy5taW4saz1nLm1heCxtLHQ9dGhpcy5pc1hBeGlzJiYhIXRoaXMub3B0aW9ucy5icmVha3MsZz10aGlzLm9wdGlvbnMub3JkaW5hbCx1PU51bWJlci5NQVhfVkFMVUUsbj10aGlzLmNoYXJ0Lm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzO1xuYj1cImhpZ2hjaGFydHMtbmF2aWdhdG9yLXhheGlzXCI9PT10aGlzLm9wdGlvbnMuY2xhc3NOYW1lOyF0aGlzLm9wdGlvbnMub3ZlcnNjcm9sbHx8dGhpcy5tYXghPT10aGlzLmRhdGFNYXh8fHRoaXMuY2hhcnQubW91c2VJc0Rvd24mJiFifHx0aGlzLmV2ZW50QXJncyYmKCF0aGlzLmV2ZW50QXJnc3x8XCJuYXZpZ2F0b3JcIj09PXRoaXMuZXZlbnRBcmdzLnRyaWdnZXIpfHwodGhpcy5tYXgrPXRoaXMub3B0aW9ucy5vdmVyc2Nyb2xsLCFiJiZxKHRoaXMudXNlck1pbikmJih0aGlzLm1pbis9dGhpcy5vcHRpb25zLm92ZXJzY3JvbGwpKTtpZihnfHx0KXt3KHRoaXMuc2VyaWVzLGZ1bmN0aW9uKGIsYyl7aWYoIShuJiYhMT09PWIudmlzaWJsZXx8ITE9PT1iLnRha2VPcmRpbmFsUG9zaXRpb24mJiF0KSYmKGU9ZS5jb25jYXQoYi5wcm9jZXNzZWRYRGF0YSksYT1lLmxlbmd0aCxlLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS1ifSksdT1NYXRoLm1pbih1LHooYi5jbG9zZXN0UG9pbnRSYW5nZSxcbnUpKSxhKSlmb3IoYz1hLTE7Yy0tOyllW2NdPT09ZVtjKzFdJiZlLnNwbGljZShjLDEpfSk7YT1lLmxlbmd0aDtpZigyPGEpe2I9ZVsxXS1lWzBdO2ZvcihtPWEtMTttLS0mJiFjOyllW20rMV0tZVttXSE9PWImJihjPSEwKTshdGhpcy5vcHRpb25zLmtlZXBPcmRpbmFsUGFkZGluZyYmKGVbMF0tbD5ifHxrLWVbZS5sZW5ndGgtMV0+YikmJihjPSEwKX1lbHNlIHRoaXMub3B0aW9ucy5vdmVyc2Nyb2xsJiYoMj09PWE/dT1lWzFdLWVbMF06MT09PWE/KHU9dGhpcy5vcHRpb25zLm92ZXJzY3JvbGwsZT1bZVswXSxlWzBdK3VdKTp1PXRoaXMub3ZlcnNjcm9sbFBvaW50c1JhbmdlKTtjPyh0aGlzLm9wdGlvbnMub3ZlcnNjcm9sbCYmKHRoaXMub3ZlcnNjcm9sbFBvaW50c1JhbmdlPXUsZT1lLmNvbmNhdCh0aGlzLmdldE92ZXJzY3JvbGxQb3NpdGlvbnMoKSkpLHRoaXMub3JkaW5hbFBvc2l0aW9ucz1lLGI9dGhpcy5vcmRpbmFsMmxpbihNYXRoLm1heChsLGVbMF0pLCEwKSxtPU1hdGgubWF4KHRoaXMub3JkaW5hbDJsaW4oTWF0aC5taW4oayxcbmVbZS5sZW5ndGgtMV0pLCEwKSwxKSx0aGlzLm9yZGluYWxTbG9wZT1rPShrLWwpLyhtLWIpLHRoaXMub3JkaW5hbE9mZnNldD1sLWIqayk6KHRoaXMub3ZlcnNjcm9sbFBvaW50c1JhbmdlPXoodGhpcy5jbG9zZXN0UG9pbnRSYW5nZSx0aGlzLm92ZXJzY3JvbGxQb2ludHNSYW5nZSksdGhpcy5vcmRpbmFsUG9zaXRpb25zPXRoaXMub3JkaW5hbFNsb3BlPXRoaXMub3JkaW5hbE9mZnNldD12b2lkIDApfXRoaXMuaXNPcmRpbmFsPWcmJmM7dGhpcy5ncm91cEludGVydmFsRmFjdG9yPW51bGx9LHZhbDJsaW46ZnVuY3Rpb24oYSxlKXt2YXIgYz10aGlzLm9yZGluYWxQb3NpdGlvbnM7aWYoYyl7dmFyIGI9Yy5sZW5ndGgsZixnO2ZvcihmPWI7Zi0tOylpZihjW2ZdPT09YSl7Zz1mO2JyZWFrfWZvcihmPWItMTtmLS07KWlmKGE+Y1tmXXx8MD09PWYpe2E9KGEtY1tmXSkvKGNbZisxXS1jW2ZdKTtnPWYrYTticmVha31lPWU/Zzp0aGlzLm9yZGluYWxTbG9wZSooZ3x8MCkrdGhpcy5vcmRpbmFsT2Zmc2V0fWVsc2UgZT1cbmE7cmV0dXJuIGV9LGxpbjJ2YWw6ZnVuY3Rpb24oYSxlKXt2YXIgYz10aGlzLm9yZGluYWxQb3NpdGlvbnM7aWYoYyl7dmFyIGI9dGhpcy5vcmRpbmFsU2xvcGUsZj10aGlzLm9yZGluYWxPZmZzZXQsZz1jLmxlbmd0aC0xLGs7aWYoZSkwPmE/YT1jWzBdOmE+Zz9hPWNbZ106KGc9TWF0aC5mbG9vcihhKSxrPWEtZyk7ZWxzZSBmb3IoO2ctLTspaWYoZT1iKmcrZixhPj1lKXtiPWIqKGcrMSkrZjtrPShhLWUpLyhiLWUpO2JyZWFrfXJldHVybiB2b2lkIDAhPT1rJiZ2b2lkIDAhPT1jW2ddP2NbZ10rKGs/ayooY1tnKzFdLWNbZ10pOjApOmF9cmV0dXJuIGF9LGdldEV4dGVuZGVkUG9zaXRpb25zOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxlPWEuY2hhcnQsYz1hLnNlcmllc1swXS5jdXJyZW50RGF0YUdyb3VwaW5nLGI9YS5vcmRpbmFsSW5kZXgsZz1jP2MuY291bnQrYy51bml0TmFtZTpcInJhd1wiLGw9YS5vcHRpb25zLm92ZXJzY3JvbGwsaz1hLmdldEV4dHJlbWVzKCksbSxxO2J8fChiPWEub3JkaW5hbEluZGV4PVxue30pO2JbZ118fChtPXtzZXJpZXM6W10sY2hhcnQ6ZSxnZXRFeHRyZW1lczpmdW5jdGlvbigpe3JldHVybnttaW46ay5kYXRhTWluLG1heDprLmRhdGFNYXgrbH19LG9wdGlvbnM6e29yZGluYWw6ITB9LHZhbDJsaW46RS5wcm90b3R5cGUudmFsMmxpbixvcmRpbmFsMmxpbjpFLnByb3RvdHlwZS5vcmRpbmFsMmxpbn0sdyhhLnNlcmllcyxmdW5jdGlvbihiKXtxPXt4QXhpczptLHhEYXRhOmIueERhdGEuc2xpY2UoKSxjaGFydDplLGRlc3Ryb3lHcm91cGVkRGF0YTp1fTtxLnhEYXRhPXEueERhdGEuY29uY2F0KGEuZ2V0T3ZlcnNjcm9sbFBvc2l0aW9ucygpKTtxLm9wdGlvbnM9e2RhdGFHcm91cGluZzpjP3tlbmFibGVkOiEwLGZvcmNlZDohMCxhcHByb3hpbWF0aW9uOlwib3BlblwiLHVuaXRzOltbYy51bml0TmFtZSxbYy5jb3VudF1dXX06e2VuYWJsZWQ6ITF9fTtiLnByb2Nlc3NEYXRhLmFwcGx5KHEpO20uc2VyaWVzLnB1c2gocSl9KSxhLmJlZm9yZVNldFRpY2tQb3NpdGlvbnMuYXBwbHkobSksXG5iW2ddPW0ub3JkaW5hbFBvc2l0aW9ucyk7cmV0dXJuIGJbZ119LGdldE92ZXJzY3JvbGxQb3NpdGlvbnM6ZnVuY3Rpb24oKXt2YXIgZj10aGlzLm9wdGlvbnMub3ZlcnNjcm9sbCxlPXRoaXMub3ZlcnNjcm9sbFBvaW50c1JhbmdlLGM9W10sYj10aGlzLmRhdGFNYXg7aWYoYS5kZWZpbmVkKGUpKWZvcihjLnB1c2goYik7Yjw9dGhpcy5kYXRhTWF4K2Y7KWIrPWUsYy5wdXNoKGIpO3JldHVybiBjfSxnZXRHcm91cEludGVydmFsRmFjdG9yOmZ1bmN0aW9uKGEsZSxjKXt2YXIgYjtjPWMucHJvY2Vzc2VkWERhdGE7dmFyIGY9Yy5sZW5ndGgsZz1bXTtiPXRoaXMuZ3JvdXBJbnRlcnZhbEZhY3RvcjtpZighYil7Zm9yKGI9MDtiPGYtMTtiKyspZ1tiXT1jW2IrMV0tY1tiXTtnLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS1ifSk7Zz1nW01hdGguZmxvb3IoZi8yKV07YT1NYXRoLm1heChhLGNbMF0pO2U9TWF0aC5taW4oZSxjW2YtMV0pO3RoaXMuZ3JvdXBJbnRlcnZhbEZhY3Rvcj1iPWYqXG5nLyhlLWEpfXJldHVybiBifSxwb3N0UHJvY2Vzc1RpY2tJbnRlcnZhbDpmdW5jdGlvbihhKXt2YXIgZT10aGlzLm9yZGluYWxTbG9wZTtyZXR1cm4gZT90aGlzLm9wdGlvbnMuYnJlYWtzP3RoaXMuY2xvc2VzdFBvaW50UmFuZ2V8fGE6YS8oZS90aGlzLmNsb3Nlc3RQb2ludFJhbmdlKTphfX0pO0UucHJvdG90eXBlLm9yZGluYWwybGluPUUucHJvdG90eXBlLnZhbDJsaW47ZyhILnByb3RvdHlwZSxcInBhblwiLGZ1bmN0aW9uKGEsZSl7dmFyIGM9dGhpcy54QXhpc1swXSxiPWMub3B0aW9ucy5vdmVyc2Nyb2xsLGY9ZS5jaGFydFgsZz0hMTtpZihjLm9wdGlvbnMub3JkaW5hbCYmYy5zZXJpZXMubGVuZ3RoKXt2YXIgaz10aGlzLm1vdXNlRG93blgsbT1jLmdldEV4dHJlbWVzKCkscT1tLmRhdGFNYXgsdD1tLm1pbixuPW0ubWF4LHU9dGhpcy5ob3ZlclBvaW50cyx6PWMuY2xvc2VzdFBvaW50UmFuZ2V8fGMub3ZlcnNjcm9sbFBvaW50c1JhbmdlLGs9KGstZikvKGMudHJhbnNsYXRpb25TbG9wZSpcbihjLm9yZGluYWxTbG9wZXx8eikpLEE9e29yZGluYWxQb3NpdGlvbnM6Yy5nZXRFeHRlbmRlZFBvc2l0aW9ucygpfSx6PWMubGluMnZhbCxkPWMudmFsMmxpbixwO0Eub3JkaW5hbFBvc2l0aW9ucz8xPE1hdGguYWJzKGspJiYodSYmdyh1LGZ1bmN0aW9uKGEpe2Euc2V0U3RhdGUoKX0pLDA+az8odT1BLHA9Yy5vcmRpbmFsUG9zaXRpb25zP2M6QSk6KHU9Yy5vcmRpbmFsUG9zaXRpb25zP2M6QSxwPUEpLEE9cC5vcmRpbmFsUG9zaXRpb25zLHE+QVtBLmxlbmd0aC0xXSYmQS5wdXNoKHEpLHRoaXMuZml4ZWRSYW5nZT1uLXQsaz1jLnRvRml4ZWRSYW5nZShudWxsLG51bGwsei5hcHBseSh1LFtkLmFwcGx5KHUsW3QsITBdKStrLCEwXSksei5hcHBseShwLFtkLmFwcGx5KHAsW24sITBdKStrLCEwXSkpLGsubWluPj1NYXRoLm1pbihtLmRhdGFNaW4sdCkmJmsubWF4PD1NYXRoLm1heChxLG4pK2ImJmMuc2V0RXh0cmVtZXMoay5taW4say5tYXgsITAsITEse3RyaWdnZXI6XCJwYW5cIn0pLHRoaXMubW91c2VEb3duWD1cbmYsdih0aGlzLmNvbnRhaW5lcix7Y3Vyc29yOlwibW92ZVwifSkpOmc9ITB9ZWxzZSBnPSEwO2cmJihiJiYoYy5tYXg9Yy5kYXRhTWF4K2IpLGEuYXBwbHkodGhpcyxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpKX0pfSkoTCk7KGZ1bmN0aW9uKGEpe2Z1bmN0aW9uIEcoKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpfWZ1bmN0aW9uIEUoYSl7YS5hcHBseSh0aGlzKTt0aGlzLmRyYXdCcmVha3ModGhpcy54QXhpcyxbXCJ4XCJdKTt0aGlzLmRyYXdCcmVha3ModGhpcy55QXhpcyxIKHRoaXMucG9pbnRBcnJheU1hcCxbXCJ5XCJdKSl9dmFyIEg9YS5waWNrLHY9YS53cmFwLGs9YS5lYWNoLHE9YS5leHRlbmQsdz1hLmlzQXJyYXksdD1hLmZpcmVFdmVudCx1PWEuQXhpcyx6PWEuU2VyaWVzO3EodS5wcm90b3R5cGUse2lzSW5CcmVhazpmdW5jdGlvbihhLGcpe3ZhciBmPWEucmVwZWF0fHxJbmZpbml0eSxlPWEuZnJvbSxjPWEudG8tYS5mcm9tO1xuZz1nPj1lPyhnLWUpJWY6Zi0oZS1nKSVmO3JldHVybiBhLmluY2x1c2l2ZT9nPD1jOmc8YyYmMCE9PWd9LGlzSW5BbnlCcmVhazpmdW5jdGlvbihhLGcpe3ZhciBmPXRoaXMub3B0aW9ucy5icmVha3MsZT1mJiZmLmxlbmd0aCxjLGIsaztpZihlKXtmb3IoO2UtLTspdGhpcy5pc0luQnJlYWsoZltlXSxhKSYmKGM9ITAsYnx8KGI9SChmW2VdLnNob3dQb2ludHMsdGhpcy5pc1hBeGlzPyExOiEwKSkpO2s9YyYmZz9jJiYhYjpjfXJldHVybiBrfX0pO3YodS5wcm90b3R5cGUsXCJzZXRUaWNrUG9zaXRpb25zXCIsZnVuY3Rpb24oYSl7YS5hcHBseSh0aGlzLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSk7aWYodGhpcy5vcHRpb25zLmJyZWFrcyl7dmFyIGc9dGhpcy50aWNrUG9zaXRpb25zLGY9dGhpcy50aWNrUG9zaXRpb25zLmluZm8sZT1bXSxjO2ZvcihjPTA7YzxnLmxlbmd0aDtjKyspdGhpcy5pc0luQW55QnJlYWsoZ1tjXSl8fGUucHVzaChnW2NdKTt0aGlzLnRpY2tQb3NpdGlvbnM9XG5lO3RoaXMudGlja1Bvc2l0aW9ucy5pbmZvPWZ9fSk7dih1LnByb3RvdHlwZSxcImluaXRcIixmdW5jdGlvbihhLGcsZil7dmFyIGU9dGhpcztmLmJyZWFrcyYmZi5icmVha3MubGVuZ3RoJiYoZi5vcmRpbmFsPSExKTthLmNhbGwodGhpcyxnLGYpO2E9dGhpcy5vcHRpb25zLmJyZWFrcztlLmlzQnJva2VuPXcoYSkmJiEhYS5sZW5ndGg7ZS5pc0Jyb2tlbiYmKGUudmFsMmxpbj1mdW5jdGlvbihhKXt2YXIgYj1hLGMsZjtmb3IoZj0wO2Y8ZS5icmVha0FycmF5Lmxlbmd0aDtmKyspaWYoYz1lLmJyZWFrQXJyYXlbZl0sYy50bzw9YSliLT1jLmxlbjtlbHNlIGlmKGMuZnJvbT49YSlicmVhaztlbHNlIGlmKGUuaXNJbkJyZWFrKGMsYSkpe2ItPWEtYy5mcm9tO2JyZWFrfXJldHVybiBifSxlLmxpbjJ2YWw9ZnVuY3Rpb24oYSl7dmFyIGIsYztmb3IoYz0wO2M8ZS5icmVha0FycmF5Lmxlbmd0aCYmIShiPWUuYnJlYWtBcnJheVtjXSxiLmZyb20+PWEpO2MrKyliLnRvPGE/YSs9Yi5sZW46ZS5pc0luQnJlYWsoYixcbmEpJiYoYSs9Yi5sZW4pO3JldHVybiBhfSxlLnNldEV4dHJlbWVzPWZ1bmN0aW9uKGEsYixlLGYsZyl7Zm9yKDt0aGlzLmlzSW5BbnlCcmVhayhhKTspYS09dGhpcy5jbG9zZXN0UG9pbnRSYW5nZTtmb3IoO3RoaXMuaXNJbkFueUJyZWFrKGIpOyliLT10aGlzLmNsb3Nlc3RQb2ludFJhbmdlO3UucHJvdG90eXBlLnNldEV4dHJlbWVzLmNhbGwodGhpcyxhLGIsZSxmLGcpfSxlLnNldEF4aXNUcmFuc2xhdGlvbj1mdW5jdGlvbihhKXt1LnByb3RvdHlwZS5zZXRBeGlzVHJhbnNsYXRpb24uY2FsbCh0aGlzLGEpO2E9ZS5vcHRpb25zLmJyZWFrczt2YXIgYj1bXSxjPVtdLGY9MCxnLG0scT1lLnVzZXJNaW58fGUubWluLHY9ZS51c2VyTWF4fHxlLm1heCxuPUgoZS5wb2ludFJhbmdlUGFkZGluZywwKSxCLHc7ayhhLGZ1bmN0aW9uKGEpe209YS5yZXBlYXR8fEluZmluaXR5O2UuaXNJbkJyZWFrKGEscSkmJihxKz1hLnRvJW0tcSVtKTtlLmlzSW5CcmVhayhhLHYpJiYodi09diVtLWEuZnJvbSVcbm0pfSk7ayhhLGZ1bmN0aW9uKGEpe0I9YS5mcm9tO2ZvcihtPWEucmVwZWF0fHxJbmZpbml0eTtCLW0+cTspQi09bTtmb3IoO0I8cTspQis9bTtmb3Iodz1CO3c8djt3Kz1tKWIucHVzaCh7dmFsdWU6dyxtb3ZlOlwiaW5cIn0pLGIucHVzaCh7dmFsdWU6dysoYS50by1hLmZyb20pLG1vdmU6XCJvdXRcIixzaXplOmEuYnJlYWtTaXplfSl9KTtiLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS52YWx1ZT09PWIudmFsdWU/KFwiaW5cIj09PWEubW92ZT8wOjEpLShcImluXCI9PT1iLm1vdmU/MDoxKTphLnZhbHVlLWIudmFsdWV9KTtnPTA7Qj1xO2soYixmdW5jdGlvbihhKXtnKz1cImluXCI9PT1hLm1vdmU/MTotMTsxPT09ZyYmXCJpblwiPT09YS5tb3ZlJiYoQj1hLnZhbHVlKTswPT09ZyYmKGMucHVzaCh7ZnJvbTpCLHRvOmEudmFsdWUsbGVuOmEudmFsdWUtQi0oYS5zaXplfHwwKX0pLGYrPWEudmFsdWUtQi0oYS5zaXplfHwwKSl9KTtlLmJyZWFrQXJyYXk9YztlLnVuaXRMZW5ndGg9di1xLWYrbjt0KGUsXG5cImFmdGVyQnJlYWtzXCIpO2Uub3B0aW9ucy5zdGF0aWNTY2FsZT9lLnRyYW5zQT1lLm9wdGlvbnMuc3RhdGljU2NhbGU6ZS51bml0TGVuZ3RoJiYoZS50cmFuc0EqPSh2LWUubWluK24pL2UudW5pdExlbmd0aCk7biYmKGUubWluUGl4ZWxQYWRkaW5nPWUudHJhbnNBKmUubWluUG9pbnRPZmZzZXQpO2UubWluPXE7ZS5tYXg9dn0pfSk7dih6LnByb3RvdHlwZSxcImdlbmVyYXRlUG9pbnRzXCIsZnVuY3Rpb24oYSl7YS5hcHBseSh0aGlzLEcoYXJndW1lbnRzKSk7dmFyIGc9dGhpcy54QXhpcyxmPXRoaXMueUF4aXMsZT10aGlzLnBvaW50cyxjLGI9ZS5sZW5ndGgsaz10aGlzLm9wdGlvbnMuY29ubmVjdE51bGxzLGw7aWYoZyYmZiYmKGcub3B0aW9ucy5icmVha3N8fGYub3B0aW9ucy5icmVha3MpKWZvcig7Yi0tOyljPWVbYl0sbD1udWxsPT09Yy55JiYhMT09PWssbHx8IWcuaXNJbkFueUJyZWFrKGMueCwhMCkmJiFmLmlzSW5BbnlCcmVhayhjLnksITApfHwoZS5zcGxpY2UoYiwxKSx0aGlzLmRhdGFbYl0mJlxudGhpcy5kYXRhW2JdLmRlc3Ryb3lFbGVtZW50cygpKX0pO2EuU2VyaWVzLnByb3RvdHlwZS5kcmF3QnJlYWtzPWZ1bmN0aW9uKGEsZyl7dmFyIGY9dGhpcyxlPWYucG9pbnRzLGMsYixtLGw7YSYmayhnLGZ1bmN0aW9uKGcpe2M9YS5icmVha0FycmF5fHxbXTtiPWEuaXNYQXhpcz9hLm1pbjpIKGYub3B0aW9ucy50aHJlc2hvbGQsYS5taW4pO2soZSxmdW5jdGlvbihlKXtsPUgoZVtcInN0YWNrXCIrZy50b1VwcGVyQ2FzZSgpXSxlW2ddKTtrKGMsZnVuY3Rpb24oYyl7bT0hMTtpZihiPGMuZnJvbSYmbD5jLnRvfHxiPmMuZnJvbSYmbDxjLmZyb20pbT1cInBvaW50QnJlYWtcIjtlbHNlIGlmKGI8Yy5mcm9tJiZsPmMuZnJvbSYmbDxjLnRvfHxiPmMuZnJvbSYmbD5jLnRvJiZsPGMuZnJvbSltPVwicG9pbnRJbkJyZWFrXCI7bSYmdChhLG0se3BvaW50OmUsYnJrOmN9KX0pfSl9KX07YS5TZXJpZXMucHJvdG90eXBlLmdhcHBlZFBhdGg9ZnVuY3Rpb24oKXt2YXIgaz10aGlzLm9wdGlvbnMuZ2FwU2l6ZSxcbmc9dGhpcy5wb2ludHMuc2xpY2UoKSxmPWcubGVuZ3RoLTEsZT10aGlzLnlBeGlzLGM7aWYoayYmMDxmKWZvcihcInZhbHVlXCIhPT10aGlzLm9wdGlvbnMuZ2FwVW5pdCYmKGsqPXRoaXMuY2xvc2VzdFBvaW50UmFuZ2UpO2YtLTspZ1tmKzFdLngtZ1tmXS54PmsmJihjPShnW2ZdLngrZ1tmKzFdLngpLzIsZy5zcGxpY2UoZisxLDAse2lzTnVsbDohMCx4OmN9KSx0aGlzLm9wdGlvbnMuc3RhY2tpbmcmJihjPWUuc3RhY2tzW3RoaXMuc3RhY2tLZXldW2NdPW5ldyBhLlN0YWNrSXRlbShlLGUub3B0aW9ucy5zdGFja0xhYmVscywhMSxjLHRoaXMuc3RhY2spLGMudG90YWw9MCkpO3JldHVybiB0aGlzLmdldEdyYXBoUGF0aChnKX07dihhLnNlcmllc1R5cGVzLmNvbHVtbi5wcm90b3R5cGUsXCJkcmF3UG9pbnRzXCIsRSk7dihhLlNlcmllcy5wcm90b3R5cGUsXCJkcmF3UG9pbnRzXCIsRSl9KShMKTsoZnVuY3Rpb24oYSl7dmFyIEc9YS5hcnJheU1heCxFPWEuYXJyYXlNaW4sSD1hLkF4aXMsdj1hLmRlZmF1bHRQbG90T3B0aW9ucyxcbms9YS5kZWZpbmVkLHE9YS5lYWNoLHc9YS5leHRlbmQsdD1hLmZvcm1hdCx1PWEuaXNOdW1iZXIsej1hLm1lcmdlLG09YS5waWNrLGc9YS5Qb2ludCxmPWEuVG9vbHRpcCxlPWEud3JhcCxjPWEuU2VyaWVzLnByb3RvdHlwZSxiPWMucHJvY2Vzc0RhdGEscj1jLmdlbmVyYXRlUG9pbnRzLGw9e2FwcHJveGltYXRpb246XCJhdmVyYWdlXCIsZ3JvdXBQaXhlbFdpZHRoOjIsZGF0ZVRpbWVMYWJlbEZvcm1hdHM6e21pbGxpc2Vjb25kOltcIiVBLCAlYiAlZSwgJUg6JU06JVMuJUxcIixcIiVBLCAlYiAlZSwgJUg6JU06JVMuJUxcIixcIi0lSDolTTolUy4lTFwiXSxzZWNvbmQ6W1wiJUEsICViICVlLCAlSDolTTolU1wiLFwiJUEsICViICVlLCAlSDolTTolU1wiLFwiLSVIOiVNOiVTXCJdLG1pbnV0ZTpbXCIlQSwgJWIgJWUsICVIOiVNXCIsXCIlQSwgJWIgJWUsICVIOiVNXCIsXCItJUg6JU1cIl0saG91cjpbXCIlQSwgJWIgJWUsICVIOiVNXCIsXCIlQSwgJWIgJWUsICVIOiVNXCIsXCItJUg6JU1cIl0sZGF5OltcIiVBLCAlYiAlZSwgJVlcIixcblwiJUEsICViICVlXCIsXCItJUEsICViICVlLCAlWVwiXSx3ZWVrOltcIldlZWsgZnJvbSAlQSwgJWIgJWUsICVZXCIsXCIlQSwgJWIgJWVcIixcIi0lQSwgJWIgJWUsICVZXCJdLG1vbnRoOltcIiVCICVZXCIsXCIlQlwiLFwiLSVCICVZXCJdLHllYXI6W1wiJVlcIixcIiVZXCIsXCItJVlcIl19fSxDPXtsaW5lOnt9LHNwbGluZTp7fSxhcmVhOnt9LGFyZWFzcGxpbmU6e30sY29sdW1uOnthcHByb3hpbWF0aW9uOlwic3VtXCIsZ3JvdXBQaXhlbFdpZHRoOjEwfSxhcmVhcmFuZ2U6e2FwcHJveGltYXRpb246XCJyYW5nZVwifSxhcmVhc3BsaW5lcmFuZ2U6e2FwcHJveGltYXRpb246XCJyYW5nZVwifSxjb2x1bW5yYW5nZTp7YXBwcm94aW1hdGlvbjpcInJhbmdlXCIsZ3JvdXBQaXhlbFdpZHRoOjEwfSxjYW5kbGVzdGljazp7YXBwcm94aW1hdGlvbjpcIm9obGNcIixncm91cFBpeGVsV2lkdGg6MTB9LG9obGM6e2FwcHJveGltYXRpb246XCJvaGxjXCIsZ3JvdXBQaXhlbFdpZHRoOjV9fSxJPWEuZGVmYXVsdERhdGFHcm91cGluZ1VuaXRzPVtbXCJtaWxsaXNlY29uZFwiLFxuWzEsMiw1LDEwLDIwLDI1LDUwLDEwMCwyMDAsNTAwXV0sW1wic2Vjb25kXCIsWzEsMiw1LDEwLDE1LDMwXV0sW1wibWludXRlXCIsWzEsMiw1LDEwLDE1LDMwXV0sW1wiaG91clwiLFsxLDIsMyw0LDYsOCwxMl1dLFtcImRheVwiLFsxXV0sW1wid2Vla1wiLFsxXV0sW1wibW9udGhcIixbMSwzLDZdXSxbXCJ5ZWFyXCIsbnVsbF1dLHg9YS5hcHByb3hpbWF0aW9ucz17c3VtOmZ1bmN0aW9uKGEpe3ZhciBiPWEubGVuZ3RoLGM7aWYoIWImJmEuaGFzTnVsbHMpYz1udWxsO2Vsc2UgaWYoYilmb3IoYz0wO2ItLTspYys9YVtiXTtyZXR1cm4gY30sYXZlcmFnZTpmdW5jdGlvbihhKXt2YXIgYj1hLmxlbmd0aDthPXguc3VtKGEpO3UoYSkmJmImJihhLz1iKTtyZXR1cm4gYX0sYXZlcmFnZXM6ZnVuY3Rpb24oKXt2YXIgYT1bXTtxKGFyZ3VtZW50cyxmdW5jdGlvbihiKXthLnB1c2goeC5hdmVyYWdlKGIpKX0pO3JldHVybiB2b2lkIDA9PT1hWzBdP3ZvaWQgMDphfSxvcGVuOmZ1bmN0aW9uKGEpe3JldHVybiBhLmxlbmd0aD9cbmFbMF06YS5oYXNOdWxscz9udWxsOnZvaWQgMH0saGlnaDpmdW5jdGlvbihhKXtyZXR1cm4gYS5sZW5ndGg/RyhhKTphLmhhc051bGxzP251bGw6dm9pZCAwfSxsb3c6ZnVuY3Rpb24oYSl7cmV0dXJuIGEubGVuZ3RoP0UoYSk6YS5oYXNOdWxscz9udWxsOnZvaWQgMH0sY2xvc2U6ZnVuY3Rpb24oYSl7cmV0dXJuIGEubGVuZ3RoP2FbYS5sZW5ndGgtMV06YS5oYXNOdWxscz9udWxsOnZvaWQgMH0sb2hsYzpmdW5jdGlvbihhLGIsYyxlKXthPXgub3BlbihhKTtiPXguaGlnaChiKTtjPXgubG93KGMpO2U9eC5jbG9zZShlKTtpZih1KGEpfHx1KGIpfHx1KGMpfHx1KGUpKXJldHVyblthLGIsYyxlXX0scmFuZ2U6ZnVuY3Rpb24oYSxiKXthPXgubG93KGEpO2I9eC5oaWdoKGIpO2lmKHUoYSl8fHUoYikpcmV0dXJuW2EsYl07aWYobnVsbD09PWEmJm51bGw9PT1iKXJldHVybiBudWxsfX07Yy5ncm91cERhdGE9ZnVuY3Rpb24oYSxiLGMsZSl7dmFyIGY9dGhpcy5kYXRhLGQ9dGhpcy5vcHRpb25zLmRhdGEsXG5nPVtdLG49W10saD1bXSxrPWEubGVuZ3RoLG0scix0PSEhYix2PVtdO2U9XCJmdW5jdGlvblwiPT09dHlwZW9mIGU/ZTp4W2VdfHxDW3RoaXMudHlwZV0mJnhbQ1t0aGlzLnR5cGVdLmFwcHJveGltYXRpb25dfHx4W2wuYXBwcm94aW1hdGlvbl07dmFyIEI9dGhpcy5wb2ludEFycmF5TWFwLHc9QiYmQi5sZW5ndGgsej0wO3I9MDt2YXIgRixKO3c/cShCLGZ1bmN0aW9uKCl7di5wdXNoKFtdKX0pOnYucHVzaChbXSk7Rj13fHwxO2ZvcihKPTA7Sjw9ayYmIShhW0pdPj1jWzBdKTtKKyspO2ZvcihKO0o8PWs7SisrKXtmb3IoO3ZvaWQgMCE9PWNbeisxXSYmYVtKXT49Y1t6KzFdfHxKPT09azspe209Y1t6XTt0aGlzLmRhdGFHcm91cEluZm89e3N0YXJ0OnIsbGVuZ3RoOnZbMF0ubGVuZ3RofTtyPWUuYXBwbHkodGhpcyx2KTt2b2lkIDAhPT1yJiYoZy5wdXNoKG0pLG4ucHVzaChyKSxoLnB1c2godGhpcy5kYXRhR3JvdXBJbmZvKSk7cj1KO2ZvcihtPTA7bTxGO20rKyl2W21dLmxlbmd0aD0wLFxudlttXS5oYXNOdWxscz0hMTt6Kz0xO2lmKEo9PT1rKWJyZWFrfWlmKEo9PT1rKWJyZWFrO2lmKEIpe209dGhpcy5jcm9wU3RhcnQrSjt2YXIgRT1mJiZmW21dfHx0aGlzLnBvaW50Q2xhc3MucHJvdG90eXBlLmFwcGx5T3B0aW9ucy5hcHBseSh7c2VyaWVzOnRoaXN9LFtkW21dXSksSTtmb3IobT0wO208dzttKyspST1FW0JbbV1dLHUoSSk/dlttXS5wdXNoKEkpOm51bGw9PT1JJiYodlttXS5oYXNOdWxscz0hMCl9ZWxzZSBtPXQ/YltKXTpudWxsLHUobSk/dlswXS5wdXNoKG0pOm51bGw9PT1tJiYodlswXS5oYXNOdWxscz0hMCl9cmV0dXJuW2csbixoXX07Yy5wcm9jZXNzRGF0YT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuY2hhcnQsZT10aGlzLm9wdGlvbnMuZGF0YUdyb3VwaW5nLGY9ITEhPT10aGlzLmFsbG93REcmJmUmJm0oZS5lbmFibGVkLGEub3B0aW9ucy5pc1N0b2NrKSxnPXRoaXMudmlzaWJsZXx8IWEub3B0aW9ucy5jaGFydC5pZ25vcmVIaWRkZW5TZXJpZXMsbCxkPXRoaXMuY3VycmVudERhdGFHcm91cGluZyxcbnA7dGhpcy5mb3JjZUNyb3A9Zjt0aGlzLmdyb3VwUGl4ZWxXaWR0aD1udWxsO3RoaXMuaGFzUHJvY2Vzc2VkPSEwO2lmKCExIT09Yi5hcHBseSh0aGlzLGFyZ3VtZW50cykmJmYpe3RoaXMuZGVzdHJveUdyb3VwZWREYXRhKCk7dmFyIHE9dGhpcy5wcm9jZXNzZWRYRGF0YSxoPXRoaXMucHJvY2Vzc2VkWURhdGEscj1hLnBsb3RTaXplWCxhPXRoaXMueEF4aXMsdD1hLm9wdGlvbnMub3JkaW5hbCx1PXRoaXMuZ3JvdXBQaXhlbFdpZHRoPWEuZ2V0R3JvdXBQaXhlbFdpZHRoJiZhLmdldEdyb3VwUGl4ZWxXaWR0aCgpO2lmKHUpe3RoaXMuaXNEaXJ0eT1sPSEwO3RoaXMucG9pbnRzPW51bGw7Zj1hLmdldEV4dHJlbWVzKCk7cD1mLm1pbjtmPWYubWF4O3Q9dCYmYS5nZXRHcm91cEludGVydmFsRmFjdG9yKHAsZix0aGlzKXx8MTt1PXUqKGYtcCkvcip0O3I9YS5nZXRUaW1lVGlja3MoYS5ub3JtYWxpemVUaW1lVGlja0ludGVydmFsKHUsZS51bml0c3x8SSksTWF0aC5taW4ocCxxWzBdKSxNYXRoLm1heChmLFxucVtxLmxlbmd0aC0xXSksYS5vcHRpb25zLnN0YXJ0T2ZXZWVrLHEsdGhpcy5jbG9zZXN0UG9pbnRSYW5nZSk7cT1jLmdyb3VwRGF0YS5hcHBseSh0aGlzLFtxLGgscixlLmFwcHJveGltYXRpb25dKTtoPXFbMF07dD1xWzFdO2lmKGUuc21vb3RoZWQmJmgubGVuZ3RoKXtlPWgubGVuZ3RoLTE7Zm9yKGhbZV09TWF0aC5taW4oaFtlXSxmKTtlLS0mJjA8ZTspaFtlXSs9dS8yO2hbMF09TWF0aC5tYXgoaFswXSxwKX1wPXIuaW5mbzt0aGlzLmNsb3Nlc3RQb2ludFJhbmdlPXIuaW5mby50b3RhbFJhbmdlO3RoaXMuZ3JvdXBNYXA9cVsyXTtrKGhbMF0pJiZoWzBdPGEuZGF0YU1pbiYmZyYmKGEubWluPT09YS5kYXRhTWluJiYoYS5taW49aFswXSksYS5kYXRhTWluPWhbMF0pO3RoaXMucHJvY2Vzc2VkWERhdGE9aDt0aGlzLnByb2Nlc3NlZFlEYXRhPXR9ZWxzZSB0aGlzLmdyb3VwTWFwPW51bGw7dGhpcy5oYXNHcm91cGVkRGF0YT1sO3RoaXMuY3VycmVudERhdGFHcm91cGluZz1wO3RoaXMucHJldmVudEdyYXBoQW5pbWF0aW9uPVxuKGQmJmQudG90YWxSYW5nZSkhPT0ocCYmcC50b3RhbFJhbmdlKX19O2MuZGVzdHJveUdyb3VwZWREYXRhPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ncm91cGVkRGF0YTtxKGF8fFtdLGZ1bmN0aW9uKGIsYyl7YiYmKGFbY109Yi5kZXN0cm95P2IuZGVzdHJveSgpOm51bGwpfSk7dGhpcy5ncm91cGVkRGF0YT1udWxsfTtjLmdlbmVyYXRlUG9pbnRzPWZ1bmN0aW9uKCl7ci5hcHBseSh0aGlzKTt0aGlzLmRlc3Ryb3lHcm91cGVkRGF0YSgpO3RoaXMuZ3JvdXBlZERhdGE9dGhpcy5oYXNHcm91cGVkRGF0YT90aGlzLnBvaW50czpudWxsfTtlKGcucHJvdG90eXBlLFwidXBkYXRlXCIsZnVuY3Rpb24oYil7dGhpcy5kYXRhR3JvdXA/YS5lcnJvcigyNCk6Yi5hcHBseSh0aGlzLFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKX0pO2UoZi5wcm90b3R5cGUsXCJ0b29sdGlwRm9vdGVySGVhZGVyRm9ybWF0dGVyXCIsZnVuY3Rpb24oYixjLGUpe3ZhciBmPWMuc2VyaWVzLGc9Zi50b29sdGlwT3B0aW9ucyxcbmQ9Zi5vcHRpb25zLmRhdGFHcm91cGluZyxwPWcueERhdGVGb3JtYXQsbCxoPWYueEF4aXMsbj1hLmRhdGVGb3JtYXQ7cmV0dXJuIGgmJlwiZGF0ZXRpbWVcIj09PWgub3B0aW9ucy50eXBlJiZkJiZ1KGMua2V5KT8oYj1mLmN1cnJlbnREYXRhR3JvdXBpbmcsZD1kLmRhdGVUaW1lTGFiZWxGb3JtYXRzLGI/KGg9ZFtiLnVuaXROYW1lXSwxPT09Yi5jb3VudD9wPWhbMF06KHA9aFsxXSxsPWhbMl0pKTohcCYmZCYmKHA9dGhpcy5nZXRYRGF0ZUZvcm1hdChjLGcsaCkpLHA9bihwLGMua2V5KSxsJiYocCs9bihsLGMua2V5K2IudG90YWxSYW5nZS0xKSksdChnWyhlP1wiZm9vdGVyXCI6XCJoZWFkZXJcIikrXCJGb3JtYXRcIl0se3BvaW50OncoYy5wb2ludCx7a2V5OnB9KSxzZXJpZXM6Zn0pKTpiLmNhbGwodGhpcyxjLGUpfSk7ZShjLFwiZGVzdHJveVwiLGZ1bmN0aW9uKGEpe2EuY2FsbCh0aGlzKTt0aGlzLmRlc3Ryb3lHcm91cGVkRGF0YSgpfSk7ZShjLFwic2V0T3B0aW9uc1wiLGZ1bmN0aW9uKGEsYil7YT1cbmEuY2FsbCh0aGlzLGIpO3ZhciBjPXRoaXMudHlwZSxlPXRoaXMuY2hhcnQub3B0aW9ucy5wbG90T3B0aW9ucyxmPXZbY10uZGF0YUdyb3VwaW5nO0NbY10mJihmfHwoZj16KGwsQ1tjXSkpLGEuZGF0YUdyb3VwaW5nPXooZixlLnNlcmllcyYmZS5zZXJpZXMuZGF0YUdyb3VwaW5nLGVbY10uZGF0YUdyb3VwaW5nLGIuZGF0YUdyb3VwaW5nKSk7dGhpcy5jaGFydC5vcHRpb25zLmlzU3RvY2smJih0aGlzLnJlcXVpcmVTb3J0aW5nPSEwKTtyZXR1cm4gYX0pO2UoSC5wcm90b3R5cGUsXCJzZXRTY2FsZVwiLGZ1bmN0aW9uKGEpe2EuY2FsbCh0aGlzKTtxKHRoaXMuc2VyaWVzLGZ1bmN0aW9uKGEpe2EuaGFzUHJvY2Vzc2VkPSExfSl9KTtILnByb3RvdHlwZS5nZXRHcm91cFBpeGVsV2lkdGg9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnNlcmllcyxiPWEubGVuZ3RoLGMsZT0wLGY9ITEsZDtmb3IoYz1iO2MtLTspKGQ9YVtjXS5vcHRpb25zLmRhdGFHcm91cGluZykmJihlPU1hdGgubWF4KGUsZC5ncm91cFBpeGVsV2lkdGgpKTtcbmZvcihjPWI7Yy0tOykoZD1hW2NdLm9wdGlvbnMuZGF0YUdyb3VwaW5nKSYmYVtjXS5oYXNQcm9jZXNzZWQmJihiPShhW2NdLnByb2Nlc3NlZFhEYXRhfHxhW2NdLmRhdGEpLmxlbmd0aCxhW2NdLmdyb3VwUGl4ZWxXaWR0aHx8Yj50aGlzLmNoYXJ0LnBsb3RTaXplWC9lfHxiJiZkLmZvcmNlZCkmJihmPSEwKTtyZXR1cm4gZj9lOjB9O0gucHJvdG90eXBlLnNldERhdGFHcm91cGluZz1mdW5jdGlvbihhLGIpe3ZhciBjO2I9bShiLCEwKTthfHwoYT17Zm9yY2VkOiExLHVuaXRzOm51bGx9KTtpZih0aGlzIGluc3RhbmNlb2YgSClmb3IoYz10aGlzLnNlcmllcy5sZW5ndGg7Yy0tOyl0aGlzLnNlcmllc1tjXS51cGRhdGUoe2RhdGFHcm91cGluZzphfSwhMSk7ZWxzZSBxKHRoaXMuY2hhcnQub3B0aW9ucy5zZXJpZXMsZnVuY3Rpb24oYil7Yi5kYXRhR3JvdXBpbmc9YX0sITEpO2ImJnRoaXMuY2hhcnQucmVkcmF3KCl9fSkoTCk7KGZ1bmN0aW9uKGEpe3ZhciBHPWEuZWFjaCxFPWEuUG9pbnQsXG5IPWEuc2VyaWVzVHlwZSx2PWEuc2VyaWVzVHlwZXM7SChcIm9obGNcIixcImNvbHVtblwiLHtsaW5lV2lkdGg6MSx0b29sdGlwOntwb2ludEZvcm1hdDonXFx4M2NzcGFuIHN0eWxlXFx4M2RcImNvbG9yOntwb2ludC5jb2xvcn1cIlxceDNlXFx1MjVjZlxceDNjL3NwYW5cXHgzZSBcXHgzY2JcXHgzZSB7c2VyaWVzLm5hbWV9XFx4M2MvYlxceDNlXFx4M2Nici9cXHgzZU9wZW46IHtwb2ludC5vcGVufVxceDNjYnIvXFx4M2VIaWdoOiB7cG9pbnQuaGlnaH1cXHgzY2JyL1xceDNlTG93OiB7cG9pbnQubG93fVxceDNjYnIvXFx4M2VDbG9zZToge3BvaW50LmNsb3NlfVxceDNjYnIvXFx4M2UnfSx0aHJlc2hvbGQ6bnVsbCxzdGF0ZXM6e2hvdmVyOntsaW5lV2lkdGg6M319LHN0aWNreVRyYWNraW5nOiEwfSx7ZGlyZWN0VG91Y2g6ITEscG9pbnRBcnJheU1hcDpbXCJvcGVuXCIsXCJoaWdoXCIsXCJsb3dcIixcImNsb3NlXCJdLHRvWURhdGE6ZnVuY3Rpb24oYSl7cmV0dXJuW2Eub3BlbixhLmhpZ2gsYS5sb3csYS5jbG9zZV19LHBvaW50VmFsS2V5OlwiY2xvc2VcIixcbnBvaW50QXR0clRvT3B0aW9uczp7c3Ryb2tlOlwiY29sb3JcIixcInN0cm9rZS13aWR0aFwiOlwibGluZVdpZHRoXCJ9LHBvaW50QXR0cmliczpmdW5jdGlvbihhLHEpe3E9di5jb2x1bW4ucHJvdG90eXBlLnBvaW50QXR0cmlicy5jYWxsKHRoaXMsYSxxKTt2YXIgaz10aGlzLm9wdGlvbnM7ZGVsZXRlIHEuZmlsbDshYS5vcHRpb25zLmNvbG9yJiZrLnVwQ29sb3ImJmEub3BlbjxhLmNsb3NlJiYocS5zdHJva2U9ay51cENvbG9yKTtyZXR1cm4gcX0sdHJhbnNsYXRlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxxPWEueUF4aXMsdz0hIWEubW9kaWZ5VmFsdWUsdD1bXCJwbG90T3BlblwiLFwicGxvdEhpZ2hcIixcInBsb3RMb3dcIixcInBsb3RDbG9zZVwiLFwieUJvdHRvbVwiXTt2LmNvbHVtbi5wcm90b3R5cGUudHJhbnNsYXRlLmFwcGx5KGEpO0coYS5wb2ludHMsZnVuY3Rpb24oayl7Ryhbay5vcGVuLGsuaGlnaCxrLmxvdyxrLmNsb3NlLGsubG93XSxmdW5jdGlvbih1LG0pe251bGwhPT11JiYodyYmKHU9YS5tb2RpZnlWYWx1ZSh1KSksXG5rW3RbbV1dPXEudG9QaXhlbHModSwhMCkpfSk7ay50b29sdGlwUG9zWzFdPWsucGxvdEhpZ2grcS5wb3MtYS5jaGFydC5wbG90VG9wfSl9LGRyYXdQb2ludHM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLHE9YS5jaGFydDtHKGEucG9pbnRzLGZ1bmN0aW9uKGspe3ZhciB0LHUsdixtLGc9ay5ncmFwaGljLGYsZT0hZzt2b2lkIDAhPT1rLnBsb3RZJiYoZ3x8KGsuZ3JhcGhpYz1nPXEucmVuZGVyZXIucGF0aCgpLmFkZChhLmdyb3VwKSksZy5hdHRyKGEucG9pbnRBdHRyaWJzKGssay5zZWxlY3RlZCYmXCJzZWxlY3RcIikpLHU9Zy5zdHJva2VXaWR0aCgpJTIvMixmPU1hdGgucm91bmQoay5wbG90WCktdSx2PU1hdGgucm91bmQoay5zaGFwZUFyZ3Mud2lkdGgvMiksbT1bXCJNXCIsZixNYXRoLnJvdW5kKGsueUJvdHRvbSksXCJMXCIsZixNYXRoLnJvdW5kKGsucGxvdEhpZ2gpXSxudWxsIT09ay5vcGVuJiYodD1NYXRoLnJvdW5kKGsucGxvdE9wZW4pK3UsbS5wdXNoKFwiTVwiLGYsdCxcIkxcIixmLXYsdCkpLFxubnVsbCE9PWsuY2xvc2UmJih0PU1hdGgucm91bmQoay5wbG90Q2xvc2UpK3UsbS5wdXNoKFwiTVwiLGYsdCxcIkxcIixmK3YsdCkpLGdbZT9cImF0dHJcIjpcImFuaW1hdGVcIl0oe2Q6bX0pLmFkZENsYXNzKGsuZ2V0Q2xhc3NOYW1lKCksITApKX0pfSxhbmltYXRlOm51bGx9LHtnZXRDbGFzc05hbWU6ZnVuY3Rpb24oKXtyZXR1cm4gRS5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lLmNhbGwodGhpcykrKHRoaXMub3Blbjx0aGlzLmNsb3NlP1wiIGhpZ2hjaGFydHMtcG9pbnQtdXBcIjpcIiBoaWdoY2hhcnRzLXBvaW50LWRvd25cIil9fSl9KShMKTsoZnVuY3Rpb24oYSl7dmFyIEc9YS5kZWZhdWx0UGxvdE9wdGlvbnMsRT1hLmVhY2gsSD1hLm1lcmdlLHY9YS5zZXJpZXNUeXBlLGs9YS5zZXJpZXNUeXBlczt2KFwiY2FuZGxlc3RpY2tcIixcIm9obGNcIixIKEcuY29sdW1uLHtzdGF0ZXM6e2hvdmVyOntsaW5lV2lkdGg6Mn19LHRvb2x0aXA6Ry5vaGxjLnRvb2x0aXAsdGhyZXNob2xkOm51bGwsbGluZUNvbG9yOlwiIzAwMDAwMFwiLFxubGluZVdpZHRoOjEsdXBDb2xvcjpcIiNmZmZmZmZcIixzdGlja3lUcmFja2luZzohMH0pLHtwb2ludEF0dHJpYnM6ZnVuY3Rpb24oYSx2KXt2YXIgcT1rLmNvbHVtbi5wcm90b3R5cGUucG9pbnRBdHRyaWJzLmNhbGwodGhpcyxhLHYpLHU9dGhpcy5vcHRpb25zLHc9YS5vcGVuPGEuY2xvc2UsbT11LmxpbmVDb2xvcnx8dGhpcy5jb2xvcjtxW1wic3Ryb2tlLXdpZHRoXCJdPXUubGluZVdpZHRoO3EuZmlsbD1hLm9wdGlvbnMuY29sb3J8fCh3P3UudXBDb2xvcnx8dGhpcy5jb2xvcjp0aGlzLmNvbG9yKTtxLnN0cm9rZT1hLmxpbmVDb2xvcnx8KHc/dS51cExpbmVDb2xvcnx8bTptKTt2JiYoYT11LnN0YXRlc1t2XSxxLmZpbGw9YS5jb2xvcnx8cS5maWxsLHEuc3Ryb2tlPWEubGluZUNvbG9yfHxxLnN0cm9rZSxxW1wic3Ryb2tlLXdpZHRoXCJdPWEubGluZVdpZHRofHxxW1wic3Ryb2tlLXdpZHRoXCJdKTtyZXR1cm4gcX0sZHJhd1BvaW50czpmdW5jdGlvbigpe3ZhciBhPXRoaXMsaz1hLmNoYXJ0O0UoYS5wb2ludHMsXG5mdW5jdGlvbihxKXt2YXIgdD1xLmdyYXBoaWMsdixtLGcsZixlLGMsYixyPSF0O3ZvaWQgMCE9PXEucGxvdFkmJih0fHwocS5ncmFwaGljPXQ9ay5yZW5kZXJlci5wYXRoKCkuYWRkKGEuZ3JvdXApKSx0LmF0dHIoYS5wb2ludEF0dHJpYnMocSxxLnNlbGVjdGVkJiZcInNlbGVjdFwiKSkuc2hhZG93KGEub3B0aW9ucy5zaGFkb3cpLGU9dC5zdHJva2VXaWR0aCgpJTIvMixjPU1hdGgucm91bmQocS5wbG90WCktZSx2PXEucGxvdE9wZW4sbT1xLnBsb3RDbG9zZSxnPU1hdGgubWluKHYsbSksdj1NYXRoLm1heCh2LG0pLGI9TWF0aC5yb3VuZChxLnNoYXBlQXJncy53aWR0aC8yKSxtPU1hdGgucm91bmQoZykhPT1NYXRoLnJvdW5kKHEucGxvdEhpZ2gpLGY9diE9PXEueUJvdHRvbSxnPU1hdGgucm91bmQoZykrZSx2PU1hdGgucm91bmQodikrZSxlPVtdLGUucHVzaChcIk1cIixjLWIsdixcIkxcIixjLWIsZyxcIkxcIixjK2IsZyxcIkxcIixjK2IsdixcIlpcIixcIk1cIixjLGcsXCJMXCIsYyxtP01hdGgucm91bmQocS5wbG90SGlnaCk6XG5nLFwiTVwiLGMsdixcIkxcIixjLGY/TWF0aC5yb3VuZChxLnlCb3R0b20pOnYpLHRbcj9cImF0dHJcIjpcImFuaW1hdGVcIl0oe2Q6ZX0pLmFkZENsYXNzKHEuZ2V0Q2xhc3NOYW1lKCksITApKX0pfX0pfSkoTCk7Wj1mdW5jdGlvbihhKXt2YXIgRz1hLmVhY2gsRT1hLnNlcmllc1R5cGVzLEg9YS5zdGFibGVTb3J0O3JldHVybnt0cmFuc2xhdGU6ZnVuY3Rpb24oKXtFLmNvbHVtbi5wcm90b3R5cGUudHJhbnNsYXRlLmFwcGx5KHRoaXMpO3ZhciBhPXRoaXMub3B0aW9ucyxrPXRoaXMuY2hhcnQscT10aGlzLnBvaW50cyx3PXEubGVuZ3RoLTEsdCx1LHo9YS5vblNlcmllczt0PXomJmsuZ2V0KHopO3ZhciBhPWEub25LZXl8fFwieVwiLHo9dCYmdC5vcHRpb25zLnN0ZXAsbT10JiZ0LnBvaW50cyxnPW0mJm0ubGVuZ3RoLGY9dGhpcy54QXhpcyxlPXRoaXMueUF4aXMsYz1mLmdldEV4dHJlbWVzKCksYj0wLHIsbCxDLEk7aWYodCYmdC52aXNpYmxlJiZnKWZvcihiPSh0LnBvaW50WE9mZnNldHx8MCkrKHQuYmFyV3x8XG4wKS8yLHQ9dC5jdXJyZW50RGF0YUdyb3VwaW5nLGw9bVtnLTFdLngrKHQ/dC50b3RhbFJhbmdlOjApLEgocSxmdW5jdGlvbihhLGIpe3JldHVybiBhLngtYi54fSksYT1cInBsb3RcIithWzBdLnRvVXBwZXJDYXNlKCkrYS5zdWJzdHIoMSk7Zy0tJiZxW3ddJiYhKHI9bVtnXSx0PXFbd10sdC55PXIueSxyLng8PXQueCYmdm9pZCAwIT09clthXSYmKHQueDw9bCYmKHQucGxvdFk9clthXSxyLng8dC54JiYheiYmKEM9bVtnKzFdKSYmdm9pZCAwIT09Q1thXSYmKEk9KHQueC1yLngpLyhDLngtci54KSx0LnBsb3RZKz1JKihDW2FdLXJbYV0pLHQueSs9SSooQy55LXIueSkpKSx3LS0sZysrLDA+dykpOyk7RyhxLGZ1bmN0aW9uKGEsZyl7dmFyIGw7dm9pZCAwPT09YS5wbG90WSYmKGEueD49Yy5taW4mJmEueDw9Yy5tYXg/YS5wbG90WT1rLmNoYXJ0SGVpZ2h0LWYuYm90dG9tLShmLm9wcG9zaXRlP2YuaGVpZ2h0OjApK2Yub2Zmc2V0LWUudG9wOmEuc2hhcGVBcmdzPXt9KTthLnBsb3RYKz1iO1xuKHU9cVtnLTFdKSYmdS5wbG90WD09PWEucGxvdFgmJih2b2lkIDA9PT11LnN0YWNrSW5kZXgmJih1LnN0YWNrSW5kZXg9MCksbD11LnN0YWNrSW5kZXgrMSk7YS5zdGFja0luZGV4PWx9KX19fShMKTsoZnVuY3Rpb24oYSxHKXtmdW5jdGlvbiBFKGEpe21bYStcInBpblwiXT1mdW5jdGlvbihmLGUsYyxiLGcpe3ZhciBsPWcmJmcuYW5jaG9yWDtnPWcmJmcuYW5jaG9yWTtcImNpcmNsZVwiPT09YSYmYj5jJiYoZi09TWF0aC5yb3VuZCgoYi1jKS8yKSxjPWIpO2Y9bVthXShmLGUsYyxiKTtsJiZnJiYoZi5wdXNoKFwiTVwiLFwiY2lyY2xlXCI9PT1hP2ZbMV0tZls0XTpmWzFdK2ZbNF0vMixlPmc/ZTplK2IsXCJMXCIsbCxnKSxmPWYuY29uY2F0KG0uY2lyY2xlKGwtMSxnLTEsMiwyKSkpO3JldHVybiBmfX12YXIgSD1hLmFkZEV2ZW50LHY9YS5lYWNoLGs9YS5tZXJnZSxxPWEubm9vcCx3PWEuUmVuZGVyZXIsdD1hLnNlcmllc1R5cGUsdT1hLlRyYWNrZXJNaXhpbix6PWEuVk1MUmVuZGVyZXIsbT1hLlNWR1JlbmRlcmVyLnByb3RvdHlwZS5zeW1ib2xzO1xudChcImZsYWdzXCIsXCJjb2x1bW5cIix7cG9pbnRSYW5nZTowLGFsbG93T3ZlcmxhcFg6ITEsc2hhcGU6XCJmbGFnXCIsc3RhY2tEaXN0YW5jZToxMix0ZXh0QWxpZ246XCJjZW50ZXJcIix0b29sdGlwOntwb2ludEZvcm1hdDpcIntwb2ludC50ZXh0fVxceDNjYnIvXFx4M2VcIn0sdGhyZXNob2xkOm51bGwseTotMzAsZmlsbENvbG9yOlwiI2ZmZmZmZlwiLGxpbmVXaWR0aDoxLHN0YXRlczp7aG92ZXI6e2xpbmVDb2xvcjpcIiMwMDAwMDBcIixmaWxsQ29sb3I6XCIjY2NkNmViXCJ9fSxzdHlsZTp7Zm9udFNpemU6XCIxMXB4XCIsZm9udFdlaWdodDpcImJvbGRcIn19LHtzb3J0ZWQ6ITEsbm9TaGFyZWRUb29sdGlwOiEwLGFsbG93REc6ITEsdGFrZU9yZGluYWxQb3NpdGlvbjohMSx0cmFja2VyR3JvdXBzOltcIm1hcmtlckdyb3VwXCJdLGZvcmNlQ3JvcDohMCxpbml0OmEuU2VyaWVzLnByb3RvdHlwZS5pbml0LHBvaW50QXR0cmliczpmdW5jdGlvbihhLGYpe3ZhciBlPXRoaXMub3B0aW9ucyxjPWEmJmEuY29sb3J8fHRoaXMuY29sb3IsXG5iPWUubGluZUNvbG9yLGc9YSYmYS5saW5lV2lkdGg7YT1hJiZhLmZpbGxDb2xvcnx8ZS5maWxsQ29sb3I7ZiYmKGE9ZS5zdGF0ZXNbZl0uZmlsbENvbG9yLGI9ZS5zdGF0ZXNbZl0ubGluZUNvbG9yLGc9ZS5zdGF0ZXNbZl0ubGluZVdpZHRoKTtyZXR1cm57ZmlsbDphfHxjLHN0cm9rZTpifHxjLFwic3Ryb2tlLXdpZHRoXCI6Z3x8ZS5saW5lV2lkdGh8fDB9fSx0cmFuc2xhdGU6Ry50cmFuc2xhdGUsZHJhd1BvaW50czpmdW5jdGlvbigpe3ZhciBnPXRoaXMucG9pbnRzLGY9dGhpcy5jaGFydCxlPWYucmVuZGVyZXIsYyxiLG09dGhpcy5vcHRpb25zLGw9bS55LHEsdCx1LHcsbixCLHo9dGhpcy55QXhpcyxBPXt9LGQ9W107Zm9yKHQ9Zy5sZW5ndGg7dC0tOyl1PWdbdF0sQj11LnBsb3RYPnRoaXMueEF4aXMubGVuLGM9dS5wbG90WCx3PXUuc3RhY2tJbmRleCxxPXUub3B0aW9ucy5zaGFwZXx8bS5zaGFwZSxiPXUucGxvdFksdm9pZCAwIT09YiYmKGI9dS5wbG90WStsLSh2b2lkIDAhPT13JiZcbncqbS5zdGFja0Rpc3RhbmNlKSksdS5hbmNob3JYPXc/dm9pZCAwOnUucGxvdFgsbj13P3ZvaWQgMDp1LnBsb3RZLHc9dS5ncmFwaGljLHZvaWQgMCE9PWImJjA8PWMmJiFCPyh3fHwodz11LmdyYXBoaWM9ZS5sYWJlbChcIlwiLG51bGwsbnVsbCxxLG51bGwsbnVsbCxtLnVzZUhUTUwpLmF0dHIodGhpcy5wb2ludEF0dHJpYnModSkpLmNzcyhrKG0uc3R5bGUsdS5zdHlsZSkpLmF0dHIoe2FsaWduOlwiZmxhZ1wiPT09cT9cImxlZnRcIjpcImNlbnRlclwiLHdpZHRoOm0ud2lkdGgsaGVpZ2h0Om0uaGVpZ2h0LFwidGV4dC1hbGlnblwiOm0udGV4dEFsaWdufSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXBvaW50XCIpLmFkZCh0aGlzLm1hcmtlckdyb3VwKSx1LmdyYXBoaWMuZGl2JiYodS5ncmFwaGljLmRpdi5wb2ludD11KSx3LnNoYWRvdyhtLnNoYWRvdyksdy5pc05ldz0hMCksMDxjJiYoYy09dy5zdHJva2VXaWR0aCgpJTIpLHE9e3k6YixhbmNob3JZOm59LG0uYWxsb3dPdmVybGFwWCYmKHEueD1jLHEuYW5jaG9yWD1cbnUuYW5jaG9yWCksdy5hdHRyKHt0ZXh0OnUub3B0aW9ucy50aXRsZXx8bS50aXRsZXx8XCJBXCJ9KVt3LmlzTmV3P1wiYXR0clwiOlwiYW5pbWF0ZVwiXShxKSxtLmFsbG93T3ZlcmxhcFh8fChBW3UucGxvdFhdP0FbdS5wbG90WF0uc2l6ZT1NYXRoLm1heChBW3UucGxvdFhdLnNpemUsdy53aWR0aCk6QVt1LnBsb3RYXT17YWxpZ246MCxzaXplOncud2lkdGgsdGFyZ2V0OmMsYW5jaG9yWDpjfSksdS50b29sdGlwUG9zPWYuaW52ZXJ0ZWQ/W3oubGVuK3oucG9zLWYucGxvdExlZnQtYix0aGlzLnhBeGlzLmxlbi1jXTpbYyxiK3oucG9zLWYucGxvdFRvcF0pOncmJih1LmdyYXBoaWM9dy5kZXN0cm95KCkpO20uYWxsb3dPdmVybGFwWHx8KGEub2JqZWN0RWFjaChBLGZ1bmN0aW9uKGEpe2EucGxvdFg9YS5hbmNob3JYO2QucHVzaChhKX0pLGEuZGlzdHJpYnV0ZShkLHRoaXMueEF4aXMubGVuKSx2KGcsZnVuY3Rpb24oYSl7dmFyIGI9YS5ncmFwaGljJiZBW2EucGxvdFhdO2ImJihhLmdyYXBoaWNbYS5ncmFwaGljLmlzTmV3P1xuXCJhdHRyXCI6XCJhbmltYXRlXCJdKHt4OmIucG9zLGFuY2hvclg6YS5hbmNob3JYfSksYS5ncmFwaGljLmlzTmV3PSExKX0pKTttLnVzZUhUTUwmJmEud3JhcCh0aGlzLm1hcmtlckdyb3VwLFwib25cIixmdW5jdGlvbihiKXtyZXR1cm4gYS5TVkdFbGVtZW50LnByb3RvdHlwZS5vbi5hcHBseShiLmFwcGx5KHRoaXMsW10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpLFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKX0pfSxkcmF3VHJhY2tlcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMucG9pbnRzO3UuZHJhd1RyYWNrZXJQb2ludC5hcHBseSh0aGlzKTt2KGEsZnVuY3Rpb24oZil7dmFyIGU9Zi5ncmFwaGljO2UmJkgoZS5lbGVtZW50LFwibW91c2VvdmVyXCIsZnVuY3Rpb24oKXswPGYuc3RhY2tJbmRleCYmIWYucmFpc2VkJiYoZi5feT1lLnksZS5hdHRyKHt5OmYuX3ktOH0pLGYucmFpc2VkPSEwKTt2KGEsZnVuY3Rpb24oYSl7YSE9PWYmJmEucmFpc2VkJiZhLmdyYXBoaWMmJihhLmdyYXBoaWMuYXR0cih7eTphLl95fSksXG5hLnJhaXNlZD0hMSl9KX0pfSl9LGFuaW1hdGU6cSxidWlsZEtEVHJlZTpxLHNldENsaXA6cX0pO20uZmxhZz1mdW5jdGlvbihhLGYsZSxjLGIpe3ZhciBnPWImJmIuYW5jaG9yWHx8YTtiPWImJmIuYW5jaG9yWXx8ZjtyZXR1cm4gbS5jaXJjbGUoZy0xLGItMSwyLDIpLmNvbmNhdChbXCJNXCIsZyxiLFwiTFwiLGEsZitjLGEsZixhK2UsZixhK2UsZitjLGEsZitjLFwiWlwiXSl9O0UoXCJjaXJjbGVcIik7RShcInNxdWFyZVwiKTt3PT09eiYmdihbXCJmbGFnXCIsXCJjaXJjbGVwaW5cIixcInNxdWFyZXBpblwiXSxmdW5jdGlvbihhKXt6LnByb3RvdHlwZS5zeW1ib2xzW2FdPW1bYV19KX0pKEwsWik7KGZ1bmN0aW9uKGEpe2Z1bmN0aW9uIEcoYSxiLGMpe3RoaXMuaW5pdChhLGIsYyl9dmFyIEU9YS5hZGRFdmVudCxIPWEuQXhpcyx2PWEuY29ycmVjdEZsb2F0LGs9YS5kZWZhdWx0T3B0aW9ucyxxPWEuZGVmaW5lZCx3PWEuZGVzdHJveU9iamVjdFByb3BlcnRpZXMsdD1hLmVhY2gsdT1hLmZpcmVFdmVudCx6PWEuaGFzVG91Y2gsXG5tPWEuaXNUb3VjaERldmljZSxnPWEubWVyZ2UsZj1hLnBpY2ssZT1hLnJlbW92ZUV2ZW50LGM9YS53cmFwLGIscj17aGVpZ2h0Om0/MjA6MTQsYmFyQm9yZGVyUmFkaXVzOjAsYnV0dG9uQm9yZGVyUmFkaXVzOjAsbGl2ZVJlZHJhdzphLnN2ZyYmIW0sbWFyZ2luOjEwLG1pbldpZHRoOjYsc3RlcDouMix6SW5kZXg6MyxiYXJCYWNrZ3JvdW5kQ29sb3I6XCIjY2NjY2NjXCIsYmFyQm9yZGVyV2lkdGg6MSxiYXJCb3JkZXJDb2xvcjpcIiNjY2NjY2NcIixidXR0b25BcnJvd0NvbG9yOlwiIzMzMzMzM1wiLGJ1dHRvbkJhY2tncm91bmRDb2xvcjpcIiNlNmU2ZTZcIixidXR0b25Cb3JkZXJDb2xvcjpcIiNjY2NjY2NcIixidXR0b25Cb3JkZXJXaWR0aDoxLHJpZmxlQ29sb3I6XCIjMzMzMzMzXCIsdHJhY2tCYWNrZ3JvdW5kQ29sb3I6XCIjZjJmMmYyXCIsdHJhY2tCb3JkZXJDb2xvcjpcIiNmMmYyZjJcIix0cmFja0JvcmRlcldpZHRoOjF9O2suc2Nyb2xsYmFyPWcoITAscixrLnNjcm9sbGJhcik7YS5zd2FwWFk9Yj1mdW5jdGlvbihhLFxuYil7dmFyIGM9YS5sZW5ndGgsZTtpZihiKWZvcihiPTA7YjxjO2IrPTMpZT1hW2IrMV0sYVtiKzFdPWFbYisyXSxhW2IrMl09ZTtyZXR1cm4gYX07Ry5wcm90b3R5cGU9e2luaXQ6ZnVuY3Rpb24oYSxiLGMpe3RoaXMuc2Nyb2xsYmFyQnV0dG9ucz1bXTt0aGlzLnJlbmRlcmVyPWE7dGhpcy51c2VyT3B0aW9ucz1iO3RoaXMub3B0aW9ucz1nKHIsYik7dGhpcy5jaGFydD1jO3RoaXMuc2l6ZT1mKHRoaXMub3B0aW9ucy5zaXplLHRoaXMub3B0aW9ucy5oZWlnaHQpO2IuZW5hYmxlZCYmKHRoaXMucmVuZGVyKCksdGhpcy5pbml0RXZlbnRzKCksdGhpcy5hZGRFdmVudHMoKSl9LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMucmVuZGVyZXIsYz10aGlzLm9wdGlvbnMsZT10aGlzLnNpemUsZjt0aGlzLmdyb3VwPWY9YS5nKFwic2Nyb2xsYmFyXCIpLmF0dHIoe3pJbmRleDpjLnpJbmRleCx0cmFuc2xhdGVZOi05OTk5OX0pLmFkZCgpO3RoaXMudHJhY2s9YS5yZWN0KCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXNjcm9sbGJhci10cmFja1wiKS5hdHRyKHt4OjAsXG5yOmMudHJhY2tCb3JkZXJSYWRpdXN8fDAsaGVpZ2h0OmUsd2lkdGg6ZX0pLmFkZChmKTt0aGlzLnRyYWNrLmF0dHIoe2ZpbGw6Yy50cmFja0JhY2tncm91bmRDb2xvcixzdHJva2U6Yy50cmFja0JvcmRlckNvbG9yLFwic3Ryb2tlLXdpZHRoXCI6Yy50cmFja0JvcmRlcldpZHRofSk7dGhpcy50cmFja0JvcmRlcldpZHRoPXRoaXMudHJhY2suc3Ryb2tlV2lkdGgoKTt0aGlzLnRyYWNrLmF0dHIoe3k6LXRoaXMudHJhY2tCb3JkZXJXaWR0aCUyLzJ9KTt0aGlzLnNjcm9sbGJhckdyb3VwPWEuZygpLmFkZChmKTt0aGlzLnNjcm9sbGJhcj1hLnJlY3QoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtc2Nyb2xsYmFyLXRodW1iXCIpLmF0dHIoe2hlaWdodDplLHdpZHRoOmUscjpjLmJhckJvcmRlclJhZGl1c3x8MH0pLmFkZCh0aGlzLnNjcm9sbGJhckdyb3VwKTt0aGlzLnNjcm9sbGJhclJpZmxlcz1hLnBhdGgoYihbXCJNXCIsLTMsZS80LFwiTFwiLC0zLDIqZS8zLFwiTVwiLDAsZS80LFwiTFwiLDAsMiplLzMsXCJNXCIsXG4zLGUvNCxcIkxcIiwzLDIqZS8zXSxjLnZlcnRpY2FsKSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXNjcm9sbGJhci1yaWZsZXNcIikuYWRkKHRoaXMuc2Nyb2xsYmFyR3JvdXApO3RoaXMuc2Nyb2xsYmFyLmF0dHIoe2ZpbGw6Yy5iYXJCYWNrZ3JvdW5kQ29sb3Isc3Ryb2tlOmMuYmFyQm9yZGVyQ29sb3IsXCJzdHJva2Utd2lkdGhcIjpjLmJhckJvcmRlcldpZHRofSk7dGhpcy5zY3JvbGxiYXJSaWZsZXMuYXR0cih7c3Ryb2tlOmMucmlmbGVDb2xvcixcInN0cm9rZS13aWR0aFwiOjF9KTt0aGlzLnNjcm9sbGJhclN0cm9rZVdpZHRoPXRoaXMuc2Nyb2xsYmFyLnN0cm9rZVdpZHRoKCk7dGhpcy5zY3JvbGxiYXJHcm91cC50cmFuc2xhdGUoLXRoaXMuc2Nyb2xsYmFyU3Ryb2tlV2lkdGglMi8yLC10aGlzLnNjcm9sbGJhclN0cm9rZVdpZHRoJTIvMik7dGhpcy5kcmF3U2Nyb2xsYmFyQnV0dG9uKDApO3RoaXMuZHJhd1Njcm9sbGJhckJ1dHRvbigxKX0scG9zaXRpb246ZnVuY3Rpb24oYSxiLGMsZSl7dmFyIGY9XG50aGlzLm9wdGlvbnMudmVydGljYWwsZz0wLGw9dGhpcy5yZW5kZXJlZD9cImFuaW1hdGVcIjpcImF0dHJcIjt0aGlzLng9YTt0aGlzLnk9Yit0aGlzLnRyYWNrQm9yZGVyV2lkdGg7dGhpcy53aWR0aD1jO3RoaXMueE9mZnNldD10aGlzLmhlaWdodD1lO3RoaXMueU9mZnNldD1nO2Y/KHRoaXMud2lkdGg9dGhpcy55T2Zmc2V0PWM9Zz10aGlzLnNpemUsdGhpcy54T2Zmc2V0PWI9MCx0aGlzLmJhcldpZHRoPWUtMipjLHRoaXMueD1hKz10aGlzLm9wdGlvbnMubWFyZ2luKToodGhpcy5oZWlnaHQ9dGhpcy54T2Zmc2V0PWU9Yj10aGlzLnNpemUsdGhpcy5iYXJXaWR0aD1jLTIqZSx0aGlzLnkrPXRoaXMub3B0aW9ucy5tYXJnaW4pO3RoaXMuZ3JvdXBbbF0oe3RyYW5zbGF0ZVg6YSx0cmFuc2xhdGVZOnRoaXMueX0pO3RoaXMudHJhY2tbbF0oe3dpZHRoOmMsaGVpZ2h0OmV9KTt0aGlzLnNjcm9sbGJhckJ1dHRvbnNbMV1bbF0oe3RyYW5zbGF0ZVg6Zj8wOmMtYix0cmFuc2xhdGVZOmY/ZS1nOjB9KX0sXG5kcmF3U2Nyb2xsYmFyQnV0dG9uOmZ1bmN0aW9uKGEpe3ZhciBjPXRoaXMucmVuZGVyZXIsZT10aGlzLnNjcm9sbGJhckJ1dHRvbnMsZj10aGlzLm9wdGlvbnMsZz10aGlzLnNpemUsbDtsPWMuZygpLmFkZCh0aGlzLmdyb3VwKTtlLnB1c2gobCk7bD1jLnJlY3QoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtc2Nyb2xsYmFyLWJ1dHRvblwiKS5hZGQobCk7bC5hdHRyKHtzdHJva2U6Zi5idXR0b25Cb3JkZXJDb2xvcixcInN0cm9rZS13aWR0aFwiOmYuYnV0dG9uQm9yZGVyV2lkdGgsZmlsbDpmLmJ1dHRvbkJhY2tncm91bmRDb2xvcn0pO2wuYXR0cihsLmNyaXNwKHt4Oi0uNSx5Oi0uNSx3aWR0aDpnKzEsaGVpZ2h0OmcrMSxyOmYuYnV0dG9uQm9yZGVyUmFkaXVzfSxsLnN0cm9rZVdpZHRoKCkpKTtsPWMucGF0aChiKFtcIk1cIixnLzIrKGE/LTE6MSksZy8yLTMsXCJMXCIsZy8yKyhhPy0xOjEpLGcvMiszLFwiTFwiLGcvMisoYT8yOi0yKSxnLzJdLGYudmVydGljYWwpKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtc2Nyb2xsYmFyLWFycm93XCIpLmFkZChlW2FdKTtcbmwuYXR0cih7ZmlsbDpmLmJ1dHRvbkFycm93Q29sb3J9KX0sc2V0UmFuZ2U6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLm9wdGlvbnMsZT1jLnZlcnRpY2FsLGY9Yy5taW5XaWR0aCxnPXRoaXMuYmFyV2lkdGgsbCxrLG09dGhpcy5yZW5kZXJlZCYmIXRoaXMuaGFzRHJhZ2dlZD9cImFuaW1hdGVcIjpcImF0dHJcIjtxKGcpJiYoYT1NYXRoLm1heChhLDApLGw9TWF0aC5jZWlsKGcqYSksdGhpcy5jYWxjdWxhdGVkV2lkdGg9az12KGcqTWF0aC5taW4oYiwxKS1sKSxrPGYmJihsPShnLWYraykqYSxrPWYpLGY9TWF0aC5mbG9vcihsK3RoaXMueE9mZnNldCt0aGlzLnlPZmZzZXQpLGc9ay8yLS41LHRoaXMuZnJvbT1hLHRoaXMudG89YixlPyh0aGlzLnNjcm9sbGJhckdyb3VwW21dKHt0cmFuc2xhdGVZOmZ9KSx0aGlzLnNjcm9sbGJhclttXSh7aGVpZ2h0Omt9KSx0aGlzLnNjcm9sbGJhclJpZmxlc1ttXSh7dHJhbnNsYXRlWTpnfSksdGhpcy5zY3JvbGxiYXJUb3A9Zix0aGlzLnNjcm9sbGJhckxlZnQ9XG4wKToodGhpcy5zY3JvbGxiYXJHcm91cFttXSh7dHJhbnNsYXRlWDpmfSksdGhpcy5zY3JvbGxiYXJbbV0oe3dpZHRoOmt9KSx0aGlzLnNjcm9sbGJhclJpZmxlc1ttXSh7dHJhbnNsYXRlWDpnfSksdGhpcy5zY3JvbGxiYXJMZWZ0PWYsdGhpcy5zY3JvbGxiYXJUb3A9MCksMTI+PWs/dGhpcy5zY3JvbGxiYXJSaWZsZXMuaGlkZSgpOnRoaXMuc2Nyb2xsYmFyUmlmbGVzLnNob3coITApLCExPT09Yy5zaG93RnVsbCYmKDA+PWEmJjE8PWI/dGhpcy5ncm91cC5oaWRlKCk6dGhpcy5ncm91cC5zaG93KCkpLHRoaXMucmVuZGVyZWQ9ITApfSxpbml0RXZlbnRzOmZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLm1vdXNlTW92ZUhhbmRsZXI9ZnVuY3Rpb24oYil7dmFyIGM9YS5jaGFydC5wb2ludGVyLm5vcm1hbGl6ZShiKSxlPWEub3B0aW9ucy52ZXJ0aWNhbD9cImNoYXJ0WVwiOlwiY2hhcnRYXCIsZj1hLmluaXRQb3NpdGlvbnM7IWEuZ3JhYmJlZENlbnRlcnx8Yi50b3VjaGVzJiYwPT09Yi50b3VjaGVzWzBdW2VdfHxcbihjPWEuY3Vyc29yVG9TY3JvbGxiYXJQb3NpdGlvbihjKVtlXSxlPWFbZV0sZT1jLWUsYS5oYXNEcmFnZ2VkPSEwLGEudXBkYXRlUG9zaXRpb24oZlswXStlLGZbMV0rZSksYS5oYXNEcmFnZ2VkJiZ1KGEsXCJjaGFuZ2VkXCIse2Zyb206YS5mcm9tLHRvOmEudG8sdHJpZ2dlcjpcInNjcm9sbGJhclwiLERPTVR5cGU6Yi50eXBlLERPTUV2ZW50OmJ9KSl9O2EubW91c2VVcEhhbmRsZXI9ZnVuY3Rpb24oYil7YS5oYXNEcmFnZ2VkJiZ1KGEsXCJjaGFuZ2VkXCIse2Zyb206YS5mcm9tLHRvOmEudG8sdHJpZ2dlcjpcInNjcm9sbGJhclwiLERPTVR5cGU6Yi50eXBlLERPTUV2ZW50OmJ9KTthLmdyYWJiZWRDZW50ZXI9YS5oYXNEcmFnZ2VkPWEuY2hhcnRYPWEuY2hhcnRZPW51bGx9O2EubW91c2VEb3duSGFuZGxlcj1mdW5jdGlvbihiKXtiPWEuY2hhcnQucG9pbnRlci5ub3JtYWxpemUoYik7Yj1hLmN1cnNvclRvU2Nyb2xsYmFyUG9zaXRpb24oYik7YS5jaGFydFg9Yi5jaGFydFg7YS5jaGFydFk9Yi5jaGFydFk7XG5hLmluaXRQb3NpdGlvbnM9W2EuZnJvbSxhLnRvXTthLmdyYWJiZWRDZW50ZXI9ITB9O2EuYnV0dG9uVG9NaW5DbGljaz1mdW5jdGlvbihiKXt2YXIgYz12KGEudG8tYS5mcm9tKSphLm9wdGlvbnMuc3RlcDthLnVwZGF0ZVBvc2l0aW9uKHYoYS5mcm9tLWMpLHYoYS50by1jKSk7dShhLFwiY2hhbmdlZFwiLHtmcm9tOmEuZnJvbSx0bzphLnRvLHRyaWdnZXI6XCJzY3JvbGxiYXJcIixET01FdmVudDpifSl9O2EuYnV0dG9uVG9NYXhDbGljaz1mdW5jdGlvbihiKXt2YXIgYz0oYS50by1hLmZyb20pKmEub3B0aW9ucy5zdGVwO2EudXBkYXRlUG9zaXRpb24oYS5mcm9tK2MsYS50bytjKTt1KGEsXCJjaGFuZ2VkXCIse2Zyb206YS5mcm9tLHRvOmEudG8sdHJpZ2dlcjpcInNjcm9sbGJhclwiLERPTUV2ZW50OmJ9KX07YS50cmFja0NsaWNrPWZ1bmN0aW9uKGIpe3ZhciBjPWEuY2hhcnQucG9pbnRlci5ub3JtYWxpemUoYiksZT1hLnRvLWEuZnJvbSxmPWEueSthLnNjcm9sbGJhclRvcCxnPWEueCthLnNjcm9sbGJhckxlZnQ7XG5hLm9wdGlvbnMudmVydGljYWwmJmMuY2hhcnRZPmZ8fCFhLm9wdGlvbnMudmVydGljYWwmJmMuY2hhcnRYPmc/YS51cGRhdGVQb3NpdGlvbihhLmZyb20rZSxhLnRvK2UpOmEudXBkYXRlUG9zaXRpb24oYS5mcm9tLWUsYS50by1lKTt1KGEsXCJjaGFuZ2VkXCIse2Zyb206YS5mcm9tLHRvOmEudG8sdHJpZ2dlcjpcInNjcm9sbGJhclwiLERPTUV2ZW50OmJ9KX19LGN1cnNvclRvU2Nyb2xsYmFyUG9zaXRpb246ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5vcHRpb25zLGI9Yi5taW5XaWR0aD50aGlzLmNhbGN1bGF0ZWRXaWR0aD9iLm1pbldpZHRoOjA7cmV0dXJue2NoYXJ0WDooYS5jaGFydFgtdGhpcy54LXRoaXMueE9mZnNldCkvKHRoaXMuYmFyV2lkdGgtYiksY2hhcnRZOihhLmNoYXJ0WS10aGlzLnktdGhpcy55T2Zmc2V0KS8odGhpcy5iYXJXaWR0aC1iKX19LHVwZGF0ZVBvc2l0aW9uOmZ1bmN0aW9uKGEsYil7MTxiJiYoYT12KDEtdihiLWEpKSxiPTEpOzA+YSYmKGI9dihiLWEpLGE9MCk7XG50aGlzLmZyb209YTt0aGlzLnRvPWJ9LHVwZGF0ZTpmdW5jdGlvbihhKXt0aGlzLmRlc3Ryb3koKTt0aGlzLmluaXQodGhpcy5jaGFydC5yZW5kZXJlcixnKCEwLHRoaXMub3B0aW9ucyxhKSx0aGlzLmNoYXJ0KX0sYWRkRXZlbnRzOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zLmludmVydGVkP1sxLDBdOlswLDFdLGI9dGhpcy5zY3JvbGxiYXJCdXR0b25zLGM9dGhpcy5zY3JvbGxiYXJHcm91cC5lbGVtZW50LGU9dGhpcy5tb3VzZURvd25IYW5kbGVyLGY9dGhpcy5tb3VzZU1vdmVIYW5kbGVyLGc9dGhpcy5tb3VzZVVwSGFuZGxlcixhPVtbYlthWzBdXS5lbGVtZW50LFwiY2xpY2tcIix0aGlzLmJ1dHRvblRvTWluQ2xpY2tdLFtiW2FbMV1dLmVsZW1lbnQsXCJjbGlja1wiLHRoaXMuYnV0dG9uVG9NYXhDbGlja10sW3RoaXMudHJhY2suZWxlbWVudCxcImNsaWNrXCIsdGhpcy50cmFja0NsaWNrXSxbYyxcIm1vdXNlZG93blwiLGVdLFtjLm93bmVyRG9jdW1lbnQsXCJtb3VzZW1vdmVcIixmXSxbYy5vd25lckRvY3VtZW50LFxuXCJtb3VzZXVwXCIsZ11dO3omJmEucHVzaChbYyxcInRvdWNoc3RhcnRcIixlXSxbYy5vd25lckRvY3VtZW50LFwidG91Y2htb3ZlXCIsZl0sW2Mub3duZXJEb2N1bWVudCxcInRvdWNoZW5kXCIsZ10pO3QoYSxmdW5jdGlvbihhKXtFLmFwcGx5KG51bGwsYSl9KTt0aGlzLl9ldmVudHM9YX0scmVtb3ZlRXZlbnRzOmZ1bmN0aW9uKCl7dCh0aGlzLl9ldmVudHMsZnVuY3Rpb24oYSl7ZS5hcHBseShudWxsLGEpfSk7dGhpcy5fZXZlbnRzLmxlbmd0aD0wfSxkZXN0cm95OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jaGFydC5zY3JvbGxlcjt0aGlzLnJlbW92ZUV2ZW50cygpO3QoW1widHJhY2tcIixcInNjcm9sbGJhclJpZmxlc1wiLFwic2Nyb2xsYmFyXCIsXCJzY3JvbGxiYXJHcm91cFwiLFwiZ3JvdXBcIl0sZnVuY3Rpb24oYSl7dGhpc1thXSYmdGhpc1thXS5kZXN0cm95JiYodGhpc1thXT10aGlzW2FdLmRlc3Ryb3koKSl9LHRoaXMpO2EmJnRoaXM9PT1hLnNjcm9sbGJhciYmKGEuc2Nyb2xsYmFyPW51bGwsdyhhLnNjcm9sbGJhckJ1dHRvbnMpKX19O1xuYyhILnByb3RvdHlwZSxcImluaXRcIixmdW5jdGlvbihhKXt2YXIgYj10aGlzO2EuYXBwbHkoYixBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpO2Iub3B0aW9ucy5zY3JvbGxiYXImJmIub3B0aW9ucy5zY3JvbGxiYXIuZW5hYmxlZCYmKGIub3B0aW9ucy5zY3JvbGxiYXIudmVydGljYWw9IWIuaG9yaXosYi5vcHRpb25zLnN0YXJ0T25UaWNrPWIub3B0aW9ucy5lbmRPblRpY2s9ITEsYi5zY3JvbGxiYXI9bmV3IEcoYi5jaGFydC5yZW5kZXJlcixiLm9wdGlvbnMuc2Nyb2xsYmFyLGIuY2hhcnQpLEUoYi5zY3JvbGxiYXIsXCJjaGFuZ2VkXCIsZnVuY3Rpb24oYSl7dmFyIGM9TWF0aC5taW4oZihiLm9wdGlvbnMubWluLGIubWluKSxiLm1pbixiLmRhdGFNaW4pLGU9TWF0aC5tYXgoZihiLm9wdGlvbnMubWF4LGIubWF4KSxiLm1heCxiLmRhdGFNYXgpLWMsZztiLmhvcml6JiYhYi5yZXZlcnNlZHx8IWIuaG9yaXomJmIucmV2ZXJzZWQ/KGc9YytlKnRoaXMudG8sYys9ZSpcbnRoaXMuZnJvbSk6KGc9YytlKigxLXRoaXMuZnJvbSksYys9ZSooMS10aGlzLnRvKSk7Yi5zZXRFeHRyZW1lcyhjLGcsITAsITEsYSl9KSl9KTtjKEgucHJvdG90eXBlLFwicmVuZGVyXCIsZnVuY3Rpb24oYSl7dmFyIGI9TWF0aC5taW4oZih0aGlzLm9wdGlvbnMubWluLHRoaXMubWluKSx0aGlzLm1pbixmKHRoaXMuZGF0YU1pbix0aGlzLm1pbikpLGM9TWF0aC5tYXgoZih0aGlzLm9wdGlvbnMubWF4LHRoaXMubWF4KSx0aGlzLm1heCxmKHRoaXMuZGF0YU1heCx0aGlzLm1heCkpLGU9dGhpcy5zY3JvbGxiYXIsZz10aGlzLnRpdGxlT2Zmc2V0fHwwO2EuYXBwbHkodGhpcyxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpO2lmKGUpe3RoaXMuaG9yaXo/KGUucG9zaXRpb24odGhpcy5sZWZ0LHRoaXMudG9wK3RoaXMuaGVpZ2h0KzIrdGhpcy5jaGFydC5zY3JvbGxiYXJzT2Zmc2V0c1sxXSsodGhpcy5vcHBvc2l0ZT8wOmcrdGhpcy5heGlzVGl0bGVNYXJnaW4rdGhpcy5vZmZzZXQpLFxudGhpcy53aWR0aCx0aGlzLmhlaWdodCksZz0xKTooZS5wb3NpdGlvbih0aGlzLmxlZnQrdGhpcy53aWR0aCsyK3RoaXMuY2hhcnQuc2Nyb2xsYmFyc09mZnNldHNbMF0rKHRoaXMub3Bwb3NpdGU/Zyt0aGlzLmF4aXNUaXRsZU1hcmdpbit0aGlzLm9mZnNldDowKSx0aGlzLnRvcCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxnPTApO2lmKCF0aGlzLm9wcG9zaXRlJiYhdGhpcy5ob3Jpenx8dGhpcy5vcHBvc2l0ZSYmdGhpcy5ob3Jpeil0aGlzLmNoYXJ0LnNjcm9sbGJhcnNPZmZzZXRzW2ddKz10aGlzLnNjcm9sbGJhci5zaXplK3RoaXMuc2Nyb2xsYmFyLm9wdGlvbnMubWFyZ2luO2lzTmFOKGIpfHxpc05hTihjKXx8IXEodGhpcy5taW4pfHwhcSh0aGlzLm1heCk/ZS5zZXRSYW5nZSgwLDApOihnPSh0aGlzLm1pbi1iKS8oYy1iKSxiPSh0aGlzLm1heC1iKS8oYy1iKSx0aGlzLmhvcml6JiYhdGhpcy5yZXZlcnNlZHx8IXRoaXMuaG9yaXomJnRoaXMucmV2ZXJzZWQ/ZS5zZXRSYW5nZShnLFxuYik6ZS5zZXRSYW5nZSgxLWIsMS1nKSl9fSk7YyhILnByb3RvdHlwZSxcImdldE9mZnNldFwiLGZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuaG9yaXo/MjoxLGM9dGhpcy5zY3JvbGxiYXI7YS5hcHBseSh0aGlzLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSk7YyYmKHRoaXMuY2hhcnQuc2Nyb2xsYmFyc09mZnNldHM9WzAsMF0sdGhpcy5jaGFydC5heGlzT2Zmc2V0W2JdKz1jLnNpemUrYy5vcHRpb25zLm1hcmdpbil9KTtjKEgucHJvdG90eXBlLFwiZGVzdHJveVwiLGZ1bmN0aW9uKGEpe3RoaXMuc2Nyb2xsYmFyJiYodGhpcy5zY3JvbGxiYXI9dGhpcy5zY3JvbGxiYXIuZGVzdHJveSgpKTthLmFwcGx5KHRoaXMsQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKX0pO2EuU2Nyb2xsYmFyPUd9KShMKTsoZnVuY3Rpb24oYSl7ZnVuY3Rpb24gRyhhKXt0aGlzLmluaXQoYSl9dmFyIEU9YS5hZGRFdmVudCxIPWEuQXhpcyx2PWEuQ2hhcnQsaz1hLmNvbG9yLFxucT1hLmRlZmF1bHRPcHRpb25zLHc9YS5kZWZpbmVkLHQ9YS5kZXN0cm95T2JqZWN0UHJvcGVydGllcyx1PWEuZWFjaCx6PWEuZXJhc2UsbT1hLmVycm9yLGc9YS5leHRlbmQsZj1hLmdyZXAsZT1hLmhhc1RvdWNoLGM9YS5pc0FycmF5LGI9YS5pc051bWJlcixyPWEuaXNPYmplY3QsbD1hLm1lcmdlLEM9YS5waWNrLEk9YS5yZW1vdmVFdmVudCx4PWEuU2Nyb2xsYmFyLEY9YS5TZXJpZXMsbj1hLnNlcmllc1R5cGVzLEI9YS53cmFwLEo9W10uY29uY2F0KGEuZGVmYXVsdERhdGFHcm91cGluZ1VuaXRzKSxBPWZ1bmN0aW9uKGEpe3ZhciBkPWYoYXJndW1lbnRzLGIpO2lmKGQubGVuZ3RoKXJldHVybiBNYXRoW2FdLmFwcGx5KDAsZCl9O0pbNF09W1wiZGF5XCIsWzEsMiwzLDRdXTtKWzVdPVtcIndlZWtcIixbMSwyLDNdXTtuPXZvaWQgMD09PW4uYXJlYXNwbGluZT9cImxpbmVcIjpcImFyZWFzcGxpbmVcIjtnKHEse25hdmlnYXRvcjp7aGVpZ2h0OjQwLG1hcmdpbjoyNSxtYXNrSW5zaWRlOiEwLGhhbmRsZXM6e3dpZHRoOjcsXG5oZWlnaHQ6MTUsc3ltYm9sczpbXCJuYXZpZ2F0b3ItaGFuZGxlXCIsXCJuYXZpZ2F0b3ItaGFuZGxlXCJdLGVuYWJsZWQ6ITAsbGluZVdpZHRoOjEsYmFja2dyb3VuZENvbG9yOlwiI2YyZjJmMlwiLGJvcmRlckNvbG9yOlwiIzk5OTk5OVwifSxtYXNrRmlsbDprKFwiIzY2ODVjMlwiKS5zZXRPcGFjaXR5KC4zKS5nZXQoKSxvdXRsaW5lQ29sb3I6XCIjY2NjY2NjXCIsb3V0bGluZVdpZHRoOjEsc2VyaWVzOnt0eXBlOm4sZmlsbE9wYWNpdHk6LjA1LGxpbmVXaWR0aDoxLGNvbXBhcmU6bnVsbCxkYXRhR3JvdXBpbmc6e2FwcHJveGltYXRpb246XCJhdmVyYWdlXCIsZW5hYmxlZDohMCxncm91cFBpeGVsV2lkdGg6MixzbW9vdGhlZDohMCx1bml0czpKfSxkYXRhTGFiZWxzOntlbmFibGVkOiExLHpJbmRleDoyfSxpZDpcImhpZ2hjaGFydHMtbmF2aWdhdG9yLXNlcmllc1wiLGNsYXNzTmFtZTpcImhpZ2hjaGFydHMtbmF2aWdhdG9yLXNlcmllc1wiLGxpbmVDb2xvcjpudWxsLG1hcmtlcjp7ZW5hYmxlZDohMX0scG9pbnRSYW5nZTowLFxudGhyZXNob2xkOm51bGx9LHhBeGlzOntvdmVyc2Nyb2xsOjAsY2xhc3NOYW1lOlwiaGlnaGNoYXJ0cy1uYXZpZ2F0b3IteGF4aXNcIix0aWNrTGVuZ3RoOjAsbGluZVdpZHRoOjAsZ3JpZExpbmVDb2xvcjpcIiNlNmU2ZTZcIixncmlkTGluZVdpZHRoOjEsdGlja1BpeGVsSW50ZXJ2YWw6MjAwLGxhYmVsczp7YWxpZ246XCJsZWZ0XCIsc3R5bGU6e2NvbG9yOlwiIzk5OTk5OVwifSx4OjMseTotNH0sY3Jvc3NoYWlyOiExfSx5QXhpczp7Y2xhc3NOYW1lOlwiaGlnaGNoYXJ0cy1uYXZpZ2F0b3IteWF4aXNcIixncmlkTGluZVdpZHRoOjAsc3RhcnRPblRpY2s6ITEsZW5kT25UaWNrOiExLG1pblBhZGRpbmc6LjEsbWF4UGFkZGluZzouMSxsYWJlbHM6e2VuYWJsZWQ6ITF9LGNyb3NzaGFpcjohMSx0aXRsZTp7dGV4dDpudWxsfSx0aWNrTGVuZ3RoOjAsdGlja1dpZHRoOjB9fX0pO2EuUmVuZGVyZXIucHJvdG90eXBlLnN5bWJvbHNbXCJuYXZpZ2F0b3ItaGFuZGxlXCJdPWZ1bmN0aW9uKGEsYixjLGUsZil7YT1mLndpZHRoL1xuMjtiPU1hdGgucm91bmQoYS8zKSsuNTtmPWYuaGVpZ2h0O3JldHVybltcIk1cIiwtYS0xLC41LFwiTFwiLGEsLjUsXCJMXCIsYSxmKy41LFwiTFwiLC1hLTEsZisuNSxcIkxcIiwtYS0xLC41LFwiTVwiLC1iLDQsXCJMXCIsLWIsZi0zLFwiTVwiLGItMSw0LFwiTFwiLGItMSxmLTNdfTtHLnByb3RvdHlwZT17ZHJhd0hhbmRsZTpmdW5jdGlvbihhLGIsYyxlKXt2YXIgZD10aGlzLm5hdmlnYXRvck9wdGlvbnMuaGFuZGxlcy5oZWlnaHQ7dGhpcy5oYW5kbGVzW2JdW2VdKGM/e3RyYW5zbGF0ZVg6TWF0aC5yb3VuZCh0aGlzLmxlZnQrdGhpcy5oZWlnaHQvMiksdHJhbnNsYXRlWTpNYXRoLnJvdW5kKHRoaXMudG9wK3BhcnNlSW50KGEsMTApKy41LWQpfTp7dHJhbnNsYXRlWDpNYXRoLnJvdW5kKHRoaXMubGVmdCtwYXJzZUludChhLDEwKSksdHJhbnNsYXRlWTpNYXRoLnJvdW5kKHRoaXMudG9wK3RoaXMuaGVpZ2h0LzItZC8yLTEpfSl9LGRyYXdPdXRsaW5lOmZ1bmN0aW9uKGEsYixjLGUpe3ZhciBkPXRoaXMubmF2aWdhdG9yT3B0aW9ucy5tYXNrSW5zaWRlLFxuaD10aGlzLm91dGxpbmUuc3Ryb2tlV2lkdGgoKSxmPWgvMixoPWglMi8yLGc9dGhpcy5vdXRsaW5lSGVpZ2h0LHA9dGhpcy5zY3JvbGxiYXJIZWlnaHQsaz10aGlzLnNpemUsbj10aGlzLmxlZnQtcCxsPXRoaXMudG9wO2M/KG4tPWYsYz1sK2IraCxiPWwrYStoLGE9W1wiTVwiLG4rZyxsLXAtaCxcIkxcIixuK2csYyxcIkxcIixuLGMsXCJMXCIsbixiLFwiTFwiLG4rZyxiLFwiTFwiLG4rZyxsK2srcF0uY29uY2F0KGQ/W1wiTVwiLG4rZyxjLWYsXCJMXCIsbitnLGIrZl06W10pKTooYSs9bitwLWgsYis9bitwLWgsbCs9ZixhPVtcIk1cIixuLGwsXCJMXCIsYSxsLFwiTFwiLGEsbCtnLFwiTFwiLGIsbCtnLFwiTFwiLGIsbCxcIkxcIixuK2srMipwLGxdLmNvbmNhdChkP1tcIk1cIixhLWYsbCxcIkxcIixiK2YsbF06W10pKTt0aGlzLm91dGxpbmVbZV0oe2Q6YX0pfSxkcmF3TWFza3M6ZnVuY3Rpb24oYSxiLGMsZSl7dmFyIGQ9dGhpcy5sZWZ0LGg9dGhpcy50b3AsZj10aGlzLmhlaWdodCxnLHAsbixrO2M/KG49W2QsZCxkXSxrPVtoLGgrYSxcbmgrYl0scD1bZixmLGZdLGc9W2EsYi1hLHRoaXMuc2l6ZS1iXSk6KG49W2QsZCthLGQrYl0saz1baCxoLGhdLHA9W2EsYi1hLHRoaXMuc2l6ZS1iXSxnPVtmLGYsZl0pO3UodGhpcy5zaGFkZXMsZnVuY3Rpb24oYSxiKXthW2VdKHt4Om5bYl0seTprW2JdLHdpZHRoOnBbYl0saGVpZ2h0OmdbYl19KX0pfSxyZW5kZXJFbGVtZW50czpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLm5hdmlnYXRvck9wdGlvbnMsYz1iLm1hc2tJbnNpZGUsZT1hLmNoYXJ0LGY9ZS5pbnZlcnRlZCxnPWUucmVuZGVyZXIsbjthLm5hdmlnYXRvckdyb3VwPW49Zy5nKFwibmF2aWdhdG9yXCIpLmF0dHIoe3pJbmRleDo4LHZpc2liaWxpdHk6XCJoaWRkZW5cIn0pLmFkZCgpO3ZhciBrPXtjdXJzb3I6Zj9cIm5zLXJlc2l6ZVwiOlwiZXctcmVzaXplXCJ9O3UoWyFjLGMsIWNdLGZ1bmN0aW9uKGQsYyl7YS5zaGFkZXNbY109Zy5yZWN0KCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLW5hdmlnYXRvci1tYXNrXCIrKDE9PT1jP1wiLWluc2lkZVwiOlxuXCItb3V0c2lkZVwiKSkuYXR0cih7ZmlsbDpkP2IubWFza0ZpbGw6XCJyZ2JhKDAsMCwwLDApXCJ9KS5jc3MoMT09PWMmJmspLmFkZChuKX0pO2Eub3V0bGluZT1nLnBhdGgoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtbmF2aWdhdG9yLW91dGxpbmVcIikuYXR0cih7XCJzdHJva2Utd2lkdGhcIjpiLm91dGxpbmVXaWR0aCxzdHJva2U6Yi5vdXRsaW5lQ29sb3J9KS5hZGQobik7Yi5oYW5kbGVzLmVuYWJsZWQmJnUoWzAsMV0sZnVuY3Rpb24oZCl7Yi5oYW5kbGVzLmludmVydGVkPWUuaW52ZXJ0ZWQ7YS5oYW5kbGVzW2RdPWcuc3ltYm9sKGIuaGFuZGxlcy5zeW1ib2xzW2RdLC1iLmhhbmRsZXMud2lkdGgvMi0xLDAsYi5oYW5kbGVzLndpZHRoLGIuaGFuZGxlcy5oZWlnaHQsYi5oYW5kbGVzKTthLmhhbmRsZXNbZF0uYXR0cih7ekluZGV4OjctZH0pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1uYXZpZ2F0b3ItaGFuZGxlIGhpZ2hjaGFydHMtbmF2aWdhdG9yLWhhbmRsZS1cIitbXCJsZWZ0XCIsXCJyaWdodFwiXVtkXSkuYWRkKG4pO1xudmFyIGM9Yi5oYW5kbGVzO2EuaGFuZGxlc1tkXS5hdHRyKHtmaWxsOmMuYmFja2dyb3VuZENvbG9yLHN0cm9rZTpjLmJvcmRlckNvbG9yLFwic3Ryb2tlLXdpZHRoXCI6Yy5saW5lV2lkdGh9KS5jc3Moayl9KX0sdXBkYXRlOmZ1bmN0aW9uKGEpe3UodGhpcy5zZXJpZXN8fFtdLGZ1bmN0aW9uKGEpe2EuYmFzZVNlcmllcyYmZGVsZXRlIGEuYmFzZVNlcmllcy5uYXZpZ2F0b3JTZXJpZXN9KTt0aGlzLmRlc3Ryb3koKTtsKCEwLHRoaXMuY2hhcnQub3B0aW9ucy5uYXZpZ2F0b3IsdGhpcy5vcHRpb25zLGEpO3RoaXMuaW5pdCh0aGlzLmNoYXJ0KX0scmVuZGVyOmZ1bmN0aW9uKGQsYyxlLGgpe3ZhciBmPXRoaXMuY2hhcnQsZyxwLG49dGhpcy5zY3JvbGxiYXJIZWlnaHQsayxsPXRoaXMueEF4aXM7Zz1sLmZha2U/Zi54QXhpc1swXTpsO3ZhciBtPXRoaXMubmF2aWdhdG9yRW5hYmxlZCxxLHI9dGhpcy5yZW5kZXJlZDtwPWYuaW52ZXJ0ZWQ7dmFyIHQsdT1mLnhBeGlzWzBdLm1pblJhbmdlLHY9XG5mLnhBeGlzWzBdLm9wdGlvbnMubWF4UmFuZ2U7aWYoIXRoaXMuaGFzRHJhZ2dlZHx8dyhlKSl7aWYoIWIoZCl8fCFiKGMpKWlmKHIpZT0wLGg9QyhsLndpZHRoLGcud2lkdGgpO2Vsc2UgcmV0dXJuO3RoaXMubGVmdD1DKGwubGVmdCxmLnBsb3RMZWZ0K24rKHA/Zi5wbG90V2lkdGg6MCkpO3RoaXMuc2l6ZT1xPWs9QyhsLmxlbiwocD9mLnBsb3RIZWlnaHQ6Zi5wbG90V2lkdGgpLTIqbik7Zj1wP246aysyKm47ZT1DKGUsbC50b1BpeGVscyhkLCEwKSk7aD1DKGgsbC50b1BpeGVscyhjLCEwKSk7YihlKSYmSW5maW5pdHkhPT1NYXRoLmFicyhlKXx8KGU9MCxoPWYpO2Q9bC50b1ZhbHVlKGUsITApO2M9bC50b1ZhbHVlKGgsITApO3Q9TWF0aC5hYnMoYS5jb3JyZWN0RmxvYXQoYy1kKSk7dDx1P3RoaXMuZ3JhYmJlZExlZnQ/ZT1sLnRvUGl4ZWxzKGMtdSwhMCk6dGhpcy5ncmFiYmVkUmlnaHQmJihoPWwudG9QaXhlbHMoZCt1LCEwKSk6dyh2KSYmdD52JiYodGhpcy5ncmFiYmVkTGVmdD9cbmU9bC50b1BpeGVscyhjLXYsITApOnRoaXMuZ3JhYmJlZFJpZ2h0JiYoaD1sLnRvUGl4ZWxzKGQrdiwhMCkpKTt0aGlzLnpvb21lZE1heD1NYXRoLm1pbihNYXRoLm1heChlLGgsMCkscSk7dGhpcy56b29tZWRNaW49TWF0aC5taW4oTWF0aC5tYXgodGhpcy5maXhlZFdpZHRoP3RoaXMuem9vbWVkTWF4LXRoaXMuZml4ZWRXaWR0aDpNYXRoLm1pbihlLGgpLDApLHEpO3RoaXMucmFuZ2U9dGhpcy56b29tZWRNYXgtdGhpcy56b29tZWRNaW47cT1NYXRoLnJvdW5kKHRoaXMuem9vbWVkTWF4KTtlPU1hdGgucm91bmQodGhpcy56b29tZWRNaW4pO20mJih0aGlzLm5hdmlnYXRvckdyb3VwLmF0dHIoe3Zpc2liaWxpdHk6XCJ2aXNpYmxlXCJ9KSxyPXImJiF0aGlzLmhhc0RyYWdnZWQ/XCJhbmltYXRlXCI6XCJhdHRyXCIsdGhpcy5kcmF3TWFza3MoZSxxLHAsciksdGhpcy5kcmF3T3V0bGluZShlLHEscCxyKSx0aGlzLm5hdmlnYXRvck9wdGlvbnMuaGFuZGxlcy5lbmFibGVkJiYodGhpcy5kcmF3SGFuZGxlKGUsXG4wLHAsciksdGhpcy5kcmF3SGFuZGxlKHEsMSxwLHIpKSk7dGhpcy5zY3JvbGxiYXImJihwPyhwPXRoaXMudG9wLW4sZz10aGlzLmxlZnQtbisobXx8IWcub3Bwb3NpdGU/MDooZy50aXRsZU9mZnNldHx8MCkrZy5heGlzVGl0bGVNYXJnaW4pLG49aysyKm4pOihwPXRoaXMudG9wKyhtP3RoaXMuaGVpZ2h0Oi1uKSxnPXRoaXMubGVmdC1uKSx0aGlzLnNjcm9sbGJhci5wb3NpdGlvbihnLHAsZixuKSx0aGlzLnNjcm9sbGJhci5zZXRSYW5nZSh0aGlzLnpvb21lZE1pbi9rLHRoaXMuem9vbWVkTWF4L2spKTt0aGlzLnJlbmRlcmVkPSEwfX0sYWRkTW91c2VFdmVudHM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5jaGFydCxjPWIuY29udGFpbmVyLGg9W10sZixnO2EubW91c2VNb3ZlSGFuZGxlcj1mPWZ1bmN0aW9uKGIpe2Eub25Nb3VzZU1vdmUoYil9O2EubW91c2VVcEhhbmRsZXI9Zz1mdW5jdGlvbihiKXthLm9uTW91c2VVcChiKX07aD1hLmdldFBhcnRzRXZlbnRzKFwibW91c2Vkb3duXCIpO1xuaC5wdXNoKEUoYyxcIm1vdXNlbW92ZVwiLGYpLEUoYy5vd25lckRvY3VtZW50LFwibW91c2V1cFwiLGcpKTtlJiYoaC5wdXNoKEUoYyxcInRvdWNobW92ZVwiLGYpLEUoYy5vd25lckRvY3VtZW50LFwidG91Y2hlbmRcIixnKSksaC5jb25jYXQoYS5nZXRQYXJ0c0V2ZW50cyhcInRvdWNoc3RhcnRcIikpKTthLmV2ZW50c1RvVW5iaW5kPWg7YS5zZXJpZXMmJmEuc2VyaWVzWzBdJiZoLnB1c2goRShhLnNlcmllc1swXS54QXhpcyxcImZvdW5kRXh0cmVtZXNcIixmdW5jdGlvbigpe2IubmF2aWdhdG9yLm1vZGlmeU5hdmlnYXRvckF4aXNFeHRyZW1lcygpfSkpfSxnZXRQYXJ0c0V2ZW50czpmdW5jdGlvbihhKXt2YXIgYj10aGlzLGQ9W107dShbXCJzaGFkZXNcIixcImhhbmRsZXNcIl0sZnVuY3Rpb24oYyl7dShiW2NdLGZ1bmN0aW9uKGUsaCl7ZC5wdXNoKEUoZS5lbGVtZW50LGEsZnVuY3Rpb24oYSl7YltjK1wiTW91c2Vkb3duXCJdKGEsaCl9KSl9KX0pO3JldHVybiBkfSxzaGFkZXNNb3VzZWRvd246ZnVuY3Rpb24oYSxcbmIpe2E9dGhpcy5jaGFydC5wb2ludGVyLm5vcm1hbGl6ZShhKTt2YXIgZD10aGlzLmNoYXJ0LGM9dGhpcy54QXhpcyxlPXRoaXMuem9vbWVkTWluLGY9dGhpcy5sZWZ0LGc9dGhpcy5zaXplLHA9dGhpcy5yYW5nZSxuPWEuY2hhcnRYLGs7ZC5pbnZlcnRlZCYmKG49YS5jaGFydFksZj10aGlzLnRvcCk7MT09PWI/KHRoaXMuZ3JhYmJlZENlbnRlcj1uLHRoaXMuZml4ZWRXaWR0aD1wLHRoaXMuZHJhZ09mZnNldD1uLWUpOihhPW4tZi1wLzIsMD09PWI/YT1NYXRoLm1heCgwLGEpOjI9PT1iJiZhK3A+PWcmJihhPWctcCxrPXRoaXMuZ2V0VW5pb25FeHRyZW1lcygpLmRhdGFNYXgpLGEhPT1lJiYodGhpcy5maXhlZFdpZHRoPXAsYj1jLnRvRml4ZWRSYW5nZShhLGErcCxudWxsLGspLHcoYi5taW4pJiZkLnhBeGlzWzBdLnNldEV4dHJlbWVzKE1hdGgubWluKGIubWluLGIubWF4KSxNYXRoLm1heChiLm1pbixiLm1heCksITAsbnVsbCx7dHJpZ2dlcjpcIm5hdmlnYXRvclwifSkpKX0saGFuZGxlc01vdXNlZG93bjpmdW5jdGlvbihhLFxuYil7dGhpcy5jaGFydC5wb2ludGVyLm5vcm1hbGl6ZShhKTthPXRoaXMuY2hhcnQ7dmFyIGQ9YS54QXhpc1swXSxjPWEuaW52ZXJ0ZWQmJiFkLnJldmVyc2VkfHwhYS5pbnZlcnRlZCYmZC5yZXZlcnNlZDswPT09Yj8odGhpcy5ncmFiYmVkTGVmdD0hMCx0aGlzLm90aGVySGFuZGxlUG9zPXRoaXMuem9vbWVkTWF4LHRoaXMuZml4ZWRFeHRyZW1lPWM/ZC5taW46ZC5tYXgpOih0aGlzLmdyYWJiZWRSaWdodD0hMCx0aGlzLm90aGVySGFuZGxlUG9zPXRoaXMuem9vbWVkTWluLHRoaXMuZml4ZWRFeHRyZW1lPWM/ZC5tYXg6ZC5taW4pO2EuZml4ZWRSYW5nZT1udWxsfSxvbk1vdXNlTW92ZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLGQ9Yi5jaGFydCxjPWIubGVmdCxlPWIubmF2aWdhdG9yU2l6ZSxmPWIucmFuZ2UsZz1iLmRyYWdPZmZzZXQsbj1kLmludmVydGVkO2EudG91Y2hlcyYmMD09PWEudG91Y2hlc1swXS5wYWdlWHx8KGE9ZC5wb2ludGVyLm5vcm1hbGl6ZShhKSxkPWEuY2hhcnRYLFxubiYmKGM9Yi50b3AsZD1hLmNoYXJ0WSksYi5ncmFiYmVkTGVmdD8oYi5oYXNEcmFnZ2VkPSEwLGIucmVuZGVyKDAsMCxkLWMsYi5vdGhlckhhbmRsZVBvcykpOmIuZ3JhYmJlZFJpZ2h0PyhiLmhhc0RyYWdnZWQ9ITAsYi5yZW5kZXIoMCwwLGIub3RoZXJIYW5kbGVQb3MsZC1jKSk6Yi5ncmFiYmVkQ2VudGVyJiYoYi5oYXNEcmFnZ2VkPSEwLGQ8Zz9kPWc6ZD5lK2ctZiYmKGQ9ZStnLWYpLGIucmVuZGVyKDAsMCxkLWcsZC1nK2YpKSxiLmhhc0RyYWdnZWQmJmIuc2Nyb2xsYmFyJiZiLnNjcm9sbGJhci5vcHRpb25zLmxpdmVSZWRyYXcmJihhLkRPTVR5cGU9YS50eXBlLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtiLm9uTW91c2VVcChhKX0sMCkpKX0sb25Nb3VzZVVwOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY2hhcnQsZD10aGlzLnhBeGlzLGM9dGhpcy5zY3JvbGxiYXIsZSxmLGc9YS5ET01FdmVudHx8YTsoIXRoaXMuaGFzRHJhZ2dlZHx8YyYmYy5oYXNEcmFnZ2VkKSYmXCJzY3JvbGxiYXJcIiE9PVxuYS50cmlnZ2VyfHwodGhpcy56b29tZWRNaW49PT10aGlzLm90aGVySGFuZGxlUG9zP2U9dGhpcy5maXhlZEV4dHJlbWU6dGhpcy56b29tZWRNYXg9PT10aGlzLm90aGVySGFuZGxlUG9zJiYoZj10aGlzLmZpeGVkRXh0cmVtZSksdGhpcy56b29tZWRNYXg9PT10aGlzLnNpemUmJihmPXRoaXMuZ2V0VW5pb25FeHRyZW1lcygpLmRhdGFNYXgpLGQ9ZC50b0ZpeGVkUmFuZ2UodGhpcy56b29tZWRNaW4sdGhpcy56b29tZWRNYXgsZSxmKSx3KGQubWluKSYmYi54QXhpc1swXS5zZXRFeHRyZW1lcyhNYXRoLm1pbihkLm1pbixkLm1heCksTWF0aC5tYXgoZC5taW4sZC5tYXgpLCEwLHRoaXMuaGFzRHJhZ2dlZD8hMTpudWxsLHt0cmlnZ2VyOlwibmF2aWdhdG9yXCIsdHJpZ2dlck9wOlwibmF2aWdhdG9yLWRyYWdcIixET01FdmVudDpnfSkpO1wibW91c2Vtb3ZlXCIhPT1hLkRPTVR5cGUmJih0aGlzLmdyYWJiZWRMZWZ0PXRoaXMuZ3JhYmJlZFJpZ2h0PXRoaXMuZ3JhYmJlZENlbnRlcj10aGlzLmZpeGVkV2lkdGg9XG50aGlzLmZpeGVkRXh0cmVtZT10aGlzLm90aGVySGFuZGxlUG9zPXRoaXMuaGFzRHJhZ2dlZD10aGlzLmRyYWdPZmZzZXQ9bnVsbCl9LHJlbW92ZUV2ZW50czpmdW5jdGlvbigpe3RoaXMuZXZlbnRzVG9VbmJpbmQmJih1KHRoaXMuZXZlbnRzVG9VbmJpbmQsZnVuY3Rpb24oYSl7YSgpfSksdGhpcy5ldmVudHNUb1VuYmluZD12b2lkIDApO3RoaXMucmVtb3ZlQmFzZVNlcmllc0V2ZW50cygpfSxyZW1vdmVCYXNlU2VyaWVzRXZlbnRzOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5iYXNlU2VyaWVzfHxbXTt0aGlzLm5hdmlnYXRvckVuYWJsZWQmJmFbMF0mJighMSE9PXRoaXMubmF2aWdhdG9yT3B0aW9ucy5hZGFwdFRvVXBkYXRlZERhdGEmJnUoYSxmdW5jdGlvbihhKXtJKGEsXCJ1cGRhdGVkRGF0YVwiLHRoaXMudXBkYXRlZERhdGFIYW5kbGVyKX0sdGhpcyksYVswXS54QXhpcyYmSShhWzBdLnhBeGlzLFwiZm91bmRFeHRyZW1lc1wiLHRoaXMubW9kaWZ5QmFzZUF4aXNFeHRyZW1lcykpfSxpbml0OmZ1bmN0aW9uKGEpe3ZhciBiPVxuYS5vcHRpb25zLGQ9Yi5uYXZpZ2F0b3IsYz1kLmVuYWJsZWQsZT1iLnNjcm9sbGJhcixmPWUuZW5hYmxlZCxiPWM/ZC5oZWlnaHQ6MCxnPWY/ZS5oZWlnaHQ6MDt0aGlzLmhhbmRsZXM9W107dGhpcy5zaGFkZXM9W107dGhpcy5jaGFydD1hO3RoaXMuc2V0QmFzZVNlcmllcygpO3RoaXMuaGVpZ2h0PWI7dGhpcy5zY3JvbGxiYXJIZWlnaHQ9Zzt0aGlzLnNjcm9sbGJhckVuYWJsZWQ9Zjt0aGlzLm5hdmlnYXRvckVuYWJsZWQ9Yzt0aGlzLm5hdmlnYXRvck9wdGlvbnM9ZDt0aGlzLnNjcm9sbGJhck9wdGlvbnM9ZTt0aGlzLm91dGxpbmVIZWlnaHQ9YitnO3RoaXMub3Bwb3NpdGU9QyhkLm9wcG9zaXRlLCFjJiZhLmludmVydGVkKTt2YXIgbj10aGlzLGU9bi5iYXNlU2VyaWVzLGY9YS54QXhpcy5sZW5ndGgsaz1hLnlBeGlzLmxlbmd0aCxtPWUmJmVbMF0mJmVbMF0ueEF4aXN8fGEueEF4aXNbMF07YS5leHRyYU1hcmdpbj17dHlwZTpuLm9wcG9zaXRlP1wicGxvdFRvcFwiOlwibWFyZ2luQm90dG9tXCIsXG52YWx1ZTooY3x8IWEuaW52ZXJ0ZWQ/bi5vdXRsaW5lSGVpZ2h0OjApK2QubWFyZ2lufTthLmludmVydGVkJiYoYS5leHRyYU1hcmdpbi50eXBlPW4ub3Bwb3NpdGU/XCJtYXJnaW5SaWdodFwiOlwicGxvdExlZnRcIik7YS5pc0RpcnR5Qm94PSEwO24ubmF2aWdhdG9yRW5hYmxlZD8obi54QXhpcz1uZXcgSChhLGwoe2JyZWFrczptLm9wdGlvbnMuYnJlYWtzLG9yZGluYWw6bS5vcHRpb25zLm9yZGluYWx9LGQueEF4aXMse2lkOlwibmF2aWdhdG9yLXgtYXhpc1wiLHlBeGlzOlwibmF2aWdhdG9yLXktYXhpc1wiLGlzWDohMCx0eXBlOlwiZGF0ZXRpbWVcIixpbmRleDpmLG9mZnNldDowLGtlZXBPcmRpbmFsUGFkZGluZzohMCxzdGFydE9uVGljazohMSxlbmRPblRpY2s6ITEsbWluUGFkZGluZzowLG1heFBhZGRpbmc6MCx6b29tRW5hYmxlZDohMX0sYS5pbnZlcnRlZD97b2Zmc2V0czpbZywwLC1nLDBdLHdpZHRoOmJ9OntvZmZzZXRzOlswLC1nLDAsZ10saGVpZ2h0OmJ9KSksbi55QXhpcz1uZXcgSChhLFxubChkLnlBeGlzLHtpZDpcIm5hdmlnYXRvci15LWF4aXNcIixhbGlnblRpY2tzOiExLG9mZnNldDowLGluZGV4Omssem9vbUVuYWJsZWQ6ITF9LGEuaW52ZXJ0ZWQ/e3dpZHRoOmJ9OntoZWlnaHQ6Yn0pKSxlfHxkLnNlcmllcy5kYXRhP24udXBkYXRlTmF2aWdhdG9yU2VyaWVzKCk6MD09PWEuc2VyaWVzLmxlbmd0aCYmQihhLFwicmVkcmF3XCIsZnVuY3Rpb24oYixkKXswPGEuc2VyaWVzLmxlbmd0aCYmIW4uc2VyaWVzJiYobi5zZXRCYXNlU2VyaWVzKCksYS5yZWRyYXc9Yik7Yi5jYWxsKGEsZCl9KSxuLnJlbmRlckVsZW1lbnRzKCksbi5hZGRNb3VzZUV2ZW50cygpKTpuLnhBeGlzPXt0cmFuc2xhdGU6ZnVuY3Rpb24oYixkKXt2YXIgYz1hLnhBeGlzWzBdLGU9Yy5nZXRFeHRyZW1lcygpLGY9Yy5sZW4tMipnLGg9QShcIm1pblwiLGMub3B0aW9ucy5taW4sZS5kYXRhTWluKSxjPUEoXCJtYXhcIixjLm9wdGlvbnMubWF4LGUuZGF0YU1heCktaDtyZXR1cm4gZD9iKmMvZitoOmYqKGItaCkvY30sdG9QaXhlbHM6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMudHJhbnNsYXRlKGEpfSxcbnRvVmFsdWU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMudHJhbnNsYXRlKGEsITApfSx0b0ZpeGVkUmFuZ2U6SC5wcm90b3R5cGUudG9GaXhlZFJhbmdlLGZha2U6ITB9O2Eub3B0aW9ucy5zY3JvbGxiYXIuZW5hYmxlZCYmKGEuc2Nyb2xsYmFyPW4uc2Nyb2xsYmFyPW5ldyB4KGEucmVuZGVyZXIsbChhLm9wdGlvbnMuc2Nyb2xsYmFyLHttYXJnaW46bi5uYXZpZ2F0b3JFbmFibGVkPzA6MTAsdmVydGljYWw6YS5pbnZlcnRlZH0pLGEpLEUobi5zY3JvbGxiYXIsXCJjaGFuZ2VkXCIsZnVuY3Rpb24oYil7dmFyIGQ9bi5zaXplLGM9ZCp0aGlzLnRvLGQ9ZCp0aGlzLmZyb207bi5oYXNEcmFnZ2VkPW4uc2Nyb2xsYmFyLmhhc0RyYWdnZWQ7bi5yZW5kZXIoMCwwLGQsYyk7KGEub3B0aW9ucy5zY3JvbGxiYXIubGl2ZVJlZHJhd3x8XCJtb3VzZW1vdmVcIiE9PWIuRE9NVHlwZSkmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtuLm9uTW91c2VVcChiKX0pfSkpO24uYWRkQmFzZVNlcmllc0V2ZW50cygpO24uYWRkQ2hhcnRFdmVudHMoKX0sXG5nZXRVbmlvbkV4dHJlbWVzOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY2hhcnQueEF4aXNbMF0sZD10aGlzLnhBeGlzLGM9ZC5vcHRpb25zLGU9Yi5vcHRpb25zLGY7YSYmbnVsbD09PWIuZGF0YU1pbnx8KGY9e2RhdGFNaW46QyhjJiZjLm1pbixBKFwibWluXCIsZS5taW4sYi5kYXRhTWluLGQuZGF0YU1pbixkLm1pbikpLGRhdGFNYXg6QyhjJiZjLm1heCxBKFwibWF4XCIsZS5tYXgsYi5kYXRhTWF4LGQuZGF0YU1heCxkLm1heCkpfSk7cmV0dXJuIGZ9LHNldEJhc2VTZXJpZXM6ZnVuY3Rpb24oYSxiKXt2YXIgZD10aGlzLmNoYXJ0LGM9dGhpcy5iYXNlU2VyaWVzPVtdO2E9YXx8ZC5vcHRpb25zJiZkLm9wdGlvbnMubmF2aWdhdG9yLmJhc2VTZXJpZXN8fDA7dShkLnNlcmllc3x8W10sZnVuY3Rpb24oYixkKXtiLm9wdGlvbnMuaXNJbnRlcm5hbHx8IWIub3B0aW9ucy5zaG93SW5OYXZpZ2F0b3ImJihkIT09YSYmYi5vcHRpb25zLmlkIT09YXx8ITE9PT1iLm9wdGlvbnMuc2hvd0luTmF2aWdhdG9yKXx8XG5jLnB1c2goYil9KTt0aGlzLnhBeGlzJiYhdGhpcy54QXhpcy5mYWtlJiZ0aGlzLnVwZGF0ZU5hdmlnYXRvclNlcmllcyhiKX0sdXBkYXRlTmF2aWdhdG9yU2VyaWVzOmZ1bmN0aW9uKGIpe3ZhciBkPXRoaXMsZT1kLmNoYXJ0LGY9ZC5iYXNlU2VyaWVzLG4sayxtPWQubmF2aWdhdG9yT3B0aW9ucy5zZXJpZXMscix0PXtlbmFibGVNb3VzZVRyYWNraW5nOiExLGluZGV4Om51bGwsbGlua2VkVG86bnVsbCxncm91cDpcIm5hdlwiLHBhZFhBeGlzOiExLHhBeGlzOlwibmF2aWdhdG9yLXgtYXhpc1wiLHlBeGlzOlwibmF2aWdhdG9yLXktYXhpc1wiLHNob3dJbkxlZ2VuZDohMSxzdGFja2luZzohMSxpc0ludGVybmFsOiEwLHZpc2libGU6ITB9LHY9ZC5zZXJpZXM9YS5ncmVwKGQuc2VyaWVzfHxbXSxmdW5jdGlvbihiKXt2YXIgYz1iLmJhc2VTZXJpZXM7cmV0dXJuIDA+YS5pbkFycmF5KGMsZik/KGMmJihJKGMsXCJ1cGRhdGVkRGF0YVwiLGQudXBkYXRlZERhdGFIYW5kbGVyKSxkZWxldGUgYy5uYXZpZ2F0b3JTZXJpZXMpLFxuYi5kZXN0cm95KCksITEpOiEwfSk7ZiYmZi5sZW5ndGgmJnUoZixmdW5jdGlvbihhKXt2YXIgaD1hLm5hdmlnYXRvclNlcmllcyxwPWcoe2NvbG9yOmEuY29sb3J9LGMobSk/cS5uYXZpZ2F0b3Iuc2VyaWVzOm0pO2gmJiExPT09ZC5uYXZpZ2F0b3JPcHRpb25zLmFkYXB0VG9VcGRhdGVkRGF0YXx8KHQubmFtZT1cIk5hdmlnYXRvciBcIitmLmxlbmd0aCxuPWEub3B0aW9uc3x8e30scj1uLm5hdmlnYXRvck9wdGlvbnN8fHt9LGs9bChuLHQscCxyKSxwPXIuZGF0YXx8cC5kYXRhLGQuaGFzTmF2aWdhdG9yRGF0YT1kLmhhc05hdmlnYXRvckRhdGF8fCEhcCxrLmRhdGE9cHx8bi5kYXRhJiZuLmRhdGEuc2xpY2UoMCksaCYmaC5vcHRpb25zP2gudXBkYXRlKGssYik6KGEubmF2aWdhdG9yU2VyaWVzPWUuaW5pdFNlcmllcyhrKSxhLm5hdmlnYXRvclNlcmllcy5iYXNlU2VyaWVzPWEsdi5wdXNoKGEubmF2aWdhdG9yU2VyaWVzKSkpfSk7aWYobS5kYXRhJiYoIWZ8fCFmLmxlbmd0aCl8fGMobSkpZC5oYXNOYXZpZ2F0b3JEYXRhPVxuITEsbT1hLnNwbGF0KG0pLHUobSxmdW5jdGlvbihhLGIpe3QubmFtZT1cIk5hdmlnYXRvciBcIisodi5sZW5ndGgrMSk7az1sKHEubmF2aWdhdG9yLnNlcmllcyx7Y29sb3I6ZS5zZXJpZXNbYl0mJiFlLnNlcmllc1tiXS5vcHRpb25zLmlzSW50ZXJuYWwmJmUuc2VyaWVzW2JdLmNvbG9yfHxlLm9wdGlvbnMuY29sb3JzW2JdfHxlLm9wdGlvbnMuY29sb3JzWzBdfSx0LGEpO2suZGF0YT1hLmRhdGE7ay5kYXRhJiYoZC5oYXNOYXZpZ2F0b3JEYXRhPSEwLHYucHVzaChlLmluaXRTZXJpZXMoaykpKX0pO3RoaXMuYWRkQmFzZVNlcmllc0V2ZW50cygpfSxhZGRCYXNlU2VyaWVzRXZlbnRzOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEuYmFzZVNlcmllc3x8W107YlswXSYmYlswXS54QXhpcyYmRShiWzBdLnhBeGlzLFwiZm91bmRFeHRyZW1lc1wiLHRoaXMubW9kaWZ5QmFzZUF4aXNFeHRyZW1lcyk7dShiLGZ1bmN0aW9uKGIpe0UoYixcInNob3dcIixmdW5jdGlvbigpe3RoaXMubmF2aWdhdG9yU2VyaWVzJiZcbnRoaXMubmF2aWdhdG9yU2VyaWVzLnNldFZpc2libGUoITAsITEpfSk7RShiLFwiaGlkZVwiLGZ1bmN0aW9uKCl7dGhpcy5uYXZpZ2F0b3JTZXJpZXMmJnRoaXMubmF2aWdhdG9yU2VyaWVzLnNldFZpc2libGUoITEsITEpfSk7ITEhPT10aGlzLm5hdmlnYXRvck9wdGlvbnMuYWRhcHRUb1VwZGF0ZWREYXRhJiZiLnhBeGlzJiZFKGIsXCJ1cGRhdGVkRGF0YVwiLHRoaXMudXBkYXRlZERhdGFIYW5kbGVyKTtFKGIsXCJyZW1vdmVcIixmdW5jdGlvbigpe3RoaXMubmF2aWdhdG9yU2VyaWVzJiYoeihhLnNlcmllcyx0aGlzLm5hdmlnYXRvclNlcmllcyksdGhpcy5uYXZpZ2F0b3JTZXJpZXMucmVtb3ZlKCExKSxkZWxldGUgdGhpcy5uYXZpZ2F0b3JTZXJpZXMpfSl9LHRoaXMpfSxtb2RpZnlOYXZpZ2F0b3JBeGlzRXh0cmVtZXM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnhBeGlzLGI7YS5nZXRFeHRyZW1lcyYmKCEoYj10aGlzLmdldFVuaW9uRXh0cmVtZXMoITApKXx8Yi5kYXRhTWluPT09YS5taW4mJlxuYi5kYXRhTWF4PT09YS5tYXh8fChhLm1pbj1iLmRhdGFNaW4sYS5tYXg9Yi5kYXRhTWF4KSl9LG1vZGlmeUJhc2VBeGlzRXh0cmVtZXM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0Lm5hdmlnYXRvcixjPXRoaXMuZ2V0RXh0cmVtZXMoKSxlPWMuZGF0YU1pbixmPWMuZGF0YU1heCxjPWMubWF4LWMubWluLGc9YS5zdGlja1RvTWluLG49YS5zdGlja1RvTWF4LGs9dGhpcy5vcHRpb25zLm92ZXJzY3JvbGwsbCxtLHE9YS5zZXJpZXMmJmEuc2VyaWVzWzBdLHI9ISF0aGlzLnNldEV4dHJlbWVzO3RoaXMuZXZlbnRBcmdzJiZcInJhbmdlU2VsZWN0b3JCdXR0b25cIj09PXRoaXMuZXZlbnRBcmdzLnRyaWdnZXJ8fChnJiYobT1lLGw9bStjKSxuJiYobD1mK2ssZ3x8KG09TWF0aC5tYXgobC1jLHEmJnEueERhdGE/cS54RGF0YVswXTotTnVtYmVyLk1BWF9WQUxVRSkpKSxyJiYoZ3x8bikmJmIobSkmJih0aGlzLm1pbj10aGlzLnVzZXJNaW49bSx0aGlzLm1heD10aGlzLnVzZXJNYXg9bCkpO2Euc3RpY2tUb01pbj1cbmEuc3RpY2tUb01heD1udWxsfSx1cGRhdGVkRGF0YUhhbmRsZXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0Lm5hdmlnYXRvcixjPXRoaXMubmF2aWdhdG9yU2VyaWVzO2Euc3RpY2tUb01heD1NYXRoLnJvdW5kKGEuem9vbWVkTWF4KT49TWF0aC5yb3VuZChhLnNpemUpO2Euc3RpY2tUb01pbj1iKHRoaXMueEF4aXMubWluKSYmdGhpcy54QXhpcy5taW48PXRoaXMueERhdGFbMF0mJighdGhpcy5jaGFydC5maXhlZFJhbmdlfHwhYS5zdGlja1RvTWF4KTtjJiYhYS5oYXNOYXZpZ2F0b3JEYXRhJiYoYy5vcHRpb25zLnBvaW50U3RhcnQ9dGhpcy54RGF0YVswXSxjLnNldERhdGEodGhpcy5vcHRpb25zLmRhdGEsITEsbnVsbCwhMSkpfSxhZGRDaGFydEV2ZW50czpmdW5jdGlvbigpe0UodGhpcy5jaGFydCxcInJlZHJhd1wiLGZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5uYXZpZ2F0b3IsYj1hJiYoYS5iYXNlU2VyaWVzJiZhLmJhc2VTZXJpZXNbMF0mJmEuYmFzZVNlcmllc1swXS54QXhpc3x8XG5hLnNjcm9sbGJhciYmdGhpcy54QXhpc1swXSk7YiYmYS5yZW5kZXIoYi5taW4sYi5tYXgpfSl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt0aGlzLnJlbW92ZUV2ZW50cygpO3RoaXMueEF4aXMmJih6KHRoaXMuY2hhcnQueEF4aXMsdGhpcy54QXhpcykseih0aGlzLmNoYXJ0LmF4ZXMsdGhpcy54QXhpcykpO3RoaXMueUF4aXMmJih6KHRoaXMuY2hhcnQueUF4aXMsdGhpcy55QXhpcykseih0aGlzLmNoYXJ0LmF4ZXMsdGhpcy55QXhpcykpO3UodGhpcy5zZXJpZXN8fFtdLGZ1bmN0aW9uKGEpe2EuZGVzdHJveSYmYS5kZXN0cm95KCl9KTt1KFwic2VyaWVzIHhBeGlzIHlBeGlzIHNoYWRlcyBvdXRsaW5lIHNjcm9sbGJhclRyYWNrIHNjcm9sbGJhclJpZmxlcyBzY3JvbGxiYXJHcm91cCBzY3JvbGxiYXIgbmF2aWdhdG9yR3JvdXAgcmVuZGVyZWRcIi5zcGxpdChcIiBcIiksZnVuY3Rpb24oYSl7dGhpc1thXSYmdGhpc1thXS5kZXN0cm95JiZ0aGlzW2FdLmRlc3Ryb3koKTt0aGlzW2FdPW51bGx9LHRoaXMpO1xudShbdGhpcy5oYW5kbGVzXSxmdW5jdGlvbihhKXt0KGEpfSx0aGlzKX19O2EuTmF2aWdhdG9yPUc7QihILnByb3RvdHlwZSxcInpvb21cIixmdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5jaGFydCxlPWQub3B0aW9ucyxmPWUuY2hhcnQuem9vbVR5cGUsZz1lLm5hdmlnYXRvcixlPWUucmFuZ2VTZWxlY3RvcixuO3RoaXMuaXNYQXhpcyYmKGcmJmcuZW5hYmxlZHx8ZSYmZS5lbmFibGVkKSYmKFwieFwiPT09Zj9kLnJlc2V0Wm9vbUJ1dHRvbj1cImJsb2NrZWRcIjpcInlcIj09PWY/bj0hMTpcInh5XCI9PT1mJiZ0aGlzLm9wdGlvbnMucmFuZ2UmJihkPXRoaXMucHJldmlvdXNab29tLHcoYik/dGhpcy5wcmV2aW91c1pvb209W3RoaXMubWluLHRoaXMubWF4XTpkJiYoYj1kWzBdLGM9ZFsxXSxkZWxldGUgdGhpcy5wcmV2aW91c1pvb20pKSk7cmV0dXJuIHZvaWQgMCE9PW4/bjphLmNhbGwodGhpcyxiLGMpfSk7Qih2LnByb3RvdHlwZSxcImluaXRcIixmdW5jdGlvbihhLGIsYyl7RSh0aGlzLFwiYmVmb3JlUmVuZGVyXCIsXG5mdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucztpZihhLm5hdmlnYXRvci5lbmFibGVkfHxhLnNjcm9sbGJhci5lbmFibGVkKXRoaXMuc2Nyb2xsZXI9dGhpcy5uYXZpZ2F0b3I9bmV3IEcodGhpcyl9KTthLmNhbGwodGhpcyxiLGMpfSk7Qih2LnByb3RvdHlwZSxcInNldENoYXJ0U2l6ZVwiLGZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubGVnZW5kLGM9dGhpcy5uYXZpZ2F0b3IsZCxlLGYsZzthLmFwcGx5KHRoaXMsW10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpO2MmJihlPWImJmIub3B0aW9ucyxmPWMueEF4aXMsZz1jLnlBeGlzLGQ9Yy5zY3JvbGxiYXJIZWlnaHQsdGhpcy5pbnZlcnRlZD8oYy5sZWZ0PWMub3Bwb3NpdGU/dGhpcy5jaGFydFdpZHRoLWQtYy5oZWlnaHQ6dGhpcy5zcGFjaW5nWzNdK2QsYy50b3A9dGhpcy5wbG90VG9wK2QpOihjLmxlZnQ9dGhpcy5wbG90TGVmdCtkLGMudG9wPWMubmF2aWdhdG9yT3B0aW9ucy50b3B8fHRoaXMuY2hhcnRIZWlnaHQtYy5oZWlnaHQtZC1cbnRoaXMuc3BhY2luZ1syXS0odGhpcy5yYW5nZVNlbGVjdG9yJiZ0aGlzLmV4dHJhQm90dG9tTWFyZ2luP3RoaXMucmFuZ2VTZWxlY3Rvci5nZXRIZWlnaHQoKTowKS0oZSYmXCJib3R0b21cIj09PWUudmVydGljYWxBbGlnbiYmZS5lbmFibGVkJiYhZS5mbG9hdGluZz9iLmxlZ2VuZEhlaWdodCtDKGUubWFyZ2luLDEwKTowKSksZiYmZyYmKHRoaXMuaW52ZXJ0ZWQ/Zi5vcHRpb25zLmxlZnQ9Zy5vcHRpb25zLmxlZnQ9Yy5sZWZ0OmYub3B0aW9ucy50b3A9Zy5vcHRpb25zLnRvcD1jLnRvcCxmLnNldEF4aXNTaXplKCksZy5zZXRBeGlzU2l6ZSgpKSl9KTtCKEYucHJvdG90eXBlLFwiYWRkUG9pbnRcIixmdW5jdGlvbihhLGIsYyxlLGYpe3ZhciBkPXRoaXMub3B0aW9ucy50dXJib1RocmVzaG9sZDtkJiZ0aGlzLnhEYXRhLmxlbmd0aD5kJiZyKGIsITApJiZ0aGlzLmNoYXJ0Lm5hdmlnYXRvciYmbSgyMCwhMCk7YS5jYWxsKHRoaXMsYixjLGUsZil9KTtCKHYucHJvdG90eXBlLFwiYWRkU2VyaWVzXCIsXG5mdW5jdGlvbihhLGIsYyxlKXthPWEuY2FsbCh0aGlzLGIsITEsZSk7dGhpcy5uYXZpZ2F0b3ImJnRoaXMubmF2aWdhdG9yLnNldEJhc2VTZXJpZXMobnVsbCwhMSk7QyhjLCEwKSYmdGhpcy5yZWRyYXcoKTtyZXR1cm4gYX0pO0IoRi5wcm90b3R5cGUsXCJ1cGRhdGVcIixmdW5jdGlvbihhLGIsYyl7YS5jYWxsKHRoaXMsYiwhMSk7dGhpcy5jaGFydC5uYXZpZ2F0b3ImJiF0aGlzLm9wdGlvbnMuaXNJbnRlcm5hbCYmdGhpcy5jaGFydC5uYXZpZ2F0b3Iuc2V0QmFzZVNlcmllcyhudWxsLCExKTtDKGMsITApJiZ0aGlzLmNoYXJ0LnJlZHJhdygpfSk7di5wcm90b3R5cGUuY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24oYSl7dmFyIGI9YS5uYXZpZ2F0b3I7YiYmKGE9YS54QXhpc1swXS5nZXRFeHRyZW1lcygpLGIucmVuZGVyKGEubWluLGEubWF4KSl9KX0pKEwpOyhmdW5jdGlvbihhKXtmdW5jdGlvbiBHKGEpe3RoaXMuaW5pdChhKX12YXIgRT1hLmFkZEV2ZW50LEg9YS5BeGlzLHY9YS5DaGFydCxcbms9YS5jc3MscT1hLmNyZWF0ZUVsZW1lbnQsdz1hLmRhdGVGb3JtYXQsdD1hLmRlZmF1bHRPcHRpb25zLHU9dC5nbG9iYWwudXNlVVRDLHo9YS5kZWZpbmVkLG09YS5kZXN0cm95T2JqZWN0UHJvcGVydGllcyxnPWEuZGlzY2FyZEVsZW1lbnQsZj1hLmVhY2gsZT1hLmV4dGVuZCxjPWEuZmlyZUV2ZW50LGI9YS5EYXRlLHI9YS5pc051bWJlcixsPWEubWVyZ2UsQz1hLnBpY2ssST1hLnBJbnQseD1hLnNwbGF0LEY9YS53cmFwO2UodCx7cmFuZ2VTZWxlY3Rvcjp7dmVydGljYWxBbGlnbjpcInRvcFwiLGJ1dHRvblRoZW1lOntcInN0cm9rZS13aWR0aFwiOjAsd2lkdGg6MjgsaGVpZ2h0OjE4LHBhZGRpbmc6Mix6SW5kZXg6N30sZmxvYXRpbmc6ITEseDowLHk6MCxoZWlnaHQ6dm9pZCAwLGlucHV0UG9zaXRpb246e2FsaWduOlwicmlnaHRcIix4OjAseTowfSxidXR0b25Qb3NpdGlvbjp7YWxpZ246XCJsZWZ0XCIseDowLHk6MH0sbGFiZWxTdHlsZTp7Y29sb3I6XCIjNjY2NjY2XCJ9fX0pO3QubGFuZz1sKHQubGFuZyxcbntyYW5nZVNlbGVjdG9yWm9vbTpcIlpvb21cIixyYW5nZVNlbGVjdG9yRnJvbTpcIkZyb21cIixyYW5nZVNlbGVjdG9yVG86XCJUb1wifSk7Ry5wcm90b3R5cGU9e2NsaWNrQnV0dG9uOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcyxlPWMuY2hhcnQsZD1jLmJ1dHRvbk9wdGlvbnNbYV0sZz1lLnhBeGlzWzBdLG49ZS5zY3JvbGxlciYmZS5zY3JvbGxlci5nZXRVbmlvbkV4dHJlbWVzKCl8fGd8fHt9LGg9bi5kYXRhTWluLGs9bi5kYXRhTWF4LGwsbT1nJiZNYXRoLnJvdW5kKE1hdGgubWluKGcubWF4LEMoayxnLm1heCkpKSxxPWQudHlwZSx0LG49ZC5fcmFuZ2Usdix3LEIsej1kLmRhdGFHcm91cGluZztpZihudWxsIT09aCYmbnVsbCE9PWspe2UuZml4ZWRSYW5nZT1uO3omJih0aGlzLmZvcmNlZERhdGFHcm91cGluZz0hMCxILnByb3RvdHlwZS5zZXREYXRhR3JvdXBpbmcuY2FsbChnfHx7Y2hhcnQ6dGhpcy5jaGFydH0seiwhMSkpO2lmKFwibW9udGhcIj09PXF8fFwieWVhclwiPT09cSlnPyhxPXtyYW5nZTpkLFxubWF4Om0sZGF0YU1pbjpoLGRhdGFNYXg6a30sbD1nLm1pbkZyb21SYW5nZS5jYWxsKHEpLHIocS5uZXdNYXgpJiYobT1xLm5ld01heCkpOm49ZDtlbHNlIGlmKG4pbD1NYXRoLm1heChtLW4saCksbT1NYXRoLm1pbihsK24sayk7ZWxzZSBpZihcInl0ZFwiPT09cSlpZihnKXZvaWQgMD09PWsmJihoPU51bWJlci5NQVhfVkFMVUUsaz1OdW1iZXIuTUlOX1ZBTFVFLGYoZS5zZXJpZXMsZnVuY3Rpb24oYSl7YT1hLnhEYXRhO2g9TWF0aC5taW4oYVswXSxoKTtrPU1hdGgubWF4KGFbYS5sZW5ndGgtMV0sayl9KSxiPSExKSxtPWMuZ2V0WVRERXh0cmVtZXMoayxoLHUpLGw9dj1tLm1pbixtPW0ubWF4O2Vsc2V7RShlLFwiYmVmb3JlUmVuZGVyXCIsZnVuY3Rpb24oKXtjLmNsaWNrQnV0dG9uKGEpfSk7cmV0dXJufWVsc2VcImFsbFwiPT09cSYmZyYmKGw9aCxtPWspO2wrPWQuX29mZnNldE1pbjttKz1kLl9vZmZzZXRNYXg7Yy5zZXRTZWxlY3RlZChhKTtnP2cuc2V0RXh0cmVtZXMobCxtLEMoYiwxKSxudWxsLFxue3RyaWdnZXI6XCJyYW5nZVNlbGVjdG9yQnV0dG9uXCIscmFuZ2VTZWxlY3RvckJ1dHRvbjpkfSk6KHQ9eChlLm9wdGlvbnMueEF4aXMpWzBdLEI9dC5yYW5nZSx0LnJhbmdlPW4sdz10Lm1pbix0Lm1pbj12LEUoZSxcImxvYWRcIixmdW5jdGlvbigpe3QucmFuZ2U9Qjt0Lm1pbj13fSkpfX0sc2V0U2VsZWN0ZWQ6ZnVuY3Rpb24oYSl7dGhpcy5zZWxlY3RlZD10aGlzLm9wdGlvbnMuc2VsZWN0ZWQ9YX0sZGVmYXVsdEJ1dHRvbnM6W3t0eXBlOlwibW9udGhcIixjb3VudDoxLHRleHQ6XCIxbVwifSx7dHlwZTpcIm1vbnRoXCIsY291bnQ6Myx0ZXh0OlwiM21cIn0se3R5cGU6XCJtb250aFwiLGNvdW50OjYsdGV4dDpcIjZtXCJ9LHt0eXBlOlwieXRkXCIsdGV4dDpcIllURFwifSx7dHlwZTpcInllYXJcIixjb3VudDoxLHRleHQ6XCIxeVwifSx7dHlwZTpcImFsbFwiLHRleHQ6XCJBbGxcIn1dLGluaXQ6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxlPWEub3B0aW9ucy5yYW5nZVNlbGVjdG9yLGc9ZS5idXR0b25zfHxbXS5jb25jYXQoYi5kZWZhdWx0QnV0dG9ucyksXG5kPWUuc2VsZWN0ZWQsbj1mdW5jdGlvbigpe3ZhciBhPWIubWluSW5wdXQsZD1iLm1heElucHV0O2EmJmEuYmx1ciYmYyhhLFwiYmx1clwiKTtkJiZkLmJsdXImJmMoZCxcImJsdXJcIil9O2IuY2hhcnQ9YTtiLm9wdGlvbnM9ZTtiLmJ1dHRvbnM9W107YS5leHRyYVRvcE1hcmdpbj1lLmhlaWdodDtiLmJ1dHRvbk9wdGlvbnM9Zzt0aGlzLnVuTW91c2VEb3duPUUoYS5jb250YWluZXIsXCJtb3VzZWRvd25cIixuKTt0aGlzLnVuUmVzaXplPUUoYSxcInJlc2l6ZVwiLG4pO2YoZyxiLmNvbXB1dGVCdXR0b25SYW5nZSk7dm9pZCAwIT09ZCYmZ1tkXSYmdGhpcy5jbGlja0J1dHRvbihkLCExKTtFKGEsXCJsb2FkXCIsZnVuY3Rpb24oKXthLnhBeGlzJiZhLnhBeGlzWzBdJiZFKGEueEF4aXNbMF0sXCJzZXRFeHRyZW1lc1wiLGZ1bmN0aW9uKGMpe3RoaXMubWF4LXRoaXMubWluIT09YS5maXhlZFJhbmdlJiZcInJhbmdlU2VsZWN0b3JCdXR0b25cIiE9PWMudHJpZ2dlciYmXCJ1cGRhdGVkRGF0YVwiIT09Yy50cmlnZ2VyJiZcbmIuZm9yY2VkRGF0YUdyb3VwaW5nJiZ0aGlzLnNldERhdGFHcm91cGluZyghMSwhMSl9KX0pfSx1cGRhdGVCdXR0b25TdGF0ZXM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0LGI9YS54QXhpc1swXSxjPU1hdGgucm91bmQoYi5tYXgtYi5taW4pLGU9IWIuaGFzVmlzaWJsZVNlcmllcyxhPWEuc2Nyb2xsZXImJmEuc2Nyb2xsZXIuZ2V0VW5pb25FeHRyZW1lcygpfHxiLGQ9YS5kYXRhTWluLGc9YS5kYXRhTWF4LGE9dGhpcy5nZXRZVERFeHRyZW1lcyhnLGQsdSksaz1hLm1pbixoPWEubWF4LGw9dGhpcy5zZWxlY3RlZCxtPXIobCkscT10aGlzLm9wdGlvbnMuYWxsQnV0dG9uc0VuYWJsZWQsdD10aGlzLmJ1dHRvbnM7Zih0aGlzLmJ1dHRvbk9wdGlvbnMsZnVuY3Rpb24oYSxmKXt2YXIgbj1hLl9yYW5nZSxwPWEudHlwZSxyPWEuY291bnR8fDEsdT10W2ZdLHY9MDthPWEuX29mZnNldE1heC1hLl9vZmZzZXRNaW47Zj1mPT09bDt2YXIgeT1uPmctZCxBPW48Yi5taW5SYW5nZSx3PSExLFxueD0hMSxuPW49PT1jOyhcIm1vbnRoXCI9PT1wfHxcInllYXJcIj09PXApJiZjKzM2RTU+PTg2NEU1Knttb250aDoyOCx5ZWFyOjM2NX1bcF0qcithJiZjLTM2RTU8PTg2NEU1Knttb250aDozMSx5ZWFyOjM2Nn1bcF0qcithP249ITA6XCJ5dGRcIj09PXA/KG49aC1rK2E9PT1jLHc9IWYpOlwiYWxsXCI9PT1wJiYobj1iLm1heC1iLm1pbj49Zy1kLHg9IWYmJm0mJm4pO3A9IXEmJih5fHxBfHx4fHxlKTtyPWYmJm58fG4mJiFtJiYhdztwP3Y9MzpyJiYobT0hMCx2PTIpO3Uuc3RhdGUhPT12JiZ1LnNldFN0YXRlKHYpfSl9LGNvbXB1dGVCdXR0b25SYW5nZTpmdW5jdGlvbihhKXt2YXIgYj1hLnR5cGUsYz1hLmNvdW50fHwxLGU9e21pbGxpc2Vjb25kOjEsc2Vjb25kOjFFMyxtaW51dGU6NkU0LGhvdXI6MzZFNSxkYXk6ODY0RTUsd2Vlazo2MDQ4RTV9O2lmKGVbYl0pYS5fcmFuZ2U9ZVtiXSpjO2Vsc2UgaWYoXCJtb250aFwiPT09Ynx8XCJ5ZWFyXCI9PT1iKWEuX3JhbmdlPTg2NEU1Knttb250aDozMCx5ZWFyOjM2NX1bYl0qXG5jO2EuX29mZnNldE1pbj1DKGEub2Zmc2V0TWluLDApO2EuX29mZnNldE1heD1DKGEub2Zmc2V0TWF4LDApO2EuX3JhbmdlKz1hLl9vZmZzZXRNYXgtYS5fb2Zmc2V0TWlufSxzZXRJbnB1dFZhbHVlOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5jaGFydC5vcHRpb25zLnJhbmdlU2VsZWN0b3IsZT10aGlzW2ErXCJJbnB1dFwiXTt6KGIpJiYoZS5wcmV2aW91c1ZhbHVlPWUuSENUaW1lLGUuSENUaW1lPWIpO2UudmFsdWU9dyhjLmlucHV0RWRpdERhdGVGb3JtYXR8fFwiJVktJW0tJWRcIixlLkhDVGltZSk7dGhpc1thK1wiRGF0ZUJveFwiXS5hdHRyKHt0ZXh0OncoYy5pbnB1dERhdGVGb3JtYXR8fFwiJWIgJWUsICVZXCIsZS5IQ1RpbWUpfSl9LHNob3dJbnB1dDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmlucHV0R3JvdXAsYz10aGlzW2ErXCJEYXRlQm94XCJdO2sodGhpc1thK1wiSW5wdXRcIl0se2xlZnQ6Yi50cmFuc2xhdGVYK2MueCtcInB4XCIsdG9wOmIudHJhbnNsYXRlWStcInB4XCIsd2lkdGg6Yy53aWR0aC1cbjIrXCJweFwiLGhlaWdodDpjLmhlaWdodC0yK1wicHhcIixib3JkZXI6XCIycHggc29saWQgc2lsdmVyXCJ9KX0saGlkZUlucHV0OmZ1bmN0aW9uKGEpe2sodGhpc1thK1wiSW5wdXRcIl0se2JvcmRlcjowLHdpZHRoOlwiMXB4XCIsaGVpZ2h0OlwiMXB4XCJ9KTt0aGlzLnNldElucHV0VmFsdWUoYSl9LGRyYXdJbnB1dDpmdW5jdGlvbihhKXtmdW5jdGlvbiBiKCl7dmFyIGE9di52YWx1ZSxiPShuLmlucHV0RGF0ZVBhcnNlcnx8RGF0ZS5wYXJzZSkoYSksZD1mLnhBeGlzWzBdLGU9Zi5zY3JvbGxlciYmZi5zY3JvbGxlci54QXhpcz9mLnNjcm9sbGVyLnhBeGlzOmQsZz1lLmRhdGFNaW4sZT1lLmRhdGFNYXg7YiE9PXYucHJldmlvdXNWYWx1ZSYmKHYucHJldmlvdXNWYWx1ZT1iLHIoYil8fChiPWEuc3BsaXQoXCItXCIpLGI9RGF0ZS5VVEMoSShiWzBdKSxJKGJbMV0pLTEsSShiWzJdKSkpLHIoYikmJih1fHwoYis9NkU0KihuZXcgRGF0ZSkuZ2V0VGltZXpvbmVPZmZzZXQoKSksbT9iPmMubWF4SW5wdXQuSENUaW1lP1xuYj12b2lkIDA6YjxnJiYoYj1nKTpiPGMubWluSW5wdXQuSENUaW1lP2I9dm9pZCAwOmI+ZSYmKGI9ZSksdm9pZCAwIT09YiYmZC5zZXRFeHRyZW1lcyhtP2I6ZC5taW4sbT9kLm1heDpiLHZvaWQgMCx2b2lkIDAse3RyaWdnZXI6XCJyYW5nZVNlbGVjdG9ySW5wdXRcIn0pKSl9dmFyIGM9dGhpcyxmPWMuY2hhcnQsZD1mLnJlbmRlcmVyLnN0eWxlfHx7fSxnPWYucmVuZGVyZXIsbj1mLm9wdGlvbnMucmFuZ2VTZWxlY3RvcixoPWMuZGl2LG09XCJtaW5cIj09PWEsdix3LHg9dGhpcy5pbnB1dEdyb3VwO3RoaXNbYStcIkxhYmVsXCJdPXc9Zy5sYWJlbCh0LmxhbmdbbT9cInJhbmdlU2VsZWN0b3JGcm9tXCI6XCJyYW5nZVNlbGVjdG9yVG9cIl0sdGhpcy5pbnB1dEdyb3VwLm9mZnNldCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXJhbmdlLWxhYmVsXCIpLmF0dHIoe3BhZGRpbmc6Mn0pLmFkZCh4KTt4Lm9mZnNldCs9dy53aWR0aCs1O3RoaXNbYStcIkRhdGVCb3hcIl09Zz1nLmxhYmVsKFwiXCIseC5vZmZzZXQpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1yYW5nZS1pbnB1dFwiKS5hdHRyKHtwYWRkaW5nOjIsXG53aWR0aDpuLmlucHV0Qm94V2lkdGh8fDkwLGhlaWdodDpuLmlucHV0Qm94SGVpZ2h0fHwxNyxzdHJva2U6bi5pbnB1dEJveEJvcmRlckNvbG9yfHxcIiNjY2NjY2NcIixcInN0cm9rZS13aWR0aFwiOjEsXCJ0ZXh0LWFsaWduXCI6XCJjZW50ZXJcIn0pLm9uKFwiY2xpY2tcIixmdW5jdGlvbigpe2Muc2hvd0lucHV0KGEpO2NbYStcIklucHV0XCJdLmZvY3VzKCl9KS5hZGQoeCk7eC5vZmZzZXQrPWcud2lkdGgrKG0/MTA6MCk7dGhpc1thK1wiSW5wdXRcIl09dj1xKFwiaW5wdXRcIix7bmFtZTphLGNsYXNzTmFtZTpcImhpZ2hjaGFydHMtcmFuZ2Utc2VsZWN0b3JcIix0eXBlOlwidGV4dFwifSx7dG9wOmYucGxvdFRvcCtcInB4XCJ9LGgpO3cuY3NzKGwoZCxuLmxhYmVsU3R5bGUpKTtnLmNzcyhsKHtjb2xvcjpcIiMzMzMzMzNcIn0sZCxuLmlucHV0U3R5bGUpKTtrKHYsZSh7cG9zaXRpb246XCJhYnNvbHV0ZVwiLGJvcmRlcjowLHdpZHRoOlwiMXB4XCIsaGVpZ2h0OlwiMXB4XCIscGFkZGluZzowLHRleHRBbGlnbjpcImNlbnRlclwiLGZvbnRTaXplOmQuZm9udFNpemUsXG5mb250RmFtaWx5OmQuZm9udEZhbWlseSx0b3A6XCItOTk5OWVtXCJ9LG4uaW5wdXRTdHlsZSkpO3Yub25mb2N1cz1mdW5jdGlvbigpe2Muc2hvd0lucHV0KGEpfTt2Lm9uYmx1cj1mdW5jdGlvbigpe2MuaGlkZUlucHV0KGEpfTt2Lm9uY2hhbmdlPWI7di5vbmtleXByZXNzPWZ1bmN0aW9uKGEpezEzPT09YS5rZXlDb2RlJiZiKCl9fSxnZXRQb3NpdGlvbjpmdW5jdGlvbigpe3ZhciBhPXRoaXMuY2hhcnQsYj1hLm9wdGlvbnMucmFuZ2VTZWxlY3RvcixhPVwidG9wXCI9PT1iLnZlcnRpY2FsQWxpZ24/YS5wbG90VG9wLWEuYXhpc09mZnNldFswXTowO3JldHVybntidXR0b25Ub3A6YStiLmJ1dHRvblBvc2l0aW9uLnksaW5wdXRUb3A6YStiLmlucHV0UG9zaXRpb24ueS0xMH19LGdldFlUREV4dHJlbWVzOmZ1bmN0aW9uKGEsYyxlKXt2YXIgZj1uZXcgYihhKSxkPWZbYi5oY0dldEZ1bGxZZWFyXSgpO2U9ZT9iLlVUQyhkLDAsMSk6K25ldyBiKGQsMCwxKTtjPU1hdGgubWF4KGN8fDAsZSk7Zj1mLmdldFRpbWUoKTtcbnJldHVybnttYXg6TWF0aC5taW4oYXx8ZixmKSxtaW46Y319LHJlbmRlcjpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMsZT1jLmNoYXJ0LGQ9ZS5yZW5kZXJlcixnPWUuY29udGFpbmVyLGs9ZS5vcHRpb25zLGg9ay5leHBvcnRpbmcmJiExIT09ay5leHBvcnRpbmcuZW5hYmxlZCYmay5uYXZpZ2F0aW9uJiZrLm5hdmlnYXRpb24uYnV0dG9uT3B0aW9ucyxuPXQubGFuZyxsPWMuZGl2LG09ay5yYW5nZVNlbGVjdG9yLGs9bS5mbG9hdGluZyxyPWMuYnV0dG9ucyxsPWMuaW5wdXRHcm91cCx1PW0uYnV0dG9uVGhlbWUsdj1tLmJ1dHRvblBvc2l0aW9uLHc9bS5pbnB1dFBvc2l0aW9uLHg9bS5pbnB1dEVuYWJsZWQsej11JiZ1LnN0YXRlcyxCPWUucGxvdExlZnQsRSxGPWMuYnV0dG9uR3JvdXAsRztHPWMucmVuZGVyZWQ7dmFyIEg9Yy5vcHRpb25zLnZlcnRpY2FsQWxpZ24sST1lLmxlZ2VuZCxMPUkmJkkub3B0aW9ucyxZPXYueSxYPXcueSxRPUd8fCExLFQ9MCxVPTAsVjtpZighMSE9PW0uZW5hYmxlZCl7R3x8XG4oYy5ncm91cD1HPWQuZyhcInJhbmdlLXNlbGVjdG9yLWdyb3VwXCIpLmF0dHIoe3pJbmRleDo3fSkuYWRkKCksYy5idXR0b25Hcm91cD1GPWQuZyhcInJhbmdlLXNlbGVjdG9yLWJ1dHRvbnNcIikuYWRkKEcpLGMuem9vbVRleHQ9ZC50ZXh0KG4ucmFuZ2VTZWxlY3Rvclpvb20sQyhCK3YueCxCKSwxNSkuY3NzKG0ubGFiZWxTdHlsZSkuYWRkKEYpLEU9QyhCK3YueCxCKStjLnpvb21UZXh0LmdldEJCb3goKS53aWR0aCs1LGYoYy5idXR0b25PcHRpb25zLGZ1bmN0aW9uKGEsYil7cltiXT1kLmJ1dHRvbihhLnRleHQsRSwwLGZ1bmN0aW9uKCl7dmFyIGQ9YS5ldmVudHMmJmEuZXZlbnRzLmNsaWNrLGU7ZCYmKGU9ZC5jYWxsKGEpKTshMSE9PWUmJmMuY2xpY2tCdXR0b24oYik7Yy5pc0FjdGl2ZT0hMH0sdSx6JiZ6LmhvdmVyLHomJnouc2VsZWN0LHomJnouZGlzYWJsZWQpLmF0dHIoe1widGV4dC1hbGlnblwiOlwiY2VudGVyXCJ9KS5hZGQoRik7RSs9cltiXS53aWR0aCtDKG0uYnV0dG9uU3BhY2luZyxcbjUpfSksITEhPT14JiYoYy5kaXY9bD1xKFwiZGl2XCIsbnVsbCx7cG9zaXRpb246XCJyZWxhdGl2ZVwiLGhlaWdodDowLHpJbmRleDoxfSksZy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShsLGcpLGMuaW5wdXRHcm91cD1sPWQuZyhcImlucHV0LWdyb3VwXCIpLmFkZChHKSxsLm9mZnNldD0wLGMuZHJhd0lucHV0KFwibWluXCIpLGMuZHJhd0lucHV0KFwibWF4XCIpKSk7Qj1lLnBsb3RMZWZ0LWUuc3BhY2luZ1szXTtjLnVwZGF0ZUJ1dHRvblN0YXRlcygpO2gmJnRoaXMudGl0bGVDb2xsaXNpb24oZSkmJlwidG9wXCI9PT1IJiZcInJpZ2h0XCI9PT12LmFsaWduJiZ2LnkrRi5nZXRCQm94KCkuaGVpZ2h0LTEyPChoLnl8fDApK2guaGVpZ2h0JiYoVD0tNDApO1wibGVmdFwiPT09di5hbGlnbj9WPXYueC1lLnNwYWNpbmdbM106XCJyaWdodFwiPT09di5hbGlnbiYmKFY9di54K1QtZS5zcGFjaW5nWzFdKTtGLmFsaWduKHt5OnYueSx3aWR0aDpGLmdldEJCb3goKS53aWR0aCxhbGlnbjp2LmFsaWduLHg6Vn0sITAsZS5zcGFjaW5nQm94KTtcbmMuZ3JvdXAucGxhY2VkPVE7Yy5idXR0b25Hcm91cC5wbGFjZWQ9UTshMSE9PXgmJihUPWgmJnRoaXMudGl0bGVDb2xsaXNpb24oZSkmJlwidG9wXCI9PT1IJiZcInJpZ2h0XCI9PT13LmFsaWduJiZ3LnktbC5nZXRCQm94KCkuaGVpZ2h0LTEyPChoLnl8fDApK2guaGVpZ2h0K2Uuc3BhY2luZ1swXT8tNDA6MCxcImxlZnRcIj09PXcuYWxpZ24/Vj1COlwicmlnaHRcIj09PXcuYWxpZ24mJihWPS1NYXRoLm1heChlLmF4aXNPZmZzZXRbMV0sLVQpKSxsLmFsaWduKHt5OncueSx3aWR0aDpsLmdldEJCb3goKS53aWR0aCxhbGlnbjp3LmFsaWduLHg6dy54K1YtMn0sITAsZS5zcGFjaW5nQm94KSxnPWwuYWxpZ25BdHRyLnRyYW5zbGF0ZVgrbC5hbGlnbk9wdGlvbnMueC1UK2wuZ2V0QkJveCgpLngrMixoPWwuYWxpZ25PcHRpb25zLndpZHRoLG49Ri5hbGlnbkF0dHIudHJhbnNsYXRlWCtGLmdldEJCb3goKS54LFY9Ri5nZXRCQm94KCkud2lkdGgrMjAsKHcuYWxpZ249PT12LmFsaWdufHxuK1Y+ZyYmZytoPlxubiYmWTxYK2wuZ2V0QkJveCgpLmhlaWdodCkmJmwuYXR0cih7dHJhbnNsYXRlWDpsLmFsaWduQXR0ci50cmFuc2xhdGVYKyhlLmF4aXNPZmZzZXRbMV0+PS1UPzA6LVQpLHRyYW5zbGF0ZVk6bC5hbGlnbkF0dHIudHJhbnNsYXRlWStGLmdldEJCb3goKS5oZWlnaHQrMTB9KSxjLnNldElucHV0VmFsdWUoXCJtaW5cIixhKSxjLnNldElucHV0VmFsdWUoXCJtYXhcIixiKSxjLmlucHV0R3JvdXAucGxhY2VkPVEpO2MuZ3JvdXAuYWxpZ24oe3ZlcnRpY2FsQWxpZ246SH0sITAsZS5zcGFjaW5nQm94KTthPWMuZ3JvdXAuZ2V0QkJveCgpLmhlaWdodCsyMDtiPWMuZ3JvdXAuYWxpZ25BdHRyLnRyYW5zbGF0ZVk7XCJib3R0b21cIj09PUgmJihJPUwmJlwiYm90dG9tXCI9PT1MLnZlcnRpY2FsQWxpZ24mJkwuZW5hYmxlZCYmIUwuZmxvYXRpbmc/SS5sZWdlbmRIZWlnaHQrQyhMLm1hcmdpbiwxMCk6MCxhPWErSS0yMCxVPWItYS0oaz8wOm0ueSktMTApO2lmKFwidG9wXCI9PT1IKWsmJihVPTApLGUudGl0bGVPZmZzZXQmJlxuKFU9ZS50aXRsZU9mZnNldCtlLm9wdGlvbnMudGl0bGUubWFyZ2luKSxVKz1lLm1hcmdpblswXS1lLnNwYWNpbmdbMF18fDA7ZWxzZSBpZihcIm1pZGRsZVwiPT09SClpZihYPT09WSlVPTA+WD9iK3ZvaWQgMDpiO2Vsc2UgaWYoWHx8WSlVPTA+WHx8MD5ZP1UtTWF0aC5taW4oWCxZKTpiLWErTmFOO2MuZ3JvdXAudHJhbnNsYXRlKG0ueCxtLnkrTWF0aC5mbG9vcihVKSk7ITEhPT14JiYoYy5taW5JbnB1dC5zdHlsZS5tYXJnaW5Ub3A9Yy5ncm91cC50cmFuc2xhdGVZK1wicHhcIixjLm1heElucHV0LnN0eWxlLm1hcmdpblRvcD1jLmdyb3VwLnRyYW5zbGF0ZVkrXCJweFwiKTtjLnJlbmRlcmVkPSEwfX0sZ2V0SGVpZ2h0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zLGI9dGhpcy5ncm91cCxjPWEueSxlPWEuYnV0dG9uUG9zaXRpb24ueSxhPWEuaW5wdXRQb3NpdGlvbi55LGI9Yj9iLmdldEJCb3goITApLmhlaWdodCsxMytjOjAsYz1NYXRoLm1pbihhLGUpO2lmKDA+YSYmMD5lfHwwPGEmJlxuMDxlKWIrPU1hdGguYWJzKGMpO3JldHVybiBifSx0aXRsZUNvbGxpc2lvbjpmdW5jdGlvbihhKXtyZXR1cm4hKGEub3B0aW9ucy50aXRsZS50ZXh0fHxhLm9wdGlvbnMuc3VidGl0bGUudGV4dCl9LHVwZGF0ZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmNoYXJ0O2woITAsYi5vcHRpb25zLnJhbmdlU2VsZWN0b3IsYSk7dGhpcy5kZXN0cm95KCk7dGhpcy5pbml0KGIpO2IucmFuZ2VTZWxlY3Rvci5yZW5kZXIoKX0sZGVzdHJveTpmdW5jdGlvbigpe3ZhciBiPXRoaXMsYz1iLm1pbklucHV0LGU9Yi5tYXhJbnB1dDtiLnVuTW91c2VEb3duKCk7Yi51blJlc2l6ZSgpO20oYi5idXR0b25zKTtjJiYoYy5vbmZvY3VzPWMub25ibHVyPWMub25jaGFuZ2U9bnVsbCk7ZSYmKGUub25mb2N1cz1lLm9uYmx1cj1lLm9uY2hhbmdlPW51bGwpO2Eub2JqZWN0RWFjaChiLGZ1bmN0aW9uKGEsYyl7YSYmXCJjaGFydFwiIT09YyYmKGEuZGVzdHJveT9hLmRlc3Ryb3koKTphLm5vZGVUeXBlJiZnKHRoaXNbY10pKTtcbmEhPT1HLnByb3RvdHlwZVtjXSYmKGJbY109bnVsbCl9LHRoaXMpfX07SC5wcm90b3R5cGUudG9GaXhlZFJhbmdlPWZ1bmN0aW9uKGEsYixjLGUpe3ZhciBkPXRoaXMuY2hhcnQmJnRoaXMuY2hhcnQuZml4ZWRSYW5nZTthPUMoYyx0aGlzLnRyYW5zbGF0ZShhLCEwLCF0aGlzLmhvcml6KSk7Yj1DKGUsdGhpcy50cmFuc2xhdGUoYiwhMCwhdGhpcy5ob3JpeikpO2M9ZCYmKGItYSkvZDsuNzxjJiYxLjM+YyYmKGU/YT1iLWQ6Yj1hK2QpO3IoYSkmJnIoYil8fChhPWI9dm9pZCAwKTtyZXR1cm57bWluOmEsbWF4OmJ9fTtILnByb3RvdHlwZS5taW5Gcm9tUmFuZ2U9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnJhbmdlLGI9e21vbnRoOlwiTW9udGhcIix5ZWFyOlwiRnVsbFllYXJcIn1bYS50eXBlXSxjLGU9dGhpcy5tYXgsZCxmLGc9ZnVuY3Rpb24oYSxjKXt2YXIgZD1uZXcgRGF0ZShhKSxlPWRbXCJnZXRcIitiXSgpO2RbXCJzZXRcIitiXShlK2MpO2U9PT1kW1wiZ2V0XCIrYl0oKSYmZC5zZXREYXRlKDApO3JldHVybiBkLmdldFRpbWUoKS1cbmF9O3IoYSk/KGM9ZS1hLGY9YSk6KGM9ZStnKGUsLWEuY291bnQpLHRoaXMuY2hhcnQmJih0aGlzLmNoYXJ0LmZpeGVkUmFuZ2U9ZS1jKSk7ZD1DKHRoaXMuZGF0YU1pbixOdW1iZXIuTUlOX1ZBTFVFKTtyKGMpfHwoYz1kKTtjPD1kJiYoYz1kLHZvaWQgMD09PWYmJihmPWcoYyxhLmNvdW50KSksdGhpcy5uZXdNYXg9TWF0aC5taW4oYytmLHRoaXMuZGF0YU1heCkpO3IoZSl8fChjPXZvaWQgMCk7cmV0dXJuIGN9O0Yodi5wcm90b3R5cGUsXCJpbml0XCIsZnVuY3Rpb24oYSxiLGMpe0UodGhpcyxcImluaXRcIixmdW5jdGlvbigpe3RoaXMub3B0aW9ucy5yYW5nZVNlbGVjdG9yLmVuYWJsZWQmJih0aGlzLnJhbmdlU2VsZWN0b3I9bmV3IEcodGhpcykpfSk7YS5jYWxsKHRoaXMsYixjKX0pO0Yodi5wcm90b3R5cGUsXCJyZW5kZXJcIixmdW5jdGlvbihhLGIsYyl7dmFyIGU9dGhpcy5heGVzLGQ9dGhpcy5yYW5nZVNlbGVjdG9yO2QmJihmKGUsZnVuY3Rpb24oYSl7YS51cGRhdGVOYW1lcygpO2Euc2V0U2NhbGUoKX0pLFxudGhpcy5nZXRBeGlzTWFyZ2lucygpLGQucmVuZGVyKCksZT1kLm9wdGlvbnMudmVydGljYWxBbGlnbixkLm9wdGlvbnMuZmxvYXRpbmd8fChcImJvdHRvbVwiPT09ZT90aGlzLmV4dHJhQm90dG9tTWFyZ2luPSEwOlwibWlkZGxlXCIhPT1lJiYodGhpcy5leHRyYVRvcE1hcmdpbj0hMCkpKTthLmNhbGwodGhpcyxiLGMpfSk7Rih2LnByb3RvdHlwZSxcInVwZGF0ZVwiLGZ1bmN0aW9uKGIsYyxlLGYpe3ZhciBkPXRoaXMucmFuZ2VTZWxlY3RvcixnO3RoaXMuZXh0cmFUb3BNYXJnaW49dGhpcy5leHRyYUJvdHRvbU1hcmdpbj0hMTtkJiYoZC5yZW5kZXIoKSxnPWMucmFuZ2VTZWxlY3RvciYmYy5yYW5nZVNlbGVjdG9yLnZlcnRpY2FsQWxpZ258fGQub3B0aW9ucyYmZC5vcHRpb25zLnZlcnRpY2FsQWxpZ24sZC5vcHRpb25zLmZsb2F0aW5nfHwoXCJib3R0b21cIj09PWc/dGhpcy5leHRyYUJvdHRvbU1hcmdpbj0hMDpcIm1pZGRsZVwiIT09ZyYmKHRoaXMuZXh0cmFUb3BNYXJnaW49ITApKSk7Yi5jYWxsKHRoaXMsXG5hLm1lcmdlKCEwLGMse2NoYXJ0OnttYXJnaW5Cb3R0b206QyhjLmNoYXJ0JiZjLmNoYXJ0Lm1hcmdpbkJvdHRvbSx0aGlzLm1hcmdpbi5ib3R0b20pLHNwYWNpbmdCb3R0b206QyhjLmNoYXJ0JiZjLmNoYXJ0LnNwYWNpbmdCb3R0b20sdGhpcy5zcGFjaW5nLmJvdHRvbSl9fSksZSxmKX0pO0Yodi5wcm90b3R5cGUsXCJyZWRyYXdcIixmdW5jdGlvbihhLGIsYyl7dmFyIGU9dGhpcy5yYW5nZVNlbGVjdG9yO2UmJiFlLm9wdGlvbnMuZmxvYXRpbmcmJihlLnJlbmRlcigpLGU9ZS5vcHRpb25zLnZlcnRpY2FsQWxpZ24sXCJib3R0b21cIj09PWU/dGhpcy5leHRyYUJvdHRvbU1hcmdpbj0hMDpcIm1pZGRsZVwiIT09ZSYmKHRoaXMuZXh0cmFUb3BNYXJnaW49ITApKTthLmNhbGwodGhpcyxiLGMpfSk7di5wcm90b3R5cGUuYWRqdXN0UGxvdEFyZWE9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnJhbmdlU2VsZWN0b3I7dGhpcy5yYW5nZVNlbGVjdG9yJiYoYT1hLmdldEhlaWdodCgpLHRoaXMuZXh0cmFUb3BNYXJnaW4mJlxuKHRoaXMucGxvdFRvcCs9YSksdGhpcy5leHRyYUJvdHRvbU1hcmdpbiYmKHRoaXMubWFyZ2luQm90dG9tKz1hKSl9O3YucHJvdG90eXBlLmNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoKXtjPWEueEF4aXNbMF0uZ2V0RXh0cmVtZXMoKTtyKGMubWluKSYmZS5yZW5kZXIoYy5taW4sYy5tYXgpfXZhciBjLGU9YS5yYW5nZVNlbGVjdG9yLGQsZjtlJiYoZj1FKGEueEF4aXNbMF0sXCJhZnRlclNldEV4dHJlbWVzXCIsZnVuY3Rpb24oYSl7ZS5yZW5kZXIoYS5taW4sYS5tYXgpfSksZD1FKGEsXCJyZWRyYXdcIixiKSxiKCkpO0UoYSxcImRlc3Ryb3lcIixmdW5jdGlvbigpe2UmJihkKCksZigpKX0pfSk7YS5SYW5nZVNlbGVjdG9yPUd9KShMKTsoZnVuY3Rpb24oYSl7dmFyIEc9YS5hcnJheU1heCxFPWEuYXJyYXlNaW4sSD1hLkF4aXMsdj1hLkNoYXJ0LGs9YS5kZWZpbmVkLHE9YS5lYWNoLHc9YS5leHRlbmQsdD1hLmZvcm1hdCx1PWEuZ3JlcCx6PWEuaW5BcnJheSxtPWEuaXNOdW1iZXIsXG5nPWEuaXNTdHJpbmcsZj1hLm1hcCxlPWEubWVyZ2UsYz1hLnBpY2ssYj1hLlBvaW50LHI9YS5SZW5kZXJlcixsPWEuU2VyaWVzLEM9YS5zcGxhdCxJPWEuU1ZHUmVuZGVyZXIseD1hLlZNTFJlbmRlcmVyLEY9YS53cmFwLG49bC5wcm90b3R5cGUsQj1uLmluaXQsSj1uLnByb2Nlc3NEYXRhLEE9Yi5wcm90b3R5cGUudG9vbHRpcEZvcm1hdHRlcjthLlN0b2NrQ2hhcnQ9YS5zdG9ja0NoYXJ0PWZ1bmN0aW9uKGIsayxsKXt2YXIgZD1nKGIpfHxiLm5vZGVOYW1lLG09YXJndW1lbnRzW2Q/MTowXSxwPW0uc2VyaWVzLG49YS5nZXRPcHRpb25zKCkscSxyPWMobS5uYXZpZ2F0b3ImJm0ubmF2aWdhdG9yLmVuYWJsZWQsbi5uYXZpZ2F0b3IuZW5hYmxlZCwhMCksdD1yP3tzdGFydE9uVGljazohMSxlbmRPblRpY2s6ITF9Om51bGwsdT17bWFya2VyOntlbmFibGVkOiExLHJhZGl1czoyfX0sdz17c2hhZG93OiExLGJvcmRlcldpZHRoOjB9O20ueEF4aXM9ZihDKG0ueEF4aXN8fHt9KSxmdW5jdGlvbihhKXtyZXR1cm4gZSh7bWluUGFkZGluZzowLFxubWF4UGFkZGluZzowLG92ZXJzY3JvbGw6MCxvcmRpbmFsOiEwLHRpdGxlOnt0ZXh0Om51bGx9LGxhYmVsczp7b3ZlcmZsb3c6XCJqdXN0aWZ5XCJ9LHNob3dMYXN0TGFiZWw6ITB9LG4ueEF4aXMsYSx7dHlwZTpcImRhdGV0aW1lXCIsY2F0ZWdvcmllczpudWxsfSx0KX0pO20ueUF4aXM9ZihDKG0ueUF4aXN8fHt9KSxmdW5jdGlvbihhKXtxPWMoYS5vcHBvc2l0ZSwhMCk7cmV0dXJuIGUoe2xhYmVsczp7eTotMn0sb3Bwb3NpdGU6cSxzaG93TGFzdExhYmVsOiExLHRpdGxlOnt0ZXh0Om51bGx9fSxuLnlBeGlzLGEpfSk7bS5zZXJpZXM9bnVsbDttPWUoe2NoYXJ0OntwYW5uaW5nOiEwLHBpbmNoVHlwZTpcInhcIn0sbmF2aWdhdG9yOntlbmFibGVkOnJ9LHNjcm9sbGJhcjp7ZW5hYmxlZDpjKG4uc2Nyb2xsYmFyLmVuYWJsZWQsITApfSxyYW5nZVNlbGVjdG9yOntlbmFibGVkOmMobi5yYW5nZVNlbGVjdG9yLmVuYWJsZWQsITApfSx0aXRsZTp7dGV4dDpudWxsfSx0b29sdGlwOntzcGxpdDpjKG4udG9vbHRpcC5zcGxpdCxcbiEwKSxjcm9zc2hhaXJzOiEwfSxsZWdlbmQ6e2VuYWJsZWQ6ITF9LHBsb3RPcHRpb25zOntsaW5lOnUsc3BsaW5lOnUsYXJlYTp1LGFyZWFzcGxpbmU6dSxhcmVhcmFuZ2U6dSxhcmVhc3BsaW5lcmFuZ2U6dSxjb2x1bW46dyxjb2x1bW5yYW5nZTp3LGNhbmRsZXN0aWNrOncsb2hsYzp3fX0sbSx7aXNTdG9jazohMH0pO20uc2VyaWVzPXA7cmV0dXJuIGQ/bmV3IHYoYixtLGwpOm5ldyB2KG0sayl9O0YoSC5wcm90b3R5cGUsXCJhdXRvTGFiZWxBbGlnblwiLGZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY2hhcnQsYz10aGlzLm9wdGlvbnMsYj1iLl9sYWJlbFBhbmVzPWIuX2xhYmVsUGFuZXN8fHt9LGQ9dGhpcy5vcHRpb25zLmxhYmVscztyZXR1cm4gdGhpcy5jaGFydC5vcHRpb25zLmlzU3RvY2smJlwieUF4aXNcIj09PXRoaXMuY29sbCYmKGM9Yy50b3ArXCIsXCIrYy5oZWlnaHQsIWJbY10mJmQuZW5hYmxlZCk/KDE1PT09ZC54JiYoZC54PTApLHZvaWQgMD09PWQuYWxpZ24mJihkLmFsaWduPVwicmlnaHRcIiksXG5iW2NdPXRoaXMsXCJyaWdodFwiKTphLmFwcGx5KHRoaXMsW10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpfSk7RihILnByb3RvdHlwZSxcImRlc3Ryb3lcIixmdW5jdGlvbihhKXt2YXIgYj10aGlzLmNoYXJ0LGM9dGhpcy5vcHRpb25zJiZ0aGlzLm9wdGlvbnMudG9wK1wiLFwiK3RoaXMub3B0aW9ucy5oZWlnaHQ7YyYmYi5fbGFiZWxQYW5lcyYmYi5fbGFiZWxQYW5lc1tjXT09PXRoaXMmJmRlbGV0ZSBiLl9sYWJlbFBhbmVzW2NdO3JldHVybiBhLmFwcGx5KHRoaXMsQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKX0pO0YoSC5wcm90b3R5cGUsXCJnZXRQbG90TGluZVBhdGhcIixmdW5jdGlvbihiLGUsbCxoLG4scil7dmFyIGQ9dGhpcyxwPXRoaXMuaXNMaW5rZWQmJiF0aGlzLnNlcmllcz90aGlzLmxpbmtlZFBhcmVudC5zZXJpZXM6dGhpcy5zZXJpZXMsdD1kLmNoYXJ0LHU9dC5yZW5kZXJlcix2PWQubGVmdCx3PWQudG9wLHkseCxBLEIsRD1bXSxDPVtdLEUsRjtpZihcInhBeGlzXCIhPT1cbmQuY29sbCYmXCJ5QXhpc1wiIT09ZC5jb2xsKXJldHVybiBiLmFwcGx5KHRoaXMsW10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpO0M9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ4QXhpc1wiPT09YT9cInlBeGlzXCI6XCJ4QXhpc1wiO2E9ZC5vcHRpb25zW2JdO3JldHVybiBtKGEpP1t0W2JdW2FdXTpnKGEpP1t0LmdldChhKV06ZihwLGZ1bmN0aW9uKGEpe3JldHVybiBhW2JdfSl9KGQuY29sbCk7cShkLmlzWEF4aXM/dC55QXhpczp0LnhBeGlzLGZ1bmN0aW9uKGEpe2lmKGsoYS5vcHRpb25zLmlkKT8tMT09PWEub3B0aW9ucy5pZC5pbmRleE9mKFwibmF2aWdhdG9yXCIpOjEpe3ZhciBiPWEuaXNYQXhpcz9cInlBeGlzXCI6XCJ4QXhpc1wiLGI9ayhhLm9wdGlvbnNbYl0pP3RbYl1bYS5vcHRpb25zW2JdXTp0W2JdWzBdO2Q9PT1iJiZDLnB1c2goYSl9fSk7RT1DLmxlbmd0aD9bXTpbZC5pc1hBeGlzP3QueUF4aXNbMF06dC54QXhpc1swXV07cShDLGZ1bmN0aW9uKGIpey0xIT09eihiLEUpfHxhLmZpbmQoRSxmdW5jdGlvbihhKXtyZXR1cm4gYS5wb3M9PT1cbmIucG9zJiZhLmxlbiYmYi5sZW59KXx8RS5wdXNoKGIpfSk7Rj1jKHIsZC50cmFuc2xhdGUoZSxudWxsLG51bGwsaCkpO20oRikmJihkLmhvcml6P3EoRSxmdW5jdGlvbihhKXt2YXIgYjt4PWEucG9zO0I9eCthLmxlbjt5PUE9TWF0aC5yb3VuZChGK2QudHJhbnNCKTtpZih5PHZ8fHk+ditkLndpZHRoKW4/eT1BPU1hdGgubWluKE1hdGgubWF4KHYseSksditkLndpZHRoKTpiPSEwO2J8fEQucHVzaChcIk1cIix5LHgsXCJMXCIsQSxCKX0pOnEoRSxmdW5jdGlvbihhKXt2YXIgYjt5PWEucG9zO0E9eSthLmxlbjt4PUI9TWF0aC5yb3VuZCh3K2QuaGVpZ2h0LUYpO2lmKHg8d3x8eD53K2QuaGVpZ2h0KW4/eD1CPU1hdGgubWluKE1hdGgubWF4KHcseCksZC50b3ArZC5oZWlnaHQpOmI9ITA7Ynx8RC5wdXNoKFwiTVwiLHkseCxcIkxcIixBLEIpfSkpO3JldHVybiAwPEQubGVuZ3RoP3UuY3Jpc3BQb2x5TGluZShELGx8fDEpOm51bGx9KTtJLnByb3RvdHlwZS5jcmlzcFBvbHlMaW5lPWZ1bmN0aW9uKGEsXG5iKXt2YXIgYztmb3IoYz0wO2M8YS5sZW5ndGg7Yys9NilhW2MrMV09PT1hW2MrNF0mJihhW2MrMV09YVtjKzRdPU1hdGgucm91bmQoYVtjKzFdKS1iJTIvMiksYVtjKzJdPT09YVtjKzVdJiYoYVtjKzJdPWFbYys1XT1NYXRoLnJvdW5kKGFbYysyXSkrYiUyLzIpO3JldHVybiBhfTtyPT09eCYmKHgucHJvdG90eXBlLmNyaXNwUG9seUxpbmU9SS5wcm90b3R5cGUuY3Jpc3BQb2x5TGluZSk7RihILnByb3RvdHlwZSxcImhpZGVDcm9zc2hhaXJcIixmdW5jdGlvbihhLGIpe2EuY2FsbCh0aGlzLGIpO3RoaXMuY3Jvc3NMYWJlbCYmKHRoaXMuY3Jvc3NMYWJlbD10aGlzLmNyb3NzTGFiZWwuaGlkZSgpKX0pO0YoSC5wcm90b3R5cGUsXCJkcmF3Q3Jvc3NoYWlyXCIsZnVuY3Rpb24oYSxiLGUpe3ZhciBkLGY7YS5jYWxsKHRoaXMsYixlKTtpZihrKHRoaXMuY3Jvc3NoYWlyLmxhYmVsKSYmdGhpcy5jcm9zc2hhaXIubGFiZWwuZW5hYmxlZCYmdGhpcy5jcm9zcyl7YT10aGlzLmNoYXJ0O3ZhciBnPXRoaXMub3B0aW9ucy5jcm9zc2hhaXIubGFiZWwsXG5sPXRoaXMuaG9yaXo7ZD10aGlzLm9wcG9zaXRlO2Y9dGhpcy5sZWZ0O3ZhciBtPXRoaXMudG9wLG49dGhpcy5jcm9zc0xhYmVsLHAscT1nLmZvcm1hdCxyPVwiXCIsdT1cImluc2lkZVwiPT09dGhpcy5vcHRpb25zLnRpY2tQb3NpdGlvbix2PSExIT09dGhpcy5jcm9zc2hhaXIuc25hcCx4PTA7Ynx8KGI9dGhpcy5jcm9zcyYmdGhpcy5jcm9zcy5lKTtwPWw/XCJjZW50ZXJcIjpkP1wicmlnaHRcIj09PXRoaXMubGFiZWxBbGlnbj9cInJpZ2h0XCI6XCJsZWZ0XCI6XCJsZWZ0XCI9PT10aGlzLmxhYmVsQWxpZ24/XCJsZWZ0XCI6XCJjZW50ZXJcIjtufHwobj10aGlzLmNyb3NzTGFiZWw9YS5yZW5kZXJlci5sYWJlbChudWxsLG51bGwsbnVsbCxnLnNoYXBlfHxcImNhbGxvdXRcIikuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWNyb3NzaGFpci1sYWJlbFwiKyh0aGlzLnNlcmllc1swXSYmXCIgaGlnaGNoYXJ0cy1jb2xvci1cIit0aGlzLnNlcmllc1swXS5jb2xvckluZGV4KSkuYXR0cih7YWxpZ246Zy5hbGlnbnx8cCxwYWRkaW5nOmMoZy5wYWRkaW5nLFxuOCkscjpjKGcuYm9yZGVyUmFkaXVzLDMpLHpJbmRleDoyfSkuYWRkKHRoaXMubGFiZWxHcm91cCksbi5hdHRyKHtmaWxsOmcuYmFja2dyb3VuZENvbG9yfHx0aGlzLnNlcmllc1swXSYmdGhpcy5zZXJpZXNbMF0uY29sb3J8fFwiIzY2NjY2NlwiLHN0cm9rZTpnLmJvcmRlckNvbG9yfHxcIlwiLFwic3Ryb2tlLXdpZHRoXCI6Zy5ib3JkZXJXaWR0aHx8MH0pLmNzcyh3KHtjb2xvcjpcIiNmZmZmZmZcIixmb250V2VpZ2h0Olwibm9ybWFsXCIsZm9udFNpemU6XCIxMXB4XCIsdGV4dEFsaWduOlwiY2VudGVyXCJ9LGcuc3R5bGUpKSk7bD8ocD12P2UucGxvdFgrZjpiLmNoYXJ0WCxtKz1kPzA6dGhpcy5oZWlnaHQpOihwPWQ/dGhpcy53aWR0aCtmOjAsbT12P2UucGxvdFkrbTpiLmNoYXJ0WSk7cXx8Zy5mb3JtYXR0ZXJ8fCh0aGlzLmlzRGF0ZXRpbWVBeGlzJiYocj1cIiViICVkLCAlWVwiKSxxPVwie3ZhbHVlXCIrKHI/XCI6XCIrcjpcIlwiKStcIn1cIik7Yj12P2VbdGhpcy5pc1hBeGlzP1wieFwiOlwieVwiXTp0aGlzLnRvVmFsdWUobD9cbmIuY2hhcnRYOmIuY2hhcnRZKTtuLmF0dHIoe3RleHQ6cT90KHEse3ZhbHVlOmJ9KTpnLmZvcm1hdHRlci5jYWxsKHRoaXMsYikseDpwLHk6bSx2aXNpYmlsaXR5OlwidmlzaWJsZVwifSk7Yj1uLmdldEJCb3goKTtpZihsKXtpZih1JiYhZHx8IXUmJmQpbT1uLnktYi5oZWlnaHR9ZWxzZSBtPW4ueS1iLmhlaWdodC8yO2w/KGQ9Zi1iLngsZj1mK3RoaXMud2lkdGgtYi54KTooZD1cImxlZnRcIj09PXRoaXMubGFiZWxBbGlnbj9mOjAsZj1cInJpZ2h0XCI9PT10aGlzLmxhYmVsQWxpZ24/Zit0aGlzLndpZHRoOmEuY2hhcnRXaWR0aCk7bi50cmFuc2xhdGVYPGQmJih4PWQtbi50cmFuc2xhdGVYKTtuLnRyYW5zbGF0ZVgrYi53aWR0aD49ZiYmKHg9LShuLnRyYW5zbGF0ZVgrYi53aWR0aC1mKSk7bi5hdHRyKHt4OnAreCx5Om0sYW5jaG9yWDpsP3A6dGhpcy5vcHBvc2l0ZT8wOmEuY2hhcnRXaWR0aCxhbmNob3JZOmw/dGhpcy5vcHBvc2l0ZT9hLmNoYXJ0SGVpZ2h0OjA6bStiLmhlaWdodC8yfSl9fSk7XG5uLmluaXQ9ZnVuY3Rpb24oKXtCLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLnNldENvbXBhcmUodGhpcy5vcHRpb25zLmNvbXBhcmUpfTtuLnNldENvbXBhcmU9ZnVuY3Rpb24oYSl7dGhpcy5tb2RpZnlWYWx1ZT1cInZhbHVlXCI9PT1hfHxcInBlcmNlbnRcIj09PWE/ZnVuY3Rpb24oYixjKXt2YXIgZD10aGlzLmNvbXBhcmVWYWx1ZTtpZih2b2lkIDAhPT1iJiZ2b2lkIDAhPT1kKXJldHVybiBiPVwidmFsdWVcIj09PWE/Yi1kOmIvZCoxMDAtKDEwMD09PXRoaXMub3B0aW9ucy5jb21wYXJlQmFzZT8wOjEwMCksYyYmKGMuY2hhbmdlPWIpLGJ9Om51bGw7dGhpcy51c2VyT3B0aW9ucy5jb21wYXJlPWE7dGhpcy5jaGFydC5oYXNSZW5kZXJlZCYmKHRoaXMuaXNEaXJ0eT0hMCl9O24ucHJvY2Vzc0RhdGE9ZnVuY3Rpb24oKXt2YXIgYSxiPS0xLGMsZSxmPSEwPT09dGhpcy5vcHRpb25zLmNvbXBhcmVTdGFydD8wOjEsZyxrO0ouYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKHRoaXMueEF4aXMmJnRoaXMucHJvY2Vzc2VkWURhdGEpZm9yKGM9XG50aGlzLnByb2Nlc3NlZFhEYXRhLGU9dGhpcy5wcm9jZXNzZWRZRGF0YSxnPWUubGVuZ3RoLHRoaXMucG9pbnRBcnJheU1hcCYmKGI9eihcImNsb3NlXCIsdGhpcy5wb2ludEFycmF5TWFwKSwtMT09PWImJihiPXoodGhpcy5wb2ludFZhbEtleXx8XCJ5XCIsdGhpcy5wb2ludEFycmF5TWFwKSkpLGE9MDthPGctZjthKyspaWYoaz1lW2FdJiYtMTxiP2VbYV1bYl06ZVthXSxtKGspJiZjW2ErZl0+PXRoaXMueEF4aXMubWluJiYwIT09ayl7dGhpcy5jb21wYXJlVmFsdWU9azticmVha319O0YobixcImdldEV4dHJlbWVzXCIsZnVuY3Rpb24oYSl7dmFyIGI7YS5hcHBseSh0aGlzLFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKTt0aGlzLm1vZGlmeVZhbHVlJiYoYj1bdGhpcy5tb2RpZnlWYWx1ZSh0aGlzLmRhdGFNaW4pLHRoaXMubW9kaWZ5VmFsdWUodGhpcy5kYXRhTWF4KV0sdGhpcy5kYXRhTWluPUUoYiksdGhpcy5kYXRhTWF4PUcoYikpfSk7SC5wcm90b3R5cGUuc2V0Q29tcGFyZT1mdW5jdGlvbihhLFxuYil7dGhpcy5pc1hBeGlzfHwocSh0aGlzLnNlcmllcyxmdW5jdGlvbihiKXtiLnNldENvbXBhcmUoYSl9KSxjKGIsITApJiZ0aGlzLmNoYXJ0LnJlZHJhdygpKX07Yi5wcm90b3R5cGUudG9vbHRpcEZvcm1hdHRlcj1mdW5jdGlvbihiKXtiPWIucmVwbGFjZShcIntwb2ludC5jaGFuZ2V9XCIsKDA8dGhpcy5jaGFuZ2U/XCIrXCI6XCJcIikrYS5udW1iZXJGb3JtYXQodGhpcy5jaGFuZ2UsYyh0aGlzLnNlcmllcy50b29sdGlwT3B0aW9ucy5jaGFuZ2VEZWNpbWFscywyKSkpO3JldHVybiBBLmFwcGx5KHRoaXMsW2JdKX07RihsLnByb3RvdHlwZSxcInJlbmRlclwiLGZ1bmN0aW9uKGEpe3RoaXMuY2hhcnQuaXMzZCYmdGhpcy5jaGFydC5pczNkKCl8fHRoaXMuY2hhcnQucG9sYXJ8fCF0aGlzLnhBeGlzfHx0aGlzLnhBeGlzLmlzUmFkaWFsfHwoIXRoaXMuY2xpcEJveCYmdGhpcy5hbmltYXRlPyh0aGlzLmNsaXBCb3g9ZSh0aGlzLmNoYXJ0LmNsaXBCb3gpLHRoaXMuY2xpcEJveC53aWR0aD10aGlzLnhBeGlzLmxlbixcbnRoaXMuY2xpcEJveC5oZWlnaHQ9dGhpcy55QXhpcy5sZW4pOnRoaXMuY2hhcnRbdGhpcy5zaGFyZWRDbGlwS2V5XT90aGlzLmNoYXJ0W3RoaXMuc2hhcmVkQ2xpcEtleV0uYXR0cih7d2lkdGg6dGhpcy54QXhpcy5sZW4saGVpZ2h0OnRoaXMueUF4aXMubGVufSk6dGhpcy5jbGlwQm94JiYodGhpcy5jbGlwQm94LndpZHRoPXRoaXMueEF4aXMubGVuLHRoaXMuY2xpcEJveC5oZWlnaHQ9dGhpcy55QXhpcy5sZW4pKTthLmNhbGwodGhpcyl9KTtGKHYucHJvdG90eXBlLFwiZ2V0U2VsZWN0ZWRQb2ludHNcIixmdW5jdGlvbihhKXt2YXIgYj1hLmNhbGwodGhpcyk7cSh0aGlzLnNlcmllcyxmdW5jdGlvbihhKXthLmhhc0dyb3VwZWREYXRhJiYoYj1iLmNvbmNhdCh1KGEucG9pbnRzfHxbXSxmdW5jdGlvbihhKXtyZXR1cm4gYS5zZWxlY3RlZH0pKSl9KTtyZXR1cm4gYn0pO0Yodi5wcm90b3R5cGUsXCJ1cGRhdGVcIixmdW5jdGlvbihhLGIpe1wic2Nyb2xsYmFyXCJpbiBiJiZ0aGlzLm5hdmlnYXRvciYmXG4oZSghMCx0aGlzLm9wdGlvbnMuc2Nyb2xsYmFyLGIuc2Nyb2xsYmFyKSx0aGlzLm5hdmlnYXRvci51cGRhdGUoe30sITEpLGRlbGV0ZSBiLnNjcm9sbGJhcik7cmV0dXJuIGEuYXBwbHkodGhpcyxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpfSl9KShMKTtyZXR1cm4gTH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hpZ2hjaGFydHMvaGlnaHN0b2NrLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBjb250ZXh0VHlwZXM6IHRydWUsXG4gICAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIGRpc3BsYXlOYW1lOiB0cnVlLFxuICAgIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBtaXhpbnM6IHRydWUsXG4gICAgcHJvcFR5cGVzOiB0cnVlLFxuICAgIHR5cGU6IHRydWVcbn07XG5cbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWVcbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIG9iamVjdFByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mICYmIGdldFByb3RvdHlwZU9mKE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGJsYWNrbGlzdCkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykgeyAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuXG4gICAgICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHZhciBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuICAgICAgICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50LCBibGFja2xpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIVJFQUNUX1NUQVRJQ1Nba2V5XSAmJiAhS05PV05fU1RBVElDU1trZXldICYmICghYmxhY2tsaXN0IHx8ICFibGFja2xpc3Rba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG4gICAgICAgICAgICAgICAgdHJ5IHsgLy8gQXZvaWQgZmFpbHVyZXMgZnJvbSByZWFkLW9ubHkgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107IH0pXG4gICAgICApO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ludmFyaWFudC9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGdldFJhd1RhZyBmcm9tICcuL19nZXRSYXdUYWcuanMnO1xuaW1wb3J0IG9iamVjdFRvU3RyaW5nIGZyb20gJy4vX29iamVjdFRvU3RyaW5nLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRUYWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuZXhwb3J0IGRlZmF1bHQgZnJlZUdsb2JhbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgb3ZlckFyZyBmcm9tICcuL19vdmVyQXJnLmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IGdldFByb3RvdHlwZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gtZXMvX2dldFByb3RvdHlwZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRSYXdUYWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLWVzL19nZXRSYXdUYWcuanNcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JqZWN0VG9TdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyQXJnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC1lcy9fb3ZlckFyZy5qc1xuLy8gbW9kdWxlIGlkID0gMTQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvb3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoLWVzL19yb290LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gtZXMvaXNPYmplY3RMaWtlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRyaW0gPSByZXF1aXJlKCd0cmltJylcbiAgLCBmb3JFYWNoID0gcmVxdWlyZSgnZm9yLWVhY2gnKVxuICAsIGlzQXJyYXkgPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgaWYgKCFoZWFkZXJzKVxuICAgIHJldHVybiB7fVxuXG4gIHZhciByZXN1bHQgPSB7fVxuXG4gIGZvckVhY2goXG4gICAgICB0cmltKGhlYWRlcnMpLnNwbGl0KCdcXG4nKVxuICAgICwgZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB2YXIgaW5kZXggPSByb3cuaW5kZXhPZignOicpXG4gICAgICAgICAgLCBrZXkgPSB0cmltKHJvdy5zbGljZSgwLCBpbmRleCkpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAsIHZhbHVlID0gdHJpbShyb3cuc2xpY2UoaW5kZXggKyAxKSlcblxuICAgICAgICBpZiAodHlwZW9mKHJlc3VsdFtrZXldKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlXG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShyZXN1bHRba2V5XSkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gWyByZXN1bHRba2V5XSwgdmFsdWUgXVxuICAgICAgICB9XG4gICAgICB9XG4gIClcblxuICByZXR1cm4gcmVzdWx0XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhcnNlLWhlYWRlcnMvcGFyc2UtaGVhZGVycy5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHNoaW0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBpZiAoc2VjcmV0ID09PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoXG4gICAgICBmYWxzZSxcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gIH07XG4gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gICAgcmV0dXJuIHNoaW07XG4gIH07XG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltLFxuICAgIGV4YWN0OiBnZXRTaGltXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBlbXB0eUZ1bmN0aW9uO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIGludmFyaWFudChcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsXG4gICAgICAgICAgICAgIHByb3BGdWxsTmFtZSxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICVzIGF0IGluZGV4ICVzLicsXG4gICAgICAgICAgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpLFxuICAgICAgICAgIGlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzJyk7XG52YXIgaHlwaGVuYXRlU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lJyk7XG52YXIgY2FtZWxpemVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZScpO1xuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuIVJlYWN0ID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET00gd2FzIGxvYWRlZCBiZWZvcmUgUmVhY3QuIE1ha2Ugc3VyZSB5b3UgbG9hZCB0aGUgUmVhY3QgcGFja2FnZSBiZWZvcmUgbG9hZGluZyBSZWFjdERPTS4nKSA6IHZvaWQgMDtcblxuLy8gVGhlc2UgYXR0cmlidXRlcyBzaG91bGQgYmUgYWxsIGxvd2VyY2FzZSB0byBhbGxvdyBmb3Jcbi8vIGNhc2UgaW5zZW5zaXRpdmUgY2hlY2tzXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGNoaWxkcmVuOiB0cnVlLFxuICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICBkZWZhdWx0Q2hlY2tlZDogdHJ1ZSxcbiAgaW5uZXJIVE1MOiB0cnVlLFxuICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXG4gIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgc3R5bGU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgPT09IGJpdG1hc2s7XG59XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDEsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDQsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDgsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDEwIHwgMHg4LFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDIwLFxuICBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUU6IDB4NDAsXG5cbiAgLyoqXG4gICAqIEluamVjdCBzb21lIHNwZWNpYWxpemVkIGtub3dsZWRnZSBhYm91dCB0aGUgRE9NLiBUaGlzIHRha2VzIGEgY29uZmlnIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01NdXRhdGlvbk1ldGhvZHMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01NdXRhdGlvbk1ldGhvZHMgfHwge307XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBQcm9wZXJ0aWVzKSB7XG4gICAgICAhIXByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCBcImluamVjdERPTVByb3BlcnR5Q29uZmlnKC4uLik6IFlvdSdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSAnJXMnIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gaW5qZWN0ZWQuIFlvdSBtYXkgYmUgYWNjaWRlbnRhbGx5IGluamVjdGluZyB0aGUgc2FtZSBET00gcHJvcGVydHkgY29uZmlnIHR3aWNlLCBvciB5b3UgbWF5IGJlIGluamVjdGluZyB0d28gY29uZmlncyB0aGF0IGhhdmUgY29uZmxpY3RpbmcgcHJvcGVydHkgbmFtZXMuXCIsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgdmFyIGxvd2VyQ2FzZWQgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogbG93ZXJDYXNlZCxcbiAgICAgICAgYXR0cmlidXRlTmFtZXNwYWNlOiBudWxsLFxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BOYW1lLFxuICAgICAgICBtdXRhdGlvbk1ldGhvZDogbnVsbCxcblxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSksXG4gICAgICAgIGhhc1N0cmluZ0Jvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUpXG4gICAgICB9O1xuICAgICAgIShwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICsgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSArIHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlIDw9IDEpID8gaW52YXJpYW50KGZhbHNlLCBcIkRPTVByb3BlcnR5OiBWYWx1ZSBjYW4gYmUgb25lIG9mIGJvb2xlYW4sIG92ZXJsb2FkZWQgYm9vbGVhbiwgb3IgbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlc1wiLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBET01BdHRyaWJ1dGVOYW1lc1twcm9wTmFtZV07XG5cbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IERPTUF0dHJpYnV0ZU5hbWVzcGFjZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICAvLyBEb3duY2FzZSByZWZlcmVuY2VzIHRvIHdoaXRlbGlzdCBwcm9wZXJ0aWVzIHRvIGNoZWNrIGZvciBtZW1iZXJzaGlwXG4gICAgICAvLyB3aXRob3V0IGNhc2Utc2Vuc2l0aXZpdHkuIFRoaXMgYWxsb3dzIHRoZSB3aGl0ZWxpc3QgdG8gcGljayB1cFxuICAgICAgLy8gYGFsbG93ZnVsbHNjcmVlbmAsIHdoaWNoIHNob3VsZCBiZSB3cml0dGVuIHVzaW5nIHRoZSBwcm9wZXJ0eSBjb25maWd1cmF0aW9uXG4gICAgICAvLyBmb3IgYGFsbG93RnVsbHNjcmVlbmBcbiAgICAgIHByb3BlcnRpZXNbcHJvcE5hbWVdID0gcHJvcGVydHlJbmZvO1xuICAgIH1cbiAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSBcIjpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcIjtcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX0NIQVIgPSBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgXCJcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MFwiO1xuXG5cbnZhciBST09UX0FUVFJJQlVURV9OQU1FID0gJ2RhdGEtcmVhY3Ryb290JztcblxuLyoqXG4gKiBNYXAgZnJvbSBwcm9wZXJ0eSBcInN0YW5kYXJkIG5hbWVcIiB0byBhbiBvYmplY3Qgd2l0aCBpbmZvIGFib3V0IGhvdyB0byBzZXRcbiAqIHRoZSBwcm9wZXJ0eSBpbiB0aGUgRE9NLiBFYWNoIG9iamVjdCBjb250YWluczpcbiAqXG4gKiBhdHRyaWJ1dGVOYW1lOlxuICogICBVc2VkIHdoZW4gcmVuZGVyaW5nIG1hcmt1cCBvciB3aXRoIGAqQXR0cmlidXRlKClgLlxuICogYXR0cmlidXRlTmFtZXNwYWNlXG4gKiBwcm9wZXJ0eU5hbWU6XG4gKiAgIFVzZWQgb24gRE9NIG5vZGUgaW5zdGFuY2VzLiAoVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgbXV0YXRlIGR1ZSB0b1xuICogICBleHRlcm5hbCBmYWN0b3JzLilcbiAqIG11dGF0aW9uTWV0aG9kOlxuICogICBJZiBub24tbnVsbCwgdXNlZCBpbnN0ZWFkIG9mIHRoZSBwcm9wZXJ0eSBvciBgc2V0QXR0cmlidXRlKClgIGFmdGVyXG4gKiAgIGluaXRpYWwgcmVuZGVyLlxuICogbXVzdFVzZVByb3BlcnR5OlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIGFjY2Vzc2VkIGFuZCBtdXRhdGVkIGFzIGFuIG9iamVjdCBwcm9wZXJ0eS5cbiAqIGhhc0Jvb2xlYW5WYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gKiBoYXNOdW1lcmljVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMgYW5kIHNob3VsZCBiZVxuICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICogaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICogaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAqICAgc3RyaWN0bHkgZXF1YWwgdG8gdHJ1ZTsgcHJlc2VudCB3aXRoIGEgdmFsdWUgb3RoZXJ3aXNlLlxuICovXG52YXIgcHJvcGVydGllcyA9IHt9O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgcHJvcGVydHkgbmFtZSBpcyBhIHdyaXRlYWJsZSBhdHRyaWJ1dGUuXG4gKiBAbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICBpZiAoaXNSZXNlcnZlZFByb3AobmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gc2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlKG5hbWUpO1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZnVuY3Rpb24sIHN5bWJvbFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEF0dHJpYnV0ZUFjY2VwdEJvb2xlYW5WYWx1ZShuYW1lKSB7XG4gIGlmIChpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICByZXR1cm4gcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzU3RyaW5nQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlO1xuICB9XG4gIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gIHJldHVybiBwcmVmaXggPT09ICdkYXRhLScgfHwgcHJlZml4ID09PSAnYXJpYS0nO1xufVxuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHdpdGhpbiB0aGUgbGlzdCBvZiBwcm9wZXJ0aWVzXG4gKiByZXNlcnZlZCBmb3IgaW50ZXJuYWwgUmVhY3Qgb3BlcmF0aW9ucy4gVGhlc2UgcHJvcGVydGllcyBzaG91bGRcbiAqIG5vdCBiZSBzZXQgb24gYW4gSFRNTCBlbGVtZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIG5hbWUgaXMgd2l0aGluIHJlc2VydmVkIHByb3BzXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWRQcm9wKG5hbWUpIHtcbiAgcmV0dXJuIFJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KG5hbWUpO1xufVxuXG52YXIgaW5qZWN0aW9uID0gRE9NUHJvcGVydHlJbmplY3Rpb247XG5cbnZhciBNVVNUX1VTRV9QUk9QRVJUWSA9IGluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWTtcbnZhciBIQVNfQk9PTEVBTl9WQUxVRSA9IGluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IGluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9IGluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG52YXIgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRTtcblxudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuICAvLyB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuICAvLyBuYW1lIHdhcm5pbmdzLlxuICBQcm9wZXJ0aWVzOiB7XG4gICAgYWxsb3dGdWxsU2NyZWVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBzcGVjaWZpZXMgdGFyZ2V0IGNvbnRleHQgZm9yIGxpbmtzIHdpdGggYHByZWxvYWRgIHR5cGVcbiAgICBhc3luYzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gTm90ZTogdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBwcmV2ZW50cyBpdCBmcm9tIGJlaW5nIHdyaXR0ZW4gdG8gdGhlIERPTVxuICAgIC8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbiAgICBhdXRvRm9jdXM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9QbGF5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjYXB0dXJlOiBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLFxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY29sczogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgY29udGVudEVkaXRhYmxlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsXG4gICAgY29udHJvbHM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgICdkZWZhdWx0JzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRpc2FibGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaGlkZGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBsb29wOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBDYXV0aW9uOyBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuICAgIC8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuXG4gICAgbXVsdGlwbGU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbXV0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcGxheXNJbmxpbmU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlYWRPbmx5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmV2ZXJzZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJvd3M6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHNjb3BlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VhbWxlc3M6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlbGVjdGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNpemU6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHN0YXJ0OiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICAvLyBzdXBwb3J0IGZvciBwcm9qZWN0aW5nIHJlZ3VsYXIgRE9NIEVsZW1lbnRzIHZpYSBWMSBuYW1lZCBzbG90cyAoIHNoYWRvdyBkb20gKVxuICAgIHNwYW46IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNwZWxsQ2hlY2s6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBTdHlsZSBtdXN0IGJlIGV4cGxpY2l0bHkgc2V0IGluIHRoZSBhdHRyaWJ1dGUgbGlzdC4gUmVhY3QgY29tcG9uZW50c1xuICAgIC8vIGV4cGVjdCBhIHN0eWxlIG9iamVjdFxuICAgIHN0eWxlOiAwLFxuICAgIC8vIEtlZXAgaXQgaW4gdGhlIHdoaXRlbGlzdCBiZWNhdXNlIGl0IGlzIGNhc2Utc2Vuc2l0aXZlIGZvciBTVkcuXG4gICAgdGFiSW5kZXg6IDAsXG4gICAgLy8gaXRlbVNjb3BlIGlzIGZvciBmb3IgTWljcm9kYXRhIHN1cHBvcnQuXG4gICAgLy8gU2VlIGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIGl0ZW1TY29wZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gVGhlc2UgYXR0cmlidXRlcyBtdXN0IHN0YXkgaW4gdGhlIHdoaXRlLWxpc3QgYmVjYXVzZSB0aGV5IGhhdmVcbiAgICAvLyBkaWZmZXJlbnQgYXR0cmlidXRlIG5hbWVzIChzZWUgRE9NQXR0cmlidXRlTmFtZXMgYmVsb3cpXG4gICAgYWNjZXB0Q2hhcnNldDogMCxcbiAgICBjbGFzc05hbWU6IDAsXG4gICAgaHRtbEZvcjogMCxcbiAgICBodHRwRXF1aXY6IDAsXG4gICAgLy8gQXR0cmlidXRlcyB3aXRoIG11dGF0aW9uIG1ldGhvZHMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIHdoaXRlbGlzdFxuICAgIC8vIFNldCB0aGUgc3RyaW5nIGJvb2xlYW4gZmxhZyB0byBhbGxvdyB0aGUgYmVoYXZpb3JcbiAgICB2YWx1ZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbiAgfSxcbiAgRE9NTXV0YXRpb25NZXRob2RzOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICAvLyBOdW1iZXIgaW5wdXRzIGdldCBzcGVjaWFsIHRyZWF0bWVudCBkdWUgdG8gc29tZSBlZGdlIGNhc2VzIGluXG4gICAgICAvLyBDaHJvbWUuIExldCBldmVyeXRoaW5nIGVsc2UgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgYXMgbm9ybWFsLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzI2lzc3VlY29tbWVudC0yMzYwNzQzMjZcbiAgICAgIGlmIChub2RlLnR5cGUgIT09ICdudW1iZXInIHx8IG5vZGUuaGFzQXR0cmlidXRlKCd2YWx1ZScpID09PSBmYWxzZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCAnJyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWxpZGl0eSAmJiAhbm9kZS52YWxpZGl0eS5iYWRJbnB1dCAmJiBub2RlLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gbm9kZSkge1xuICAgICAgICAvLyBEb24ndCBhc3NpZ24gYW4gYXR0cmlidXRlIGlmIHZhbGlkYXRpb24gcmVwb3J0cyBiYWRcbiAgICAgICAgLy8gaW5wdXQuIENocm9tZSB3aWxsIGNsZWFyIHRoZSB2YWx1ZS4gQWRkaXRpb25hbGx5LCBkb24ndFxuICAgICAgICAvLyBvcGVyYXRlIG9uIGlucHV0cyB0aGF0IGhhdmUgZm9jdXMsIG90aGVyd2lzZSBDaHJvbWUgbWlnaHRcbiAgICAgICAgLy8gc3RyaXAgb2ZmIHRyYWlsaW5nIGRlY2ltYWwgcGxhY2VzIGFuZCBjYXVzZSB0aGUgdXNlcidzXG4gICAgICAgIC8vIGN1cnNvciBwb3NpdGlvbiB0byBqdW1wIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGlucHV0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJbiBSZWFjdERPTUlucHV0LCB3ZSBoYXZlIGFuIG9uQmx1ciBldmVudCB0aGF0IHdpbGwgdHJpZ2dlclxuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIGFnYWluIHdoZW4gZm9jdXMgaXMgbG9zdC5cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEgPSBpbmplY3Rpb24uSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFO1xuXG5cbnZhciBOUyA9IHtcbiAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgeG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLFxuICogbmFtZXNwYWNpbmcsIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC5cbiAqXG4gKiBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4gKiB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuICogbmFtZSB3YXJuaW5ncy5cbiAqXG4gKiBTVkcgQXR0cmlidXRlcyBMaXN0OlxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9hdHRpbmRleC5odG1sXG4gKiBTTUlMIFNwZWM6XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvc21pbFxuICovXG52YXIgQVRUUlMgPSBbJ2FjY2VudC1oZWlnaHQnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FyYWJpYy1mb3JtJywgJ2Jhc2VsaW5lLXNoaWZ0JywgJ2NhcC1oZWlnaHQnLCAnY2xpcC1wYXRoJywgJ2NsaXAtcnVsZScsICdjb2xvci1pbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdjb2xvci1wcm9maWxlJywgJ2NvbG9yLXJlbmRlcmluZycsICdkb21pbmFudC1iYXNlbGluZScsICdlbmFibGUtYmFja2dyb3VuZCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2Zsb29kLWNvbG9yJywgJ2Zsb29kLW9wYWNpdHknLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc2l6ZS1hZGp1c3QnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2dseXBoLW5hbWUnLCAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsICdob3Jpei1hZHYteCcsICdob3Jpei1vcmlnaW4teCcsICdpbWFnZS1yZW5kZXJpbmcnLCAnbGV0dGVyLXNwYWNpbmcnLCAnbGlnaHRpbmctY29sb3InLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdvdmVybGluZS1wb3NpdGlvbicsICdvdmVybGluZS10aGlja25lc3MnLCAncGFpbnQtb3JkZXInLCAncGFub3NlLTEnLCAncG9pbnRlci1ldmVudHMnLCAncmVuZGVyaW5nLWludGVudCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2Utb3BhY2l0eScsICdzdHJva2Utd2lkdGgnLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3VuZGVybGluZS1wb3NpdGlvbicsICd1bmRlcmxpbmUtdGhpY2tuZXNzJywgJ3VuaWNvZGUtYmlkaScsICd1bmljb2RlLXJhbmdlJywgJ3VuaXRzLXBlci1lbScsICd2LWFscGhhYmV0aWMnLCAndi1oYW5naW5nJywgJ3YtaWRlb2dyYXBoaWMnLCAndi1tYXRoZW1hdGljYWwnLCAndmVjdG9yLWVmZmVjdCcsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd3b3JkLXNwYWNpbmcnLCAnd3JpdGluZy1tb2RlJywgJ3gtaGVpZ2h0JywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbG5zOnhsaW5rJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddO1xuXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHtcbiAgICBhdXRvUmV2ZXJzZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEsXG4gICAgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEsXG4gICAgcHJlc2VydmVBbHBoYTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDFcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhdXRvUmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gICAgcHJlc2VydmVBbHBoYTogJ3ByZXNlcnZlQWxwaGEnXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IHtcbiAgICB4bGlua0FjdHVhdGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rQXJjcm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtIcmVmOiBOUy54bGluayxcbiAgICB4bGlua1JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rU2hvdzogTlMueGxpbmssXG4gICAgeGxpbmtUaXRsZTogTlMueGxpbmssXG4gICAgeGxpbmtUeXBlOiBOUy54bGluayxcbiAgICB4bWxCYXNlOiBOUy54bWwsXG4gICAgeG1sTGFuZzogTlMueG1sLFxuICAgIHhtbFNwYWNlOiBOUy54bWxcbiAgfVxufTtcblxudmFyIENBTUVMSVpFID0gL1tcXC1cXDpdKFthLXpdKS9nO1xudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59O1xuXG5BVFRSUy5mb3JFYWNoKGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgcmVhY3ROYW1lID0gb3JpZ2luYWwucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG5cbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuUHJvcGVydGllc1tyZWFjdE5hbWVdID0gMDtcbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNbcmVhY3ROYW1lXSA9IG9yaWdpbmFsO1xufSk7XG5cbmluamVjdGlvbi5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhIVE1MRE9NUHJvcGVydHlDb25maWcpO1xuaW5qZWN0aW9uLmluamVjdERPTVByb3BlcnR5Q29uZmlnKFNWR0RPTVByb3BlcnR5Q29uZmlnKTtcblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHtcbiAgLy8gVXNlZCBieSBGaWJlciB0byBzaW11bGF0ZSBhIHRyeS1jYXRjaC5cbiAgX2NhdWdodEVycm9yOiBudWxsLFxuICBfaGFzQ2F1Z2h0RXJyb3I6IGZhbHNlLFxuXG4gIC8vIFVzZWQgYnkgZXZlbnQgc3lzdGVtIHRvIGNhcHR1cmUvcmV0aHJvdyB0aGUgZmlyc3QgZXJyb3IuXG4gIF9yZXRocm93RXJyb3I6IG51bGwsXG4gIF9oYXNSZXRocm93RXJyb3I6IGZhbHNlLFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdEVycm9yVXRpbHM6IGZ1bmN0aW9uIChpbmplY3RlZEVycm9yVXRpbHMpIHtcbiAgICAgICEodHlwZW9mIGluamVjdGVkRXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW5qZWN0ZWQgaW52b2tlR3VhcmRlZENhbGxiYWNrKCkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpIDogdm9pZCAwO1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gaW5qZWN0ZWRFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gICAqXG4gICAqIEluIHByb2R1Y3Rpb24sIHRoaXMgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSB0cnktY2F0Y2guIFRoZSByZWFzb24gd2UgZG9uJ3RcbiAgICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gICAqIGltcGxlbWVudGF0aW9uIGluIERFViBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gICAqIGl0IGluIGEgZ2xvYmFsIHNvIGl0IGNhbiBiZSByZXRocm93biBieSBgcmV0aHJvd0NhdWdodEVycm9yYCBsYXRlci5cbiAgICogVE9ETzogU2VlIGlmIF9jYXVnaHRFcnJvciBhbmQgX3JldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yOiBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBpZiAoIVJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICAgKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gICAqL1xuICByZXRocm93Q2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmV0aHJvd0NhdWdodEVycm9yLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICBoYXNDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yO1xuICB9LFxuXG4gIGNsZWFyQ2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvcjtcbiAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdjbGVhckNhdWdodEVycm9yIHdhcyBjYWxsZWQgYnV0IG5vIGVycm9yIHdhcyBjYXB0dXJlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICB0cnkge1xuICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gdHJ1ZTtcbiAgfVxufTtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bnRpbnR1aXRpdmUsIHRob3VnaCwgYmVjYXVzZSBldmVuIHRob3VnaCBSZWFjdCBoYXMgY2F1Z2h0IHRoZSBlcnJvciwgZnJvbVxuICAvLyB0aGUgZGV2ZWxvcGVyJ3MgcGVyc3BlY3RpdmUsIHRoZSBlcnJvciBpcyB1bmNhdWdodC5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLCB3ZSBkb24ndCB1c2UgYVxuICAvLyB0cnktY2F0Y2ggaW4gREVWLiBJbnN0ZWFkLCB3ZSBzeW5jaHJvbm91c2x5IGRpc3BhdGNoIGEgZmFrZSBldmVudCB0byBhIGZha2VcbiAgLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbiAgLy8gZm9yIHRoYXQgZmFrZSBldmVudC4gSWYgdGhlIGNhbGxiYWNrIHRocm93cywgdGhlIGVycm9yIGlzIFwiY2FwdHVyZWRcIiB1c2luZ1xuICAvLyBhIGdsb2JhbCBldmVudCBoYW5kbGVyLiBCdXQgYmVjYXVzZSB0aGUgZXJyb3IgaGFwcGVucyBpbiBhIGRpZmZlcmVudFxuICAvLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbiAgLy8gRWZmZWN0aXZlbHksIHRoaXMgZ2l2ZXMgdXMgdHJ5LWNhdGNoIGJlaGF2aW9yIHdpdGhvdXQgYWN0dWFsbHkgdXNpbmdcbiAgLy8gdHJ5LWNhdGNoLiBOZWF0IVxuXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgdmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0RldiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAvLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLiBXZVxuICAgICAgLy8gc2V0IHRoaXMgdG8gdHJ1ZSBhdCB0aGUgYmVnaW5uaW5nLCB0aGVuIHNldCBpdCB0byBmYWxzZSByaWdodCBhZnRlclxuICAgICAgLy8gY2FsbGluZyB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBlcnJvcnMsIGBkaWRFcnJvcmAgd2lsbCBuZXZlciBiZVxuICAgICAgLy8gc2V0IHRvIGZhbHNlLiBUaGlzIHN0cmF0ZWd5IHdvcmtzIGV2ZW4gaWYgdGhlIGJyb3dzZXIgaXMgZmxha3kgYW5kXG4gICAgICAvLyBmYWlscyB0byBjYWxsIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlciwgYmVjYXVzZSBpdCBkb2Vzbid0IHJlbHkgb25cbiAgICAgIC8vIHRoZSBlcnJvciBldmVudCBhdCBhbGwuXG4gICAgICB2YXIgZGlkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAvLyBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3Igb3VyIGZha2UgZXZlbnQuIFdlIHdpbGwgc3luY2hyb25vdXNseVxuICAgICAgLy8gZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQgdXNpbmcgYGRpc3BhdGNoRXZlbnRgLiBJbnNpZGUgdGhlIGhhbmRsZXIsIHdlXG4gICAgICAvLyBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrLlxuICAgICAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjaygpIHtcbiAgICAgICAgLy8gV2UgaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0XG4gICAgICAgIC8vIG5lc3RlZCBgaW52b2tlR3VhcmRlZENhbGxiYWNrYCBjYWxscyBkbyBub3QgY2xhc2guIE90aGVyd2lzZSwgYVxuICAgICAgICAvLyBuZXN0ZWQgY2FsbCB3b3VsZCB0cmlnZ2VyIHRoZSBmYWtlIGV2ZW50IGhhbmRsZXJzIG9mIGFueSBjYWxsIGhpZ2hlclxuICAgICAgICAvLyBpbiB0aGUgc3RhY2suXG4gICAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICAgICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBnbG9iYWwgZXJyb3IgZXZlbnQgaGFuZGxlci4gV2UgdXNlIHRoaXMgdG8gY2FwdHVyZSB0aGUgdmFsdWVcbiAgICAgIC8vIHRoYXQgd2FzIHRocm93bi4gSXQncyBwb3NzaWJsZSB0aGF0IHRoaXMgZXJyb3IgaGFuZGxlciB3aWxsIGZpcmUgbW9yZVxuICAgICAgLy8gdGhhbiBvbmNlOyBmb3IgZXhhbXBsZSwgaWYgbm9uLVJlYWN0IGNvZGUgYWxzbyBjYWxscyBgZGlzcGF0Y2hFdmVudGBcbiAgICAgIC8vIGFuZCBhIGhhbmRsZXIgZm9yIHRoYXQgZXZlbnQgdGhyb3dzLiBXZSBzaG91bGQgYmUgcmVzaWxpZW50IHRvIG1vc3Qgb2ZcbiAgICAgIC8vIHRob3NlIGNhc2VzLiBFdmVuIGlmIG91ciBlcnJvciBldmVudCBoYW5kbGVyIGZpcmVzIG1vcmUgdGhhbiBvbmNlLCB0aGVcbiAgICAgIC8vIGxhc3QgZXJyb3IgZXZlbnQgaXMgYWx3YXlzIHVzZWQuIElmIHRoZSBjYWxsYmFjayBhY3R1YWxseSBkb2VzIGVycm9yLFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBsYXN0IGVycm9yIGV2ZW50IGlzIHRoZSBjb3JyZWN0IG9uZSwgYmVjYXVzZSBpdCdzIG5vdFxuICAgICAgLy8gcG9zc2libGUgZm9yIGFueXRoaW5nIGVsc2UgdG8gaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIG91ciBjYWxsYmFja1xuICAgICAgLy8gZXJyb3JpbmcgYW5kIHRoZSBjb2RlIHRoYXQgZm9sbG93cyB0aGUgYGRpc3BhdGNoRXZlbnRgIGNhbGwgYmVsb3cuIElmXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgZG9lc24ndCBlcnJvciwgYnV0IHRoZSBlcnJvciBldmVudCB3YXMgZmlyZWQsIHdlIGtub3cgdG9cbiAgICAgIC8vIGlnbm9yZSBpdCBiZWNhdXNlIGBkaWRFcnJvcmAgd2lsbCBiZSBmYWxzZSwgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgICAgdmFyIGVycm9yID0gdm9pZCAwO1xuICAgICAgLy8gVXNlIHRoaXMgdG8gdHJhY2sgd2hldGhlciB0aGUgZXJyb3IgZXZlbnQgaXMgZXZlciBjYWxsZWQuXG4gICAgICB2YXIgZGlkU2V0RXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBpc0Nyb3NzT3JpZ2luRXJyb3IgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gb25FcnJvcihldmVudCkge1xuICAgICAgICBlcnJvciA9IGV2ZW50LmVycm9yO1xuICAgICAgICBkaWRTZXRFcnJvciA9IHRydWU7XG4gICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCAmJiBldmVudC5jb2xubyA9PT0gMCAmJiBldmVudC5saW5lbm8gPT09IDApIHtcbiAgICAgICAgICBpc0Nyb3NzT3JpZ2luRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGZha2UgZXZlbnQgdHlwZS5cbiAgICAgIHZhciBldnRUeXBlID0gJ3JlYWN0LScgKyAobmFtZSA/IG5hbWUgOiAnaW52b2tlZ3VhcmRlZGNhbGxiYWNrJyk7XG5cbiAgICAgIC8vIEF0dGFjaCBvdXIgZXZlbnQgaGFuZGxlcnNcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTtcblxuICAgICAgLy8gU3luY2hyb25vdXNseSBkaXNwYXRjaCBvdXIgZmFrZSBldmVudC4gSWYgdGhlIHVzZXItcHJvdmlkZWQgZnVuY3Rpb25cbiAgICAgIC8vIGVycm9ycywgaXQgd2lsbCB0cmlnZ2VyIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlci5cbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgIGlmICghZGlkU2V0RXJyb3IpIHtcbiAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgZXJyb3JlZCwgYnV0IHRoZSBlcnJvciBldmVudCBuZXZlciBmaXJlZC5cbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignQW4gZXJyb3Igd2FzIHRocm93biBpbnNpZGUgb25lIG9mIHlvdXIgY29tcG9uZW50cywgYnV0IFJlYWN0ICcgKyBcImRvZXNuJ3Qga25vdyB3aGF0IGl0IHdhcy4gVGhpcyBpcyBsaWtlbHkgZHVlIHRvIGJyb3dzZXIgXCIgKyAnZmxha2luZXNzLiBSZWFjdCBkb2VzIGl0cyBiZXN0IHRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uICcgKyAnZXhjZXB0aW9uc1wiIGJlaGF2aW9yIG9mIHRoZSBEZXZUb29scywgd2hpY2ggcmVxdWlyZXMgc29tZSAnICsgXCJERVYtbW9kZSBvbmx5IHRyaWNrcy4gSXQncyBwb3NzaWJsZSB0aGF0IHRoZXNlIGRvbid0IHdvcmsgaW4gXCIgKyAneW91ciBicm93c2VyLiBUcnkgdHJpZ2dlcmluZyB0aGUgZXJyb3IgaW4gcHJvZHVjdGlvbiBtb2RlLCAnICsgJ29yIHN3aXRjaGluZyB0byBhIG1vZGVybiBicm93c2VyLiBJZiB5b3Ugc3VzcGVjdCB0aGF0IHRoaXMgaXMgJyArICdhY3R1YWxseSBhbiBpc3N1ZSB3aXRoIFJlYWN0LCBwbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Nyb3NzT3JpZ2luRXJyb3IpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkEgY3Jvc3Mtb3JpZ2luIGVycm9yIHdhcyB0aHJvd24uIFJlYWN0IGRvZXNuJ3QgaGF2ZSBhY2Nlc3MgdG8gXCIgKyAndGhlIGFjdHVhbCBlcnJvciBvYmplY3QgaW4gZGV2ZWxvcG1lbnQuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtY3Jvc3NvcmlnaW4tZXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IHRydWU7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSBmYWxzZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICB9O1xuXG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2O1xuICB9XG59XG5cbnZhciByZXRocm93Q2F1Z2h0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvcikge1xuICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yO1xuICAgIFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yID0gbnVsbDtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIGV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIWV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBldmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBldmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2lucyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgcGx1Z2luIG9yZGVyaW5nLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIGlmIChwbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFwbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgIG1ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgcGx1Z2luc1twbHVnaW5JbmRleF0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgdmFyIHB1Ymxpc2hlZEV2ZW50cyA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwdWJsaXNoZWRFdmVudHMpIHtcbiAgICAgICFwdWJsaXNoRXZlbnRGb3JQbHVnaW4ocHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSBldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiB2b2lkIDA7XG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgcmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSkgOiB2b2lkIDA7XG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG5cbiAge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLm9uZGJsY2xpY2sgPSByZWdpc3RyYXRpb25OYW1lO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG5cbi8qKlxuICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gKi9cbnZhciBwbHVnaW5zID0gW107XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gKi9cbnZhciBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcmVnaXN0cmF0aW9uIG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLFxuICogdXNlZCB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgZXZlbnQgaGFuZGxlcnMuIEF2YWlsYWJsZVxuICogb25seSBpbiB0cnVlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSB7fTtcbi8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyBpbiB0cnVlXG5cbi8qKlxuICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luT3JkZXIoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICEhZXZlbnRQbHVnaW5PcmRlciA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgZXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XG4gIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG59XG5cbi8qKlxuICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICpcbiAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICovXG5mdW5jdGlvbiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IHBsdWdpbk1vZHVsZSkge1xuICAgICAgISFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zIHVzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9XG59XG5cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdHBsdWdpbnM6IHBsdWdpbnMsXG5cdGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczogZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLFxuXHRyZWdpc3RyYXRpb25OYW1lTW9kdWxlczogcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMsXG5cdHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMsXG5cdHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMsXG5cdGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cdGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG59KTtcblxudmFyIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldEluc3RhbmNlRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBudWxsO1xuXG52YXIgaW5qZWN0aW9uJDIgPSB7XG4gIGluamVjdENvbXBvbmVudFRyZWU6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlO1xuICAgIGdldEluc3RhbmNlRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRJbnN0YW5jZUZyb21Ob2RlO1xuICAgIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBJbmplY3RlZC5nZXROb2RlRnJvbUluc3RhbmNlO1xuXG4gICAge1xuICAgICAgd2FybmluZyhnZXROb2RlRnJvbUluc3RhbmNlICYmIGdldEluc3RhbmNlRnJvbU5vZGUsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RDb21wb25lbnRUcmVlKC4uLik6IEluamVjdGVkICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgZ2V0Tm9kZUZyb21JbnN0YW5jZSBvciBnZXRJbnN0YW5jZUZyb21Ob2RlLicpO1xuICAgIH1cbiAgfVxufTtcblxuXG5cblxuXG5cbnZhciB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcztcbntcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIHZhciBpbnN0YW5jZXNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICAgIHZhciBpbnN0YW5jZXNMZW4gPSBpbnN0YW5jZXNJc0FyciA/IGRpc3BhdGNoSW5zdGFuY2VzLmxlbmd0aCA6IGRpc3BhdGNoSW5zdGFuY2VzID8gMSA6IDA7XG5cbiAgICB3YXJuaW5nKGluc3RhbmNlc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBpbnN0YW5jZXNMZW4gPT09IGxpc3RlbmVyc0xlbiwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgaW5zdCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcih0eXBlLCBsaXN0ZW5lciwgdW5kZWZpbmVkLCBldmVudCk7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cblxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXG4gKiBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucywgYW5kIHRodXMgc2FjcmlmaWNlc1xuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxuICpcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxuICpcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBzcGFyaW5nbHkgdXNlZC4gVHJ5IGBhY2N1bXVsYXRlYCBmb3Igc29tZXRoaW5nIGNsZWFuZXIuXG4gKlxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcbiAgIShuZXh0ICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgLy8gQSBiaXQgdG9vIGRhbmdlcm91cyB0byBtdXRhdGUgYG5leHRgLlxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcbiAqIGEgc2luZ2xlIGl0ZW0uIFVzZWZ1bCB3aGVuIHBhaXJlZCB3aXRoIHRoZSBgYWNjdW11bGF0ZWAgbW9kdWxlLiBUaGlzIGlzIGFcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFsbG9jYXRlIGFuIGFycmF5KS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIGludm9rZWQgd2l0aCBlYWNoIGVsZW1lbnQgb3IgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHs/fSBbc2NvcGVdIFNjb3BlIHVzZWQgYXMgYHRoaXNgIGluIGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29uQ2xpY2snOlxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxuICAgIGNhc2UgJ29uTW91c2VEb3duQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZVVwJzpcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciBpbmplY3Rpb24kMSA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAcHVibGljXG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBpbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259IFRoZSBzdG9yZWQgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGxpc3RlbmVyO1xuXG4gIC8vIFRPRE86IHNob3VsZFByZXZlbnRNb3VzZUV2ZW50IGlzIERPTS1zcGVjaWZpYyBhbmQgZGVmaW5pdGVseSBzaG91bGQgbm90XG4gIC8vIGxpdmUgaGVyZTsgbmVlZHMgdG8gYmUgbW92ZWQgdG8gYSBiZXR0ZXIgcGxhY2Ugc29vblxuICB2YXIgc3RhdGVOb2RlID0gaW5zdC5zdGF0ZU5vZGU7XG4gIGlmICghc3RhdGVOb2RlKSB7XG4gICAgLy8gV29yayBpbiBwcm9ncmVzcyAoZXg6IG9ubG9hZCBldmVudHMgaW4gaW5jcmVtZW50YWwgbW9kZSkuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShzdGF0ZU5vZGUpO1xuICBpZiAoIXByb3BzKSB7XG4gICAgLy8gV29yayBpbiBwcm9ncmVzcy5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsaXN0ZW5lciA9IHByb3BzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICBpZiAoc2hvdWxkUHJldmVudE1vdXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgaW5zdC50eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAhKCFsaXN0ZW5lciB8fCB0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS4nLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogdm9pZCAwO1xuICByZXR1cm4gbGlzdGVuZXI7XG59XG5cbi8qKlxuICogQWxsb3dzIHJlZ2lzdGVyZWQgcGx1Z2lucyBhbiBvcHBvcnR1bml0eSB0byBleHRyYWN0IGV2ZW50cyBmcm9tIHRvcC1sZXZlbFxuICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICpcbiAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50cztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICBpZiAoZXh0cmFjdGVkRXZlbnRzKSB7XG4gICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50cztcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAqIGBwcm9jZXNzRXZlbnRRdWV1ZWAgaXMgaW52b2tlZC5cbiAqXG4gKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBlbnF1ZXVlRXZlbnRzKGV2ZW50cykge1xuICBpZiAoZXZlbnRzKSB7XG4gICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc0V2ZW50UXVldWUoc2ltdWxhdGVkKSB7XG4gIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICB2YXIgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICBldmVudFF1ZXVlID0gbnVsbDtcblxuICBpZiAoIXByb2Nlc3NpbmdFdmVudFF1ZXVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgfVxuICAhIWV2ZW50UXVldWUgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcbiAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gIFJlYWN0RXJyb3JVdGlscy5yZXRocm93Q2F1Z2h0RXJyb3IoKTtcbn1cblxudmFyIEV2ZW50UGx1Z2luSHViID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGluamVjdGlvbjogaW5qZWN0aW9uJDEsXG5cdGdldExpc3RlbmVyOiBnZXRMaXN0ZW5lcixcblx0ZXh0cmFjdEV2ZW50czogZXh0cmFjdEV2ZW50cyxcblx0ZW5xdWV1ZUV2ZW50czogZW5xdWV1ZUV2ZW50cyxcblx0cHJvY2Vzc0V2ZW50UXVldWU6IHByb2Nlc3NFdmVudFF1ZXVlXG59KTtcblxudmFyIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAwOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uYWwgb3IgY2xhc3NcbnZhciBGdW5jdGlvbmFsQ29tcG9uZW50ID0gMTtcbnZhciBDbGFzc0NvbXBvbmVudCA9IDI7XG52YXIgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cbnZhciBIb3N0UG9ydGFsID0gNDsgLy8gQSBzdWJ0cmVlLiBDb3VsZCBiZSBhbiBlbnRyeSBwb2ludCB0byBhIGRpZmZlcmVudCByZW5kZXJlci5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG52YXIgQ2FsbENvbXBvbmVudCA9IDc7XG52YXIgQ2FsbEhhbmRsZXJQaGFzZSA9IDg7XG52YXIgUmV0dXJuQ29tcG9uZW50ID0gOTtcbnZhciBGcmFnbWVudCA9IDEwO1xuXG52YXIgcmFuZG9tS2V5ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsRXZlbnRIYW5kbGVyc0tleSA9ICdfX3JlYWN0RXZlbnRIYW5kbGVycyQnICsgcmFuZG9tS2V5O1xuXG5mdW5jdGlvbiBwcmVjYWNoZUZpYmVyTm9kZSQxKGhvc3RJbnN0LCBub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgUmVhY3RET01Db21wb25lbnQgb3JcbiAqIFJlYWN0RE9NVGV4dENvbXBvbmVudCBpbnN0YW5jZSBhbmNlc3Rvci5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICBpZiAobm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHJldHVybiBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIGluc3RhbmNlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIW5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9wIG9mIHRoZSB0cmVlLiBUaGlzIG5vZGUgbXVzdCBub3QgYmUgcGFydCBvZiBhIFJlYWN0IHRyZWUgKG9yIGlzXG4gICAgICAvLyB1bm1vdW50ZWQsIHBvdGVudGlhbGx5KS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjbG9zZXN0ID0gdm9pZCAwO1xuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciwgdGhpcyB3aWxsIGFsd2F5cyBiZSB0aGUgZGVlcGVzdCByb290LlxuICAgIHJldHVybiBpbnN0O1xuICB9XG4gIGZvciAoOyBub2RlICYmIChpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSk7IG5vZGUgPSBwYXJlbnRzLnBvcCgpKSB7XG4gICAgY2xvc2VzdCA9IGluc3Q7XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIG5vZGUgd2FzIG5vdCByZW5kZXJlZCBieSB0aGlzIFJlYWN0LlxuICovXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEobm9kZSkge1xuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0KSB7XG4gICAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudCwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKGluc3QpIHtcbiAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgIC8vIEluIEZpYmVyIHRoaXMsIGlzIGp1c3QgdGhlIHN0YXRlIG5vZGUgcmlnaHQgbm93LiBXZSBhc3N1bWUgaXQgd2lsbCBiZVxuICAgIC8vIGEgaG9zdCBjb21wb25lbnQgb3IgaG9zdCB0ZXh0LlxuICAgIHJldHVybiBpbnN0LnN0YXRlTm9kZTtcbiAgfVxuXG4gIC8vIFdpdGhvdXQgdGhpcyBmaXJzdCBpbnZhcmlhbnQsIHBhc3NpbmcgYSBub24tRE9NLWNvbXBvbmVudCB0cmlnZ2VycyB0aGUgbmV4dFxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cbiAgaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVGaWJlclByb3BzJDEobm9kZSwgcHJvcHMpIHtcbiAgbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldID0gcHJvcHM7XG59XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSBPYmplY3QuZnJlZXplKHtcblx0cHJlY2FjaGVGaWJlck5vZGU6IHByZWNhY2hlRmliZXJOb2RlJDEsXG5cdGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcblx0Z2V0SW5zdGFuY2VGcm9tTm9kZTogZ2V0SW5zdGFuY2VGcm9tTm9kZSQxLFxuXHRnZXROb2RlRnJvbUluc3RhbmNlOiBnZXROb2RlRnJvbUluc3RhbmNlJDEsXG5cdGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU6IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMSxcblx0dXBkYXRlRmliZXJQcm9wczogdXBkYXRlRmliZXJQcm9wcyQxXG59KTtcblxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgZG8ge1xuICAgIGluc3QgPSBpbnN0WydyZXR1cm4nXTtcbiAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgSG9zdFJvb3Qgd2UgbWlnaHQgd2FudCB0byBiYWlsIG91dC5cbiAgICAvLyBUaGF0IGlzIGRlcGVuZGluZyBvbiBpZiB3ZSB3YW50IG5lc3RlZCBzdWJ0cmVlcyAobGF5ZXJzKSB0byBidWJibGVcbiAgICAvLyBldmVudHMgdG8gdGhlaXIgcGFyZW50LiBXZSBjb3VsZCBhbHNvIGdvIHRocm91Z2ggcGFyZW50Tm9kZSBvbiB0aGVcbiAgICAvLyBob3N0IG5vZGUgYnV0IHRoYXQgd291bGRuJ3Qgd29yayBmb3IgUmVhY3QgTmF0aXZlIGFuZCBkb2Vzbid0IGxldCB1c1xuICAgIC8vIGRvIHRoZSBwb3J0YWwgZmVhdHVyZS5cbiAgfSB3aGlsZSAoaW5zdCAmJiBpbnN0LnRhZyAhPT0gSG9zdENvbXBvbmVudCk7XG4gIGlmIChpbnN0KSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSBnZXRQYXJlbnQodGVtcEEpKSB7XG4gICAgZGVwdGhBKys7XG4gIH1cbiAgdmFyIGRlcHRoQiA9IDA7XG4gIGZvciAodmFyIHRlbXBCID0gaW5zdEI7IHRlbXBCOyB0ZW1wQiA9IGdldFBhcmVudCh0ZW1wQikpIHtcbiAgICBkZXB0aEIrKztcbiAgfVxuXG4gIC8vIElmIEEgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICAgIGRlcHRoQi0tO1xuICB9XG5cbiAgLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG4gIHZhciBkZXB0aCA9IGRlcHRoQTtcbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAoaW5zdEEgPT09IGluc3RCIHx8IGluc3RBID09PSBpbnN0Qi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBpbnN0QTtcbiAgICB9XG4gICAgaW5zdEEgPSBnZXRQYXJlbnQoaW5zdEEpO1xuICAgIGluc3RCID0gZ2V0UGFyZW50KGluc3RCKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gaWYgQSBpcyBhbiBhbmNlc3RvciBvZiBCLlxuICovXG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHBhcmVudCBpbnN0YW5jZSBvZiB0aGUgcGFzc2VkLWluIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnRJbnN0YW5jZShpbnN0KSB7XG4gIHJldHVybiBnZXRQYXJlbnQoaW5zdCk7XG59XG5cbi8qKlxuICogU2ltdWxhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSB0d28tcGhhc2UsIGNhcHR1cmUvYnViYmxlIGV2ZW50IGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZVR3b1BoYXNlKGluc3QsIGZuLCBhcmcpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgd2hpbGUgKGluc3QpIHtcbiAgICBwYXRoLnB1c2goaW5zdCk7XG4gICAgaW5zdCA9IGdldFBhcmVudChpbnN0KTtcbiAgfVxuICB2YXIgaTtcbiAgZm9yIChpID0gcGF0aC5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFtpXSwgJ2NhcHR1cmVkJywgYXJnKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhbaV0sICdidWJibGVkJywgYXJnKTtcbiAgfVxufVxuXG4vKipcbiAqIFRyYXZlcnNlcyB0aGUgSUQgaGllcmFyY2h5IGFuZCBpbnZva2VzIHRoZSBzdXBwbGllZCBgY2JgIG9uIGFueSBJRHMgdGhhdFxuICogc2hvdWxkIHdvdWxkIHJlY2VpdmUgYSBgbW91c2VFbnRlcmAgb3IgYG1vdXNlTGVhdmVgIGV2ZW50LlxuICpcbiAqIERvZXMgbm90IGludm9rZSB0aGUgY2FsbGJhY2sgb24gdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGJlY2F1c2Ugbm90aGluZ1xuICogXCJlbnRlcmVkXCIgb3IgXCJsZWZ0XCIgdGhhdCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbykge1xuICB2YXIgY29tbW9uID0gZnJvbSAmJiB0byA/IGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGZyb20sIHRvKSA6IG51bGw7XG4gIHZhciBwYXRoRnJvbSA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghZnJvbSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChmcm9tID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgYWx0ZXJuYXRlID0gZnJvbS5hbHRlcm5hdGU7XG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhdGhGcm9tLnB1c2goZnJvbSk7XG4gICAgZnJvbSA9IGdldFBhcmVudChmcm9tKTtcbiAgfVxuICB2YXIgcGF0aFRvID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCF0bykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0byA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIF9hbHRlcm5hdGUgPSB0by5hbHRlcm5hdGU7XG4gICAgaWYgKF9hbHRlcm5hdGUgIT09IG51bGwgJiYgX2FsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aFRvLnB1c2godG8pO1xuICAgIHRvID0gZ2V0UGFyZW50KHRvKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aEZyb21baV0sICdidWJibGVkJywgYXJnRnJvbSk7XG4gIH1cbiAgZm9yICh2YXIgX2kgPSBwYXRoVG8ubGVuZ3RoOyBfaS0tID4gMDspIHtcbiAgICBmbihwYXRoVG9bX2ldLCAnY2FwdHVyZWQnLCBhcmdUbyk7XG4gIH1cbn1cblxuLyoqXG4gKiBTb21lIGV2ZW50IHR5cGVzIGhhdmUgYSBub3Rpb24gb2YgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBuYW1lcyBmb3IgZGlmZmVyZW50XG4gKiBcInBoYXNlc1wiIG9mIHByb3BhZ2F0aW9uLiBUaGlzIGZpbmRzIGxpc3RlbmVycyBieSBhIGdpdmVuIHBoYXNlLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW4gYVxuICogc2luZ2xlIG9uZS5cbiAqL1xuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhpbnN0LCBwaGFzZSwgZXZlbnQpIHtcbiAge1xuICAgIHdhcm5pbmcoaW5zdCwgJ0Rpc3BhdGNoaW5nIGluc3QgbXVzdCBub3QgYmUgbnVsbCcpO1xuICB9XG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcGhhc2UpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICB9XG59XG5cbi8qKlxuICogQ29sbGVjdCBkaXNwYXRjaGVzIChtdXN0IGJlIGVudGlyZWx5IGNvbGxlY3RlZCBiZWZvcmUgZGlzcGF0Y2hpbmcgLSBzZWUgdW5pdFxuICogdGVzdHMpLiBMYXppbHkgYWxsb2NhdGUgdGhlIGFycmF5IHRvIGNvbnNlcnZlIG1lbW9yeS4gIFdlIG11c3QgbG9vcCB0aHJvdWdoXG4gKiBlYWNoIGV2ZW50IGFuZCBwZXJmb3JtIHRoZSB0cmF2ZXJzYWwgZm9yIGVhY2ggb25lLiBXZSBjYW5ub3QgcGVyZm9ybSBhXG4gKiBzaW5nbGUgdHJhdmVyc2FsIGZvciB0aGUgZW50aXJlIGNvbGxlY3Rpb24gb2YgZXZlbnRzIGJlY2F1c2UgZWFjaCBldmVudCBtYXlcbiAqIGhhdmUgYSBkaWZmZXJlbnQgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHZhciB0YXJnZXRJbnN0ID0gZXZlbnQuX3RhcmdldEluc3Q7XG4gICAgdmFyIHBhcmVudEluc3QgPSB0YXJnZXRJbnN0ID8gZ2V0UGFyZW50SW5zdGFuY2UodGFyZ2V0SW5zdCkgOiBudWxsO1xuICAgIHRyYXZlcnNlVHdvUGhhc2UocGFyZW50SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcbiAqIHJlZ2lzdHJhdGlvbiBuYW1lcy4gU2FtZSBhcyBgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGVgIGJ1dCB3aXRob3V0XG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpc3BhdGNoZXMoaW5zdCwgaWdub3JlZERpcmVjdGlvbiwgZXZlbnQpIHtcbiAgaWYgKGluc3QgJiYgZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZTtcbiAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBkaXNwYXRjaGVzIG9uIGFuIGBTeW50aGV0aWNFdmVudGAsIGJ1dCBvbmx5IGZvciB0aGVcbiAqIGBkaXNwYXRjaE1hcmtlcmAuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGV2ZW50Ll90YXJnZXRJbnN0LCBudWxsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0KGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKSB7XG4gIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbnZhciBFdmVudFByb3BhZ2F0b3JzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG5cdGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcblx0YWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMsXG5cdGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzOiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1xufSk7XG5cbnZhciBjb250ZW50S2V5ID0gbnVsbDtcblxuLyoqXG4gKiBHZXRzIHRoZSBrZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50IG9uIGEgRE9NIG5vZGUuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gS2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudEFjY2Vzc29yKCkge1xuICBpZiAoIWNvbnRlbnRLZXkgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgLy8gUHJlZmVyIHRleHRDb250ZW50IHRvIGlubmVyVGV4dCBiZWNhdXNlIG1hbnkgYnJvd3NlcnMgc3VwcG9ydCBib3RoIGJ1dFxuICAgIC8vIFNWRyA8dGV4dD4gZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCBpbm5lclRleHQgZXZlbiB3aGVuIDxkaXY+IGRvZXMuXG4gICAgY29udGVudEtleSA9ICd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gJ3RleHRDb250ZW50JyA6ICdpbm5lclRleHQnO1xuICB9XG4gIHJldHVybiBjb250ZW50S2V5O1xufVxuXG4vKipcbiAqIFRoaXMgaGVscGVyIG9iamVjdCBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKlxuICovXG52YXIgY29tcG9zaXRpb25TdGF0ZSA9IHtcbiAgX3Jvb3Q6IG51bGwsXG4gIF9zdGFydFRleHQ6IG51bGwsXG4gIF9mYWxsYmFja1RleHQ6IG51bGxcbn07XG5cbmZ1bmN0aW9uIGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgY29tcG9zaXRpb25TdGF0ZS5fcm9vdCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICBjb21wb3NpdGlvblN0YXRlLl9zdGFydFRleHQgPSBnZXRUZXh0KCk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXNldCgpIHtcbiAgY29tcG9zaXRpb25TdGF0ZS5fcm9vdCA9IG51bGw7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dCA9IG51bGw7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEoKSB7XG4gIGlmIChjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQpIHtcbiAgICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0O1xuICB9XG5cbiAgdmFyIHN0YXJ0O1xuICB2YXIgc3RhcnRWYWx1ZSA9IGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dDtcbiAgdmFyIHN0YXJ0TGVuZ3RoID0gc3RhcnRWYWx1ZS5sZW5ndGg7XG4gIHZhciBlbmQ7XG4gIHZhciBlbmRWYWx1ZSA9IGdldFRleHQoKTtcbiAgdmFyIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcblxuICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0XSAhPT0gZW5kVmFsdWVbc3RhcnRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgbWluRW5kID0gc3RhcnRMZW5ndGggLSBzdGFydDtcbiAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgaWYgKCd2YWx1ZScgaW4gY29tcG9zaXRpb25TdGF0ZS5fcm9vdCkge1xuICAgIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9yb290LnZhbHVlO1xuICB9XG4gIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9yb290W2dldFRleHRDb250ZW50QWNjZXNzb3IoKV07XG59XG5cbi8qIGVzbGludCB2YWxpZC10eXBlb2Y6IDAgKi9cblxudmFyIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gZmFsc2U7XG52YXIgaXNQcm94eVN1cHBvcnRlZCA9IHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBFVkVOVF9QT09MX1NJWkUgPSAxMDtcblxudmFyIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzID0gWydkaXNwYXRjaENvbmZpZycsICdfdGFyZ2V0SW5zdCcsICduYXRpdmVFdmVudCcsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCAnX2Rpc3BhdGNoTGlzdGVuZXJzJywgJ19kaXNwYXRjaEluc3RhbmNlcyddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB7XG4gICAgLy8gdGhlc2UgaGF2ZSBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XG4gICAgZGVsZXRlIHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAge1xuICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdOyAvLyB0aGlzIGhhcyBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbl9hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wTmFtZSwgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgSW50ZXJmYWNlW3Byb3BOYW1lXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzW3Nob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzW2ldXSA9IG51bGw7XG4gICAgfVxuICAgIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJldmVudERlZmF1bHQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgZW1wdHlGdW5jdGlvbikpO1xuICAgIH1cbiAgfVxufSk7XG5cblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xuXG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzXG4gKiBAcGFyYW0gez9vYmplY3R9IEludGVyZmFjZVxuICovXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MsIEludGVyZmFjZSkge1xuICB2YXIgU3VwZXIgPSB0aGlzO1xuXG4gIHZhciBFID0gZnVuY3Rpb24gKCkge307XG4gIEUucHJvdG90eXBlID0gU3VwZXIucHJvdG90eXBlO1xuICB2YXIgcHJvdG90eXBlID0gbmV3IEUoKTtcblxuICBfYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBTdXBlci5JbnRlcmZhY2UsIEludGVyZmFjZSk7XG4gIENsYXNzLmF1Z21lbnRDbGFzcyA9IFN1cGVyLmF1Z21lbnRDbGFzcztcbiAgYWRkRXZlbnRQb29saW5nVG8oQ2xhc3MpO1xufTtcblxuLyoqIFByb3h5aW5nIGFmdGVyIGV2ZXJ5dGhpbmcgc2V0IG9uIFN5bnRoZXRpY0V2ZW50XG4gKiB0byByZXNvbHZlIFByb3h5IGlzc3VlIG9uIHNvbWUgV2ViS2l0IGJyb3dzZXJzXG4gKiBpbiB3aGljaCBzb21lIEV2ZW50IHByb3BlcnRpZXMgYXJlIHNldCB0byB1bmRlZmluZWQgKEdIIzEwMDEwKVxuICovXG57XG4gIGlmIChpc1Byb3h5U3VwcG9ydGVkKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICAgIFN5bnRoZXRpY0V2ZW50ID0gbmV3IFByb3h5KFN5bnRoZXRpY0V2ZW50LCB7XG4gICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uICh0YXJnZXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHkodGFyZ2V0LCBPYmplY3QuY3JlYXRlKHRhcmdldC5wcm90b3R5cGUpLCBhcmdzKTtcbiAgICAgIH0sXG4gICAgICBhcHBseTogZnVuY3Rpb24gKGNvbnN0cnVjdG9yLCB0aGF0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoY29uc3RydWN0b3IuYXBwbHkodGhhdCwgYXJncyksIHtcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ2lzUGVyc2lzdGVudCcgJiYgIXRhcmdldC5jb25zdHJ1Y3Rvci5JbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgd2FybmluZyhkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSB8fCB0YXJnZXQuaXNQZXJzaXN0ZW50KCksIFwiVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3UncmUgXCIgKyBcInNlZWluZyB0aGlzLCB5b3UncmUgYWRkaW5nIGEgbmV3IHByb3BlcnR5IGluIHRoZSBzeW50aGV0aWMgZXZlbnQgb2JqZWN0LiBcIiArICdUaGUgcHJvcGVydHkgaXMgbmV2ZXIgcmVsZWFzZWQuIFNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgICAgICAgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qZXNsaW50LWVuYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICB9XG59XG5cbmFkZEV2ZW50UG9vbGluZ1RvKFN5bnRoZXRpY0V2ZW50KTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gbnVsbGlmeSBzeW50aGV0aWNFdmVudCBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gZGVzdHJ1Y3RpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWVcbiAqIEBwYXJhbSB7P29iamVjdH0gZ2V0VmFsXG4gKiBAcmV0dXJuIHtvYmplY3R9IGRlZmluZVByb3BlcnR5IG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBnZXRWYWwpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgZ2V0VmFsID09PSAnZnVuY3Rpb24nO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IHNldCxcbiAgICBnZXQ6IGdldFxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdzZXR0aW5nIHRoZSBtZXRob2QnIDogJ3NldHRpbmcgdGhlIHByb3BlcnR5JztcbiAgICB3YXJuKGFjdGlvbiwgJ1RoaXMgaXMgZWZmZWN0aXZlbHkgYSBuby1vcCcpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnYWNjZXNzaW5nIHRoZSBtZXRob2QnIDogJ2FjY2Vzc2luZyB0aGUgcHJvcGVydHknO1xuICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uID8gJ1RoaXMgaXMgYSBuby1vcCBmdW5jdGlvbicgOiAnVGhpcyBpcyBzZXQgdG8gbnVsbCc7XG4gICAgd2FybihhY3Rpb24sIHJlc3VsdCk7XG4gICAgcmV0dXJuIGdldFZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oYWN0aW9uLCByZXN1bHQpIHtcbiAgICB2YXIgd2FybmluZ0NvbmRpdGlvbiA9IGZhbHNlO1xuICAgIHdhcm5pbmcod2FybmluZ0NvbmRpdGlvbiwgXCJUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgXCIgKyBcInlvdSdyZSAlcyBgJXNgIG9uIGEgcmVsZWFzZWQvbnVsbGlmaWVkIHN5bnRoZXRpYyBldmVudC4gJXMuIFwiICsgJ0lmIHlvdSBtdXN0IGtlZXAgdGhlIG9yaWdpbmFsIHN5bnRoZXRpYyBldmVudCBhcm91bmQsIHVzZSBldmVudC5wZXJzaXN0KCkuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBhY3Rpb24sIHByb3BOYW1lLCByZXN1bHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBvb2xlZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCkge1xuICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIGlmIChFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5wb3AoKTtcbiAgICBFdmVudENvbnN0cnVjdG9yLmNhbGwoaW5zdGFuY2UsIGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIHJldHVybiBuZXcgRXZlbnRDb25zdHJ1Y3RvcihkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlUG9vbGVkRXZlbnQoZXZlbnQpIHtcbiAgdmFyIEV2ZW50Q29uc3RydWN0b3IgPSB0aGlzO1xuICAhKGV2ZW50IGluc3RhbmNlb2YgRXZlbnRDb25zdHJ1Y3RvcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBldmVudCBpbnN0YW5jZSAgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IHZvaWQgMDtcbiAgZXZlbnQuZGVzdHJ1Y3RvcigpO1xuICBpZiAoRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wubGVuZ3RoIDwgRVZFTlRfUE9PTF9TSVpFKSB7XG4gICAgRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wucHVzaChldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRQb29saW5nVG8oRXZlbnRDb25zdHJ1Y3Rvcikge1xuICBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbCA9IFtdO1xuICBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZCA9IGdldFBvb2xlZEV2ZW50O1xuICBFdmVudENvbnN0cnVjdG9yLnJlbGVhc2UgPSByZWxlYXNlUG9vbGVkRXZlbnQ7XG59XG5cbnZhciBTeW50aGV0aWNFdmVudCQxID0gU3ludGhldGljRXZlbnQ7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50c1xuICovXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIElucHV0RXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNJbnB1dEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNJbnB1dEV2ZW50LCBJbnB1dEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcbnZhciBTVEFSVF9LRVlDT0RFID0gMjI5O1xuXG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xuXG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufVxuXG4vLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlICYmICFpc1ByZXN0bygpO1xuXG4vLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xuXG4vKipcbiAqIE9wZXJhIDw9IDEyIGluY2x1ZGVzIFRleHRFdmVudCBpbiB3aW5kb3csIGJ1dCBkb2VzIG5vdCBmaXJlXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBpc1ByZXN0bygpIHtcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xuICByZXR1cm4gdHlwZW9mIG9wZXJhID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBwYXJzZUludChvcGVyYS52ZXJzaW9uKCksIDEwKSA8PSAxMjtcbn1cblxudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGJlZm9yZUlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkJlZm9yZUlucHV0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25CZWZvcmVJbnB1dENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQ29tcG9zaXRpb25FbmQnLCAndG9wS2V5UHJlc3MnLCAndG9wVGV4dElucHV0JywgJ3RvcFBhc3RlJ11cbiAgfSxcbiAgY29tcG9zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25FbmQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uRW5kJywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfSxcbiAgY29tcG9zaXRpb25TdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblN0YXJ0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uU3RhcnQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9LFxuICBjb21wb3NpdGlvblVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblVwZGF0ZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25VcGRhdGUnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9XG59O1xuXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG52YXIgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAhKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uU3RhcnQnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvblVwZGF0ZSc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicgJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG4gICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgLy8gRXZlbnRzIGFyZSBub3QgcG9zc2libGUgd2l0aG91dCBjYW5jZWxsaW5nIElNRS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHb29nbGUgSW5wdXQgVG9vbHMgcHJvdmlkZXMgY29tcG9zaXRpb24gZGF0YSB2aWEgYSBDdXN0b21FdmVudCxcbiAqIHdpdGggdGhlIGBkYXRhYCBwcm9wZXJ0eSBwb3B1bGF0ZWQgaW4gdGhlIGBkZXRhaWxgIG9iamVjdC4gSWYgdGhpc1xuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBldmVudCBvYmplY3QsIHVzZSBpdC4gSWYgbm90LCB0aGlzIGlzIGEgcGxhaW5cbiAqIGNvbXBvc2l0aW9uIGV2ZW50IGFuZCB3ZSBoYXZlIG5vdGhpbmcgc3BlY2lhbCB0byBleHRyYWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuICBpZiAodHlwZW9mIGRldGFpbCA9PT0gJ29iamVjdCcgJiYgJ2RhdGEnIGluIGRldGFpbCkge1xuICAgIHJldHVybiBkZXRhaWwuZGF0YTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVHJhY2sgdGhlIGN1cnJlbnQgSU1FIGNvbXBvc2l0aW9uIHN0YXR1cywgaWYgYW55LlxudmFyIGlzQ29tcG9zaW5nID0gZmFsc2U7XG5cbi8qKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRUeXBlO1xuICB2YXIgZmFsbGJhY2tEYXRhO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKTtcbiAgfSBlbHNlIGlmICghaXNDb21wb3NpbmcpIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEpIHtcbiAgICAvLyBUaGUgY3VycmVudCBjb21wb3NpdGlvbiBpcyBzdG9yZWQgc3RhdGljYWxseSBhbmQgbXVzdCBub3QgYmVcbiAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgaWYgKCFpc0NvbXBvc2luZyAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgaXNDb21wb3NpbmcgPSBpbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZCkge1xuICAgICAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmdldFBvb2xlZChldmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKGZhbGxiYWNrRGF0YSkge1xuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgZXZlbnQuZGF0YSA9IGZhbGxiYWNrRGF0YTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VG9wTGV2ZWxUeXBlc30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgIC8qKlxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXG4gICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXG4gICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICogcGFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAqXG4gICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSAndG9wVGV4dElucHV0JzpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBibGFja2xpc3QgaXQuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgQnJvd3NlckV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBmYWxsYmFjayBzdHJpbmcgZm9yIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgLy8gSWYgY29tcG9zaXRpb24gZXZlbnQgaXMgYXZhaWxhYmxlLCB3ZSBleHRyYWN0IGEgc3RyaW5nIG9ubHkgYXRcbiAgLy8gY29tcG9zaXRpb25ldmVudCwgb3RoZXJ3aXNlIGV4dHJhY3QgaXQgYXQgZmFsbGJhY2sgZXZlbnRzLlxuICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ29tcG9zaXRpb25FbmQnIHx8ICFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ICYmIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgdmFyIGNoYXJzID0gZ2V0RGF0YSgpO1xuICAgICAgcmVzZXQoKTtcbiAgICAgIGlzQ29tcG9zaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAoIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAvLyBJRSBmaXJlcyB0aGUgYGtleXByZXNzYCBldmVudCB3aGVuIGEgdXNlciB0eXBlcyBhbiBlbW9qaSB2aWFcbiAgICAgICAgLy8gVG91Y2gga2V5Ym9hcmQgb2YgV2luZG93cy4gIEluIHN1Y2ggYSBjYXNlLCB0aGUgYGNoYXJgIHByb3BlcnR5XG4gICAgICAgIC8vIGhvbGRzIGFuIGVtb2ppIGNoYXJhY3RlciBsaWtlIGBcXHVEODNEXFx1REUwQWAuICBCZWNhdXNlIGl0cyBsZW5ndGhcbiAgICAgICAgLy8gaXMgMiwgdGhlIHByb3BlcnR5IGB3aGljaGAgZG9lcyBub3QgcmVwcmVzZW50IGFuIGVtb2ppIGNvcnJlY3RseS5cbiAgICAgICAgLy8gSW4gc3VjaCBhIGNhc2UsIHdlIGRpcmVjdGx5IHJldHVybiB0aGUgYGNoYXJgIHByb3BlcnR5IGluc3RlYWQgb2ZcbiAgICAgICAgLy8gdXNpbmcgYHdoaWNoYC5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmNoYXIgJiYgbmF0aXZlRXZlbnQuY2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmNoYXI7XG4gICAgICAgIH0gZWxzZSBpZiAobmF0aXZlRXZlbnQud2hpY2gpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICByZXR1cm4gW2V4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSwgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpXTtcbiAgfVxufTtcblxuLy8gVXNlIHRvIHJlc3RvcmUgY29udHJvbGxlZCBzdGF0ZSBhZnRlciBhIGNoYW5nZSBldmVudCBoYXMgZmlyZWQuXG5cbnZhciBmaWJlckhvc3RDb21wb25lbnQgPSBudWxsO1xuXG52YXIgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uID0ge1xuICBpbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50OiBmdW5jdGlvbiAoaG9zdENvbXBvbmVudEltcGwpIHtcbiAgICAvLyBUaGUgZmliZXIgaW1wbGVtZW50YXRpb24gZG9lc24ndCB1c2UgZHluYW1pYyBkaXNwYXRjaCBzbyB3ZSBuZWVkIHRvXG4gICAgLy8gaW5qZWN0IHRoZSBpbXBsZW1lbnRhdGlvbi5cbiAgICBmaWJlckhvc3RDb21wb25lbnQgPSBob3N0Q29tcG9uZW50SW1wbDtcbiAgfVxufTtcblxudmFyIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xudmFyIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCkge1xuICAvLyBXZSBwZXJmb3JtIHRoaXMgdHJhbnNsYXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQgbG9vcCBzbyB0aGF0IHdlXG4gIC8vIGFsd2F5cyByZWNlaXZlIHRoZSBjb3JyZWN0IGZpYmVyIGhlcmVcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKHRhcmdldCk7XG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIC8vIFVubW91bnRlZFxuICAgIHJldHVybjtcbiAgfVxuICAhKGZpYmVySG9zdENvbXBvbmVudCAmJiB0eXBlb2YgZmliZXJIb3N0Q29tcG9uZW50LnJlc3RvcmVDb250cm9sbGVkU3RhdGUgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnRmliZXIgbmVlZHMgdG8gYmUgaW5qZWN0ZWQgdG8gaGFuZGxlIGEgZmliZXIgdGFyZ2V0IGZvciBjb250cm9sbGVkIGV2ZW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSk7XG4gIGZpYmVySG9zdENvbXBvbmVudC5yZXN0b3JlQ29udHJvbGxlZFN0YXRlKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlLCBpbnRlcm5hbEluc3RhbmNlLnR5cGUsIHByb3BzKTtcbn1cblxudmFyIGluamVjdGlvbiQzID0gUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uO1xuXG5mdW5jdGlvbiBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCkge1xuICBpZiAocmVzdG9yZVRhcmdldCkge1xuICAgIGlmIChyZXN0b3JlUXVldWUpIHtcbiAgICAgIHJlc3RvcmVRdWV1ZS5wdXNoKHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RvcmVRdWV1ZSA9IFt0YXJnZXRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN0b3JlVGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCkge1xuICBpZiAoIXJlc3RvcmVUYXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHRhcmdldCA9IHJlc3RvcmVUYXJnZXQ7XG4gIHZhciBxdWV1ZWRUYXJnZXRzID0gcmVzdG9yZVF1ZXVlO1xuICByZXN0b3JlVGFyZ2V0ID0gbnVsbDtcbiAgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuICByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpO1xuICBpZiAocXVldWVkVGFyZ2V0cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWVkVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQocXVldWVkVGFyZ2V0c1tpXSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQgPSBPYmplY3QuZnJlZXplKHtcblx0aW5qZWN0aW9uOiBpbmplY3Rpb24kMyxcblx0ZW5xdWV1ZVN0YXRlUmVzdG9yZTogZW5xdWV1ZVN0YXRlUmVzdG9yZSxcblx0cmVzdG9yZVN0YXRlSWZOZWVkZWQ6IHJlc3RvcmVTdGF0ZUlmTmVlZGVkXG59KTtcblxuLy8gVXNlZCBhcyBhIHdheSB0byBjYWxsIGJhdGNoZWRVcGRhdGVzIHdoZW4gd2UgZG9uJ3QgaGF2ZSBhIHJlZmVyZW5jZSB0b1xuLy8gdGhlIHJlbmRlcmVyLiBTdWNoIGFzIHdoZW4gd2UncmUgZGlzcGF0Y2hpbmcgZXZlbnRzIG9yIGlmIHRoaXJkIHBhcnR5XG4vLyBsaWJyYXJpZXMgbmVlZCB0byBjYWxsIGJhdGNoZWRVcGRhdGVzLiBFdmVudHVhbGx5LCB0aGlzIEFQSSB3aWxsIGdvIGF3YXkgd2hlblxuLy8gZXZlcnl0aGluZyBpcyBiYXRjaGVkIGJ5IGRlZmF1bHQuIFdlJ2xsIHRoZW4gaGF2ZSBhIHNpbWlsYXIgQVBJIHRvIG9wdC1vdXQgb2Zcbi8vIHNjaGVkdWxlZCB3b3JrIGFuZCBpbnN0ZWFkIGRvIHN5bmNocm9ub3VzIHdvcmsuXG5cbi8vIERlZmF1bHRzXG52YXIgZmliZXJCYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYm9va2tlZXBpbmcpIHtcbiAgcmV0dXJuIGZuKGJvb2trZWVwaW5nKTtcbn07XG5cbnZhciBpc05lc3RpbmdCYXRjaGVkID0gZmFsc2U7XG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpIHtcbiAgaWYgKGlzTmVzdGluZ0JhdGNoZWQpIHtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluc2lkZSBhbm90aGVyIGJhdGNoLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXRcbiAgICAvLyBmdWxseSBjb21wbGV0ZXMgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZS4gVGhlcmVmb3JlLCB3ZSBhZGQgdGhlIHRhcmdldCB0b1xuICAgIC8vIGEgcXVldWUgb2Ygd29yay5cbiAgICByZXR1cm4gZmliZXJCYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpO1xuICB9XG4gIGlzTmVzdGluZ0JhdGNoZWQgPSB0cnVlO1xuICB0cnkge1xuICAgIHJldHVybiBmaWJlckJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZyk7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gSGVyZSB3ZSB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2ggaXMgaW1wb3J0YW50XG4gICAgLy8gd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgICAvLyBUaGVuIHdlIHJlc3RvcmUgc3RhdGUgb2YgYW55IGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICAgIGlzTmVzdGluZ0JhdGNoZWQgPSBmYWxzZTtcbiAgICByZXN0b3JlU3RhdGVJZk5lZWRlZCgpO1xuICB9XG59XG5cbnZhciBSZWFjdEdlbmVyaWNCYXRjaGluZ0luamVjdGlvbiA9IHtcbiAgaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKF9iYXRjaGVkVXBkYXRlcykge1xuICAgIGZpYmVyQmF0Y2hlZFVwZGF0ZXMgPSBfYmF0Y2hlZFVwZGF0ZXM7XG4gIH1cbn07XG5cbnZhciBpbmplY3Rpb24kNCA9IFJlYWN0R2VuZXJpY0JhdGNoaW5nSW5qZWN0aW9uO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgY29sb3I6IHRydWUsXG4gIGRhdGU6IHRydWUsXG4gIGRhdGV0aW1lOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICBlbWFpbDogdHJ1ZSxcbiAgbW9udGg6IHRydWUsXG4gIG51bWJlcjogdHJ1ZSxcbiAgcGFzc3dvcmQ6IHRydWUsXG4gIHJhbmdlOiB0cnVlLFxuICBzZWFyY2g6IHRydWUsXG4gIHRlbDogdHJ1ZSxcbiAgdGV4dDogdHJ1ZSxcbiAgdGltZTogdHJ1ZSxcbiAgdXJsOiB0cnVlLFxuICB3ZWVrOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgIHJldHVybiAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEhUTUwgbm9kZVR5cGUgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSB0eXBlIG9mIHRoZSBub2RlXG4gKi9cblxudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xudmFyIERPQ1VNRU5UX05PREUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcblxuICAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gIH1cblxuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSBURVhUX05PREUgPyB0YXJnZXQucGFyZW50Tm9kZSA6IHRhcmdldDtcbn1cblxudmFyIHVzZUhhc0ZlYXR1cmU7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHVzZUhhc0ZlYXR1cmUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gIC8vIGFsd2F5cyByZXR1cm5zIHRydWUgaW4gbmV3ZXIgYnJvd3NlcnMgYXMgcGVyIHRoZSBzdGFuZGFyZC5cbiAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQ2hlY2thYmxlKGVsZW0pIHtcbiAgdmFyIHR5cGUgPSBlbGVtLnR5cGU7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmICh0eXBlID09PSAnY2hlY2tib3gnIHx8IHR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFja2VyKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3ZhbHVlVHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gZGV0YWNoVHJhY2tlcihub2RlKSB7XG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgdmFsdWUgPSAnJztcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKGlzQ2hlY2thYmxlKG5vZGUpKSB7XG4gICAgdmFsdWUgPSBub2RlLmNoZWNrZWQgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJhY2tWYWx1ZU9uTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZUZpZWxkID0gaXNDaGVja2FibGUobm9kZSkgPyAnY2hlY2tlZCcgOiAndmFsdWUnO1xuICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHZhbHVlRmllbGQpO1xuXG4gIHZhciBjdXJyZW50VmFsdWUgPSAnJyArIG5vZGVbdmFsdWVGaWVsZF07XG5cbiAgLy8gaWYgc29tZW9uZSBoYXMgYWxyZWFkeSBkZWZpbmVkIGEgdmFsdWUgb3IgU2FmYXJpLCB0aGVuIGJhaWxcbiAgLy8gYW5kIGRvbid0IHRyYWNrIHZhbHVlIHdpbGwgY2F1c2Ugb3ZlciByZXBvcnRpbmcgb2YgY2hhbmdlcyxcbiAgLy8gYnV0IGl0J3MgYmV0dGVyIHRoZW4gYSBoYXJkIGZhaWx1cmVcbiAgLy8gKG5lZWRlZCBmb3IgY2VydGFpbiB0ZXN0cyB0aGF0IHNweU9uIGlucHV0IHZhbHVlcyBhbmQgU2FmYXJpKVxuICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZUZpZWxkKSB8fCB0eXBlb2YgZGVzY3JpcHRvci5nZXQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwodGhpcyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudFZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHRyYWNrZXIgPSB7XG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfSxcbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0sXG4gICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXRhY2hUcmFja2VyKG5vZGUpO1xuICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gdHJhY2sobm9kZSkge1xuICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE86IE9uY2UgaXQncyBqdXN0IEZpYmVyIHdlIGNhbiBtb3ZlIHRoaXMgdG8gbm9kZS5fd3JhcHBlclN0YXRlXG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IHRyYWNrVmFsdWVPbk5vZGUobm9kZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpO1xuICAvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuICAvLyB0aGF0IHRyeWluZyBhZ2FpbiB3aWxsIHN1Y2NlZWRcbiAgaWYgKCF0cmFja2VyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbGFzdFZhbHVlID0gdHJhY2tlci5nZXRWYWx1ZSgpO1xuICB2YXIgbmV4dFZhbHVlID0gZ2V0VmFsdWVGcm9tTm9kZShub2RlKTtcbiAgaWYgKG5leHRWYWx1ZSAhPT0gbGFzdFZhbHVlKSB7XG4gICAgdHJhY2tlci5zZXRWYWx1ZShuZXh0VmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGV2ZW50VHlwZXMkMSA9IHtcbiAgY2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNoYW5nZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ2hhbmdlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENoYW5nZScsICd0b3BDbGljaycsICd0b3BGb2N1cycsICd0b3BJbnB1dCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChpbnN0LCBuYXRpdmVFdmVudCwgdGFyZ2V0KSB7XG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50JDEuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMS5jaGFuZ2UsIGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpO1xuICBldmVudC50eXBlID0gJ2NoYW5nZSc7XG4gIC8vIEZsYWcgdGhpcyBldmVudCBsb29wIGFzIG5lZWRpbmcgc3RhdGUgcmVzdG9yZS5cbiAgZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpO1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBiYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIGVucXVldWVFdmVudHMoZXZlbnQpO1xuICBwcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KSB7XG4gIHZhciB0YXJnZXROb2RlID0gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpO1xuICBpZiAodXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KSkge1xuICAgIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wU2VsZWN0aW9uQ2hhbmdlJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlVcCcgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicpIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENsaWNrJykge1xuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcElucHV0JyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKGluc3QsIG5vZGUpIHtcbiAgLy8gVE9ETzogSW4gSUUsIGluc3QgaXMgb2NjYXNpb25hbGx5IG51bGwuIFdoeT9cbiAgaWYgKGluc3QgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZpYmVyIGFuZCBSZWFjdERPTSBrZWVwIHdyYXBwZXIgc3RhdGUgaW4gc2VwYXJhdGUgcGxhY2VzXG4gIHZhciBzdGF0ZSA9IGluc3QuX3dyYXBwZXJTdGF0ZSB8fCBub2RlLl93cmFwcGVyU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuY29udHJvbGxlZCB8fCBub2RlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgY29udHJvbGxlZCwgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb24gYmx1clxuICB2YXIgdmFsdWUgPSAnJyArIG5vZGUudmFsdWU7XG4gIGlmIChub2RlLmdldEF0dHJpYnV0ZSgndmFsdWUnKSAhPT0gdmFsdWUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvbkNoYW5nZWAgZXZlbnQgdGhhdCBub3JtYWxpemVzIGNoYW5nZSBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLiBUaGlzIGV2ZW50IGZpcmVzIGF0IGEgdGltZSB3aGVuIGl0J3MgcG9zc2libGUgdG9cbiAqIGNoYW5nZSB0aGUgZWxlbWVudCdzIHZhbHVlIHdpdGhvdXQgc2VlaW5nIGEgZmxpY2tlci5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBzZWxlY3RcbiAqL1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDEsXG5cbiAgX2lzSW5wdXRFdmVudFN1cHBvcnRlZDogaXNJbnB1dEV2ZW50U3VwcG9ydGVkLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHZhciBnZXRUYXJnZXRJbnN0RnVuYywgaGFuZGxlRXZlbnRGdW5jO1xuICAgIGlmIChzaG91bGRVc2VDaGFuZ2VFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQ7XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChpc0lucHV0RXZlbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsO1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaG91bGRVc2VDbGlja0V2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChnZXRUYXJnZXRJbnN0RnVuYykge1xuICAgICAgdmFyIGluc3QgPSBnZXRUYXJnZXRJbnN0RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpO1xuICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlRXZlbnRGdW5jKSB7XG4gICAgICBoYW5kbGVFdmVudEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXROb2RlLCB0YXJnZXRJbnN0KTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGJsdXJyaW5nLCBzZXQgdGhlIHZhbHVlIGF0dHJpYnV0ZSBmb3IgbnVtYmVyIGlucHV0c1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xuICAgICAgaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cih0YXJnZXRJbnN0LCB0YXJnZXROb2RlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cbnZhciBET01FdmVudFBsdWdpbk9yZGVyID0gWydSZXNwb25kZXJFdmVudFBsdWdpbicsICdTaW1wbGVFdmVudFBsdWdpbicsICdUYXBFdmVudFBsdWdpbicsICdFbnRlckxlYXZlRXZlbnRQbHVnaW4nLCAnQ2hhbmdlRXZlbnRQbHVnaW4nLCAnU2VsZWN0RXZlbnRQbHVnaW4nLCAnQmVmb3JlSW5wdXRFdmVudFBsdWdpbiddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBudWxsLFxuICBkZXRhaWw6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNVSUV2ZW50LCBVSUV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gIEFsdDogJ2FsdEtleScsXG4gIENvbnRyb2w6ICdjdHJsS2V5JyxcbiAgTWV0YTogJ21ldGFLZXknLFxuICBTaGlmdDogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IHtcbiAgc2NyZWVuWDogbnVsbCxcbiAgc2NyZWVuWTogbnVsbCxcbiAgY2xpZW50WDogbnVsbCxcbiAgY2xpZW50WTogbnVsbCxcbiAgcGFnZVg6IG51bGwsXG4gIHBhZ2VZOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogbnVsbCxcbiAgYnV0dG9uczogbnVsbCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNNb3VzZUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNNb3VzZUV2ZW50LCBNb3VzZUV2ZW50SW50ZXJmYWNlKTtcblxudmFyIGV2ZW50VHlwZXMkMiA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlRW50ZXInLFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BNb3VzZU91dCcsICd0b3BNb3VzZU92ZXInXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VMZWF2ZScsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH1cbn07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMixcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlT3ZlcicgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3V0JyAmJiB0b3BMZXZlbFR5cGUgIT09ICd0b3BNb3VzZU92ZXInKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgICAgLy8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdXQnKSB7XG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcbiAgICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQ7XG4gICAgICB0byA9IHJlbGF0ZWQgPyBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgICBmcm9tID0gbnVsbDtcbiAgICAgIHRvID0gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmcm9tTm9kZSA9IGZyb20gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UkMShmcm9tKTtcbiAgICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0byk7XG5cbiAgICB2YXIgbGVhdmUgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzJDIubW91c2VMZWF2ZSwgZnJvbSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzJDIubW91c2VFbnRlciwgdG8sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZW50ZXIudHlwZSA9ICdtb3VzZWVudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0b05vZGU7XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuXG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pO1xuXG4gICAgcmV0dXJuIFtsZWF2ZSwgZW50ZXJdO1xuICB9XG59O1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9cblxuLyoqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICogdHJhbnNmb3JtIHRoZXNlIHRvIHN0cmluZ3MgZm9yIElFIHN1cHBvcnQuIFdoZW4gdGhpcyB0cmFuc2Zvcm0gaXMgZnVsbHlcbiAqIHN1cHBvcnRlZCB3ZSBjYW4gcmVuYW1lIGl0LlxuICovXG5cblxuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXI7XG59XG5cbmZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyID0gdmFsdWU7XG59XG5cbnZhciBSZWFjdEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikge1xuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gRG9uJ3QgY2hhbmdlIHRoZXNlIHR3byB2YWx1ZXM6XG52YXIgTm9FZmZlY3QgPSAwOyAvLyAgICAgICAgICAgMGIwMDAwMDAwMFxudmFyIFBlcmZvcm1lZFdvcmsgPSAxOyAvLyAgICAgIDBiMDAwMDAwMDFcblxuLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG52YXIgUGxhY2VtZW50ID0gMjsgLy8gICAgICAgICAgMGIwMDAwMDAxMFxudmFyIFVwZGF0ZSA9IDQ7IC8vICAgICAgICAgICAgIDBiMDAwMDAxMDBcbnZhciBQbGFjZW1lbnRBbmRVcGRhdGUgPSA2OyAvLyAwYjAwMDAwMTEwXG52YXIgRGVsZXRpb24gPSA4OyAvLyAgICAgICAgICAgMGIwMDAwMTAwMFxudmFyIENvbnRlbnRSZXNldCA9IDE2OyAvLyAgICAgIDBiMDAwMTAwMDBcbnZhciBDYWxsYmFjayA9IDMyOyAvLyAgICAgICAgICAwYjAwMTAwMDAwXG52YXIgRXJyID0gNjQ7IC8vICAgICAgICAgICAgICAgMGIwMTAwMDAwMFxudmFyIFJlZiA9IDEyODsgLy8gICAgICAgICAgICAgIDBiMTAwMDAwMDBcblxudmFyIE1PVU5USU5HID0gMTtcbnZhciBNT1VOVEVEID0gMjtcbnZhciBVTk1PVU5URUQgPSAzO1xuXG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICByZXR1cm4gTU9VTlRJTkc7XG4gICAgfVxuICAgIHdoaWxlIChub2RlWydyZXR1cm4nXSkge1xuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICAgIHJldHVybiBNT1VOVElORztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGVbJ3JldHVybiddKSB7XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBNT1VOVEVEO1xuICB9XG4gIC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cbiAgcmV0dXJuIFVOTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWQoZmliZXIpIHtcbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGlzTW91bnRlZChjb21wb25lbnQpIHtcbiAge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIHdhcm5pbmcoaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lckZpYmVyKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG4gIGlmICghZmliZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICAhKGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICBpZiAoIWFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhlbiB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgaWYgaXQgaXMgbW91bnRlZC5cbiAgICB2YXIgc3RhdGUgPSBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpO1xuICAgICEoc3RhdGUgIT09IFVOTU9VTlRFRCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gICAgaWYgKHN0YXRlID09PSBNT1VOVElORykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3RcbiAgLy8gdG8gc2VlIHdoYXQgcGF0aCB0aGUgcm9vdCBwb2ludHMgdG8uIE9uIHRoZSB3YXkgd2UgbWF5IGhpdCBvbmUgb2YgdGhlXG4gIC8vIHNwZWNpYWwgY2FzZXMgYW5kIHdlJ2xsIGRlYWwgd2l0aCB0aGVtLlxuICB2YXIgYSA9IGZpYmVyO1xuICB2YXIgYiA9IGFsdGVybmF0ZTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcGFyZW50QSA9IGFbJ3JldHVybiddO1xuICAgIHZhciBwYXJlbnRCID0gcGFyZW50QSA/IHBhcmVudEEuYWx0ZXJuYXRlIDogbnVsbDtcbiAgICBpZiAoIXBhcmVudEEgfHwgIXBhcmVudEIpIHtcbiAgICAgIC8vIFdlJ3JlIGF0IHRoZSByb290LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gSWYgYm90aCBjb3BpZXMgb2YgdGhlIHBhcmVudCBmaWJlciBwb2ludCB0byB0aGUgc2FtZSBjaGlsZCwgd2UgY2FuXG4gICAgLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG4gICAgLy8gcHJpb3JpdHk6IHRoZSBiYWlsZWQgb3V0IGZpYmVyJ3MgY2hpbGQgcmV1c2VzIHRoZSBjdXJyZW50IGNoaWxkLlxuICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYSkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGFsdGVybmF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSBhbiBhbHRlcm5hdGUgZm9yIGFueSBtb3VudGluZyBub2RlLiBTbyB0aGUgb25seVxuICAgICAgLy8gd2F5IHRoaXMgY291bGQgcG9zc2libHkgaGFwcGVuIGlzIGlmIHRoaXMgd2FzIHVubW91bnRlZCwgaWYgYXQgYWxsLlxuICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChhWydyZXR1cm4nXSAhPT0gYlsncmV0dXJuJ10pIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbiAgICAgIC8vIGZpYmVycy4gV2UgYXNzdW1lIHRoYXQgcmV0dXJuIHBvaW50ZXJzIG5ldmVyIGNyaXNzLWNyb3NzLCBzbyBBIG11c3RcbiAgICAgIC8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbiAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cbiAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgYiA9IHBhcmVudEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlcnMgcG9pbnQgdG8gdGhlIHNhbWUgZmliZXIuIFdlJ2xsIGhhdmUgdG8gdXNlIHRoZVxuICAgICAgLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbiAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuICAgICAgLy9cbiAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxuICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuICAgICAgdmFyIF9jaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgLy8gU2VhcmNoIHBhcmVudCBCJ3MgY2hpbGQgc2V0XG4gICAgICAgIF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG4gICAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuICAgICAgICAhZGlkRmluZENoaWxkID8gaW52YXJpYW50KGZhbHNlLCAnQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgICEoYS5hbHRlcm5hdGUgPT09IGIpID8gaW52YXJpYW50KGZhbHNlLCAnUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzXFwnIGFsdGVybmF0ZXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIH1cbiAgLy8gSWYgdGhlIHJvb3QgaXMgbm90IGEgaG9zdCBjb250YWluZXIsIHdlJ3JlIGluIGEgZGlzY29ubmVjdGVkIHRyZWUuIEkuZS5cbiAgLy8gdW5tb3VudGVkLlxuICAhKGEudGFnID09PSBIb3N0Um9vdCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG4gIHJldHVybiBhbHRlcm5hdGU7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAmJiBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSA9IDEwO1xudmFyIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sID0gW107XG5cbi8qKlxuICogRmluZCB0aGUgZGVlcGVzdCBSZWFjdCBjb21wb25lbnQgY29tcGxldGVseSBjb250YWluaW5nIHRoZSByb290IG9mIHRoZVxuICogcGFzc2VkLWluIGluc3RhbmNlIChmb3IgdXNlIHdoZW4gZW50aXJlIFJlYWN0IHRyZWVzIGFyZSBuZXN0ZWQgd2l0aGluIGVhY2hcbiAqIG90aGVyKS4gSWYgUmVhY3QgdHJlZXMgYXJlIG5vdCBuZXN0ZWQsIHJldHVybnMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZmluZFJvb3RDb250YWluZXJOb2RlKGluc3QpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgd2hpbGUgKGluc3RbJ3JldHVybiddKSB7XG4gICAgaW5zdCA9IGluc3RbJ3JldHVybiddO1xuICB9XG4gIGlmIChpbnN0LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgd2UncmUgaW4gYSBkZXRhY2hlZCB0cmVlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBpbnN0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIGdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0KSB7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wb3AoKTtcbiAgICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gICAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3BMZXZlbFR5cGU6IHRvcExldmVsVHlwZSxcbiAgICBuYXRpdmVFdmVudDogbmF0aXZlRXZlbnQsXG4gICAgdGFyZ2V0SW5zdDogdGFyZ2V0SW5zdCxcbiAgICBhbmNlc3RvcnM6IFtdXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBudWxsO1xuICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gbnVsbDtcbiAgaW5zdGFuY2UuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGggPCBDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUpIHtcbiAgICBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbEltcGwoYm9va0tlZXBpbmcpIHtcbiAgdmFyIHRhcmdldEluc3QgPSBib29rS2VlcGluZy50YXJnZXRJbnN0O1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgaGllcmFyY2h5LCBpbiBjYXNlIHRoZXJlJ3MgYW55IG5lc3RlZCBjb21wb25lbnRzLlxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIGJ1aWxkIHRoZSBhcnJheSBvZiBhbmNlc3RvcnMgYmVmb3JlIGNhbGxpbmcgYW55XG4gIC8vIGV2ZW50IGhhbmRsZXJzLCBiZWNhdXNlIGV2ZW50IGhhbmRsZXJzIGNhbiBtb2RpZnkgdGhlIERPTSwgbGVhZGluZyB0b1xuICAvLyBpbmNvbnNpc3RlbmNpZXMgd2l0aCBSZWFjdE1vdW50J3Mgbm9kZSBjYWNoZS4gU2VlICMxMTA1LlxuICB2YXIgYW5jZXN0b3IgPSB0YXJnZXRJbnN0O1xuICBkbyB7XG4gICAgaWYgKCFhbmNlc3Rvcikge1xuICAgICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciByb290ID0gZmluZFJvb3RDb250YWluZXJOb2RlKGFuY2VzdG9yKTtcbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgYW5jZXN0b3IgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyb290KTtcbiAgfSB3aGlsZSAoYW5jZXN0b3IpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLmFuY2VzdG9yc1tpXTtcbiAgICBfaGFuZGxlVG9wTGV2ZWwoYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBjYW4gd2Ugc3RvcCBleHBvcnRpbmcgdGhlc2U/XG52YXIgX2VuYWJsZWQgPSB0cnVlO1xudmFyIF9oYW5kbGVUb3BMZXZlbCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gc2V0SGFuZGxlVG9wTGV2ZWwoaGFuZGxlVG9wTGV2ZWwpIHtcbiAgX2hhbmRsZVRvcExldmVsID0gaGFuZGxlVG9wTGV2ZWw7XG59XG5cbmZ1bmN0aW9uIHNldEVuYWJsZWQoZW5hYmxlZCkge1xuICBfZW5hYmxlZCA9ICEhZW5hYmxlZDtcbn1cblxuZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICByZXR1cm4gX2VuYWJsZWQ7XG59XG5cbi8qKlxuICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIEV2ZW50TGlzdGVuZXIubGlzdGVuKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xufVxuXG4vKipcbiAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBkaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBpZiAoIV9lbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpO1xuICB2YXIgdGFyZ2V0SW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgaWYgKHRhcmdldEluc3QgIT09IG51bGwgJiYgdHlwZW9mIHRhcmdldEluc3QudGFnID09PSAnbnVtYmVyJyAmJiAhaXNGaWJlck1vdW50ZWQodGFyZ2V0SW5zdCkpIHtcbiAgICAvLyBJZiB3ZSBnZXQgYW4gZXZlbnQgKGV4OiBpbWcgb25sb2FkKSBiZWZvcmUgY29tbWl0dGluZyB0aGF0XG4gICAgLy8gY29tcG9uZW50J3MgbW91bnQsIGlnbm9yZSBpdCBmb3Igbm93ICh0aGF0IGlzLCB0cmVhdCBpdCBhcyBpZiBpdCB3YXMgYW5cbiAgICAvLyBldmVudCBvbiBhIG5vbi1SZWFjdCB0cmVlKS4gV2UgbWlnaHQgYWxzbyBjb25zaWRlciBxdWV1ZWluZyBldmVudHMgYW5kXG4gICAgLy8gZGlzcGF0Y2hpbmcgdGhlbSBhZnRlciB0aGUgbW91bnQuXG4gICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gIH1cblxuICB2YXIgYm9va0tlZXBpbmcgPSBnZXRUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCwgdGFyZ2V0SW5zdCk7XG5cbiAgdHJ5IHtcbiAgICAvLyBFdmVudCBxdWV1ZSBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHNhbWUgY3ljbGUgYWxsb3dzXG4gICAgLy8gYHByZXZlbnREZWZhdWx0YC5cbiAgICBiYXRjaGVkVXBkYXRlcyhoYW5kbGVUb3BMZXZlbEltcGwsIGJvb2tLZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKGJvb2tLZWVwaW5nKTtcbiAgfVxufVxuXG52YXIgUmVhY3RET01FdmVudExpc3RlbmVyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGdldCBfZW5hYmxlZCAoKSB7IHJldHVybiBfZW5hYmxlZDsgfSxcblx0Z2V0IF9oYW5kbGVUb3BMZXZlbCAoKSB7IHJldHVybiBfaGFuZGxlVG9wTGV2ZWw7IH0sXG5cdHNldEhhbmRsZVRvcExldmVsOiBzZXRIYW5kbGVUb3BMZXZlbCxcblx0c2V0RW5hYmxlZDogc2V0RW5hYmxlZCxcblx0aXNFbmFibGVkOiBpc0VuYWJsZWQsXG5cdHRyYXBCdWJibGVkRXZlbnQ6IHRyYXBCdWJibGVkRXZlbnQsXG5cdHRyYXBDYXB0dXJlZEV2ZW50OiB0cmFwQ2FwdHVyZWRFdmVudCxcblx0ZGlzcGF0Y2hFdmVudDogZGlzcGF0Y2hFdmVudFxufSk7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBtYXBwaW5nIG9mIHN0YW5kYXJkIHZlbmRvciBwcmVmaXhlcyB1c2luZyB0aGUgZGVmaW5lZCBzdHlsZSBwcm9wZXJ0eSBhbmQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVQcm9wXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gIHZhciBwcmVmaXhlcyA9IHt9O1xuXG4gIHByZWZpeGVzW3N0eWxlUHJvcC50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICBwcmVmaXhlc1snV2Via2l0JyArIHN0eWxlUHJvcF0gPSAnd2Via2l0JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ01veicgKyBzdHlsZVByb3BdID0gJ21veicgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydtcycgKyBzdHlsZVByb3BdID0gJ01TJyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ08nICsgc3R5bGVQcm9wXSA9ICdvJyArIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBwcmVmaXhlcztcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXG4gIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkl0ZXJhdGlvbicpLFxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpXG59O1xuXG4vKipcbiAqIEV2ZW50IG5hbWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGV0ZWN0ZWQgYW5kIHByZWZpeGVkIChpZiBhcHBsaWNhYmxlKS5cbiAqL1xudmFyIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xuXG4vKipcbiAqIEVsZW1lbnQgdG8gY2hlY2sgZm9yIHByZWZpeGVzIG9uLlxuICovXG52YXIgc3R5bGUgPSB7fTtcblxuLyoqXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxuICovXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cbiAgLy8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxuICAvLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2FibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbWFwLlxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xuICB9XG5cbiAgLy8gU2FtZSBhcyBhYm92ZVxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgaWYgKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICB9IGVsc2UgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgfVxuXG4gIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdO1xuXG4gIGZvciAodmFyIHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApIHtcbiAgICBpZiAocHJlZml4TWFwLmhhc093blByb3BlcnR5KHN0eWxlUHJvcCkgJiYgc3R5bGVQcm9wIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0gPSBwcmVmaXhNYXBbc3R5bGVQcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogVHlwZXMgb2YgcmF3IHNpZ25hbHMgZnJvbSB0aGUgYnJvd3NlciBjYXVnaHQgYXQgdGhlIHRvcCBsZXZlbC5cbiAqXG4gKiBGb3IgZXZlbnRzIGxpa2UgJ3N1Ym1pdCcgd2hpY2ggZG9uJ3QgY29uc2lzdGVudGx5IGJ1YmJsZSAod2hpY2ggd2VcbiAqIHRyYXAgYXQgYSBsb3dlciBub2RlIHRoYW4gYGRvY3VtZW50YCksIGJpbmRpbmcgYXQgYGRvY3VtZW50YCB3b3VsZFxuICogY2F1c2UgZHVwbGljYXRlIGV2ZW50cyBzbyB3ZSBkb24ndCBpbmNsdWRlIHRoZW0gaGVyZS5cbiAqL1xudmFyIHRvcExldmVsVHlwZXMkMSA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcEFuaW1hdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbmVuZCcpIHx8ICdhbmltYXRpb25lbmQnLFxuICB0b3BBbmltYXRpb25JdGVyYXRpb246IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25pdGVyYXRpb24nKSB8fCAnYW5pbWF0aW9uaXRlcmF0aW9uJyxcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25zdGFydCcpIHx8ICdhbmltYXRpb25zdGFydCcsXG4gIHRvcEJsdXI6ICdibHVyJyxcbiAgdG9wQ2FuY2VsOiAnY2FuY2VsJyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wQ2hhbmdlOiAnY2hhbmdlJyxcbiAgdG9wQ2xpY2s6ICdjbGljaycsXG4gIHRvcENsb3NlOiAnY2xvc2UnLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWQ6ICdsb2FkJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcE1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIHRvcE1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gIHRvcE1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICB0b3BNb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICB0b3BNb3VzZVVwOiAnbW91c2V1cCcsXG4gIHRvcFBhc3RlOiAncGFzdGUnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNjcm9sbDogJ3Njcm9sbCcsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRleHRJbnB1dDogJ3RleHRJbnB1dCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVG9nZ2xlOiAndG9nZ2xlJyxcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxuICB0b3BUb3VjaE1vdmU6ICd0b3VjaG1vdmUnLFxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXG4gIHRvcFRyYW5zaXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJykgfHwgJ3RyYW5zaXRpb25lbmQnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZycsXG4gIHRvcFdoZWVsOiAnd2hlZWwnXG59O1xuXG52YXIgQnJvd3NlckV2ZW50Q29uc3RhbnRzID0ge1xuICB0b3BMZXZlbFR5cGVzOiB0b3BMZXZlbFR5cGVzJDFcbn07XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cykge1xuICBlbnF1ZXVlRXZlbnRzKGV2ZW50cyk7XG4gIHByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuLyoqXG4gKiBTdHJlYW1zIGEgZmlyZWQgdG9wLWxldmVsIGV2ZW50IHRvIGBFdmVudFBsdWdpbkh1YmAgd2hlcmUgcGx1Z2lucyBoYXZlIHRoZVxuICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWwodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50cyA9IGV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpO1xufVxuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEJyb3dzZXJFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RET01FdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0XG4gKiAgICBwbHVnZ2FibGUgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluXG4gKiAgICB0aHJlYWQuXG4gKlxuICogIC0gV2Ugbm9ybWFsaXplIGFuZCBkZS1kdXBsaWNhdGUgZXZlbnRzIHRvIGFjY291bnQgZm9yIGJyb3dzZXIgcXVpcmtzLiBUaGlzXG4gKiAgICBtYXkgYmUgZG9uZSBpbiB0aGUgd29ya2VyIHRocmVhZC5cbiAqXG4gKiAgLSBGb3J3YXJkIHRoZXNlIG5hdGl2ZSBldmVudHMgKHdpdGggdGhlIGFzc29jaWF0ZWQgdG9wLWxldmVsIHR5cGUgdXNlZCB0b1xuICogICAgdHJhcCBpdCkgdG8gYEV2ZW50UGx1Z2luSHViYCwgd2hpY2ggaW4gdHVybiB3aWxsIGFzayBwbHVnaW5zIGlmIHRoZXkgd2FudFxuICogICAgdG8gZXh0cmFjdCBhbnkgc3ludGhldGljIGV2ZW50cy5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB3aWxsIHRoZW4gcHJvY2VzcyBlYWNoIGV2ZW50IGJ5IGFubm90YXRpbmcgdGhlbSB3aXRoXG4gKiAgICBcImRpc3BhdGNoZXNcIiwgYSBzZXF1ZW5jZSBvZiBsaXN0ZW5lcnMgYW5kIElEcyB0aGF0IGNhcmUgYWJvdXQgdGhhdCBldmVudC5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB0aGVuIGRpc3BhdGNoZXMgdGhlIGV2ZW50cy5cbiAqXG4gKiBPdmVydmlldyBvZiBSZWFjdCBhbmQgdGhlIGV2ZW50IHN5c3RlbTpcbiAqXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8ICAgIERPTSAgICAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiAgICAgICB8ICAgICAgICAgICAuXG4gKiAgICAgICB2ICAgICAgICAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuXG4gKiB8ICBMaXN0ZW5lciAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICArLS0tLS0tLS0rfFNpbXBsZUV2ZW50fFxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgIHwgICAgICAgICB8UGx1Z2luICAgICB8XG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgdiAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fEV2ZW50UGx1Z2luSHVifCAgICAgICAgICAgICAgICAgICAgfCAgICBFdmVudCAgIHxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCBQcm9wYWdhdG9yc3xcbiAqIHwgUmVhY3RFdmVudCB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgfFRhcEV2ZW50ICAgfCAgfC0tLS0tLS0tLS0tLXxcbiAqIHwgIEVtaXR0ZXIgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfDwtLS0rfFBsdWdpbiAgICAgfCAgfG90aGVyIHBsdWdpbnxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCAgdXRpbGl0aWVzIHxcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tK1xuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICBeICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgIHwgICAgICAgIHxFbnRlci9MZWF2ZXxcbiAqICAgICAgICsgICAgICAgICAgIC4gICAgICAgICAgICAgICAgKy0tLS0tLS0rfFBsdWdpbiAgICAgfFxuICogKy0tLS0tLS0tLS0tLS0rICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8IGFwcGxpY2F0aW9uIHwgICAuXG4gKiB8LS0tLS0tLS0tLS0tLXwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuXG4gKiAgICAgICAgICAgICAgICAgICAuXG4gKiAgICBSZWFjdCBDb3JlICAgICAuICBHZW5lcmFsIFB1cnBvc2UgRXZlbnQgUGx1Z2luIFN5c3RlbVxuICovXG5cbnZhciBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcbnZhciByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xuXG4vKipcbiAqIFRvIGVuc3VyZSBubyBjb25mbGljdHMgd2l0aCBvdGhlciBwb3RlbnRpYWwgUmVhY3QgaW5zdGFuY2VzIG9uIHRoZSBwYWdlXG4gKi9cbnZhciB0b3BMaXN0ZW5lcnNJREtleSA9ICdfcmVhY3RMaXN0ZW5lcnNJRCcgKyAoJycgKyBNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcblxuZnVuY3Rpb24gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCkge1xuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxuICAvLyBkaXJlY3RseS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW91bnRBdCwgdG9wTGlzdGVuZXJzSURLZXkpKSB7XG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XG4gIH1cbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XG59XG5cbi8qKlxuICogV2UgbGlzdGVuIGZvciBidWJibGVkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICpcbiAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAqIG1vdW50aW5nIGBvbm1vdXNlbW92ZWAgZXZlbnRzIGF0IHNvbWUgbm9kZSB0aGF0IHdhcyBub3QgdGhlIGRvY3VtZW50XG4gKiBlbGVtZW50LiBUaGUgc3ltcHRvbXMgd2VyZSB0aGF0IGlmIHlvdXIgbW91c2UgaXMgbm90IG1vdmluZyBvdmVyIHNvbWV0aGluZ1xuICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIGZvciBgb25tb3VzZW1vdmVgIHdvbid0IGJlIGNhbGxlZC4gSG93ZXZlciwgaWYgeW91XG4gKiByZWdpc3RlciB0aGUgYG1vdXNlbW92ZWAgb24gdGhlIGRvY3VtZW50IG9iamVjdCwgdGhlbiBpdCB3aWxsIG9mIGNvdXJzZVxuICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICogdG9wLWxldmVsIGxpc3RlbmVycyB0byB0aGUgZG9jdW1lbnQgb2JqZWN0IG9ubHksIGF0IGxlYXN0IGZvciB0aGVzZVxuICogbW92ZW1lbnQgdHlwZXMgb2YgZXZlbnRzIGFuZCBwb3NzaWJseSBhbGwgZXZlbnRzLlxuICpcbiAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAqXG4gKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gKiB0aGV5IGJ1YmJsZSB0byBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGVudERvY3VtZW50SGFuZGxlIERvY3VtZW50IHdoaWNoIG93bnMgdGhlIGNvbnRhaW5lclxuICovXG5mdW5jdGlvbiBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBjb250ZW50RG9jdW1lbnRIYW5kbGUpIHtcbiAgdmFyIG1vdW50QXQgPSBjb250ZW50RG9jdW1lbnRIYW5kbGU7XG4gIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BTY3JvbGwnKSB7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BTY3JvbGwnLCAnc2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BGb2N1cycgfHwgZGVwZW5kZW5jeSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1cycsIG1vdW50QXQpO1xuICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudCgndG9wQmx1cicsICdibHVyJywgbW91bnRBdCk7XG5cbiAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGJsdXIgYW5kIGZvY3VzIGV2ZW50IGxpc3RlbmVycyBhcmUgb25seSBhdHRhY2hlZCBvbmNlXG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcEJsdXIgPSB0cnVlO1xuICAgICAgICBpc0xpc3RlbmluZy50b3BGb2N1cyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BDYW5jZWwnKSB7XG4gICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdjYW5jZWwnLCB0cnVlKSkge1xuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BDYW5jZWwnLCAnY2FuY2VsJywgbW91bnRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQ2FuY2VsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcENsb3NlJykge1xuICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnY2xvc2UnLCB0cnVlKSkge1xuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BDbG9zZScsICdjbG9zZScsIG1vdW50QXQpO1xuICAgICAgICB9XG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcENsb3NlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlcy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSkge1xuICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcExldmVsVHlwZXNbZGVwZW5kZW5jeV0sIG1vdW50QXQpO1xuICAgICAgfVxuXG4gICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTGlzdGVuaW5nVG9BbGxEZXBlbmRlbmNpZXMocmVnaXN0cmF0aW9uTmFtZSwgbW91bnRBdCkge1xuICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgbm9kZUVuZCA9IG5vZGVTdGFydCArIG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuXG4gICAgICBpZiAobm9kZVN0YXJ0IDw9IG9mZnNldCAmJiBub2RlRW5kID49IG9mZnNldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBub2RlU3RhcnRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbm9kZVN0YXJ0ID0gbm9kZUVuZDtcbiAgICB9XG5cbiAgICBub2RlID0gZ2V0TGVhZk5vZGUoZ2V0U2libGluZ05vZGUobm9kZSkpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBvdXRlck5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldHMob3V0ZXJOb2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uICYmIHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGUkJDEgPSBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG5cbiAgLy8gSW4gRmlyZWZveCwgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGNhbiBiZSBcImFub255bW91cyBkaXZzXCIsIGUuZy4gdGhlXG4gIC8vIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzIGRpdnMgZG8gbm90IHNlZW0gdG9cbiAgLy8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkIGVycm9yXCIgaWYgYW55IG9mIGl0c1xuICAvLyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlIHdheSB0byBhdm9pZCBlcnJvcmluZ1xuICAvLyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3Igbm9uLWFub255bW91cyBkaXZzIGFuZFxuICAvLyBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG5cbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICBhbmNob3JOb2RlLm5vZGVUeXBlO1xuICAgIGZvY3VzTm9kZSQkMS5ub2RlVHlwZTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSQkMSwgZm9jdXNPZmZzZXQpO1xufVxuXG4vKipcbiAqIFJldHVybnMge3N0YXJ0LCBlbmR9IHdoZXJlIGBzdGFydGAgaXMgdGhlIGNoYXJhY3Rlci9jb2RlcG9pbnQgaW5kZXggb2ZcbiAqIChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpIHdpdGhpbiB0aGUgdGV4dENvbnRlbnQgb2YgYG91dGVyTm9kZWAsIGFuZFxuICogYGVuZGAgaXMgdGhlIGluZGV4IG9mIChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KS5cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgeW91IHBhc3MgaW4gZ2FyYmFnZSBpbnB1dCBidXQgd2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgY3Jhc2guXG4gKlxuICogRXhwb3J0ZWQgb25seSBmb3IgdGVzdGluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSQkMSwgZm9jdXNPZmZzZXQpIHtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBzdGFydCA9IC0xO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBpbmRleFdpdGhpbkFuY2hvciA9IDA7XG4gIHZhciBpbmRleFdpdGhpbkZvY3VzID0gMDtcbiAgdmFyIG5vZGUgPSBvdXRlck5vZGU7XG4gIHZhciBwYXJlbnROb2RlID0gbnVsbDtcblxuICBvdXRlcjogd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbmV4dCA9IG51bGw7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IGFuY2hvck5vZGUgJiYgKGFuY2hvck9mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoICsgYW5jaG9yT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IGZvY3VzTm9kZSQkMSAmJiAoZm9jdXNPZmZzZXQgPT09IDAgfHwgbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSkge1xuICAgICAgICBlbmQgPSBsZW5ndGggKyBmb2N1c09mZnNldDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgICBsZW5ndGggKz0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoKG5leHQgPSBub2RlLmZpcnN0Q2hpbGQpID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBmaXJzdCBjaGlsZCBgbmV4dGAuXG4gICAgICBwYXJlbnROb2RlID0gbm9kZTtcbiAgICAgIG5vZGUgPSBuZXh0O1xuICAgIH1cblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gb3V0ZXJOb2RlKSB7XG4gICAgICAgIC8vIElmIGBvdXRlck5vZGVgIGhhcyBjaGlsZHJlbiwgdGhpcyBpcyBhbHdheXMgdGhlIHNlY29uZCB0aW1lIHZpc2l0aW5nXG4gICAgICAgIC8vIGl0LiBJZiBpdCBoYXMgbm8gY2hpbGRyZW4sIHRoaXMgaXMgc3RpbGwgdGhlIGZpcnN0IGxvb3AsIGFuZCB0aGUgb25seVxuICAgICAgICAvLyB2YWxpZCBzZWxlY3Rpb24gaXMgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGJvdGggZXF1YWwgdG8gdGhpcyBub2RlXG4gICAgICAgIC8vIGFuZCBib3RoIG9mZnNldHMgMCwgaW4gd2hpY2ggY2FzZSB3ZSB3aWxsIGhhdmUgaGFuZGxlZCBhYm92ZS5cbiAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gYW5jaG9yTm9kZSAmJiArK2luZGV4V2l0aGluQW5jaG9yID09PSBhbmNob3JPZmZzZXQpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gZm9jdXNOb2RlJCQxICYmICsraW5kZXhXaXRoaW5Gb2N1cyA9PT0gZm9jdXNPZmZzZXQpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKChuZXh0ID0gbm9kZS5uZXh0U2libGluZykgIT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBub2RlID0gcGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBuZXh0IHNpYmxpbmcgYG5leHRgLlxuICAgIG5vZGUgPSBuZXh0O1xuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgPT09IC0xKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLiAoV291bGQgaGFwcGVuIGlmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYXJlbid0XG4gICAgLy8gYWN0dWFsbHkgaW5zaWRlIHRoZSBwYXNzZWQtaW4gbm9kZS4pXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0T2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3IoKV0ubGVuZ3RoO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XG5cbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbiAgaWYgKCFzZWxlY3Rpb24uZXh0ZW5kICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgdmFyIHRlbXAgPSBlbmQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSB0ZW1wO1xuICB9XG5cbiAgdmFyIHN0YXJ0TWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBzdGFydCk7XG4gIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIGVuZCk7XG5cbiAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgIGlmIChzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMSAmJiBzZWxlY3Rpb24uYW5jaG9yTm9kZSA9PT0gc3RhcnRNYXJrZXIubm9kZSAmJiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ID09PSBzdGFydE1hcmtlci5vZmZzZXQgJiYgc2VsZWN0aW9uLmZvY3VzTm9kZSA9PT0gZW5kTWFya2VyLm5vZGUgJiYgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0ID09PSBlbmRNYXJrZXIub2Zmc2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBjb250YWluc05vZGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuLyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi9cblxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICd0ZXh0JyB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24oKSB7XG4gIHZhciBmb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgcmV0dXJuIHtcbiAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgc2VsZWN0aW9uUmFuZ2U6IGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSkgPyBnZXRTZWxlY3Rpb24kMShmb2N1c2VkRWxlbSkgOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogQHJlc3RvcmVTZWxlY3Rpb246IElmIGFueSBzZWxlY3Rpb24gaW5mb3JtYXRpb24gd2FzIHBvdGVudGlhbGx5IGxvc3QsXG4gKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cbiAqIG5vZGVzIGFuZCBwbGFjZSB0aGVtIGJhY2sgaW4sIHJlc3VsdGluZyBpbiBmb2N1cyBiZWluZyBsb3N0LlxuICovXG5mdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgIGlmIChoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIHNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICB9XG5cbiAgICAvLyBGb2N1c2luZyBhIG5vZGUgY2FuIGNoYW5nZSB0aGUgc2Nyb2xsIHBvc2l0aW9uLCB3aGljaCBpcyB1bmRlc2lyYWJsZVxuICAgIHZhciBhbmNlc3RvcnMgPSBbXTtcbiAgICB2YXIgYW5jZXN0b3IgPSBwcmlvckZvY3VzZWRFbGVtO1xuICAgIHdoaWxlIChhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChhbmNlc3Rvci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGFuY2VzdG9ycy5wdXNoKHtcbiAgICAgICAgICBlbGVtZW50OiBhbmNlc3RvcixcbiAgICAgICAgICBsZWZ0OiBhbmNlc3Rvci5zY3JvbGxMZWZ0LFxuICAgICAgICAgIHRvcDogYW5jZXN0b3Iuc2Nyb2xsVG9wXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaW5mbyA9IGFuY2VzdG9yc1tpXTtcbiAgICAgIGluZm8uZWxlbWVudC5zY3JvbGxMZWZ0ID0gaW5mby5sZWZ0O1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbFRvcCA9IGluZm8udG9wO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbiQxKGlucHV0KSB7XG4gIHZhciBzZWxlY3Rpb24gPSB2b2lkIDA7XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbiAgICBzZWxlY3Rpb24gPSBnZXRPZmZzZXRzKGlucHV0KTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb24gfHwgeyBzdGFydDogMCwgZW5kOiAwIH07XG59XG5cbi8qKlxuICogQHNldFNlbGVjdGlvbjogU2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIHRleHRhcmVhIG9yIGlucHV0IGFuZCBmb2N1c2VzXG4gKiB0aGUgaW5wdXQuXG4gKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXG4gKiAtQG9mZnNldHMgICBPYmplY3Qgb2Ygc2FtZSBmb3JtIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSBnZXQqXG4gKi9cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbihpbnB1dCwgb2Zmc2V0cykge1xuICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0LFxuICAgICAgZW5kID0gb2Zmc2V0cy5lbmQ7XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gc3RhcnQ7XG4gIH1cblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICB9XG59XG5cbnZhciBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDw9IDExO1xuXG52YXIgZXZlbnRUeXBlcyQzID0ge1xuICBzZWxlY3Q6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uU2VsZWN0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25TZWxlY3RDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29udGV4dE1lbnUnLCAndG9wRm9jdXMnLCAndG9wS2V5RG93bicsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nLCAndG9wTW91c2VVcCcsICd0b3BTZWxlY3Rpb25DaGFuZ2UnXVxuICB9XG59O1xuXG52YXIgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhub2RlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbm9kZS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogbm9kZS5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3JOb2RlOiBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldDogc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZTogc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXNPZmZzZXRcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgaWYgKG1vdXNlRG93biB8fCBhY3RpdmVFbGVtZW50JDEgPT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50JDEgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50JDEpO1xuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuXG4gICAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gU3ludGhldGljRXZlbnQkMS5nZXRQb29sZWQoZXZlbnRUeXBlcyQzLnNlbGVjdCwgYWN0aXZlRWxlbWVudEluc3QkMSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcbiAgICBzeW50aGV0aWNFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50JDE7XG5cbiAgICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcblxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkb2MgPSBuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0ID8gbmF0aXZlRXZlbnRUYXJnZXQuZG9jdW1lbnQgOiBuYXRpdmVFdmVudFRhcmdldC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IG5hdGl2ZUV2ZW50VGFyZ2V0IDogbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAvLyBUcmFjayB3aGV0aGVyIGFsbCBsaXN0ZW5lcnMgZXhpc3RzIGZvciB0aGlzIHBsdWdpbi4gSWYgbm9uZSBleGlzdCwgd2UgZG9cbiAgICAvLyBub3QgZXh0cmFjdCBldmVudHMuIFNlZSAjMzYzOS5cbiAgICBpZiAoIWRvYyB8fCAhaXNMaXN0ZW5pbmdUb0FsbERlcGVuZGVuY2llcygnb25TZWxlY3QnLCBkb2MpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlJDEodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgICBjYXNlICd0b3BGb2N1cyc6XG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkgfHwgdGFyZ2V0Tm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQkMSA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IHRhcmdldEluc3Q7XG4gICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IG51bGw7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIERvbid0IGZpcmUgdGhlIGV2ZW50IHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nLiBUaGlzIG1hdGNoZXMgdGhlXG4gICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG4gICAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENvbnRleHRNZW51JzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlVXAnOlxuICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAgIC8vXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG4gICAgICBjYXNlICd0b3BTZWxlY3Rpb25DaGFuZ2UnOlxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYW5pbWF0aW9ucy8jQW5pbWF0aW9uRXZlbnQtaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxuICovXG52YXIgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGFuaW1hdGlvbk5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQW5pbWF0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LCBBbmltYXRpb25FdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xudmFyIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LCBDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0ZvY3VzRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0ZvY3VzRXZlbnQsIEZvY3VzRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICBFc2M6ICdFc2NhcGUnLFxuICBTcGFjZWJhcjogJyAnLFxuICBMZWZ0OiAnQXJyb3dMZWZ0JyxcbiAgVXA6ICdBcnJvd1VwJyxcbiAgUmlnaHQ6ICdBcnJvd1JpZ2h0JyxcbiAgRG93bjogJ0Fycm93RG93bicsXG4gIERlbDogJ0RlbGV0ZScsXG4gIFdpbjogJ09TJyxcbiAgTWVudTogJ0NvbnRleHRNZW51JyxcbiAgQXBwczogJ0NvbnRleHRNZW51JyxcbiAgU2Nyb2xsOiAnU2Nyb2xsTG9jaycsXG4gIE1velByaW50YWJsZUtleTogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gICc4JzogJ0JhY2tzcGFjZScsXG4gICc5JzogJ1RhYicsXG4gICcxMic6ICdDbGVhcicsXG4gICcxMyc6ICdFbnRlcicsXG4gICcxNic6ICdTaGlmdCcsXG4gICcxNyc6ICdDb250cm9sJyxcbiAgJzE4JzogJ0FsdCcsXG4gICcxOSc6ICdQYXVzZScsXG4gICcyMCc6ICdDYXBzTG9jaycsXG4gICcyNyc6ICdFc2NhcGUnLFxuICAnMzInOiAnICcsXG4gICczMyc6ICdQYWdlVXAnLFxuICAnMzQnOiAnUGFnZURvd24nLFxuICAnMzUnOiAnRW5kJyxcbiAgJzM2JzogJ0hvbWUnLFxuICAnMzcnOiAnQXJyb3dMZWZ0JyxcbiAgJzM4JzogJ0Fycm93VXAnLFxuICAnMzknOiAnQXJyb3dSaWdodCcsXG4gICc0MCc6ICdBcnJvd0Rvd24nLFxuICAnNDUnOiAnSW5zZXJ0JyxcbiAgJzQ2JzogJ0RlbGV0ZScsXG4gICcxMTInOiAnRjEnLFxuICAnMTEzJzogJ0YyJyxcbiAgJzExNCc6ICdGMycsXG4gICcxMTUnOiAnRjQnLFxuICAnMTE2JzogJ0Y1JyxcbiAgJzExNyc6ICdGNicsXG4gICcxMTgnOiAnRjcnLFxuICAnMTE5JzogJ0Y4JyxcbiAgJzEyMCc6ICdGOScsXG4gICcxMjEnOiAnRjEwJyxcbiAgJzEyMic6ICdGMTEnLFxuICAnMTIzJzogJ0YxMicsXG4gICcxNDQnOiAnTnVtTG9jaycsXG4gICcxNDUnOiAnU2Nyb2xsTG9jaycsXG4gICcyMjQnOiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNLZXlib2FyZEV2ZW50LCBLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRHJhZ0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNEcmFnRXZlbnQsIERyYWdFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1jc3MzLXRyYW5zaXRpb25zLTIwMDkwMzIwLyN0cmFuc2l0aW9uLWV2ZW50cy1cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zaXRpb25FdmVudFxuICovXG52YXIgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBwcm9wZXJ0eU5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQsIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBXaGVlbEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFdoZWVsRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG4gIGRlbHRhWjogbnVsbCxcblxuICAvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcbiAgLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG4gIGRlbHRhTW9kZTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljV2hlZWxFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljV2hlZWxFdmVudCwgV2hlZWxFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogVHVybnNcbiAqIFsnYWJvcnQnLCAuLi5dXG4gKiBpbnRvXG4gKiBldmVudFR5cGVzID0ge1xuICogICAnYWJvcnQnOiB7XG4gKiAgICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAqICAgICAgIGJ1YmJsZWQ6ICdvbkFib3J0JyxcbiAqICAgICAgIGNhcHR1cmVkOiAnb25BYm9ydENhcHR1cmUnLFxuICogICAgIH0sXG4gKiAgICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEFib3J0J10sXG4gKiAgIH0sXG4gKiAgIC4uLlxuICogfTtcbiAqIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHtcbiAqICAgJ3RvcEFib3J0JzogeyBzYW1lQ29uZmlnIH1cbiAqIH07XG4gKi9cbnZhciBldmVudFR5cGVzJDQgPSB7fTtcbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7fTtcblsnYWJvcnQnLCAnYW5pbWF0aW9uRW5kJywgJ2FuaW1hdGlvbkl0ZXJhdGlvbicsICdhbmltYXRpb25TdGFydCcsICdibHVyJywgJ2NhbmNlbCcsICdjYW5QbGF5JywgJ2NhblBsYXlUaHJvdWdoJywgJ2NsaWNrJywgJ2Nsb3NlJywgJ2NvbnRleHRNZW51JywgJ2NvcHknLCAnY3V0JywgJ2RvdWJsZUNsaWNrJywgJ2RyYWcnLCAnZHJhZ0VuZCcsICdkcmFnRW50ZXInLCAnZHJhZ0V4aXQnLCAnZHJhZ0xlYXZlJywgJ2RyYWdPdmVyJywgJ2RyYWdTdGFydCcsICdkcm9wJywgJ2R1cmF0aW9uQ2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2ZvY3VzJywgJ2lucHV0JywgJ2ludmFsaWQnLCAna2V5RG93bicsICdrZXlQcmVzcycsICdrZXlVcCcsICdsb2FkJywgJ2xvYWRlZERhdGEnLCAnbG9hZGVkTWV0YWRhdGEnLCAnbG9hZFN0YXJ0JywgJ21vdXNlRG93bicsICdtb3VzZU1vdmUnLCAnbW91c2VPdXQnLCAnbW91c2VPdmVyJywgJ21vdXNlVXAnLCAncGFzdGUnLCAncGF1c2UnLCAncGxheScsICdwbGF5aW5nJywgJ3Byb2dyZXNzJywgJ3JhdGVDaGFuZ2UnLCAncmVzZXQnLCAnc2Nyb2xsJywgJ3NlZWtlZCcsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3VibWl0JywgJ3N1c3BlbmQnLCAndGltZVVwZGF0ZScsICd0b2dnbGUnLCAndG91Y2hDYW5jZWwnLCAndG91Y2hFbmQnLCAndG91Y2hNb3ZlJywgJ3RvdWNoU3RhcnQnLCAndHJhbnNpdGlvbkVuZCcsICd2b2x1bWVDaGFuZ2UnLCAnd2FpdGluZycsICd3aGVlbCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBjYXBpdGFsaXplZEV2ZW50ID0gZXZlbnRbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50LnNsaWNlKDEpO1xuICB2YXIgb25FdmVudCA9ICdvbicgKyBjYXBpdGFsaXplZEV2ZW50O1xuICB2YXIgdG9wRXZlbnQgPSAndG9wJyArIGNhcGl0YWxpemVkRXZlbnQ7XG5cbiAgdmFyIHR5cGUgPSB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IG9uRXZlbnQsXG4gICAgICBjYXB0dXJlZDogb25FdmVudCArICdDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wRXZlbnRdXG4gIH07XG4gIGV2ZW50VHlwZXMkNFtldmVudF0gPSB0eXBlO1xuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wRXZlbnRdID0gdHlwZTtcbn0pO1xuXG4vLyBPbmx5IHVzZWQgaW4gREVWIGZvciBleGhhdXN0aXZlbmVzcyB2YWxpZGF0aW9uLlxudmFyIGtub3duSFRNTFRvcExldmVsVHlwZXMgPSBbJ3RvcEFib3J0JywgJ3RvcENhbmNlbCcsICd0b3BDYW5QbGF5JywgJ3RvcENhblBsYXlUaHJvdWdoJywgJ3RvcENsb3NlJywgJ3RvcER1cmF0aW9uQ2hhbmdlJywgJ3RvcEVtcHRpZWQnLCAndG9wRW5jcnlwdGVkJywgJ3RvcEVuZGVkJywgJ3RvcEVycm9yJywgJ3RvcElucHV0JywgJ3RvcEludmFsaWQnLCAndG9wTG9hZCcsICd0b3BMb2FkZWREYXRhJywgJ3RvcExvYWRlZE1ldGFkYXRhJywgJ3RvcExvYWRTdGFydCcsICd0b3BQYXVzZScsICd0b3BQbGF5JywgJ3RvcFBsYXlpbmcnLCAndG9wUHJvZ3Jlc3MnLCAndG9wUmF0ZUNoYW5nZScsICd0b3BSZXNldCcsICd0b3BTZWVrZWQnLCAndG9wU2Vla2luZycsICd0b3BTdGFsbGVkJywgJ3RvcFN1Ym1pdCcsICd0b3BTdXNwZW5kJywgJ3RvcFRpbWVVcGRhdGUnLCAndG9wVG9nZ2xlJywgJ3RvcFZvbHVtZUNoYW5nZScsICd0b3BXYWl0aW5nJ107XG5cbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQ0LFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgY2FzZSAndG9wRm9jdXMnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDbGljayc6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wRG91YmxlQ2xpY2snOlxuICAgICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlTW92ZSc6XG4gICAgICBjYXNlICd0b3BNb3VzZVVwJzpcbiAgICAgIC8vIFRPRE86IERpc2FibGVkIGVsZW1lbnRzIHNob3VsZCBub3QgcmVzcG9uZCB0byBtb3VzZSBldmVudHNcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcE1vdXNlT3V0JzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlT3Zlcic6XG4gICAgICBjYXNlICd0b3BDb250ZXh0TWVudSc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcERyYWcnOlxuICAgICAgY2FzZSAndG9wRHJhZ0VuZCc6XG4gICAgICBjYXNlICd0b3BEcmFnRW50ZXInOlxuICAgICAgY2FzZSAndG9wRHJhZ0V4aXQnOlxuICAgICAgY2FzZSAndG9wRHJhZ0xlYXZlJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdPdmVyJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdTdGFydCc6XG4gICAgICBjYXNlICd0b3BEcm9wJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BUb3VjaENhbmNlbCc6XG4gICAgICBjYXNlICd0b3BUb3VjaEVuZCc6XG4gICAgICBjYXNlICd0b3BUb3VjaE1vdmUnOlxuICAgICAgY2FzZSAndG9wVG91Y2hTdGFydCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvbkVuZCc6XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25JdGVyYXRpb24nOlxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uU3RhcnQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wVHJhbnNpdGlvbkVuZCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wU2Nyb2xsJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wV2hlZWwnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljV2hlZWxFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDb3B5JzpcbiAgICAgIGNhc2UgJ3RvcEN1dCc6XG4gICAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGtub3duSFRNTFRvcExldmVsVHlwZXMuaW5kZXhPZih0b3BMZXZlbFR5cGUpID09PSAtMSkge1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ1NpbXBsZUV2ZW50UGx1Z2luOiBVbmhhbmRsZWQgZXZlbnQgdHlwZSwgYCVzYC4gVGhpcyB3YXJuaW5nICcgKyAnaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgdG9wTGV2ZWxUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSFRNTCBFdmVudHNcbiAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmRleC5odG1sI2V2ZW50cy0wXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNFdmVudCQxO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG59O1xuXG5zZXRIYW5kbGVUb3BMZXZlbChoYW5kbGVUb3BMZXZlbCk7XG5cbi8qKlxuICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKi9cbmluamVjdGlvbiQxLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoRE9NRXZlbnRQbHVnaW5PcmRlcik7XG5pbmplY3Rpb24kMi5pbmplY3RDb21wb25lbnRUcmVlKFJlYWN0RE9NQ29tcG9uZW50VHJlZSk7XG5cbi8qKlxuICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gKiB0aGVtKS5cbiAqL1xuaW5qZWN0aW9uJDEuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcbiAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbn0pO1xuXG52YXIgZW5hYmxlQXN5bmNTdWJ0cmVlQVBJID0gdHJ1ZTtcbnZhciBlbmFibGVBc3luY1NjaGVkdWxpbmdCeURlZmF1bHRJblJlYWN0RE9NID0gZmFsc2U7XG4vLyBFeHBvcnRzIFJlYWN0RE9NLmNyZWF0ZVJvb3RcbnZhciBlbmFibGVDcmVhdGVSb290ID0gZmFsc2U7XG52YXIgZW5hYmxlVXNlclRpbWluZ0FQSSA9IHRydWU7XG5cbi8vIE11dGF0aW5nIG1vZGUgKFJlYWN0IERPTSwgUmVhY3QgQVJULCBSZWFjdCBOYXRpdmUpOlxudmFyIGVuYWJsZU11dGF0aW5nUmVjb25jaWxlciA9IHRydWU7XG4vLyBFeHBlcmltZW50YWwgbm9vcCBtb2RlIChjdXJyZW50bHkgdW51c2VkKTpcbnZhciBlbmFibGVOb29wUmVjb25jaWxlciA9IGZhbHNlO1xuLy8gRXhwZXJpbWVudGFsIHBlcnNpc3RlbnQgbW9kZSAoQ1MpOlxudmFyIGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyID0gZmFsc2U7XG5cbi8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiBiZWdpbi1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlIHJlZHVjZXJzOlxudmFyIGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyA9IGZhbHNlO1xuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxudmFyIHZhbHVlU3RhY2sgPSBbXTtcblxue1xuICB2YXIgZmliZXJTdGFjayA9IFtdO1xufVxuXG52YXIgaW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZVxuICB9O1xufVxuXG5cblxuZnVuY3Rpb24gcG9wKGN1cnNvciwgZmliZXIpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmV4cGVjdGVkIHBvcC4nKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIGlmIChmaWJlciAhPT0gZmliZXJTdGFja1tpbmRleF0pIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmV4cGVjdGVkIEZpYmVyIHBvcHBlZC4nKTtcbiAgICB9XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlU3RhY2tbaW5kZXhdO1xuXG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICB9XG5cbiAgaW5kZXgtLTtcbn1cblxuZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICBpbmRleCsrO1xuXG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gZmliZXI7XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiByZXNldCQxKCkge1xuICB3aGlsZSAoaW5kZXggPiAtMSkge1xuICAgIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICAgIHtcbiAgICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgICB9XG5cbiAgICBpbmRleC0tO1xuICB9XG59XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG5mdW5jdGlvbiBkZXNjcmliZUZpYmVyKGZpYmVyKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHZhciBvd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgICAgdmFyIHNvdXJjZSA9IGZpYmVyLl9kZWJ1Z1NvdXJjZTtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcik7XG4gICAgICB2YXIgb3duZXJOYW1lID0gbnVsbDtcbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICBvd25lck5hbWUgPSBnZXRDb21wb25lbnROYW1lKG93bmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gY2FuIG9ubHkgYmUgY2FsbGVkIHdpdGggYSB3b3JrLWluLXByb2dyZXNzIGZpYmVyIGFuZFxuLy8gb25seSBkdXJpbmcgYmVnaW4gb3IgY29tcGxldGUgcGhhc2UuIERvIG5vdCBjYWxsIGl0IHVuZGVyIGFueSBvdGhlclxuLy8gY2lyY3Vtc3RhbmNlcy5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIGluZm8gPSAnJztcbiAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgZG8ge1xuICAgIGluZm8gKz0gZGVzY3JpYmVGaWJlcihub2RlKTtcbiAgICAvLyBPdGhlcndpc2UgdGhpcyByZXR1cm4gcG9pbnRlciBtaWdodCBwb2ludCB0byB0aGUgd3JvbmcgdHJlZTpcbiAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gIH0gd2hpbGUgKG5vZGUpO1xuICByZXR1cm4gaW5mbztcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50O1xuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBvd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3duZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShvd25lcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKCkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50O1xuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuICAgIC8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG4gICAgcmV0dXJuIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmliZXIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50ID0gZmliZXI7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50UGhhc2UocGhhc2UpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IHBoYXNlO1xufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlciA9IHtcbiAgY3VycmVudDogbnVsbCxcbiAgcGhhc2U6IG51bGwsXG4gIHJlc2V0Q3VycmVudEZpYmVyOiByZXNldEN1cnJlbnRGaWJlcixcbiAgc2V0Q3VycmVudEZpYmVyOiBzZXRDdXJyZW50RmliZXIsXG4gIHNldEN1cnJlbnRQaGFzZTogc2V0Q3VycmVudFBoYXNlLFxuICBnZXRDdXJyZW50RmliZXJPd25lck5hbWU6IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSxcbiAgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTogZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bVxufTtcblxuLy8gUHJlZml4IG1lYXN1cmVtZW50cyBzbyB0aGF0IGl0J3MgcG9zc2libGUgdG8gZmlsdGVyIHRoZW0uXG4vLyBMb25nZXIgcHJlZml4ZXMgYXJlIGhhcmQgdG8gcmVhZCBpbiBEZXZUb29scy5cbnZhciByZWFjdEVtb2ppID0gJ1xcdTI2OUInO1xudmFyIHdhcm5pbmdFbW9qaSA9ICdcXHUyNkQ0JztcbnZhciBzdXBwb3J0c1VzZXJUaW1pbmcgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1hcmtzID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzID09PSAnZnVuY3Rpb24nO1xuXG4vLyBLZWVwIHRyYWNrIG9mIGN1cnJlbnQgZmliZXIgc28gdGhhdCB3ZSBrbm93IHRoZSBwYXRoIHRvIHVud2luZCBvbiBwYXVzZS5cbi8vIFRPRE86IHRoaXMgbG9va3MgdGhlIHNhbWUgYXMgbmV4dFVuaXRPZldvcmsgaW4gc2NoZWR1bGVyLiBDYW4gd2UgdW5pZnkgdGhlbT9cbnZhciBjdXJyZW50RmliZXIgPSBudWxsO1xuLy8gSWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiB1c2VyIGNvZGUsIHdoaWNoIGZpYmVyIGFuZCBtZXRob2QgaXMgaXQ/XG4vLyBSZXVzaW5nIGBjdXJyZW50RmliZXJgIHdvdWxkIGJlIGNvbmZ1c2luZyBmb3IgdGhpcyBiZWNhdXNlIHVzZXIgY29kZSBmaWJlclxuLy8gY2FuIGNoYW5nZSBkdXJpbmcgY29tbWl0IHBoYXNlIHRvbywgYnV0IHdlIGRvbid0IG5lZWQgdG8gdW53aW5kIGl0IChzaW5jZVxuLy8gbGlmZWN5Y2xlcyBpbiB0aGUgY29tbWl0IHBoYXNlIGRvbid0IHJlc2VtYmxlIGEgdHJlZSkuXG52YXIgY3VycmVudFBoYXNlID0gbnVsbDtcbnZhciBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4vLyBEaWQgbGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGUgYW4gdXBkYXRlPyBUaGlzIGlzIG9mdGVuIGEgcGVyZm9ybWFuY2UgcHJvYmxlbSxcbi8vIHNvIHdlIHdpbGwga2VlcCB0cmFjayBvZiBpdCwgYW5kIGluY2x1ZGUgaXQgaW4gdGhlIHJlcG9ydC5cbi8vIFRyYWNrIGNvbW1pdHMgY2F1c2VkIGJ5IGNhc2NhZGluZyB1cGRhdGVzLlxudmFyIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG52YXIgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG52YXIgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xudmFyIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gZmFsc2U7XG4vLyBEdXJpbmcgY29tbWl0cywgd2Ugb25seSBzaG93IGEgbWVhc3VyZW1lbnQgb25jZSBwZXIgbWV0aG9kIG5hbWVcbi8vIHRvIGF2b2lkIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSB3aXRoIG1lYXN1cmVtZW50IG92ZXJoZWFkLlxudmFyIGxhYmVsc0luQ3VycmVudENvbW1pdCA9IG5ldyBTZXQoKTtcblxudmFyIGZvcm1hdE1hcmtOYW1lID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHJldHVybiByZWFjdEVtb2ppICsgJyAnICsgbWFya05hbWU7XG59O1xuXG52YXIgZm9ybWF0TGFiZWwgPSBmdW5jdGlvbiAobGFiZWwsIHdhcm5pbmckJDEpIHtcbiAgdmFyIHByZWZpeCA9IHdhcm5pbmckJDEgPyB3YXJuaW5nRW1vamkgKyAnICcgOiByZWFjdEVtb2ppICsgJyAnO1xuICB2YXIgc3VmZml4ID0gd2FybmluZyQkMSA/ICcgV2FybmluZzogJyArIHdhcm5pbmckJDEgOiAnJztcbiAgcmV0dXJuICcnICsgcHJlZml4ICsgbGFiZWwgKyBzdWZmaXg7XG59O1xuXG52YXIgYmVnaW5NYXJrID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHBlcmZvcm1hbmNlLm1hcmsoZm9ybWF0TWFya05hbWUobWFya05hbWUpKTtcbn07XG5cbnZhciBjbGVhck1hcmsgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xufTtcblxudmFyIGVuZE1hcmsgPSBmdW5jdGlvbiAobGFiZWwsIG1hcmtOYW1lLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBmb3JtYXR0ZWRNYXJrTmFtZSA9IGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKTtcbiAgdmFyIGZvcm1hdHRlZExhYmVsID0gZm9ybWF0TGFiZWwobGFiZWwsIHdhcm5pbmckJDEpO1xuICB0cnkge1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoZm9ybWF0dGVkTGFiZWwsIGZvcm1hdHRlZE1hcmtOYW1lKTtcbiAgfSBjYXRjaCAoZXJyKSB7fVxuICAvLyBJZiBwcmV2aW91cyBtYXJrIHdhcyBtaXNzaW5nIGZvciBzb21lIHJlYXNvbiwgdGhpcyB3aWxsIHRocm93LlxuICAvLyBUaGlzIGNvdWxkIG9ubHkgaGFwcGVuIGlmIFJlYWN0IGNyYXNoZWQgaW4gYW4gdW5leHBlY3RlZCBwbGFjZSBlYXJsaWVyLlxuICAvLyBEb24ndCBwaWxlIG9uIHdpdGggbW9yZSBlcnJvcnMuXG5cbiAgLy8gQ2xlYXIgbWFya3MgaW1tZWRpYXRlbHkgdG8gYXZvaWQgZ3Jvd2luZyBidWZmZXIuXG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MoZm9ybWF0dGVkTWFya05hbWUpO1xuICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKGZvcm1hdHRlZExhYmVsKTtcbn07XG5cbnZhciBnZXRGaWJlck1hcmtOYW1lID0gZnVuY3Rpb24gKGxhYmVsLCBkZWJ1Z0lEKSB7XG4gIHJldHVybiBsYWJlbCArICcgKCMnICsgZGVidWdJRCArICcpJztcbn07XG5cbnZhciBnZXRGaWJlckxhYmVsID0gZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpIHtcbiAgaWYgKHBoYXNlID09PSBudWxsKSB7XG4gICAgLy8gVGhlc2UgYXJlIGNvbXBvc2l0ZSBjb21wb25lbnQgdG90YWwgdGltZSBtZWFzdXJlbWVudHMuXG4gICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgKyAnIFsnICsgKGlzTW91bnRlZCA/ICd1cGRhdGUnIDogJ21vdW50JykgKyAnXSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29tcG9zaXRlIGNvbXBvbmVudCBtZXRob2RzLlxuICAgIHJldHVybiBjb21wb25lbnROYW1lICsgJy4nICsgcGhhc2U7XG4gIH1cbn07XG5cbnZhciBiZWdpbkZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG5cbiAgaWYgKGlzQ29tbWl0dGluZyAmJiBsYWJlbHNJbkN1cnJlbnRDb21taXQuaGFzKGxhYmVsKSkge1xuICAgIC8vIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCB3ZSBkb24ndCBzaG93IGR1cGxpY2F0ZSBsYWJlbHMgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIGEgZml4ZWQgb3ZlcmhlYWQgZm9yIGV2ZXJ5IG1lYXN1cmVtZW50LCBhbmQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRvIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSBiZXlvbmQgbmVjZXNzYXJ5LlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsYWJlbHNJbkN1cnJlbnRDb21taXQuYWRkKGxhYmVsKTtcblxuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgYmVnaW5NYXJrKG1hcmtOYW1lKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgY2xlYXJGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgY2xlYXJNYXJrKG1hcmtOYW1lKTtcbn07XG5cbnZhciBlbmRGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgZW5kTWFyayhsYWJlbCwgbWFya05hbWUsIHdhcm5pbmckJDEpO1xufTtcblxudmFyIHNob3VsZElnbm9yZUZpYmVyID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIC8vIEhvc3QgY29tcG9uZW50cyBzaG91bGQgYmUgc2tpcHBlZCBpbiB0aGUgdGltZWxpbmUuXG4gIC8vIFdlIGNvdWxkIGNoZWNrIHR5cGVvZiBmaWJlci50eXBlLCBidXQgZG9lcyB0aGlzIHdvcmsgd2l0aCBSTj9cbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICBjYXNlIFJldHVybkNvbXBvbmVudDpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlRmliZXIgIT09IG51bGwpIHtcbiAgICBjbGVhckZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlKTtcbiAgfVxuICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIGN1cnJlbnRQaGFzZSA9IG51bGw7XG4gIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG59O1xuXG52YXIgcGF1c2VUaW1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFN0b3BzIGFsbCBjdXJyZW50bHkgYWN0aXZlIG1lYXN1cmVtZW50cyBzbyB0aGF0IHRoZXkgY2FuIGJlIHJlc3VtZWRcbiAgLy8gaWYgd2UgY29udGludWUgaW4gYSBsYXRlciBkZWZlcnJlZCBsb29wIGZyb20gdGhlIHNhbWUgdW5pdCBvZiB3b3JrLlxuICB2YXIgZmliZXIgPSBjdXJyZW50RmliZXI7XG4gIHdoaWxlIChmaWJlcikge1xuICAgIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCBudWxsKTtcbiAgICB9XG4gICAgZmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gIH1cbn07XG5cbnZhciByZXN1bWVUaW1lcnNSZWN1cnNpdmVseSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICBpZiAoZmliZXJbJ3JldHVybiddICE9PSBudWxsKSB7XG4gICAgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkoZmliZXJbJ3JldHVybiddKTtcbiAgfVxuICBpZiAoZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICBiZWdpbkZpYmVyTWFyayhmaWJlciwgbnVsbCk7XG4gIH1cbn07XG5cbnZhciByZXN1bWVUaW1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFJlc3VtZXMgYWxsIG1lYXN1cmVtZW50cyB0aGF0IHdlcmUgYWN0aXZlIGR1cmluZyB0aGUgbGFzdCBkZWZlcnJlZCBsb29wLlxuICBpZiAoY3VycmVudEZpYmVyICE9PSBudWxsKSB7XG4gICAgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkoY3VycmVudEZpYmVyKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVjb3JkRWZmZWN0KCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0Kys7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkU2NoZWR1bGVVcGRhdGUoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2UgIT09ICdjb21wb25lbnRXaWxsTW91bnQnICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UmVxdWVzdENhbGxiYWNrVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZyAmJiAhaXNXYWl0aW5nRm9yQ2FsbGJhY2spIHtcbiAgICAgIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgIGJlZ2luTWFyaygnKFdhaXRpbmcgZm9yIGFzeW5jIGNhbGxiYWNrLi4uKScpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUmVxdWVzdENhbGxiYWNrVGltZXIoZGlkRXhwaXJlKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgIHZhciB3YXJuaW5nJCQxID0gZGlkRXhwaXJlID8gJ1JlYWN0IHdhcyBibG9ja2VkIGJ5IG1haW4gdGhyZWFkJyA6IG51bGw7XG4gICAgICBlbmRNYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJywgJyhXYWl0aW5nIGZvciBhc3luYyBjYWxsYmFjay4uLiknLCB3YXJuaW5nJCQxKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIHRoaXMgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyO1xuICAgIGlmICghYmVnaW5GaWJlck1hcmsoZmliZXIsIG51bGwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVtZW1iZXIgd2Ugc2hvdWxkbid0IGNvbXBsZXRlIG1lYXN1cmVtZW50IGZvciB0aGlzIGZpYmVyLlxuICAgIC8vIE90aGVyd2lzZSBmbGFtZWNoYXJ0IHdpbGwgYmUgZGVlcCBldmVuIGZvciBzbWFsbCB1cGRhdGVzLlxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgY2xlYXJGaWJlck1hcmsoZmliZXIsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIGl0cyBwYXJlbnQgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICBpZiAoIWZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wRmFpbGVkV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCBpdHMgcGFyZW50IGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gICAgaWYgKCFmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIHZhciB3YXJuaW5nJCQxID0gJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIHRoaXMgZXJyb3IgYm91bmRhcnknO1xuICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgd2FybmluZyQkMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRQaGFzZVRpbWVyKGZpYmVyLCBwaGFzZSkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQoKTtcbiAgICBpZiAoIWJlZ2luRmliZXJNYXJrKGZpYmVyLCBwaGFzZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3VycmVudFBoYXNlRmliZXIgPSBmaWJlcjtcbiAgICBjdXJyZW50UGhhc2UgPSBwaGFzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUGhhc2VUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZUZpYmVyICE9PSBudWxsKSB7XG4gICAgICB2YXIgd2FybmluZyQkMSA9IGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID8gJ1NjaGVkdWxlZCBhIGNhc2NhZGluZyB1cGRhdGUnIDogbnVsbDtcbiAgICAgIGVuZEZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlLCB3YXJuaW5nJCQxKTtcbiAgICB9XG4gICAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrTG9vcFRpbWVyKG5leHRVbml0T2ZXb3JrKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgY3VycmVudEZpYmVyID0gbmV4dFVuaXRPZldvcms7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgLy8gVGhpcyBpcyB0b3AgbGV2ZWwgY2FsbC5cbiAgICAvLyBBbnkgb3RoZXIgbWVhc3VyZW1lbnRzIGFyZSBwZXJmb3JtZWQgd2l0aGluLlxuICAgIGJlZ2luTWFyaygnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJyk7XG4gICAgLy8gUmVzdW1lIGFueSBtZWFzdXJlbWVudHMgdGhhdCB3ZXJlIGluIHByb2dyZXNzIGR1cmluZyB0aGUgbGFzdCBsb29wLlxuICAgIHJlc3VtZVRpbWVycygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnkpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgd2FybmluZyQkMSA9IG51bGw7XG4gICAgaWYgKGludGVycnVwdGVkQnkgIT09IG51bGwpIHtcbiAgICAgIGlmIChpbnRlcnJ1cHRlZEJ5LnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgd2FybmluZyQkMSA9ICdBIHRvcC1sZXZlbCB1cGRhdGUgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoaW50ZXJydXB0ZWRCeSkgfHwgJ1Vua25vd24nO1xuICAgICAgICB3YXJuaW5nJCQxID0gJ0FuIHVwZGF0ZSB0byAnICsgY29tcG9uZW50TmFtZSArICcgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMSkge1xuICAgICAgd2FybmluZyQkMSA9ICdUaGVyZSB3ZXJlIGNhc2NhZGluZyB1cGRhdGVzJztcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgLy8gUGF1c2UgYW55IG1lYXN1cmVtZW50cyB1bnRpbCB0aGUgbmV4dCBsb29wLlxuICAgIHBhdXNlVGltZXJzKCk7XG4gICAgZW5kTWFyaygnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJywgJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0VGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNDb21taXR0aW5nID0gdHJ1ZTtcbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBsYWJlbHNJbkN1cnJlbnRDb21taXQuY2xlYXIoKTtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIENoYW5nZXMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdFRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmckJDEgPSBudWxsO1xuICAgIGlmIChoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQpIHtcbiAgICAgIHdhcm5pbmckJDEgPSAnTGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGVkIGEgY2FzY2FkaW5nIHVwZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMCkge1xuICAgICAgd2FybmluZyQkMSA9ICdDYXVzZWQgYnkgYSBjYXNjYWRpbmcgdXBkYXRlIGluIGVhcmxpZXIgY29tbWl0JztcbiAgICB9XG4gICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCsrO1xuICAgIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuXG4gICAgZW5kTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCAnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCB3YXJuaW5nJCQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGJlZ2luTWFyaygnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHM6ICcgKyBjb3VudCArICcgVG90YWwpJywgJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0cyknLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kczogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHMpJywgbnVsbCk7XG4gIH1cbn1cblxue1xuICB2YXIgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0ID0ge307XG59XG5cbi8vIEEgY3Vyc29yIHRvIHRoZSBjdXJyZW50IG1lcmdlZCBjb250ZXh0IG9iamVjdCBvbiB0aGUgc3RhY2suXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGVtcHR5T2JqZWN0KTtcbi8vIEEgY3Vyc29yIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQuXG52YXIgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihmYWxzZSk7XG4vLyBLZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBjb250ZXh0IG9iamVjdCB0aGF0IHdhcyBvbiB0aGUgc3RhY2suXG4vLyBXZSB1c2UgdGhpcyB0byBnZXQgYWNjZXNzIHRvIHRoZSBwYXJlbnQgY29udGV4dCBhZnRlciB3ZSBoYXZlIGFscmVhZHlcbi8vIHB1c2hlZCB0aGUgbmV4dCBjb250ZXh0IHByb3ZpZGVyLCBhbmQgbm93IG5lZWQgdG8gbWVyZ2UgdGhlaXIgY29udGV4dHMuXG52YXIgcHJldmlvdXNDb250ZXh0ID0gZW1wdHlPYmplY3Q7XG5cbmZ1bmN0aW9uIGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaGFzT3duQ29udGV4dCA9IGlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgaWYgKGhhc093bkNvbnRleHQpIHtcbiAgICAvLyBJZiB0aGUgZmliZXIgaXMgYSBjb250ZXh0IHByb3ZpZGVyIGl0c2VsZiwgd2hlbiB3ZSByZWFkIGl0cyBjb250ZXh0XG4gICAgLy8gd2UgaGF2ZSBhbHJlYWR5IHB1c2hlZCBpdHMgb3duIGNoaWxkIGNvbnRleHQgb24gdGhlIHN0YWNrLiBBIGNvbnRleHRcbiAgICAvLyBwcm92aWRlciBzaG91bGQgbm90IFwic2VlXCIgaXRzIG93biBjaGlsZCBjb250ZXh0LiBUaGVyZWZvcmUgd2UgcmVhZCB0aGVcbiAgICAvLyBwcmV2aW91cyAocGFyZW50KSBjb250ZXh0IGluc3RlYWQgZm9yIGEgY29udGV4dCBwcm92aWRlci5cbiAgICByZXR1cm4gcHJldmlvdXNDb250ZXh0O1xuICB9XG4gIHJldHVybiBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIG1hc2tlZENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCA9IG1hc2tlZENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBjb250ZXh0VHlwZXMgPSB0eXBlLmNvbnRleHRUeXBlcztcbiAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gIH1cblxuICAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAvLyBGYWlsaW5nIHRvIGRvIHRoaXMgd2lsbCByZXN1bHQgaW4gdW5uZWNlc3NhcnkgY2FsbHMgdG8gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5cbiAgLy8gVGhpcyBtYXkgdHJpZ2dlciBpbmZpbml0ZSBsb29wcyBpZiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGNhbGxzIHNldFN0YXRlLlxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID09PSB1bm1hc2tlZENvbnRleHQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgY29udGV4dFtrZXldID0gdW5tYXNrZWRDb250ZXh0W2tleV07XG4gIH1cblxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bic7XG4gICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUsIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gIC8vIENvbnRleHQgaXMgY3JlYXRlZCBiZWZvcmUgdGhlIGNsYXNzIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgc28gY2hlY2sgZm9yIGluc3RhbmNlLlxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gaGFzQ29udGV4dENoYW5nZWQoKSB7XG4gIHJldHVybiBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY29udGV4dFR5cGVzICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcG9wQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIGlmICghaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIpIHtcbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyLCBjb250ZXh0LCBkaWRDaGFuZ2UpIHtcbiAgIShjb250ZXh0U3RhY2tDdXJzb3IuY3Vyc29yID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBjb250ZXh0LCBmaWJlcik7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gIC8vIFRPRE8gKGJ2YXVnaG4pIFJlcGxhY2UgdGhpcyBiZWhhdmlvciB3aXRoIGFuIGludmFyaWFudCgpIGluIHRoZSBmdXR1cmUuXG4gIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCF3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gIH1cblxuICB2YXIgY2hpbGRDb250ZXh0ID0gdm9pZCAwO1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ2dldENoaWxkQ29udGV4dCcpO1xuICB9XG4gIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgJ2dldENoaWxkQ29udGV4dCcpO1xuICBjaGlsZENvbnRleHQgPSBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtcbiAgc3RvcFBoYXNlVGltZXIoKTtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9XG4gIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgIShjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dFR5cGVzKSA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJywgY29udGV4dEtleSkgOiB2b2lkIDA7XG4gIH1cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICAgIGNoZWNrUHJvcFR5cGVzKGNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsICdjaGlsZCBjb250ZXh0JywgbmFtZSxcbiAgICAvLyBJbiBwcmFjdGljZSwgdGhlcmUgaXMgb25lIGNhc2UgaW4gd2hpY2ggd2Ugd29uJ3QgZ2V0IGEgc3RhY2suIEl0J3Mgd2hlblxuICAgIC8vIHNvbWVib2R5IGNhbGxzIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKCkgYW5kIHdlIHByb2Nlc3NcbiAgICAvLyBjb250ZXh0IGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQgaW5zdGFuY2UuIFRoZSBzdGFjayB3aWxsIGJlIG1pc3NpbmdcbiAgICAvLyBiZWNhdXNlIGl0J3Mgb3V0c2lkZSBvZiB0aGUgcmVjb25jaWxpYXRpb24sIGFuZCBzbyB0aGUgcG9pbnRlciBoYXMgbm90XG4gICAgLy8gYmVlbiBzZXQuIFRoaXMgaXMgcmFyZSBhbmQgZG9lc24ndCBtYXR0ZXIuIFdlJ2xsIGFsc28gcmVtb3ZlIHRoYXQgQVBJLlxuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICByZXR1cm4gX2Fzc2lnbih7fSwgcGFyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoIWlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gV2UgcHVzaCB0aGUgY29udGV4dCBhcyBlYXJseSBhcyBwb3NzaWJsZSB0byBlbnN1cmUgc3RhY2sgaW50ZWdyaXR5LlxuICAvLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbiAgLy8gYW5kIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGxhdGVyIHdoZW4gaW52YWxpZGF0aW5nIHRoZSBjb250ZXh0LlxuICB2YXIgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCB8fCBlbXB0eU9iamVjdDtcblxuICAvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4gIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRpZC1wZXJmb3JtLXdvcmsgdmFsdWUgdG8gYXZvaWQgaW5hZHZlcnRlbnRseSBibG9ja2luZyB1cGRhdGVzLlxuICBwcmV2aW91c0NvbnRleHQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGRpZENoYW5nZSkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICFpbnN0YW5jZSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGhhdmUgYW4gaW5zdGFuY2UgYnkgdGhpcyBwb2ludC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgLy8gTWVyZ2UgcGFyZW50IGFuZCBvd24gY29udGV4dC5cbiAgICAvLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4gICAgLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcmlseSByZWNvbXB1dGluZyBtZW1vaXplZCB2YWx1ZXMuXG4gICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2aW91c0NvbnRleHQpO1xuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDtcblxuICAgIC8vIFJlcGxhY2UgdGhlIG9sZCAob3IgZW1wdHkpIGNvbnRleHQgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gdW53aW5kIHRoZSBjb250ZXh0IGluIHRoZSByZXZlcnNlIG9yZGVyLlxuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIC8vIE5vdyBwdXNoIHRoZSBuZXcgY29udGV4dCBhbmQgbWFyayB0aGF0IGl0IGhhcyBjaGFuZ2VkLlxuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZXJnZWRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRDb250ZXh0KCkge1xuICBwcmV2aW91c0NvbnRleHQgPSBlbXB0eU9iamVjdDtcbiAgY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBlbXB0eU9iamVjdDtcbiAgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50ID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKSB7XG4gIC8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuICAvLyBtYWtlcyBzZW5zZSBlbHNld2hlcmVcbiAgIShpc0ZpYmVyTW91bnRlZChmaWJlcikgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBzdWJ0cmVlIHBhcmVudCB0byBiZSBhIG1vdW50ZWQgY2xhc3MgY29tcG9uZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHZhciBub2RlID0gZmliZXI7XG4gIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDtcbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IG5vZGVbJ3JldHVybiddO1xuICAgICFwYXJlbnQgPyBpbnZhcmlhbnQoZmFsc2UsICdGb3VuZCB1bmV4cGVjdGVkIGRldGFjaGVkIHN1YnRyZWUgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIG5vZGUgPSBwYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLmNvbnRleHQ7XG59XG5cbnZhciBOb1dvcmsgPSAwOyAvLyBUT0RPOiBVc2UgYW4gb3BhcXVlIHR5cGUgb25jZSBFU0xpbnQgZXQgYWwgc3VwcG9ydCB0aGUgc3ludGF4XG5cbnZhciBTeW5jID0gMTtcbnZhciBOZXZlciA9IDIxNDc0ODM2NDc7IC8vIE1heCBpbnQzMjogTWF0aC5wb3coMiwgMzEpIC0gMVxuXG52YXIgVU5JVF9TSVpFID0gMTA7XG52YXIgTUFHSUNfTlVNQkVSX09GRlNFVCA9IDI7XG5cbi8vIDEgdW5pdCBvZiBleHBpcmF0aW9uIHRpbWUgcmVwcmVzZW50cyAxMG1zLlxuZnVuY3Rpb24gbXNUb0V4cGlyYXRpb25UaW1lKG1zKSB7XG4gIC8vIEFsd2F5cyBhZGQgYW4gb2Zmc2V0IHNvIHRoYXQgd2UgZG9uJ3QgY2xhc2ggd2l0aCB0aGUgbWFnaWMgbnVtYmVyIGZvciBOb1dvcmsuXG4gIHJldHVybiAobXMgLyBVTklUX1NJWkUgfCAwKSArIE1BR0lDX05VTUJFUl9PRkZTRVQ7XG59XG5cbmZ1bmN0aW9uIGV4cGlyYXRpb25UaW1lVG9NcyhleHBpcmF0aW9uVGltZSkge1xuICByZXR1cm4gKGV4cGlyYXRpb25UaW1lIC0gTUFHSUNfTlVNQkVSX09GRlNFVCkgKiBVTklUX1NJWkU7XG59XG5cbmZ1bmN0aW9uIGNlaWxpbmcobnVtLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuICgobnVtIC8gcHJlY2lzaW9uIHwgMCkgKyAxKSAqIHByZWNpc2lvbjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQoY3VycmVudFRpbWUsIGV4cGlyYXRpb25Jbk1zLCBidWNrZXRTaXplTXMpIHtcbiAgcmV0dXJuIGNlaWxpbmcoY3VycmVudFRpbWUgKyBleHBpcmF0aW9uSW5NcyAvIFVOSVRfU0laRSwgYnVja2V0U2l6ZU1zIC8gVU5JVF9TSVpFKTtcbn1cblxudmFyIE5vQ29udGV4dCA9IDA7XG52YXIgQXN5bmNVcGRhdGVzID0gMTtcblxue1xuICB2YXIgaGFzQmFkTWFwUG9seWZpbGwgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG4gICAgXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgYWJvdXQgYmFkIHBvbHlmaWxsc1xuICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBBIEZpYmVyIGlzIHdvcmsgb24gYSBDb21wb25lbnQgdGhhdCBuZWVkcyB0byBiZSBkb25lIG9yIHdhcyBkb25lLiBUaGVyZSBjYW5cbi8vIGJlIG1vcmUgdGhhbiBvbmUgcGVyIGNvbXBvbmVudC5cblxuXG57XG4gIHZhciBkZWJ1Z0NvdW50ZXIgPSAxO1xufVxuXG5mdW5jdGlvbiBGaWJlck5vZGUodGFnLCBrZXksIGludGVybmFsQ29udGV4dFRhZykge1xuICAvLyBJbnN0YW5jZVxuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMudHlwZSA9IG51bGw7XG4gIHRoaXMuc3RhdGVOb2RlID0gbnVsbDtcblxuICAvLyBGaWJlclxuICB0aGlzWydyZXR1cm4nXSA9IG51bGw7XG4gIHRoaXMuY2hpbGQgPSBudWxsO1xuICB0aGlzLnNpYmxpbmcgPSBudWxsO1xuICB0aGlzLmluZGV4ID0gMDtcblxuICB0aGlzLnJlZiA9IG51bGw7XG5cbiAgdGhpcy5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgdGhpcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcblxuICB0aGlzLmludGVybmFsQ29udGV4dFRhZyA9IGludGVybmFsQ29udGV4dFRhZztcblxuICAvLyBFZmZlY3RzXG4gIHRoaXMuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG4gIHRoaXMubmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gIHRoaXMubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICB0aGlzLmFsdGVybmF0ZSA9IG51bGw7XG5cbiAge1xuICAgIHRoaXMuX2RlYnVnSUQgPSBkZWJ1Z0NvdW50ZXIrKztcbiAgICB0aGlzLl9kZWJ1Z1NvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdPd25lciA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGlmICghaGFzQmFkTWFwUG9seWZpbGwgJiYgdHlwZW9mIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIGlzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIHJhdGhlciB0aGFuIGEgUE9KTyBjb25zdHJ1Y3Rvciwgc3RpbGxcbi8vIHBsZWFzZSBlbnN1cmUgd2UgZG8gdGhlIGZvbGxvd2luZzpcbi8vIDEpIE5vYm9keSBzaG91bGQgYWRkIGFueSBpbnN0YW5jZSBtZXRob2RzIG9uIHRoaXMuIEluc3RhbmNlIG1ldGhvZHMgY2FuIGJlXG4vLyAgICBtb3JlIGRpZmZpY3VsdCB0byBwcmVkaWN0IHdoZW4gdGhleSBnZXQgb3B0aW1pemVkIGFuZCB0aGV5IGFyZSBhbG1vc3Rcbi8vICAgIG5ldmVyIGlubGluZWQgcHJvcGVybHkgaW4gc3RhdGljIGNvbXBpbGVycy5cbi8vIDIpIE5vYm9keSBzaG91bGQgcmVseSBvbiBgaW5zdGFuY2VvZiBGaWJlcmAgZm9yIHR5cGUgdGVzdGluZy4gV2Ugc2hvdWxkXG4vLyAgICBhbHdheXMga25vdyB3aGVuIGl0IGlzIGEgZmliZXIuXG4vLyAzKSBXZSBtaWdodCB3YW50IHRvIGV4cGVyaW1lbnQgd2l0aCB1c2luZyBudW1lcmljIGtleXMgc2luY2UgdGhleSBhcmUgZWFzaWVyXG4vLyAgICB0byBvcHRpbWl6ZSBpbiBhIG5vbi1KSVQgZW52aXJvbm1lbnQuXG4vLyA0KSBXZSBjYW4gZWFzaWx5IGdvIGZyb20gYSBjb25zdHJ1Y3RvciB0byBhIGNyZWF0ZUZpYmVyIG9iamVjdCBsaXRlcmFsIGlmIHRoYXRcbi8vICAgIGlzIGZhc3Rlci5cbi8vIDUpIEl0IHNob3VsZCBiZSBlYXN5IHRvIHBvcnQgdGhpcyB0byBhIEMgc3RydWN0IGFuZCBrZWVwIGEgQyBpbXBsZW1lbnRhdGlvblxuLy8gICAgY29tcGF0aWJsZS5cbnZhciBjcmVhdGVGaWJlciA9IGZ1bmN0aW9uICh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSB7XG4gIC8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuLy8gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBhbiBhbHRlcm5hdGUgZmliZXIgdG8gZG8gd29yayBvbi5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHVzZSBhIGRvdWJsZSBidWZmZXJpbmcgcG9vbGluZyB0ZWNobmlxdWUgYmVjYXVzZSB3ZSBrbm93IHRoYXQgd2UnbGxcbiAgICAvLyBvbmx5IGV2ZXIgbmVlZCBhdCBtb3N0IHR3byB2ZXJzaW9ucyBvZiBhIHRyZWUuIFdlIHBvb2wgdGhlIFwib3RoZXJcIiB1bnVzZWRcbiAgICAvLyBub2RlIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nXG4gICAgLy8gZXh0cmEgb2JqZWN0cyBmb3IgdGhpbmdzIHRoYXQgYXJlIG5ldmVyIHVwZGF0ZWQuIEl0IGFsc28gYWxsb3cgdXMgdG9cbiAgICAvLyByZWNsYWltIHRoZSBleHRyYSBtZW1vcnkgaWYgbmVlZGVkLlxuICAgIHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoY3VycmVudC50YWcsIGN1cnJlbnQua2V5LCBjdXJyZW50LmludGVybmFsQ29udGV4dFRhZyk7XG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZTtcblxuICAgIHtcbiAgICAgIC8vIERFVi1vbmx5IGZpZWxkc1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgPSBjdXJyZW50Ll9kZWJ1Z0lEO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlID0gY3VycmVudC5fZGVidWdTb3VyY2U7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gY3VycmVudDtcbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBhbHRlcm5hdGUuXG4gICAgLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG5cbiAgICAvLyBUaGUgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgIHdvcmtJblByb2dyZXNzLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcblxuICAvLyBUaGVzZSB3aWxsIGJlIG92ZXJyaWRkZW4gZHVyaW5nIHRoZSBwYXJlbnQncyByZWNvbmNpbGlhdGlvblxuICB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gY3VycmVudC5zaWJsaW5nO1xuICB3b3JrSW5Qcm9ncmVzcy5pbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gIHdvcmtJblByb2dyZXNzLnJlZiA9IGN1cnJlbnQucmVmO1xuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcigpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFJvb3QsIG51bGwsIE5vQ29udGV4dCk7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBvd25lciA9IG51bGw7XG4gIHtcbiAgICBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIGZpYmVyID0gdm9pZCAwO1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZSxcbiAgICAgIGtleSA9IGVsZW1lbnQua2V5O1xuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZpYmVyID0gc2hvdWxkQ29uc3RydWN0KHR5cGUpID8gY3JlYXRlRmliZXIoQ2xhc3NDb21wb25lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSA6IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgICBmaWJlci50eXBlID0gdHlwZTtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICAgIGZpYmVyLnR5cGUgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgdHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgIC8vIEN1cnJlbnRseSBhc3N1bWVkIHRvIGJlIGEgY29udGludWF0aW9uIGFuZCB0aGVyZWZvcmUgaXMgYSBmaWJlciBhbHJlYWR5LlxuICAgIC8vIFRPRE86IFRoZSB5aWVsZCBzeXN0ZW0gaXMgY3VycmVudGx5IGJyb2tlbiBmb3IgdXBkYXRlcyBpbiBzb21lIGNhc2VzLlxuICAgIC8vIFRoZSByZWlmaWVkIHlpZWxkIHN0b3JlcyBhIGZpYmVyLCBidXQgd2UgZG9uJ3Qga25vdyB3aGljaCBmaWJlciB0aGF0IGlzO1xuICAgIC8vIHRoZSBjdXJyZW50IG9yIGEgd29ya0luUHJvZ3Jlc3M/IFdoZW4gdGhlIGNvbnRpbnVhdGlvbiBnZXRzIHJlbmRlcmVkIGhlcmVcbiAgICAvLyB3ZSBkb24ndCBrbm93IGlmIHdlIGNhbiByZXVzZSB0aGF0IGZpYmVyIG9yIGlmIHdlIG5lZWQgdG8gY2xvbmUgaXQuXG4gICAgLy8gVGhlcmUgaXMgcHJvYmFibHkgYSBjbGV2ZXIgd2F5IHRvIHJlc3RydWN0dXJlIHRoaXMuXG4gICAgZmliZXIgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB7XG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lcikgOiBudWxsO1xuICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pO1xuICB9XG5cbiAge1xuICAgIGZpYmVyLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcblxuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnRzLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRnJhZ21lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudHM7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RUZXh0LCBudWxsLCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb250ZW50O1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LCBudWxsLCBOb0NvbnRleHQpO1xuICBmaWJlci50eXBlID0gJ0RFTEVURUQnO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUNhbGwoY2FsbCwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihDYWxsQ29tcG9uZW50LCBjYWxsLmtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIudHlwZSA9IGNhbGwuaGFuZGxlcjtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gY2FsbDtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihSZXR1cm5Db21wb25lbnQsIG51bGwsIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0UG9ydGFsLCBwb3J0YWwua2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBwb3J0YWwuY2hpbGRyZW4gfHwgW107XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsIC8vIFVzZWQgYnkgcGVyc2lzdGVudCB1cGRhdGVzXG4gICAgaW1wbGVtZW50YXRpb246IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuICB9O1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCBoeWRyYXRlKSB7XG4gIC8vIEN5Y2xpYyBjb25zdHJ1Y3Rpb24uIFRoaXMgY2hlYXRzIHRoZSB0eXBlIHN5c3RlbSByaWdodCBub3cgYmVjYXVzZVxuICAvLyBzdGF0ZU5vZGUgaXMgYW55LlxuICB2YXIgdW5pbml0aWFsaXplZEZpYmVyID0gY3JlYXRlSG9zdFJvb3RGaWJlcigpO1xuICB2YXIgcm9vdCA9IHtcbiAgICBjdXJyZW50OiB1bmluaXRpYWxpemVkRmliZXIsXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgcmVtYWluaW5nRXhwaXJhdGlvblRpbWU6IE5vV29yayxcbiAgICBpc1JlYWR5Rm9yQ29tbWl0OiBmYWxzZSxcbiAgICBmaW5pc2hlZFdvcms6IG51bGwsXG4gICAgY29udGV4dDogbnVsbCxcbiAgICBwZW5kaW5nQ29udGV4dDogbnVsbCxcbiAgICBoeWRyYXRlOiBoeWRyYXRlLFxuICAgIG5leHRTY2hlZHVsZWRSb290OiBudWxsXG4gIH07XG4gIHVuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGUgPSByb290O1xuICByZXR1cm4gcm9vdDtcbn1cblxudmFyIG9uQ29tbWl0RmliZXJSb290ID0gbnVsbDtcbnZhciBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IG51bGw7XG52YXIgaGFzTG9nZ2VkRXJyb3IgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2F0Y2hFcnJvcnMoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGFyZyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodHJ1ZSAmJiAhaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpIHtcbiAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTm8gRGV2VG9vbHNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG4gIGlmIChob29rLmlzRGlzYWJsZWQpIHtcbiAgICAvLyBUaGlzIGlzbid0IGEgcmVhbCBwcm9wZXJ0eSBvbiB0aGUgaG9vaywgYnV0IGl0IGNhbiBiZSBzZXQgdG8gb3B0IG91dFxuICAgIC8vIG9mIERldlRvb2xzIGludGVncmF0aW9uIGFuZCBhc3NvY2lhdGVkIHdhcm5pbmdzIGFuZCBsb2dzLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzg3N1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghaG9vay5zdXBwb3J0c0ZpYmVyKSB7XG4gICAge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBpbnN0YWxsZWQgdmVyc2lvbiBvZiBSZWFjdCBEZXZUb29scyBpcyB0b28gb2xkIGFuZCB3aWxsIG5vdCB3b3JrICcgKyAnd2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFJlYWN0LiBQbGVhc2UgdXBkYXRlIFJlYWN0IERldlRvb2xzLiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9XG4gICAgLy8gRGV2VG9vbHMgZXhpc3RzLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IHN1cHBvcnQgRmliZXIuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgcmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscyk7XG4gICAgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cbiAgICBvbkNvbW1pdEZpYmVyUm9vdCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICB9KTtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgcmV0dXJuIGhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLicsIGVycik7XG4gICAgfVxuICB9XG4gIC8vIERldlRvb2xzIGV4aXN0c1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21taXRSb290KHJvb3QpIHtcbiAgaWYgKHR5cGVvZiBvbkNvbW1pdEZpYmVyUm9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9uQ29tbWl0RmliZXJSb290KHJvb3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uQ29tbWl0VW5tb3VudChmaWJlcikge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclVubW91bnQoZmliZXIpO1xuICB9XG59XG5cbntcbiAgdmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSBmYWxzZTtcbn1cblxuLy8gQ2FsbGJhY2tzIGFyZSBub3QgdmFsaWRhdGVkIHVudGlsIGludm9jYXRpb25cblxuXG4vLyBTaW5nbHkgbGlua2VkLWxpc3Qgb2YgdXBkYXRlcy4gV2hlbiBhbiB1cGRhdGUgaXMgc2NoZWR1bGVkLCBpdCBpcyBhZGRlZCB0b1xuLy8gdGhlIHF1ZXVlIG9mIHRoZSBjdXJyZW50IGZpYmVyIGFuZCB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci4gVGhlIHR3byBxdWV1ZXNcbi8vIGFyZSBzZXBhcmF0ZSBidXQgdGhleSBzaGFyZSBhIHBlcnNpc3RlbnQgc3RydWN0dXJlLlxuLy9cbi8vIER1cmluZyByZWNvbmNpbGlhdGlvbiwgdXBkYXRlcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLFxuLy8gYnV0IHRoZXkgcmVtYWluIG9uIHRoZSBjdXJyZW50IGZpYmVyLiBUaGF0IGVuc3VyZXMgdGhhdCBpZiBhIHdvcmstaW4tcHJvZ3Jlc3Ncbi8vIGlzIGFib3J0ZWQsIHRoZSBhYm9ydGVkIHVwZGF0ZXMgYXJlIHJlY292ZXJlZCBieSBjbG9uaW5nIGZyb20gY3VycmVudC5cbi8vXG4vLyBUaGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyBhbHdheXMgYSBzdWJzZXQgb2YgdGhlIGN1cnJlbnQgcXVldWUuXG4vL1xuLy8gV2hlbiB0aGUgdHJlZSBpcyBjb21taXR0ZWQsIHRoZSB3b3JrLWluLXByb2dyZXNzIGJlY29tZXMgdGhlIGN1cnJlbnQuXG5cblxuZnVuY3Rpb24gY3JlYXRlVXBkYXRlUXVldWUoYmFzZVN0YXRlKSB7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBiYXNlU3RhdGU6IGJhc2VTdGF0ZSxcbiAgICBleHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgIGZpcnN0OiBudWxsLFxuICAgIGxhc3Q6IG51bGwsXG4gICAgY2FsbGJhY2tMaXN0OiBudWxsLFxuICAgIGhhc0ZvcmNlVXBkYXRlOiBmYWxzZSxcbiAgICBpc0luaXRpYWxpemVkOiBmYWxzZVxuICB9O1xuICB7XG4gICAgcXVldWUuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUsIHVwZGF0ZSkge1xuICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICBpZiAocXVldWUubGFzdCA9PT0gbnVsbCkge1xuICAgIC8vIFF1ZXVlIGlzIGVtcHR5XG4gICAgcXVldWUuZmlyc3QgPSBxdWV1ZS5sYXN0ID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlLmxhc3QubmV4dCA9IHVwZGF0ZTtcbiAgICBxdWV1ZS5sYXN0ID0gdXBkYXRlO1xuICB9XG4gIGlmIChxdWV1ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHF1ZXVlLmV4cGlyYXRpb25UaW1lID4gdXBkYXRlLmV4cGlyYXRpb25UaW1lKSB7XG4gICAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSB1cGRhdGUuZXhwaXJhdGlvblRpbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0VXBkYXRlSW50b0ZpYmVyKGZpYmVyLCB1cGRhdGUpIHtcbiAgLy8gV2UnbGwgaGF2ZSBhdCBsZWFzdCBvbmUgYW5kIGF0IG1vc3QgdHdvIGRpc3RpbmN0IHVwZGF0ZSBxdWV1ZXMuXG4gIHZhciBhbHRlcm5hdGVGaWJlciA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgdmFyIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICBpZiAocXVldWUxID09PSBudWxsKSB7XG4gICAgLy8gVE9ETzogV2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBiYXNlIHN0YXRlIHdpbGwgYmUgdW50aWwgd2UgYmVnaW4gd29yay5cbiAgICAvLyBJdCBkZXBlbmRzIG9uIHdoaWNoIGZpYmVyIGlzIHRoZSBuZXh0IGN1cnJlbnQuIEluaXRpYWxpemUgd2l0aCBhbiBlbXB0eVxuICAgIC8vIGJhc2Ugc3RhdGUsIHRoZW4gc2V0IHRvIHRoZSBtZW1vaXplZFN0YXRlIHdoZW4gcmVuZGVyaW5nLiBOb3Qgc3VwZXJcbiAgICAvLyBoYXBweSB3aXRoIHRoaXMgYXBwcm9hY2guXG4gICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShudWxsKTtcbiAgfVxuXG4gIHZhciBxdWV1ZTIgPSB2b2lkIDA7XG4gIGlmIChhbHRlcm5hdGVGaWJlciAhPT0gbnVsbCkge1xuICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUobnVsbCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHF1ZXVlMiA9IG51bGw7XG4gIH1cbiAgcXVldWUyID0gcXVldWUyICE9PSBxdWV1ZTEgPyBxdWV1ZTIgOiBudWxsO1xuXG4gIC8vIFdhcm4gaWYgYW4gdXBkYXRlIGlzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhbiB1cGRhdGVyIGZ1bmN0aW9uLlxuICB7XG4gICAgaWYgKChxdWV1ZTEuaXNQcm9jZXNzaW5nIHx8IHF1ZXVlMiAhPT0gbnVsbCAmJiBxdWV1ZTIuaXNQcm9jZXNzaW5nKSAmJiAhZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0FuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgJyArICdmcm9tIGluc2lkZSBhbiB1cGRhdGUgZnVuY3Rpb24uIFVwZGF0ZSBmdW5jdGlvbnMgc2hvdWxkIGJlIHB1cmUsICcgKyAnd2l0aCB6ZXJvIHNpZGUtZWZmZWN0cy4gQ29uc2lkZXIgdXNpbmcgY29tcG9uZW50RGlkVXBkYXRlIG9yIGEgJyArICdjYWxsYmFjay4nKTtcbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZXJlJ3Mgb25seSBvbmUgcXVldWUsIGFkZCB0aGUgdXBkYXRlIHRvIHRoYXQgcXVldWUgYW5kIGV4aXQuXG4gIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIGVpdGhlciBxdWV1ZSBpcyBlbXB0eSwgd2UgbmVlZCB0byBhZGQgdG8gYm90aCBxdWV1ZXMuXG4gIGlmIChxdWV1ZTEubGFzdCA9PT0gbnVsbCB8fCBxdWV1ZTIubGFzdCA9PT0gbnVsbCkge1xuICAgIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gICAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMiwgdXBkYXRlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBib3RoIGxpc3RzIGFyZSBub3QgZW1wdHksIHRoZSBsYXN0IHVwZGF0ZSBpcyB0aGUgc2FtZSBmb3IgYm90aCBsaXN0c1xuICAvLyBiZWNhdXNlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy4gU28sIHdlIHNob3VsZCBvbmx5IGFwcGVuZCB0byBvbmUgb2ZcbiAgLy8gdGhlIGxpc3RzLlxuICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAvLyBCdXQgd2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgdGhlIGBsYXN0YCBwb2ludGVyIG9mIHF1ZXVlMi5cbiAgcXVldWUyLmxhc3QgPSB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGdldFVwZGF0ZUV4cGlyYXRpb25UaW1lKGZpYmVyKSB7XG4gIGlmIChmaWJlci50YWcgIT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICByZXR1cm4gTm9Xb3JrO1xuICB9XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTm9Xb3JrO1xuICB9XG4gIHJldHVybiB1cGRhdGVRdWV1ZS5leHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpIHtcbiAgdmFyIHBhcnRpYWxTdGF0ZSA9IHVwZGF0ZS5wYXJ0aWFsU3RhdGU7XG4gIGlmICh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHVwZGF0ZUZuID0gcGFydGlhbFN0YXRlO1xuXG4gICAgLy8gSW52b2tlIHNldFN0YXRlIGNhbGxiYWNrIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgIHVwZGF0ZUZuLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVGbi5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFydGlhbFN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcXVldWUsIGluc3RhbmNlLCBwcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC51cGRhdGVRdWV1ZSA9PT0gcXVldWUpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIGJ5IGNsb25pbmcgdGhlIGN1cnJlbnQgcXVldWUuXG4gICAgdmFyIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB7XG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsXG4gICAgICBleHBpcmF0aW9uVGltZTogY3VycmVudFF1ZXVlLmV4cGlyYXRpb25UaW1lLFxuICAgICAgZmlyc3Q6IGN1cnJlbnRRdWV1ZS5maXJzdCxcbiAgICAgIGxhc3Q6IGN1cnJlbnRRdWV1ZS5sYXN0LFxuICAgICAgaXNJbml0aWFsaXplZDogY3VycmVudFF1ZXVlLmlzSW5pdGlhbGl6ZWQsXG4gICAgICAvLyBUaGVzZSBmaWVsZHMgYXJlIG5vIGxvbmdlciB2YWxpZCBiZWNhdXNlIHRoZXkgd2VyZSBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAgIC8vIFJlc2V0IHRoZW0uXG4gICAgICBjYWxsYmFja0xpc3Q6IG51bGwsXG4gICAgICBoYXNGb3JjZVVwZGF0ZTogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFNldCB0aGlzIGZsYWcgc28gd2UgY2FuIHdhcm4gaWYgc2V0U3RhdGUgaXMgY2FsbGVkIGluc2lkZSB0aGUgdXBkYXRlXG4gICAgLy8gZnVuY3Rpb24gb2YgYW5vdGhlciBzZXRTdGF0ZS5cbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICB9XG5cbiAgLy8gUmVzZXQgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUuIElmIHdlIHNraXAgb3ZlciBhbnkgdXBkYXRlcywgd2UnbGxcbiAgLy8gaW5jcmVhc2UgdGhpcyBhY2NvcmRpbmdseS5cbiAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgLy8gVE9ETzogV2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBiYXNlIHN0YXRlIHdpbGwgYmUgdW50aWwgd2UgYmVnaW4gd29yay5cbiAgLy8gSXQgZGVwZW5kcyBvbiB3aGljaCBmaWJlciBpcyB0aGUgbmV4dCBjdXJyZW50LiBJbml0aWFsaXplIHdpdGggYW4gZW1wdHlcbiAgLy8gYmFzZSBzdGF0ZSwgdGhlbiBzZXQgdG8gdGhlIG1lbW9pemVkU3RhdGUgd2hlbiByZW5kZXJpbmcuIE5vdCBzdXBlclxuICAvLyBoYXBweSB3aXRoIHRoaXMgYXBwcm9hY2guXG4gIHZhciBzdGF0ZSA9IHZvaWQgMDtcbiAgaWYgKHF1ZXVlLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICBzdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgcXVldWUuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gIH1cbiAgdmFyIGRvbnRNdXRhdGVQcmV2U3RhdGUgPSB0cnVlO1xuICB2YXIgdXBkYXRlID0gcXVldWUuZmlyc3Q7XG4gIHZhciBkaWRTa2lwID0gZmFsc2U7XG4gIHdoaWxlICh1cGRhdGUgIT09IG51bGwpIHtcbiAgICB2YXIgdXBkYXRlRXhwaXJhdGlvblRpbWUgPSB1cGRhdGUuZXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKHVwZGF0ZUV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgbm90IGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS4gU2tpcCBpdC5cbiAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHF1ZXVlLmV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPiB1cGRhdGVFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICAgIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gdXBkYXRlRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBpZiAoIWRpZFNraXApIHtcbiAgICAgICAgZGlkU2tpcCA9IHRydWU7XG4gICAgICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IHN0YXRlO1xuICAgICAgfVxuICAgICAgLy8gQ29udGludWUgdG8gdGhlIG5leHQgdXBkYXRlLlxuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cblxuICAgIC8vIElmIG5vIHByZXZpb3VzIHVwZGF0ZXMgd2VyZSBza2lwcGVkLCBkcm9wIHRoaXMgdXBkYXRlIGZyb20gdGhlIHF1ZXVlIGJ5XG4gICAgLy8gYWR2YW5jaW5nIHRoZSBoZWFkIG9mIHRoZSBsaXN0LlxuICAgIGlmICghZGlkU2tpcCkge1xuICAgICAgcXVldWUuZmlyc3QgPSB1cGRhdGUubmV4dDtcbiAgICAgIGlmIChxdWV1ZS5maXJzdCA9PT0gbnVsbCkge1xuICAgICAgICBxdWV1ZS5sYXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIHRoZSB1cGRhdGVcbiAgICB2YXIgX3BhcnRpYWxTdGF0ZSA9IHZvaWQgMDtcbiAgICBpZiAodXBkYXRlLmlzUmVwbGFjZSkge1xuICAgICAgc3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgIGRvbnRNdXRhdGVQcmV2U3RhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcGFydGlhbFN0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHN0YXRlLCBwcm9wcyk7XG4gICAgICBpZiAoX3BhcnRpYWxTdGF0ZSkge1xuICAgICAgICBpZiAoZG9udE11dGF0ZVByZXZTdGF0ZSkge1xuICAgICAgICAgIC8vICRGbG93Rml4TWU6IElkayBob3cgdG8gdHlwZSB0aGlzIHByb3Blcmx5LlxuICAgICAgICAgIHN0YXRlID0gX2Fzc2lnbih7fSwgc3RhdGUsIF9wYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlID0gX2Fzc2lnbihzdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9udE11dGF0ZVByZXZTdGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXBkYXRlLmlzRm9yY2VkKSB7XG4gICAgICBxdWV1ZS5oYXNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh1cGRhdGUuY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIC8vIEFwcGVuZCB0byBsaXN0IG9mIGNhbGxiYWNrcy5cbiAgICAgIHZhciBfY2FsbGJhY2tMaXN0ID0gcXVldWUuY2FsbGJhY2tMaXN0O1xuICAgICAgaWYgKF9jYWxsYmFja0xpc3QgPT09IG51bGwpIHtcbiAgICAgICAgX2NhbGxiYWNrTGlzdCA9IHF1ZXVlLmNhbGxiYWNrTGlzdCA9IFtdO1xuICAgICAgfVxuICAgICAgX2NhbGxiYWNrTGlzdC5wdXNoKHVwZGF0ZSk7XG4gICAgfVxuICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICB9XG5cbiAgaWYgKHF1ZXVlLmNhbGxiYWNrTGlzdCAhPT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgfSBlbHNlIGlmIChxdWV1ZS5maXJzdCA9PT0gbnVsbCAmJiAhcXVldWUuaGFzRm9yY2VVcGRhdGUpIHtcbiAgICAvLyBUaGUgcXVldWUgaXMgZW1wdHkuIFdlIGNhbiByZXNldCBpdC5cbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIH1cblxuICBpZiAoIWRpZFNraXApIHtcbiAgICBkaWRTa2lwID0gdHJ1ZTtcbiAgICBxdWV1ZS5iYXNlU3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHtcbiAgICAvLyBObyBsb25nZXIgcHJvY2Vzc2luZy5cbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gY29tbWl0Q2FsbGJhY2tzKHF1ZXVlLCBjb250ZXh0KSB7XG4gIHZhciBjYWxsYmFja0xpc3QgPSBxdWV1ZS5jYWxsYmFja0xpc3Q7XG4gIGlmIChjYWxsYmFja0xpc3QgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gU2V0IHRoZSBsaXN0IHRvIG51bGwgdG8gbWFrZSBzdXJlIHRoZXkgZG9uJ3QgZ2V0IGNhbGxlZCBtb3JlIHRoYW4gb25jZS5cbiAgcXVldWUuY2FsbGJhY2tMaXN0ID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdXBkYXRlID0gY2FsbGJhY2tMaXN0W2ldO1xuICAgIHZhciBfY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG4gICAgLy8gVGhpcyB1cGRhdGUgbWlnaHQgYmUgcHJvY2Vzc2VkIGFnYWluLiBDbGVhciB0aGUgY2FsbGJhY2sgc28gaXQncyBvbmx5XG4gICAgLy8gY2FsbGVkIG9uY2UuXG4gICAgdXBkYXRlLmNhbGxiYWNrID0gbnVsbDtcbiAgICAhKHR5cGVvZiBfY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgX2NhbGxiYWNrKSA6IHZvaWQgMDtcbiAgICBfY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbiAgfVxufVxuXG52YXIgZmFrZUludGVybmFsSW5zdGFuY2UgPSB7fTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxue1xuICB2YXIgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0ge307XG5cbiAgdmFyIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5pbmcoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHNvIGdyb3NzIGJ1dCBpdCdzIGF0IGxlYXN0IG5vbi1jcml0aWNhbCBhbmQgY2FuIGJlIHJlbW92ZWQgaWZcbiAgLy8gaXQgY2F1c2VzIHByb2JsZW1zLiBUaGlzIGlzIG1lYW50IHRvIGdpdmUgYSBuaWNlciBlcnJvciBtZXNzYWdlIGZvclxuICAvLyBSZWFjdERPTTE1LnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHJlYWN0RE9NMTZDb21wb25lbnQsXG4gIC8vIC4uLikpIHdoaWNoIG90aGVyd2lzZSB0aHJvd3MgYSBcIl9wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhIGZ1bmN0aW9uXCJcbiAgLy8gZXhjZXB0aW9uLlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5IG1lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCBhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuXFwndCBzdXBwb3J0ZWQuIFRyeSB0byBtYWtlIHN1cmUgeW91IGhhdmUgb25seSBvbmUgY29weSBvZiBSZWFjdCAoYW5kIGlkZWFsbHksIHN3aXRjaCB0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLicpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5mcmVlemUoZmFrZUludGVybmFsSW5zdGFuY2UpO1xufVxuXG52YXIgUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWVtb2l6ZVByb3BzLCBtZW1vaXplU3RhdGUpIHtcbiAgLy8gQ2xhc3MgY29tcG9uZW50IHN0YXRlIHVwZGF0ZXJcbiAgdmFyIHVwZGF0ZXIgPSB7XG4gICAgaXNNb3VudGVkOiBpc01vdW50ZWQsXG4gICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBmaWJlciA9IGdldChpbnN0YW5jZSk7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICB9XG4gICAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGZpYmVyKTtcbiAgICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgcGFydGlhbFN0YXRlOiBwYXJ0aWFsU3RhdGUsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmliZXIgPSBnZXQoaW5zdGFuY2UpO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdyZXBsYWNlU3RhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IHN0YXRlLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIGlzUmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGZpYmVyID0gZ2V0KGluc3RhbmNlKTtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IG51bGwsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgICAgaXNGb3JjZWQ6IHRydWUsXG4gICAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpIHtcbiAgICBpZiAob2xkUHJvcHMgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpIHtcbiAgICAgIC8vIElmIHRoZSB3b3JrSW5Qcm9ncmVzcyBhbHJlYWR5IGhhcyBhbiBVcGRhdGUgZWZmZWN0LCByZXR1cm4gdHJ1ZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICAgIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHdhcm5pbmcoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICAgIH1cblxuICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCkge1xuICAgICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBub0dldEluaXRpYWxTdGF0ZU9uRVM2ID0gIWluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSB8fCBpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgfHwgaW5zdGFuY2Uuc3RhdGU7XG4gICAgICB3YXJuaW5nKG5vR2V0SW5pdGlhbFN0YXRlT25FUzYsICdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/JywgbmFtZSk7XG4gICAgICB2YXIgbm9HZXREZWZhdWx0UHJvcHNPbkVTNiA9ICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgfHwgaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkO1xuICAgICAgd2FybmluZyhub0dldERlZmF1bHRQcm9wc09uRVM2LCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB2YXIgbm9JbnN0YW5jZVByb3BUeXBlcyA9ICFpbnN0YW5jZS5wcm9wVHlwZXM7XG4gICAgICB3YXJuaW5nKG5vSW5zdGFuY2VQcm9wVHlwZXMsICdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIHZhciBub0luc3RhbmNlQ29udGV4dFR5cGVzID0gIWluc3RhbmNlLmNvbnRleHRUeXBlcztcbiAgICAgIHdhcm5pbmcobm9JbnN0YW5jZUNvbnRleHRUeXBlcywgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgdmFyIG5vQ29tcG9uZW50U2hvdWxkVXBkYXRlID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnRTaG91bGRVcGRhdGUsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBuYW1lKTtcbiAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0EgcHVyZSBjb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICAgIHZhciBub0NvbXBvbmVudERpZFVubW91bnQgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnREaWRVbm1vdW50LCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCBuYW1lKTtcbiAgICAgIHZhciBub0NvbXBvbmVudERpZFJlY2VpdmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSk7XG4gICAgICB2YXIgbm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgICB2YXIgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgIHdhcm5pbmcoaW5zdGFuY2UucHJvcHMgPT09IHVuZGVmaW5lZCB8fCAhaGFzTXV0YXRlZFByb3BzLCAnJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIG5hbWUsIG5hbWUpO1xuICAgICAgdmFyIG5vSW5zdGFuY2VEZWZhdWx0UHJvcHMgPSAhaW5zdGFuY2UuZGVmYXVsdFByb3BzO1xuICAgICAgd2FybmluZyhub0luc3RhbmNlRGVmYXVsdFByb3BzLCAnU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLicgKyAnIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuJywgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaWYgKHN0YXRlICYmICh0eXBlb2Ygc3RhdGUgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkoc3RhdGUpKSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdhcm5pbmcodHlwZW9mIHdvcmtJblByb2dyZXNzLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIGluc3RhbmNlLnByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuICAgIHNldChpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBwcm9wcykge1xuICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmVlZHNDb250ZXh0ID0gaXNDb250ZXh0Q29uc3VtZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gbmVlZHNDb250ZXh0ID8gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSA6IGVtcHR5T2JqZWN0O1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgICAvLyBSZWFjdEZpYmVyQ29udGV4dCB1c3VhbGx5IHVwZGF0ZXMgdGhpcyBjYWNoZSBidXQgY2FuJ3QgZm9yIG5ld2x5LWNyZWF0ZWQgaW5zdGFuY2VzLlxuICAgIGlmIChuZWVkc0NvbnRleHQpIHtcbiAgICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICAgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cykge1xuICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgfVxuXG4gICAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzICcgKyBcImRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld0NvbnRleHQpIHtcbiAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IG9sZFN0YXRlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvICcgKyBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuICBmdW5jdGlvbiBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICB7XG4gICAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSB8fCBudWxsO1xuXG4gICAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICFwcm9wcyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIG11c3QgYmUgcGVuZGluZyBwcm9wcyBmb3IgYW4gaW5pdGlhbCBtb3VudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBzdGF0ZTtcbiAgICBpbnN0YW5jZS5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoZW5hYmxlQXN5bmNTdWJ0cmVlQVBJICYmIHdvcmtJblByb2dyZXNzLnR5cGUgIT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy50eXBlLnByb3RvdHlwZSAhPSBudWxsICYmIHdvcmtJblByb2dyZXNzLnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9PT0gdHJ1ZSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuaW50ZXJuYWxDb250ZXh0VGFnIHw9IEFzeW5jVXBkYXRlcztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgICAgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgICAgLy8gcHJvY2VzcyB0aGVtIG5vdy5cbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIGluc3RhbmNlLnN0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIHByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIG9uIGEgcHJlZXhpc3RpbmcgY2xhc3MgaW5zdGFuY2UuIFJldHVybnMgZmFsc2UgaWYgYSByZXN1bWVkIHJlbmRlclxuICAvLyBjb3VsZCBiZSByZXVzZWQuXG4gIC8vIGZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZShcbiAgLy8gICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIC8vICAgcHJpb3JpdHlMZXZlbDogUHJpb3JpdHlMZXZlbCxcbiAgLy8gKTogYm9vbGVhbiB7XG4gIC8vICAgY29uc3QgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIC8vICAgcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAgLy8gICBsZXQgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAvLyAgIGxldCBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgLy8gICBpZiAoIW5ld1Byb3BzKSB7XG4gIC8vICAgICAvLyBJZiB0aGVyZSBpc24ndCBhbnkgbmV3IHByb3BzLCB0aGVuIHdlJ2xsIHJldXNlIHRoZSBtZW1vaXplZCBwcm9wcy5cbiAgLy8gICAgIC8vIFRoaXMgY291bGQgYmUgZnJvbSBhbHJlYWR5IGNvbXBsZXRlZCB3b3JrLlxuICAvLyAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAvLyAgICAgaW52YXJpYW50KFxuICAvLyAgICAgICBuZXdQcm9wcyAhPSBudWxsLFxuICAvLyAgICAgICAnVGhlcmUgc2hvdWxkIGFsd2F5cyBiZSBwZW5kaW5nIG9yIG1lbW9pemVkIHByb3BzLiBUaGlzIGVycm9yIGlzICcgK1xuICAvLyAgICAgICAgICdsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG4gIC8vICAgY29uc3QgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgLy8gICBjb25zdCBuZXdDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV3VW5tYXNrZWRDb250ZXh0KTtcblxuICAvLyAgIGNvbnN0IG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICAvLyAgIGNvbnN0IG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcblxuICAvLyAgIGlmIChcbiAgLy8gICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmXG4gIC8vICAgICAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5ld0NvbnRleHQpXG4gIC8vICAgKSB7XG4gIC8vICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICBuZXdQcm9wcyxcbiAgLy8gICAgICAgbmV3Q29udGV4dCxcbiAgLy8gICAgICk7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gUHJvY2VzcyB0aGUgdXBkYXRlIHF1ZXVlIGJlZm9yZSBjYWxsaW5nIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICAvLyAgIGNvbnN0IHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIC8vICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gIC8vICAgICBuZXdTdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHVwZGF0ZVF1ZXVlLFxuICAvLyAgICAgICBpbnN0YW5jZSxcbiAgLy8gICAgICAgbmV3U3RhdGUsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICBwcmlvcml0eUxldmVsLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBUT0RPOiBTaG91bGQgd2UgZGVhbCB3aXRoIGEgc2V0U3RhdGUgdGhhdCBoYXBwZW5lZCBhZnRlciB0aGUgbGFzdFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgYmVmb3JlIHRoaXMgY29tcG9uZW50V2lsbE1vdW50PyBQcm9iYWJseVxuICAvLyAgIC8vIHVuc3VwcG9ydGVkIGFueXdheS5cblxuICAvLyAgIGlmIChcbiAgLy8gICAgICFjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLFxuICAvLyAgICAgICBuZXdTdGF0ZSxcbiAgLy8gICAgICAgbmV3Q29udGV4dCxcbiAgLy8gICAgIClcbiAgLy8gICApIHtcbiAgLy8gICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gICAgIC8vIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dC5cbiAgLy8gICAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAvLyAgICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG4gIC8vICAgICByZXR1cm4gZmFsc2U7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gVXBkYXRlIHRoZSBpbnB1dCBwb2ludGVycyBub3cgc28gdGhhdCB0aGV5IGFyZSBjb3JyZWN0IHdoZW4gd2UgY2FsbFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudFxuICAvLyAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgLy8gICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcblxuICAvLyAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vICAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gIC8vICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgbWF5IGhhdmUgY2FsbGVkIHNldFN0YXRlLiBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUuXG4gIC8vICAgICBjb25zdCBuZXdVcGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAvLyAgICAgaWYgKG5ld1VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gIC8vICAgICAgIG5ld1N0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAvLyAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAvLyAgICAgICAgIG5ld1VwZGF0ZVF1ZXVlLFxuICAvLyAgICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICAgIG5ld1N0YXRlLFxuICAvLyAgICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICAgIHByaW9yaXR5TGV2ZWwsXG4gIC8vICAgICAgICk7XG4gIC8vICAgICB9XG4gIC8vICAgfVxuXG4gIC8vICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgLy8gICB9XG5cbiAgLy8gICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuXG4gIC8vICAgcmV0dXJuIHRydWU7XG4gIC8vIH1cblxuICAvLyBJbnZva2VzIHRoZSB1cGRhdGUgbGlmZS1jeWNsZXMgYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkbid0IHJlcmVuZGVyLlxuICBmdW5jdGlvbiB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZW4ndCBhbnkgbmV3IHByb3BzLCB0aGVuIHdlJ2xsIHJldXNlIHRoZSBtZW1vaXplZCBwcm9wcy5cbiAgICAgIC8vIFRoaXMgY291bGQgYmUgZnJvbSBhbHJlYWR5IGNvbXBsZXRlZCB3b3JrLlxuICAgICAgbmV3UHJvcHMgPSBvbGRQcm9wcztcbiAgICAgICEobmV3UHJvcHMgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBzaG91bGQgYWx3YXlzIGJlIHBlbmRpbmcgb3IgbWVtb2l6ZWQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgICB2YXIgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmV3Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5ld1VubWFza2VkQ29udGV4dCk7XG5cbiAgICAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gICAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV3Q29udGV4dCkpIHtcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgdGhlIG5leHQgc3RhdGUgdXNpbmcgdGhlIG1lbW9pemVkIHN0YXRlIGFuZCB0aGUgdXBkYXRlIHF1ZXVlLlxuICAgIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgLy8gVE9ETzogUHJldmlvdXMgc3RhdGUgY2FuIGJlIG51bGwuXG4gICAgdmFyIG5ld1N0YXRlID0gdm9pZCAwO1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgbmV3U3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSwgbmV3UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3RhdGUgPSBvbGRTdGF0ZTtcbiAgICB9XG5cbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSkge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcblxuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgICAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAgIC8vIG1lbW9pemVkIHByb3BzL3N0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzKTtcbiAgICAgIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgbmV3U3RhdGUpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cbiAgICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2U6IGFkb3B0Q2xhc3NJbnN0YW5jZSxcbiAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlOiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlLFxuICAgIG1vdW50Q2xhc3NJbnN0YW5jZTogbW91bnRDbGFzc0luc3RhbmNlLFxuICAgIC8vIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgICB1cGRhdGVDbGFzc0luc3RhbmNlOiB1cGRhdGVDbGFzc0luc3RhbmNlXG4gIH07XG59O1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXTtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9DQUxMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5jYWxsJykgOiAweGVhYzg7XG52YXIgUkVBQ1RfUkVUVVJOX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5yZXR1cm4nKSA6IDB4ZWFjOTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAgICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gICAqIHVwZGF0ZXMuXG4gICAqL1xuICB2YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gIHZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB7fTtcblxuICB2YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT09IG51bGwgfHwgdHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICEodHlwZW9mIGNoaWxkLl9zdG9yZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkpO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpIHtcbiAgdmFyIG1peGVkUmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChtaXhlZFJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgbWl4ZWRSZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGluc3QgPSB2b2lkIDA7XG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcbiAgICAgICAgIShvd25lckZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpID8gaW52YXJpYW50KGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgcmVmcy4nKSA6IHZvaWQgMDtcbiAgICAgICAgaW5zdCA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgICAgIWluc3QgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNzaW5nIG93bmVyIGZvciBzdHJpbmcgcmVmICVzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsIG1peGVkUmVmKSA6IHZvaWQgMDtcbiAgICAgIHZhciBzdHJpbmdSZWYgPSAnJyArIG1peGVkUmVmO1xuICAgICAgLy8gQ2hlY2sgaWYgcHJldmlvdXMgc3RyaW5nIHJlZiBtYXRjaGVzIG5ldyBzdHJpbmcgcmVmXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZi5fc3RyaW5nUmVmID09PSBzdHJpbmdSZWYpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQucmVmO1xuICAgICAgfVxuICAgICAgdmFyIHJlZiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVmcyA9IGluc3QucmVmcyA9PT0gZW1wdHlPYmplY3QgPyBpbnN0LnJlZnMgPSB7fSA6IGluc3QucmVmcztcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgZGVsZXRlIHJlZnNbc3RyaW5nUmVmXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZzW3N0cmluZ1JlZl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlZi5fc3RyaW5nUmVmID0gc3RyaW5nUmVmO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgISh0eXBlb2YgbWl4ZWRSZWYgPT09ICdzdHJpbmcnKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHJlZiB0byBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nLicpIDogdm9pZCAwO1xuICAgICAgIWVsZW1lbnQuX293bmVyID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCByZWYgd2FzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoJXMpIGJ1dCBubyBvd25lciB3YXMgc2V0LiBZb3UgbWF5IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZC4gKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicsIG1peGVkUmVmKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1peGVkUmVmO1xufVxuXG5mdW5jdGlvbiB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKSB7XG4gIGlmIChyZXR1cm5GaWJlci50eXBlICE9PSAndGV4dGFyZWEnKSB7XG4gICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAge1xuICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyAoZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdDaGlsZCkgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbignLCAnKSArICd9JyA6IG5ld0NoaWxkLCBhZGRlbmR1bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKCkge1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nICsgKGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpIHx8ICcnKTtcblxuICBpZiAob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgd2FybmluZyhmYWxzZSwgJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xufVxuXG4vLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZXhpc3RzIGJlY2F1c2UgSSBleHBlY3QgdG8gY2xvbmUgdGhlIGNvZGUgaW4gZWFjaCBwYXRoXG4vLyB0byBiZSBhYmxlIHRvIG9wdGltaXplIGVhY2ggcGF0aCBpbmRpdmlkdWFsbHkgYnkgYnJhbmNoaW5nIGVhcmx5LiBUaGlzIG5lZWRzXG4vLyBhIGNvbXBpbGVyIG9yIHdlIGNhbiBkbyBpdCBtYW51YWxseS4gSGVscGVycyB0aGF0IGRvbid0IG5lZWQgdGhpcyBicmFuY2hpbmdcbi8vIGxpdmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuZnVuY3Rpb24gQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIERlbGV0aW9ucyBhcmUgYWRkZWQgaW4gcmV2ZXJzZWQgb3JkZXIgc28gd2UgYWRkIGl0IHRvIHRoZSBmcm9udC5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmV0dXJuIGZpYmVyJ3MgZWZmZWN0IGxpc3QgaXMgZW1wdHkgZXhjZXB0IGZvclxuICAgIC8vIGRlbGV0aW9ucywgc28gd2UgY2FuIGp1c3QgYXBwZW5kIHRoZSBkZWxldGlvbiB0byB0aGUgbGlzdC4gVGhlIHJlbWFpbmluZ1xuICAgIC8vIGVmZmVjdHMgYXJlbid0IGFkZGVkIHVudGlsIHRoZSBjb21wbGV0ZSBwaGFzZS4gT25jZSB3ZSBpbXBsZW1lbnRcbiAgICAvLyByZXN1bWluZywgdGhpcyBtYXkgbm90IGJlIHRydWUuXG4gICAgdmFyIGxhc3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0O1xuICAgIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgICBsYXN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfVxuICAgIGNoaWxkVG9EZWxldGUubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEZvciB0aGUgc2hvdWxkQ2xvbmUgY2FzZSwgdGhpcyBjb3VsZCBiZSBtaWNyby1vcHRpbWl6ZWQgYSBiaXQgYnlcbiAgICAvLyBhc3N1bWluZyB0aGF0IGFmdGVyIHRoZSBmaXJzdCBjaGlsZCB3ZSd2ZSBhbHJlYWR5IGFkZGVkIGV2ZXJ5dGhpbmcuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGRUb0RlbGV0ZSAhPT0gbnVsbCkge1xuICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpO1xuICAgICAgY2hpbGRUb0RlbGV0ZSA9IGNoaWxkVG9EZWxldGUuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB0byBhIHRlbXBvcmFyeSBtYXAgc28gdGhhdCB3ZSBjYW4gZmluZCB0aGVtIGJ5XG4gICAgLy8ga2V5cyBxdWlja2x5LiBJbXBsaWNpdCAobnVsbCkga2V5cyBnZXQgYWRkZWQgdG8gdGhpcyBzZXQgd2l0aCB0aGVpciBpbmRleFxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuICAgICAgZXhpc3RpbmdDaGlsZCA9IGV4aXN0aW5nQ2hpbGQuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gIH1cblxuICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFdlIGN1cnJlbnRseSBzZXQgc2libGluZyB0byBudWxsIGFuZCBpbmRleCB0byAwIGhlcmUgYmVjYXVzZSBpdCBpcyBlYXN5XG4gICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbiAgICB2YXIgY2xvbmUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY2xvbmUuaW5kZXggPSAwO1xuICAgIGNsb25lLnNpYmxpbmcgPSBudWxsO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SW5kZXgpIHtcbiAgICBuZXdGaWJlci5pbmRleCA9IG5ld0luZGV4O1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICAgIHZhciBjdXJyZW50ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgb2xkSW5kZXggPSBjdXJyZW50LmluZGV4O1xuICAgICAgaWYgKG9sZEluZGV4IDwgbGFzdFBsYWNlZEluZGV4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBtb3ZlLlxuICAgICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlU2luZ2xlQ2hpbGQobmV3RmliZXIpIHtcbiAgICAvLyBUaGlzIGlzIHNpbXBsZXIgZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS4gV2Ugb25seSBuZWVkIHRvIGRvIGFcbiAgICAvLyBwbGFjZW1lbnQgZm9yIGluc2VydGluZyBuZXcgY2hpbGRyZW4uXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXdGaWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmVmID0gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICB7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50LCBjYWxsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGFsc28gY29tcGFyZSBoYW5kbGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldXNlP1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBDYWxsQ29tcG9uZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50LCByZXR1cm5Ob2RlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnR5cGUgPSByZXR1cm5Ob2RlLnZhbHVlO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBudWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0UG9ydGFsIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBmcmFnbWVudCwgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBGcmFnbWVudCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZyYWdtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KCcnICsgbmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHZhciBfY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgICBfY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9jcmVhdGVkMiA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgICBfY3JlYXRlZDIucmVmID0gY29lcmNlUmVmKG51bGwsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgX2NyZWF0ZWQyWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tQ2FsbChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDNbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQzO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4obmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgX2NyZWF0ZWQ0LnR5cGUgPSBuZXdDaGlsZC52YWx1ZTtcbiAgICAgICAgICAgIF9jcmVhdGVkNFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkNSA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDVbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ1O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9jcmVhdGVkNiA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgICAgX2NyZWF0ZWQ2WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZWQ2O1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cblxuICAgIHZhciBrZXkgPSBvbGRGaWJlciAhPT0gbnVsbCA/IG9sZEZpYmVyLmtleSA6IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAgICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGFcbiAgICAgICAgICAgIC8vIHlpZWxkLlxuICAgICAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUmV0dXJuKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMiwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBSZXR1cm5zIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAgICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgcmV0dXJucywgdGhleSBtYXRjaC5cbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMyA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVSZXR1cm4ocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIzLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyNCA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXI0LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9tYXRjaGVkRmliZXI1ID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXI1LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhcm5zIGlmIHRoZXJlIGlzIGEgZHVwbGljYXRlIG9yIG1pc3Npbmcga2V5XG4gICAqL1xuICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fCBjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ga25vd25LZXlzO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkoY2hpbGQpO1xuICAgICAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtub3duS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAga25vd25LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgha25vd25LZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0VuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gJyArICdLZXlzIHNob3VsZCBiZSB1bmlxdWUgc28gdGhhdCBjb21wb25lbnRzIG1haW50YWluIHRoZWlyIGlkZW50aXR5ICcgKyAnYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgJyArICdkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIOKAlCB0aGUgYmVoYXZpb3IgaXMgdW5zdXBwb3J0ZWQgYW5kICcgKyAnY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uJXMnLCBrZXksIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtub3duS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGFsZ29yaXRobSBjYW4ndCBvcHRpbWl6ZSBieSBzZWFyY2hpbmcgZnJvbSBib3RocyBlbmRzIHNpbmNlIHdlXG4gICAgLy8gZG9uJ3QgaGF2ZSBiYWNrcG9pbnRlcnMgb24gZmliZXJzLiBJJ20gdHJ5aW5nIHRvIHNlZSBob3cgZmFyIHdlIGNhbiBnZXRcbiAgICAvLyB3aXRoIHRoYXQgbW9kZWwuIElmIGl0IGVuZHMgdXAgbm90IGJlaW5nIHdvcnRoIHRoZSB0cmFkZW9mZnMsIHdlIGNhblxuICAgIC8vIGFkZCBpdCBsYXRlci5cblxuICAgIC8vIEV2ZW4gd2l0aCBhIHR3byBlbmRlZCBvcHRpbWl6YXRpb24sIHdlJ2Qgd2FudCB0byBvcHRpbWl6ZSBmb3IgdGhlIGNhc2VcbiAgICAvLyB3aGVyZSB0aGVyZSBhcmUgZmV3IGNoYW5nZXMgYW5kIGJydXRlIGZvcmNlIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2ZcbiAgICAvLyBnb2luZyBmb3IgdGhlIE1hcC4gSXQnZCBsaWtlIHRvIGV4cGxvcmUgaGl0dGluZyB0aGF0IHBhdGggZmlyc3QgaW5cbiAgICAvLyBmb3J3YXJkLW9ubHkgbW9kZSBhbmQgb25seSBnbyBmb3IgdGhlIE1hcCBvbmNlIHdlIG5vdGljZSB0aGF0IHdlIG5lZWRcbiAgICAvLyBsb3RzIG9mIGxvb2sgYWhlYWQuIFRoaXMgZG9lc24ndCBoYW5kbGUgcmV2ZXJzYWwgYXMgd2VsbCBhcyB0d28gZW5kZWRcbiAgICAvLyBzZWFyY2ggYnV0IHRoYXQncyB1bnVzdWFsLiBCZXNpZGVzLCBmb3IgdGhlIHR3byBlbmRlZCBvcHRpbWl6YXRpb24gdG9cbiAgICAvLyB3b3JrIG9uIEl0ZXJhYmxlcywgd2UnZCBuZWVkIHRvIGNvcHkgdGhlIHdob2xlIHNldC5cblxuICAgIC8vIEluIHRoaXMgZmlyc3QgaXRlcmF0aW9uLCB3ZSdsbCBqdXN0IGxpdmUgd2l0aCBoaXR0aW5nIHRoZSBiYWQgY2FzZVxuICAgIC8vIChhZGRpbmcgZXZlcnl0aGluZyB0byBhIE1hcCkgaW4gZm9yIGV2ZXJ5IGluc2VydC9tb3ZlLlxuXG4gICAgLy8gSWYgeW91IGNoYW5nZSB0aGlzIGNvZGUsIGFsc28gdXBkYXRlIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoKSB3aGljaFxuICAgIC8vIHVzZXMgdGhlIHNhbWUgYWxnb3JpdGhtLlxuXG4gICAge1xuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblxuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoIV9uZXdGaWJlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG4gICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIHZhciBfbmV3RmliZXIyID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoX25ld0ZpYmVyMikge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXIyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW5bJ2RlbGV0ZSddKF9uZXdGaWJlcjIua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyMi5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW5JdGVyYWJsZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoKSxcbiAgICAvLyBidXQgdXNpbmcgdGhlIGl0ZXJhdG9yIGluc3RlYWQuXG5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgISh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBvYmplY3QgaXMgbm90IGFuIGl0ZXJhYmxlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAge1xuICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkcmVuSXRlcmFibGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcG9zc2libGVNYXAgPSBuZXdDaGlsZHJlbkl0ZXJhYmxlO1xuICAgICAgICBpZiAocG9zc2libGVNYXAuZW50cmllcyA9PT0gaXRlcmF0b3JGbikge1xuICAgICAgICAgIHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICAvLyBXZSdsbCBnZXQgYSBkaWZmZXJlbnQgaXRlcmF0b3IgbGF0ZXIgZm9yIHRoZSBtYWluIHBhc3MuXG4gICAgICB2YXIgX25ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICAgaWYgKF9uZXdDaGlsZHJlbikge1xuICAgICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICAgICAgdmFyIF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKTtcbiAgICAgICAgZm9yICg7ICFfc3RlcC5kb25lOyBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICEobmV3Q2hpbGRyZW4gIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuJykgOiB2b2lkIDA7XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuXG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKTtcbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmICghb2xkRmliZXIpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlcjMgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoX25ld0ZpYmVyMyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMywgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIzO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgdmFyIF9uZXdGaWJlcjQgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChfbmV3RmliZXI0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjQuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlblsnZGVsZXRlJ10oX25ld0ZpYmVyNC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXI0LmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyNCwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIGNoZWNrIGZvciBrZXlzIG9uIHRleHQgbm9kZXMgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhXG4gICAgLy8gd2F5IHRvIGRlZmluZSB0aGVtLlxuICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZCAhPT0gbnVsbCAmJiBjdXJyZW50Rmlyc3RDaGlsZC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBzbyBsZXQncyBqdXN0IHVwZGF0ZSBpdCBhbmQgZGVsZXRlXG4gICAgICAvLyB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICAgIC8vIFRoZSBleGlzdGluZyBmaXJzdCBjaGlsZCBpcyBub3QgYSB0ZXh0IG5vZGUgc28gd2UgbmVlZCB0byBjcmVhdGUgb25lXG4gICAgLy8gYW5kIGRlbGV0ZSB0aGUgZXhpc3Rpbmcgb25lcy5cbiAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBGcmFnbWVudCA/IGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSA6IGNoaWxkLnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFID8gZWxlbWVudC5wcm9wcy5jaGlsZHJlbiA6IGVsZW1lbnQucHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYoY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSwgZWxlbWVudC5rZXkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NyZWF0ZWQ3ID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIF9jcmVhdGVkNy5yZWYgPSBjb2VyY2VSZWYoY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQpO1xuICAgICAgX2NyZWF0ZWQ3WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIF9jcmVhdGVkNztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIga2V5ID0gY2FsbC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gQ2FsbENvbXBvbmVudCkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcmV0dXJuTm9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24geWllbGRzIHNpbmNlIHRoZXkncmUgc3RhdGVsZXNzLlxuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gUmV0dXJuQ29tcG9uZW50KSB7XG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgZXhpc3RpbmcudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUmV0dXJuKHJldHVybk5vZGUsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWQudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHBvcnRhbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIga2V5ID0gcG9ydGFsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBIb3N0UG9ydGFsICYmIGNoaWxkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvID09PSBwb3J0YWwuY29udGFpbmVySW5mbyAmJiBjaGlsZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gPT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgLy8gVGhpcyBBUEkgd2lsbCB0YWcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHRoZSByZWNvbmNpbGlhdGlvblxuICAvLyBpdHNlbGYuIFRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2lkZS1lZmZlY3QgbGlzdCBhcyB3ZSBwYXNzIHRocm91Z2ggdGhlXG4gIC8vIGNoaWxkcmVuIGFuZCB0aGUgcGFyZW50LlxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlY3Vyc2l2ZS5cbiAgICAvLyBJZiB0aGUgdG9wIGxldmVsIGl0ZW0gaXMgYW4gYXJyYXksIHdlIHRyZWF0IGl0IGFzIGEgc2V0IG9mIGNoaWxkcmVuLFxuICAgIC8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgIC8vIGZyYWdtZW50IG5vZGVzLiBSZWN1cnNpb24gaGFwcGVucyBhdCB0aGUgbm9ybWFsIGZsb3cuXG5cbiAgICAvLyBIYW5kbGUgdG9wIGxldmVsIHVua2V5ZWQgZnJhZ21lbnRzIGFzIGlmIHRoZXkgd2VyZSBhcnJheXMuXG4gICAgLy8gVGhpcyBsZWFkcyB0byBhbiBhbWJpZ3VpdHkgYmV0d2VlbiA8PntbLi4uXX08Lz4gYW5kIDw+Li4uPC8+LlxuICAgIC8vIFdlIHRyZWF0IHRoZSBhbWJpZ3VvdXMgY2FzZXMgYWJvdmUgdGhlIHNhbWUuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwgJiYgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSAmJiBuZXdDaGlsZC5rZXkgPT09IG51bGwpIHtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGw7XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUNhbGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVSZXR1cm4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBJZiB0aGUgbmV3IGNoaWxkIGlzIHVuZGVmaW5lZCwgYW5kIHRoZSByZXR1cm4gZmliZXIgaXMgYSBjb21wb3NpdGVcbiAgICAgIC8vIGNvbXBvbmVudCwgdGhyb3cgYW4gZXJyb3IuIElmIEZpYmVyIHJldHVybiB0eXBlcyBhcmUgZGlzYWJsZWQsXG4gICAgICAvLyB3ZSBhbHJlYWR5IHRocmV3IGFib3ZlLlxuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBmYWxsIHRocm91Z2ggdG8gdGhlIG5leHQgY2FzZSwgd2hpY2ggaGFuZGxlcyBib3RoXG4gICAgICAgIC8vIGZ1bmN0aW9ucyBhbmQgY2xhc3Nlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVkIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJyVzKC4uLik6IE5vdGhpbmcgd2FzIHJldHVybmVkIGZyb20gcmVuZGVyLiBUaGlzIHVzdWFsbHkgbWVhbnMgYSByZXR1cm4gc3RhdGVtZW50IGlzIG1pc3NpbmcuIE9yLCB0byByZW5kZXIgbm90aGluZywgcmV0dXJuIG51bGwuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIGNhc2VzIGFyZSBhbGwgdHJlYXRlZCBhcyBlbXB0eS5cbiAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVycztcbn1cblxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKHRydWUpO1xudmFyIG1vdW50Q2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIoZmFsc2UpO1xuXG5mdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICEoY3VycmVudCA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gY3VycmVudC5jaGlsZCkgPyBpbnZhcmlhbnQoZmFsc2UsICdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMsIGN1cnJlbnRDaGlsZC5leHBpcmF0aW9uVGltZSk7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV3Q2hpbGQ7XG5cbiAgbmV3Q2hpbGRbJ3JldHVybiddID0gd29ya0luUHJvZ3Jlc3M7XG4gIHdoaWxlIChjdXJyZW50Q2hpbGQuc2libGluZyAhPT0gbnVsbCkge1xuICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZC5zaWJsaW5nO1xuICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQuc2libGluZyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcywgY3VycmVudENoaWxkLmV4cGlyYXRpb25UaW1lKTtcbiAgICBuZXdDaGlsZFsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuICBuZXdDaGlsZC5zaWJsaW5nID0gbnVsbDtcbn1cblxue1xuICB2YXIgd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzID0ge307XG59XG5cbnZhciBSZWFjdEZpYmVyQmVnaW5Xb3JrID0gZnVuY3Rpb24gKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQsIHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcikge1xuICB2YXIgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSBjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICB1c2VTeW5jU2NoZWR1bGluZyA9IGNvbmZpZy51c2VTeW5jU2NoZWR1bGluZyxcbiAgICAgIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUgPSBjb25maWcuc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTtcbiAgdmFyIHB1c2hIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnB1c2hIb3N0Q29udGV4dCxcbiAgICAgIHB1c2hIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucHVzaEhvc3RDb250YWluZXI7XG4gIHZhciBlbnRlckh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5lbnRlckh5ZHJhdGlvblN0YXRlLFxuICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSA9IGh5ZHJhdGlvbkNvbnRleHQucmVzZXRIeWRyYXRpb25TdGF0ZSxcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC50cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJDbGFzc0NvbXBvID0gUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50KHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWVtb2l6ZVByb3BzLCBtZW1vaXplU3RhdGUpLFxuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLmFkb3B0Q2xhc3NJbnN0YW5jZSxcbiAgICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8uY29uc3RydWN0Q2xhc3NJbnN0YW5jZSxcbiAgICAgIG1vdW50Q2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby5tb3VudENsYXNzSW5zdGFuY2UsXG4gICAgICB1cGRhdGVDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLnVwZGF0ZUNsYXNzSW5zdGFuY2U7XG5cbiAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgYW5kIHVzZSByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUgZGlyZWN0bHkuXG5cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgZnJlc2ggbmV3IGNvbXBvbmVudCB0aGF0IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldCwgd2VcbiAgICAgIC8vIHdvbid0IHVwZGF0ZSBpdHMgY2hpbGQgc2V0IGJ5IGFwcGx5aW5nIG1pbmltYWwgc2lkZS1lZmZlY3RzLiBJbnN0ZWFkLFxuICAgICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgICAvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyByZWNvbmNpbGlhdGlvbiBwYXNzIGJ5IG5vdCB0cmFja2luZyBzaWRlLWVmZmVjdHMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgY3VycmVudCBjaGlsZCBpcyB0aGUgc2FtZSBhcyB0aGUgd29yayBpbiBwcm9ncmVzcywgaXQgbWVhbnMgdGhhdFxuICAgICAgLy8gd2UgaGF2ZW4ndCB5ZXQgc3RhcnRlZCBhbnkgd29yayBvbiB0aGVzZSBjaGlsZHJlbi4gVGhlcmVmb3JlLCB3ZSB1c2VcbiAgICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG5cbiAgICAgIC8vIElmIHdlIGhhZCBhbnkgcHJvZ3Jlc3NlZCB3b3JrIGFscmVhZHksIHRoYXQgaXMgaW52YWxpZCBhdCB0aGlzIHBvaW50IHNvXG4gICAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICAgIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwgJiYgKCFjdXJyZW50IHx8IGN1cnJlbnQucmVmICE9PSByZWYpKSB7XG4gICAgICAvLyBTY2hlZHVsZSBhIFJlZiBlZmZlY3RcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBSZWY7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIHZhciBtZW1vaXplZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgICBuZXh0UHJvcHMgPSBtZW1vaXplZFByb3BzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV4dFByb3BzID09PSBudWxsIHx8IG1lbW9pemVkUHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBjb25zaWRlciBicmluZ2luZyBmbi5zaG91bGRDb21wb25lbnRVcGRhdGUoKSBiYWNrLlxuICAgICAgLy8gSXQgdXNlZCB0byBiZSBoZXJlLlxuICAgIH1cblxuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIHZhciBuZXh0Q2hpbGRyZW47XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBmbihuZXh0UHJvcHMsIGNvbnRleHQpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgIHZhciBoYXNDb250ZXh0ID0gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gdm9pZCAwO1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICBpZiAoIXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSkge1xuICAgICAgICAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cbiAgICAgICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKTtcbiAgICAgICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIHNob3VsZFVwZGF0ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gICAgICAgIC8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuICAgICAgICAvLyBzaG91bGRVcGRhdGUgPSByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0KSB7XG4gICAgLy8gUmVmcyBzaG91bGQgdXBkYXRlIGV2ZW4gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2VcbiAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIGlmICghc2hvdWxkVXBkYXRlKSB7XG4gICAgICAvLyBDb250ZXh0IHByb3ZpZGVycyBzaG91bGQgZGVmZXIgdG8gc0NVIGZvciByZW5kZXJpbmdcbiAgICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIC8vIFJlcmVuZGVyXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB2b2lkIDA7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ3JlbmRlcicpO1xuICAgICAgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICAgIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgfVxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICAvLyBNZW1vaXplIHByb3BzIGFuZCBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gICAgLy8gVE9ETzogUmVzdHJ1Y3R1cmUgc28gd2UgbmV2ZXIgcmVhZCB2YWx1ZXMgZnJvbSB0aGUgaW5zdGFuY2UuXG4gICAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5zdGF0ZSk7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5wcm9wcyk7XG5cbiAgICAvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cbiAgICBpZiAoaGFzQ29udGV4dCkge1xuICAgICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGlmIChyb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LnBlbmRpbmdDb250ZXh0LCByb290LnBlbmRpbmdDb250ZXh0ICE9PSByb290LmNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAocm9vdC5jb250ZXh0KSB7XG4gICAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxuICAgICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250ZXh0LCBmYWxzZSk7XG4gICAgfVxuICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCByb290LmNvbnRhaW5lckluZm8pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHZhciBzdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUXVldWUsIG51bGwsIG51bGwsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChwcmV2U3RhdGUgPT09IHN0YXRlKSB7XG4gICAgICAgIC8vIElmIHRoZSBzdGF0ZSBpcyB0aGUgc2FtZSBhcyBiZWZvcmUsIHRoYXQncyBhIGJhaWxvdXQgYmVjYXVzZSB3ZSBoYWRcbiAgICAgICAgLy8gbm8gd29yayB0aGF0IGV4cGlyZXMgYXQgdGhpcyB0aW1lLlxuICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudDtcbiAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgaWYgKChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpICYmIHJvb3QuaHlkcmF0ZSAmJiBlbnRlckh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBjdXJyZW50IGNoaWxkcmVuIHRoaXMgbWlnaHQgYmUgdGhlIGZpcnN0IHBhc3MuXG4gICAgICAgIC8vIFdlIGFsd2F5cyB0cnkgdG8gaHlkcmF0ZS4gSWYgdGhpcyBpc24ndCBhIGh5ZHJhdGlvbiBwYXNzIHRoZXJlIHdvbid0XG4gICAgICAgIC8vIGJlIGFueSBjaGlsZHJlbiB0byBoeWRyYXRlIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nIGFzXG4gICAgICAgIC8vIG5vdCBoeWRyYXRpbmcuXG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2suIFdlIHRyYWNrIHRoZSBob3N0IHJvb3QgYXMgYSBwbGFjZW1lbnQgdG9cbiAgICAgICAgLy8ga25vdyB0aGF0IHdlJ3JlIGN1cnJlbnRseSBpbiBhIG1vdW50aW5nIHN0YXRlLiBUaGF0IHdheSBpc01vdW50ZWRcbiAgICAgICAgLy8gd29ya3MgYXMgZXhwZWN0ZWQuIFdlIG11c3QgcmVzZXQgdGhpcyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBjaGlsZHJlbiBtb3VudCBpbnRvIHRoaXMgcm9vdCB3aXRob3V0IHRyYWNraW5nXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3Qgc3RvcmUgUGxhY2VtZW50IGVmZmVjdHMgb25cbiAgICAgICAgLy8gbm9kZXMgdGhhdCB3aWxsIGJlIGh5ZHJhdGVkLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIGVsZW1lbnQsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSByZXNldCBoeWRyYXRpb24gc3RhdGUgaW4gY2FzZSB3ZSBhYm9ydGVkIGFuZCByZXN1bWVkIGFub3RoZXJcbiAgICAgICAgLy8gcm9vdC5cbiAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIHN0YXRlKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIHVwZGF0ZSBxdWV1ZSwgdGhhdCdzIGEgYmFpbG91dCBiZWNhdXNlIHRoZSByb290IGhhcyBubyBwcm9wcy5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgbWVtb2l6ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAobmV4dFByb3BzID09PSBudWxsKSB7XG4gICAgICBuZXh0UHJvcHMgPSBtZW1vaXplZFByb3BzO1xuICAgICAgIShuZXh0UHJvcHMgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBudWxsO1xuXG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCB8fCBtZW1vaXplZFByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBpc0RpcmVjdFRleHRDaGlsZCA9IHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIG5leHRQcm9wcyk7XG5cbiAgICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgICAvLyBjYXNlLiBXZSB3b24ndCBoYW5kbGUgaXQgYXMgYSByZWlmaWVkIGNoaWxkLiBXZSB3aWxsIGluc3RlYWQgaGFuZGxlXG4gICAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXZlIGFjY2VzcyB0byB0aGlzIHByb3AuIFRoYXRcbiAgICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG4gICAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICAgIH0gZWxzZSBpZiAocHJldlByb3BzICYmIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByZXZQcm9wcykpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4gICAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENvbnRlbnRSZXNldDtcbiAgICB9XG5cbiAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIENoZWNrIHRoZSBob3N0IGNvbmZpZyB0byBzZWUgaWYgdGhlIGNoaWxkcmVuIGFyZSBvZmZzY3JlZW4vaGlkZGVuLlxuICAgIGlmIChyZW5kZXJFeHBpcmF0aW9uVGltZSAhPT0gTmV2ZXIgJiYgIXVzZVN5bmNTY2hlZHVsaW5nICYmIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUodHlwZSwgbmV4dFByb3BzKSkge1xuICAgICAgLy8gRG93bi1wcmlvcml0aXplIHRoZSBjaGlsZHJlbi5cbiAgICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gTmV2ZXI7XG4gICAgICAvLyBCYWlsb3V0IGFuZCBjb21lIGJhY2sgdG8gdGhpcyBmaWJlciBsYXRlci5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB9XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIC8vIE5vdGhpbmcgdG8gZG8gaGVyZS4gVGhpcyBpcyB0ZXJtaW5hbC4gV2UnbGwgZG8gdGhlIGNvbXBsZXRpb24gc3RlcFxuICAgIC8vIGltbWVkaWF0ZWx5IGFmdGVyLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICEoY3VycmVudCA9PT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBpbmRldGVybWluYXRlIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgaGF2ZSBtb3VudGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIHZhciB2YWx1ZTtcblxuICAgIHtcbiAgICAgIGlmIChmbi5wcm90b3R5cGUgJiYgdHlwZW9mIGZuLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB2YWx1ZSA9IGZuKHByb3BzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBjbGFzcyBpbnN0YW5jZVxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7XG5cbiAgICAgIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gICAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgICB2YXIgaGFzQ29udGV4dCA9IHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHJ1ZSwgaGFzQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IEZ1bmN0aW9uYWxDb21wb25lbnQ7XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuaW5nKCFDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsICclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgICAgdmFyIG93bmVyTmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCk7XG4gICAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB3YXJuaW5nS2V5ID0gb3duZXJOYW1lIHx8IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0lEIHx8ICcnO1xuICAgICAgICAgIHZhciBkZWJ1Z1NvdXJjZSA9IHdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZTtcbiAgICAgICAgICBpZiAoZGVidWdTb3VyY2UpIHtcbiAgICAgICAgICAgIHdhcm5pbmdLZXkgPSBkZWJ1Z1NvdXJjZS5maWxlTmFtZSArICc6JyArIGRlYnVnU291cmNlLmxpbmVOdW1iZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzW3dhcm5pbmdLZXldKSB7XG4gICAgICAgICAgICB3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuJXMlcycsIGluZm8sIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIHByb3BzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDYWxsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBuZXh0Q2FsbCA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRDYWxsID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDYWxsID0gY3VycmVudCAmJiBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICEobmV4dENhbGwgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDYWxsID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDYWxsKSB7XG4gICAgICBuZXh0Q2FsbCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAvLyBUT0RPOiBXaGVuIGJhaWxpbmcgb3V0LCB3ZSBtaWdodCBuZWVkIHRvIHJldHVybiB0aGUgc3RhdGVOb2RlIGluc3RlYWRcbiAgICAgIC8vIG9mIHRoZSBjaGlsZC4gVG8gY2hlY2sgaXQgZm9yIHdvcmsuXG4gICAgICAvLyByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRDYWxsLmNoaWxkcmVuO1xuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBpcyBhIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIGJ1dCB1c2luZ1xuICAgIC8vIHN0YXRlTm9kZSB0byBzdG9yZSB0aGUgY2hpbGQuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENhbGwpO1xuICAgIC8vIFRoaXMgZG9lc24ndCB0YWtlIGFyYml0cmFyeSB0aW1lIHNvIHdlIGNvdWxkIHN5bmNocm9ub3VzbHkganVzdCBiZWdpblxuICAgIC8vIGVhZ2VybHkgZG8gdGhlIHdvcmsgb2Ygd29ya0luUHJvZ3Jlc3MuY2hpbGQgYXMgYW4gb3B0aW1pemF0aW9uLlxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dENoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IGN1cnJlbnQgJiYgY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAhKG5leHRDaGlsZHJlbiAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIHNob3VsZCBhbHdheXMgaGF2ZSBwZW5kaW5nIG9yIGN1cnJlbnQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFBvcnRhbHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB3ZSBkb24ndCBhcHBlbmQgdGhlIGNoaWxkcmVuIGR1cmluZyBtb3VudFxuICAgICAgLy8gYnV0IGF0IGNvbW1pdC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gdHJhY2sgaW5zZXJ0aW9ucyB3aGljaCB0aGUgbm9ybWFsXG4gICAgICAvLyBmbG93IGRvZXNuJ3QgZG8gZHVyaW5nIG1vdW50LiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGF0IHRoZSByb290IGJlY2F1c2VcbiAgICAgIC8vIHRoZSByb290IGFsd2F5cyBzdGFydHMgd2l0aCBhIFwiY3VycmVudFwiIHdpdGggYSBudWxsIGNoaWxkLlxuICAgICAgLy8gVE9ETzogQ29uc2lkZXIgdW5pZnlpbmcgdGhpcyB3aXRoIGhvdyB0aGUgcm9vdCB3b3Jrcy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgLypcbiAgZnVuY3Rpb24gcmV1c2VDaGlsZHJlbkVmZmVjdHMocmV0dXJuRmliZXIgOiBGaWJlciwgZmlyc3RDaGlsZCA6IEZpYmVyKSB7XG4gICAgbGV0IGNoaWxkID0gZmlyc3RDaGlsZDtcbiAgICBkbyB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgZmlyc3QgYW5kIGxhc3QgZWZmZWN0IG9mIHRoZSBwYXJlbnQgY29ycmVzcG9uZHNcbiAgICAgIC8vIHRvIHRoZSBjaGlsZHJlbidzIGZpcnN0IGFuZCBsYXN0IGVmZmVjdC5cbiAgICAgIGlmICghcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSBjaGlsZC5maXJzdEVmZmVjdDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5sYXN0RWZmZWN0KSB7XG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0KSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGQuZmlyc3RFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkLmxhc3RFZmZlY3Q7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoY2hpbGQgPSBjaGlsZC5zaWJsaW5nKTtcbiAgfVxuICAqL1xuXG4gIGZ1bmN0aW9uIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICBjYW5jZWxXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gVE9ETzogV2Ugc2hvdWxkIGlkZWFsbHkgYmUgYWJsZSB0byBiYWlsIG91dCBlYXJseSBpZiB0aGUgY2hpbGRyZW4gaGF2ZSBub1xuICAgIC8vIG1vcmUgd29yayB0byBkby4gSG93ZXZlciwgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhIHNlcGFyYXRpb24gb2YgdGhpc1xuICAgIC8vIEZpYmVyJ3MgcHJpb3JpdHkgYW5kIGl0cyBjaGlsZHJlbiB5ZXQgLSB3ZSBkb24ndCBrbm93IHdpdGhvdXQgZG9pbmcgbG90c1xuICAgIC8vIG9mIHRoZSBzYW1lIHdvcmsgd2UgZG8gYW55d2F5LiBPbmNlIHdlIGhhdmUgdGhhdCBzZXBhcmF0aW9uIHdlIGNhbiBqdXN0XG4gICAgLy8gYmFpbCBvdXQgaGVyZSBpZiB0aGUgY2hpbGRyZW4gaGFzIG5vIG1vcmUgd29yayBhdCB0aGlzIHByaW9yaXR5IGxldmVsLlxuICAgIC8vIGlmICh3b3JrSW5Qcm9ncmVzcy5wcmlvcml0eU9mQ2hpbGRyZW4gPD0gcHJpb3JpdHlMZXZlbCkge1xuICAgIC8vICAgLy8gSWYgdGhlcmUgYXJlIHNpZGUtZWZmZWN0cyBpbiB0aGVzZSBjaGlsZHJlbiB0aGF0IGhhdmUgbm90IHlldCBiZWVuXG4gICAgLy8gICAvLyBjb21taXR0ZWQgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGV5IGdldCBwcm9wZXJseSB0cmFuc2ZlcnJlZCB1cC5cbiAgICAvLyAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuY2hpbGQgIT09IHdvcmtJblByb2dyZXNzLmNoaWxkKSB7XG4gICAgLy8gICAgIHJldXNlQ2hpbGRyZW5FZmZlY3RzKHdvcmtJblByb2dyZXNzLCBjaGlsZCk7XG4gICAgLy8gICB9XG4gICAgLy8gICByZXR1cm4gbnVsbDtcbiAgICAvLyB9XG5cbiAgICBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGNhbmNlbFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAvLyBUT0RPOiBIYW5kbGUgSG9zdENvbXBvbmVudCB0YWdzIGhlcmUgYXMgd2VsbCBhbmQgY2FsbCBwdXNoSG9zdENvbnRleHQoKT9cbiAgICAvLyBTZWUgUFIgODU5MCBkaXNjdXNzaW9uIGZvciBjb250ZXh0XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFRPRE86IFdoYXQgaWYgdGhpcyBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3M/XG4gICAgLy8gSG93IGNhbiB0aGF0IGhhcHBlbj8gSG93IGlzIHRoaXMgbm90IGJlaW5nIGNsb25lZD9cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFRPRE86IERlbGV0ZSBtZW1vaXplUHJvcHMvU3RhdGUgYW5kIG1vdmUgdG8gcmVjb25jaWxlL2JhaWxvdXQgaW5zdGVhZFxuICBmdW5jdGlvbiBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcykge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIG5leHRTdGF0ZSkge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgLy8gRG9uJ3QgcmVzZXQgdGhlIHVwZGF0ZVF1ZXVlLCBpbiBjYXNlIHRoZXJlIGFyZSBwZW5kaW5nIHVwZGF0ZXMuIFJlc2V0dGluZ1xuICAgIC8vIGlzIGhhbmRsZWQgYnkgcHJvY2Vzc1VwZGF0ZVF1ZXVlLlxuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGNhc2UgQ2FsbEhhbmRsZXJQaGFzZTpcbiAgICAgICAgLy8gVGhpcyBpcyBhIHJlc3RhcnQuIFJlc2V0IHRoZSB0YWcgdG8gdGhlIGluaXRpYWwgcGhhc2UuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENhbGxDb21wb25lbnQ7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGZhbGwgdGhyb3VnaCBzaW5jZSB0aGlzIGlzIG5vdyB0aGUgc2FtZS5cbiAgICAgIGNhc2UgQ2FsbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgUmV0dXJuQ29tcG9uZW50OlxuICAgICAgICAvLyBBIHJldHVybiBjb21wb25lbnQgaXMganVzdCBhIHBsYWNlaG9sZGVyLCB3ZSBjYW4ganVzdCBydW4gdGhyb3VnaCB0aGVcbiAgICAgICAgLy8gbmV4dCBvbmUgaW1tZWRpYXRlbHkuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luRmFpbGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGhlcmUgdG8gYXZvaWQgYSBwdXNoL3BvcCBjb250ZXh0IG1pc21hdGNoLlxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHR5cGUgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYW4gZXJyb3IgZWZmZWN0IHNvIHdlIGNhbiBoYW5kbGUgdGhlIGVycm9yIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IEVycjtcblxuICAgIC8vIFRoaXMgaXMgYSB3ZWlyZCBjYXNlIHdoZXJlIHdlIGRvIFwicmVzdW1lXCIgd29yayDigJQgd29yayB0aGF0IGZhaWxlZCBvblxuICAgIC8vIG91ciBmaXJzdCBhdHRlbXB0LiBCZWNhdXNlIHdlIG5vIGxvbmdlciBoYXZlIGEgbm90aW9uIG9mIFwicHJvZ3Jlc3NlZFxuICAgIC8vIGRlbGV0aW9ucyxcIiByZXNldCB0aGUgY2hpbGQgdG8gdGhlIGN1cnJlbnQgY2hpbGQgdG8gbWFrZSBzdXJlIHdlIGRlbGV0ZVxuICAgIC8vIGl0IGFnYWluLiBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcywgcGVyaGFwcyBkdXJpbmcgYSBtb3JlXG4gICAgLy8gZ2VuZXJhbCBvdmVyaGF1bCBvZiBlcnJvciBoYW5kbGluZy5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgIT09IGN1cnJlbnQuY2hpbGQpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGRvbid0IGJhaWwgb3V0LCB3ZSdyZSBnb2luZyBiZSByZWNvbXB1dGluZyBvdXIgY2hpbGRyZW4gc28gd2UgbmVlZFxuICAgIC8vIHRvIGRyb3Agb3VyIGVmZmVjdCBsaXN0LlxuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICAgIC8vIFVubW91bnQgdGhlIGN1cnJlbnQgY2hpbGRyZW4gYXMgaWYgdGhlIGNvbXBvbmVudCByZW5kZXJlZCBudWxsXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiZWdpbldvcms6IGJlZ2luV29yayxcbiAgICBiZWdpbkZhaWxlZFdvcms6IGJlZ2luRmFpbGVkV29ya1xuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJDb21wbGV0ZVdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCkge1xuICB2YXIgY3JlYXRlSW5zdGFuY2UgPSBjb25maWcuY3JlYXRlSW5zdGFuY2UsXG4gICAgICBjcmVhdGVUZXh0SW5zdGFuY2UgPSBjb25maWcuY3JlYXRlVGV4dEluc3RhbmNlLFxuICAgICAgYXBwZW5kSW5pdGlhbENoaWxkID0gY29uZmlnLmFwcGVuZEluaXRpYWxDaGlsZCxcbiAgICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuID0gY29uZmlnLmZpbmFsaXplSW5pdGlhbENoaWxkcmVuLFxuICAgICAgcHJlcGFyZVVwZGF0ZSA9IGNvbmZpZy5wcmVwYXJlVXBkYXRlLFxuICAgICAgbXV0YXRpb24gPSBjb25maWcubXV0YXRpb24sXG4gICAgICBwZXJzaXN0ZW5jZSA9IGNvbmZpZy5wZXJzaXN0ZW5jZTtcbiAgdmFyIGdldFJvb3RIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQuZ2V0Um9vdEhvc3RDb250YWluZXIsXG4gICAgICBwb3BIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250ZXh0LFxuICAgICAgZ2V0SG9zdENvbnRleHQgPSBob3N0Q29udGV4dC5nZXRIb3N0Q29udGV4dCxcbiAgICAgIHBvcEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGFpbmVyO1xuICB2YXIgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSA9IGh5ZHJhdGlvbkNvbnRleHQucHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC5wcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5wb3BIeWRyYXRpb25TdGF0ZTtcblxuXG4gIGZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gICAgLy8gYW4gVXBkYXRlQW5kUGxhY2VtZW50LlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUmVmKHdvcmtJblByb2dyZXNzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFJlZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZEFsbFJldHVybnMocmV0dXJucywgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZVsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQgfHwgbm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnQSBjYWxsIGNhbm5vdCBoYXZlIGhvc3QgY29tcG9uZW50IGNoaWxkcmVuLicpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gUmV0dXJuQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybnMucHVzaChub2RlLnR5cGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZUNhbGxUb0hhbmRsZXJQaGFzZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgY2FsbCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgIWNhbGwgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgcmVzb2x2ZWQgYnkgbm93LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgLy8gRmlyc3Qgc3RlcCBvZiB0aGUgY2FsbCBoYXMgY29tcGxldGVkLiBOb3cgd2UgbmVlZCB0byBkbyB0aGUgc2Vjb25kLlxuICAgIC8vIFRPRE86IEl0IHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSBhIG11bHRpIHN0YWdlIGNhbGwgcmVwcmVzZW50ZWQgYnkgYVxuICAgIC8vIHNpbmdsZSBjb21wb25lbnQsIG9yIGF0IGxlYXN0IHRhaWwgY2FsbCBvcHRpbWl6ZSBuZXN0ZWQgb25lcy4gQ3VycmVudGx5XG4gICAgLy8gdGhhdCByZXF1aXJlcyBhZGRpdGlvbmFsIGZpZWxkcyB0aGF0IHdlIGRvbid0IHdhbnQgdG8gYWRkIHRvIHRoZSBmaWJlci5cbiAgICAvLyBTbyB0aGlzIHJlcXVpcmVzIG5lc3RlZCBoYW5kbGVycy5cbiAgICAvLyBOb3RlOiBUaGlzIGRvZXNuJ3QgbXV0YXRlIHRoZSBhbHRlcm5hdGUgbm9kZS4gSSBkb24ndCB0aGluayBpdCBuZWVkcyB0b1xuICAgIC8vIHNpbmNlIHRoaXMgc3RhZ2UgaXMgcmVzZXQgZm9yIGV2ZXJ5IHBhc3MuXG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbEhhbmRsZXJQaGFzZTtcblxuICAgIC8vIEJ1aWxkIHVwIHRoZSByZXR1cm5zLlxuICAgIC8vIFRPRE86IENvbXBhcmUgdGhpcyB0byBhIGdlbmVyYXRvciBvciBvcGFxdWUgaGVscGVycyBsaWtlIENoaWxkcmVuLlxuICAgIHZhciByZXR1cm5zID0gW107XG4gICAgYXBwZW5kQWxsUmV0dXJucyhyZXR1cm5zLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGZuID0gY2FsbC5oYW5kbGVyO1xuICAgIHZhciBwcm9wcyA9IGNhbGwucHJvcHM7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IGZuKHByb3BzLCByZXR1cm5zKTtcblxuICAgIHZhciBjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50LmNoaWxkIDogbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnRhbCBjaGlsZCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlSG9zdENvbnRhaW5lciA9IHZvaWQgMDtcbiAgdmFyIHVwZGF0ZUhvc3RDb21wb25lbnQgPSB2b2lkIDA7XG4gIHZhciB1cGRhdGVIb3N0VGV4dCA9IHZvaWQgMDtcbiAgaWYgKG11dGF0aW9uKSB7XG4gICAgaWYgKGVuYWJsZU11dGF0aW5nUmVjb25jaWxlcikge1xuICAgICAgLy8gTXV0YXRpb24gbW9kZVxuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAgICAgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gICAgICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgLy8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ011dGF0aW5nIHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBlcnNpc3RlbmNlKSB7XG4gICAgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyKSB7XG4gICAgICAvLyBQZXJzaXN0ZW50IGhvc3QgdHJlZSBtb2RlXG4gICAgICB2YXIgY2xvbmVJbnN0YW5jZSA9IHBlcnNpc3RlbmNlLmNsb25lSW5zdGFuY2UsXG4gICAgICAgICAgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQgPSBwZXJzaXN0ZW5jZS5jcmVhdGVDb250YWluZXJDaGlsZFNldCxcbiAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQgPSBwZXJzaXN0ZW5jZS5hcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbiA9IHBlcnNpc3RlbmNlLmZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW47XG5cbiAgICAgIC8vIEFuIHVuZm9ydHVuYXRlIGZvcmsgb2YgYXBwZW5kQWxsQ2hpbGRyZW4gYmVjYXVzZSB3ZSBoYXZlIHR3byBkaWZmZXJlbnQgcGFyZW50IHR5cGVzLlxuXG4gICAgICB2YXIgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXJDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICAgICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyQ2hpbGRTZXQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICB2YXIgcG9ydGFsT3JSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9PT0gbnVsbDtcbiAgICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSB7XG4gICAgICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgICAgIHZhciBuZXdDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lcik7XG4gICAgICAgICAgaWYgKGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVyLCBuZXdDaGlsZFNldCkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuID0gbmV3Q2hpbGRTZXQ7XG4gICAgICAgICAgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIobmV3Q2hpbGRTZXQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhlIGNvbnRhaW5lciB0byBzd2FwIG91dCB0aGUgY29udGFpbmVyLlxuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGVmZmVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgdGhlbiBub25lIG9mIG91ciBjaGlsZHJlbiBoYWQgYW55IHVwZGF0ZXMuXG4gICAgICAgIC8vIFRoaXMgZ3VhcmFudGVlcyB0aGF0IHdlIGNhbiByZXVzZSBhbGwgb2YgdGhlbS5cbiAgICAgICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPT09IG51bGw7XG4gICAgICAgIHZhciBjdXJyZW50SW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkICYmIHVwZGF0ZVBheWxvYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtaWdodCByZWxlYXNlIGEgcHJldmlvdXMgY2xvbmUuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZWN5Y2xhYmxlSW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld0luc3RhbmNlID0gY2xvbmVJbnN0YW5jZShjdXJyZW50SW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgd29ya0luUHJvZ3Jlc3MsIGNoaWxkcmVuVW5jaGFuZ2VkLCByZWN5Y2xhYmxlSW5zdGFuY2UpO1xuICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihuZXdJbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBuZXdJbnN0YW5jZTtcbiAgICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBvdGhlciBlZmZlY3RzIGluIHRoaXMgdHJlZSwgd2UgbmVlZCB0byBmbGFnIHRoaXMgbm9kZSBhcyBoYXZpbmcgb25lLlxuICAgICAgICAgICAgLy8gRXZlbiB0aG91Z2ggd2UncmUgbm90IGdvaW5nIHRvIHVzZSBpdCBmb3IgYW55dGhpbmcuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcGFyZW50cyB3b24ndCBrbm93IHRoYXQgdGhlcmUgYXJlIG5ldyBjaGlsZHJlbiB0byBwcm9wYWdhdGUgdXB3YXJkcy5cbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihuZXdJbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHRleHQgY29udGVudCBkaWZmZXJzLCB3ZSdsbCBjcmVhdGUgYSBuZXcgdGV4dCBpbnN0YW5jZSBmb3IgaXQuXG4gICAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgLy8gV2UnbGwgaGF2ZSB0byBtYXJrIGl0IGFzIGhhdmluZyBhbiBlZmZlY3QsIGV2ZW4gdGhvdWdoIHdlIHdvbid0IHVzZSB0aGUgZWZmZWN0IGZvciBhbnl0aGluZy5cbiAgICAgICAgICAvLyBUaGlzIGxldHMgdGhlIHBhcmVudHMga25vdyB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVpciBjaGlsZHJlbiBoYXMgY2hhbmdlZC5cbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnUGVyc2lzdGVudCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIC8vIE5vIGhvc3Qgb3BlcmF0aW9uc1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ05vb3AgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gR2V0IHRoZSBsYXRlc3QgcHJvcHMuXG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChuZXdQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgIT09IE5ldmVyIHx8IHJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgICAgLy8gUmVzZXQgdGhlIHBlbmRpbmcgcHJvcHMsIHVubGVzcyB0aGlzIHdhcyBhIGRvd24tcHJpb3JpdGl6YXRpb24uXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICAgIH1cblxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGFyZSBsZWF2aW5nIHRoaXMgc3VidHJlZSwgc28gcG9wIGNvbnRleHQgaWYgYW55LlxuICAgICAgICAgIHBvcENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciBmaWJlclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgICAgZmliZXJSb290LmNvbnRleHQgPSBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQ7XG4gICAgICAgICAgICBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgICAgIC8vIHRoYXQgd2VyZW4ndCBoeWRyYXRlZC5cbiAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIC8vIFRoaXMgcmVzZXRzIHRoZSBoYWNreSBzdGF0ZSB0byBmaXggaXNNb3VudGVkIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIGhhdmUgbmV3UHJvcHMgc28gd2UnbGwgaGF2ZSB0byByZXVzZSB0aGVtLlxuICAgICAgICAgICAgLy8gVE9ETzogU3BsaXQgdGhlIHVwZGF0ZSBBUEkgYXMgc2VwYXJhdGUgZm9yIHRoZSBwcm9wcyB2cy4gY2hpbGRyZW4uXG4gICAgICAgICAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTtcblxuICAgICAgICAgICAgdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudC5yZWYgIT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSBjcmVhdGVJbnN0YW5jZSB0byBiZWdpbldvcmsgYW5kIGtlZXAgaXQgb24gYSBjb250ZXh0XG4gICAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdlIHdhbnQgdG8gYWRkIHRoZW4gdG9wLT5kb3duIG9yXG4gICAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG4gICAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgICAgLy8gdG8gY29uc29saWRhdGUuXG4gICAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgY2hhbmdlcyB0byB0aGUgaHlkcmF0ZWQgbm9kZSBuZWVkcyB0byBiZSBhcHBsaWVkIGF0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihfaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICAvLyBDZXJ0YWluIHJlbmRlcmVycyByZXF1aXJlIGNvbW1pdC10aW1lIGVmZmVjdHMgZm9yIGluaXRpYWwgbW91bnQuXG4gICAgICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuICAgICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oX2luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9pbnN0YW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZiBvbiBhIGhvc3Qgbm9kZSB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgICAgICAgICAgbWFya1JlZih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBuZXdQcm9wcztcbiAgICAgICAgICBpZiAoY3VycmVudCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbiAgICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdUZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICAgIHZhciBfY3VycmVudEhvc3RDb250ZXh0MiA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShuZXdUZXh0LCBfcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0Miwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBDYWxsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gbW92ZUNhbGxUb0hhbmRsZXJQaGFzZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBDYWxsSGFuZGxlclBoYXNlOlxuICAgICAgICAvLyBSZXNldCB0aGUgdGFnIHRvIG5vdyBiZSBhIGZpcnN0IHBoYXNlIGNhbGwuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENhbGxDb21wb25lbnQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBSZXR1cm5Db21wb25lbnQ6XG4gICAgICAgIC8vIERvZXMgbm90aGluZy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIC8vIEVycm9yIGNhc2VzXG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBoYXZlIGJlY29tZSBkZXRlcm1pbmF0ZSBiZWZvcmUgY29tcGxldGluZy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tcGxldGVXb3JrOiBjb21wbGV0ZVdvcmtcbiAgfTtcbn07XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMiA9IFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2s7XG52YXIgaGFzQ2F1Z2h0RXJyb3IkMSA9IFJlYWN0RXJyb3JVdGlscy5oYXNDYXVnaHRFcnJvcjtcbnZhciBjbGVhckNhdWdodEVycm9yJDEgPSBSZWFjdEVycm9yVXRpbHMuY2xlYXJDYXVnaHRFcnJvcjtcblxuXG52YXIgUmVhY3RGaWJlckNvbW1pdFdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBjYXB0dXJlRXJyb3IpIHtcbiAgdmFyIGdldFB1YmxpY0luc3RhbmNlID0gY29uZmlnLmdldFB1YmxpY0luc3RhbmNlLFxuICAgICAgbXV0YXRpb24gPSBjb25maWcubXV0YXRpb24sXG4gICAgICBwZXJzaXN0ZW5jZSA9IGNvbmZpZy5wZXJzaXN0ZW5jZTtcblxuXG4gIHZhciBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIgPSBmdW5jdGlvbiAoY3VycmVudCwgaW5zdGFuY2UpIHtcbiAgICBzdGFydFBoYXNlVGltZXIoY3VycmVudCwgJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICBzdG9wUGhhc2VUaW1lcigpO1xuICB9O1xuXG4gIC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IHVubW91bnRpbmcuXG4gIGZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBpbnN0YW5jZSkge1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciwgbnVsbCwgY3VycmVudCwgaW5zdGFuY2UpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICB2YXIgdW5tb3VudEVycm9yID0gY2xlYXJDYXVnaHRFcnJvciQxKCk7XG4gICAgICAgIGNhcHR1cmVFcnJvcihjdXJyZW50LCB1bm1vdW50RXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50KSB7XG4gICAgdmFyIHJlZiA9IGN1cnJlbnQucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIobnVsbCwgcmVmLCBudWxsLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICAgIHZhciByZWZFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IkMSgpO1xuICAgICAgICAgIGNhcHR1cmVFcnJvcihjdXJyZW50LCByZWZFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRMaWZlQ3ljbGVzKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdjb21wb25lbnREaWRNb3VudCcpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgc3RhcnRQaGFzZVRpbWVyKGZpbmlzaGVkV29yaywgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3ModXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBpZiAoX3VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gZmluaXNoZWRXb3JrLmNoaWxkICE9PSBudWxsID8gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSA6IG51bGw7XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3MoX3VwZGF0ZVF1ZXVlLCBfaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgIC8vIFJlbmRlcmVycyBtYXkgc2NoZWR1bGUgd29yayB0byBiZSBkb25lIGFmdGVyIGhvc3QgY29tcG9uZW50cyBhcmUgbW91bnRlZFxuICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgICAgIC8vIGFrYSB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQvYWx0ZXJuYXRlLlxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsICYmIGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIGNvbW1pdE1vdW50KF9pbnN0YW5jZTIsIHR5cGUsIHByb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHRleHQuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCBwb3J0YWxzLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuICAgIHZhciByZWYgPSBmaW5pc2hlZFdvcmsucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHJlZihnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlZihpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpIHtcbiAgICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQucmVmO1xuICAgIGlmIChjdXJyZW50UmVmICE9PSBudWxsKSB7XG4gICAgICBjdXJyZW50UmVmKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZXItb3JpZ2luYXRpbmcgZXJyb3JzIChsaWZlY3ljbGVzIGFuZCByZWZzKSBzaG91bGQgbm90IGludGVycnVwdFxuICAvLyBkZWxldGlvbiwgc28gZG9uJ3QgbGV0IHRoZW0gdGhyb3cuIEhvc3Qtb3JpZ2luYXRpbmcgZXJyb3JzIHNob3VsZFxuICAvLyBpbnRlcnJ1cHQgZGVsZXRpb24sIHNvIGl0J3Mgb2theVxuICBmdW5jdGlvbiBjb21taXRVbm1vdW50KGN1cnJlbnQpIHtcbiAgICBpZiAodHlwZW9mIG9uQ29tbWl0VW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25Db21taXRVbm1vdW50KGN1cnJlbnQpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIENhbGxDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhjdXJyZW50LnN0YXRlTm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIHJlY3Vyc2l2ZS5cbiAgICAgICAgICAvLyBXZSBhcmUgYWxzbyBub3QgdXNpbmcgdGhpcyBwYXJlbnQgYmVjYXVzZVxuICAgICAgICAgIC8vIHRoZSBwb3J0YWwgd2lsbCBnZXQgcHVzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICAgIGlmIChlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIgJiYgbXV0YXRpb24pIHtcbiAgICAgICAgICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyICYmIHBlcnNpc3RlbmNlKSB7XG4gICAgICAgICAgICBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0TmVzdGVkVW5tb3VudHMocm9vdCkge1xuICAgIC8vIFdoaWxlIHdlJ3JlIGluc2lkZSBhIHJlbW92ZWQgaG9zdCBub2RlIHdlIGRvbid0IHdhbnQgdG8gY2FsbFxuICAgIC8vIHJlbW92ZUNoaWxkIG9uIHRoZSBpbm5lciBub2RlcyBiZWNhdXNlIHRoZXkncmUgcmVtb3ZlZCBieSB0aGUgdG9wXG4gICAgLy8gY2FsbCBhbnl3YXkuIFdlIGFsc28gd2FudCB0byBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50IG9uIGFsbFxuICAgIC8vIGNvbXBvc2l0ZXMgYmVmb3JlIHRoaXMgaG9zdCBub2RlIGlzIHJlbW92ZWQgZnJvbSB0aGUgdHJlZS4gVGhlcmVmb3JlXG4gICAgdmFyIG5vZGUgPSByb290O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB0aGV5IG1heSBjb250YWluIG1vcmUgY29tcG9zaXRlIG9yIGhvc3Qgbm9kZXMuXG4gICAgICAvLyBTa2lwIHBvcnRhbHMgYmVjYXVzZSBjb21taXRVbm1vdW50KCkgY3VycmVudGx5IHZpc2l0cyB0aGVtIHJlY3Vyc2l2ZWx5LlxuICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwgJiYgKFxuICAgICAgLy8gSWYgd2UgdXNlIG11dGF0aW9uIHdlIGRyaWxsIGRvd24gaW50byBwb3J0YWxzIHVzaW5nIGNvbW1pdFVubW91bnQgYWJvdmUuXG4gICAgICAvLyBJZiB3ZSBkb24ndCB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgaGVyZSBpbnN0ZWFkLlxuICAgICAgIW11dGF0aW9uIHx8IG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSByb290KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoRmliZXIoY3VycmVudCkge1xuICAgIC8vIEN1dCBvZmYgdGhlIHJldHVybiBwb2ludGVycyB0byBkaXNjb25uZWN0IGl0IGZyb20gdGhlIHRyZWUuIElkZWFsbHksIHdlXG4gICAgLy8gc2hvdWxkIGNsZWFyIHRoZSBjaGlsZCBwb2ludGVyIG9mIHRoZSBwYXJlbnQgYWx0ZXJuYXRlIHRvIGxldCB0aGlzXG4gICAgLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuICAgIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLiBUaGlzIGNoaWxkXG4gICAgLy8gaXRzZWxmIHdpbGwgYmUgR0M6ZWQgd2hlbiB0aGUgcGFyZW50IHVwZGF0ZXMgdGhlIG5leHQgdGltZS5cbiAgICBjdXJyZW50WydyZXR1cm4nXSA9IG51bGw7XG4gICAgY3VycmVudC5jaGlsZCA9IG51bGw7XG4gICAgaWYgKGN1cnJlbnQuYWx0ZXJuYXRlKSB7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZS5jaGlsZCA9IG51bGw7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZVsncmV0dXJuJ10gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbXV0YXRpb24pIHtcbiAgICB2YXIgY29tbWl0Q29udGFpbmVyID0gdm9pZCAwO1xuICAgIGlmIChwZXJzaXN0ZW5jZSkge1xuICAgICAgdmFyIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbiA9IHBlcnNpc3RlbmNlLnJlcGxhY2VDb250YWluZXJDaGlsZHJlbixcbiAgICAgICAgICBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0O1xuXG4gICAgICB2YXIgZW1wdHlQb3J0YWxDb250YWluZXIgPSBmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgICB2YXIgcG9ydGFsID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsLmNvbnRhaW5lckluZm87XG5cbiAgICAgICAgdmFyIGVtcHR5Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXJJbmZvKTtcbiAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIGVtcHR5Q2hpbGRTZXQpO1xuICAgICAgfTtcbiAgICAgIGNvbW1pdENvbnRhaW5lciA9IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBvcnRhbE9yUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm8sXG4gICAgICAgICAgICAgICAgICBfcGVuZGluZ0NoaWxkcmVuID0gcG9ydGFsT3JSb290LnBlbmRpbmdDaGlsZHJlbjtcblxuICAgICAgICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgX3BlbmRpbmdDaGlsZHJlbik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0Q29udGFpbmVyID0gZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIgfHwgZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHt9LFxuICAgICAgICBjb21taXRQbGFjZW1lbnQ6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHt9LFxuICAgICAgICBjb21taXREZWxldGlvbjogZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgICAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGN1cnJlbnQpO1xuICAgICAgICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBjb21taXRXb3JrOiBmdW5jdGlvbiAoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICAgICAgY29tbWl0Q29udGFpbmVyKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tbWl0TGlmZUN5Y2xlczogY29tbWl0TGlmZUN5Y2xlcyxcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICAgIGNvbW1pdERldGFjaFJlZjogY29tbWl0RGV0YWNoUmVmXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocGVyc2lzdGVuY2UpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1BlcnNpc3RlbnQgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTm9vcCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfVxuICB2YXIgY29tbWl0TW91bnQgPSBtdXRhdGlvbi5jb21taXRNb3VudCxcbiAgICAgIGNvbW1pdFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFVwZGF0ZSxcbiAgICAgIHJlc2V0VGV4dENvbnRlbnQgPSBtdXRhdGlvbi5yZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0VGV4dFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFRleHRVcGRhdGUsXG4gICAgICBhcHBlbmRDaGlsZCA9IG11dGF0aW9uLmFwcGVuZENoaWxkLFxuICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciA9IG11dGF0aW9uLmFwcGVuZENoaWxkVG9Db250YWluZXIsXG4gICAgICBpbnNlcnRCZWZvcmUgPSBtdXRhdGlvbi5pbnNlcnRCZWZvcmUsXG4gICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSA9IG11dGF0aW9uLmluc2VydEluQ29udGFpbmVyQmVmb3JlLFxuICAgICAgcmVtb3ZlQ2hpbGQgPSBtdXRhdGlvbi5yZW1vdmVDaGlsZCxcbiAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciA9IG11dGF0aW9uLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjtcblxuXG4gIGZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgICByZXR1cm4gZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgfHwgZmliZXIudGFnID09PSBIb3N0UG9ydGFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgICAvLyBXZSdyZSBnb2luZyB0byBzZWFyY2ggZm9yd2FyZCBpbnRvIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBzaWJsaW5nIGhvc3RcbiAgICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgICAvLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcsIGxldCdzIHRyeSB0aGUgbmV4dCBzaWJsaW5nLlxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGVbJ3JldHVybiddKSkge1xuICAgICAgICAgIC8vIElmIHdlIHBvcCBvdXQgb2YgdGhlIHJvb3Qgb3IgaGl0IHRoZSBwYXJlbnQgdGhlIGZpYmVyIHdlIGFyZSB0aGVcbiAgICAgICAgICAvLyBsYXN0IHNpYmxpbmcuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBub2RlLnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgICAgLy8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuICAgICAgICAvLyBUcnkgdG8gc2VhcmNoIGRvd24gdW50aWwgd2UgZmluZCBvbmUuXG4gICAgICAgIGlmIChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkge1xuICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAvLyBXZSBhbHNvIHNraXAgcG9ydGFscyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgaG9zdCB0cmVlLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cbiAgICAgIGlmICghKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSkge1xuICAgICAgICAvLyBGb3VuZCBpdCFcbiAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcbiAgICAvLyBSZWN1cnNpdmVseSBpbnNlcnQgYWxsIGhvc3Qgbm9kZXMgaW50byB0aGUgcGFyZW50LlxuICAgIHZhciBwYXJlbnRGaWJlciA9IGdldEhvc3RQYXJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuICAgIHZhciBwYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGlzQ29udGFpbmVyID0gdm9pZCAwO1xuICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgaXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgICBpZiAocGFyZW50RmliZXIuZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG4gICAgICByZXNldFRleHRDb250ZW50KHBhcmVudCk7XG4gICAgICAvLyBDbGVhciBDb250ZW50UmVzZXQgZnJvbSB0aGUgZWZmZWN0IHRhZ1xuICAgICAgcGFyZW50RmliZXIuZWZmZWN0VGFnICY9IH5Db250ZW50UmVzZXQ7XG4gICAgfVxuXG4gICAgdmFyIGJlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IGZpbmlzaGVkV29yaztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsIG5vZGUuc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLnN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgdGhlIGluc2VydGlvbiBpdHNlbGYgaXMgYSBwb3J0YWwsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCkge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICB2YXIgbm9kZSA9IGN1cnJlbnQ7XG5cbiAgICAvLyBFYWNoIGl0ZXJhdGlvbiwgY3VycmVudFBhcmVudCBpcyBwb3B1bGF0ZWQgd2l0aCBub2RlJ3MgaG9zdCBwYXJlbnQgaWYgbm90XG4gICAgLy8gY3VycmVudFBhcmVudElzVmFsaWQuXG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHZvaWQgMDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnRJc1ZhbGlkKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgZmluZFBhcmVudDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAhKHBhcmVudCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgc3dpdGNoIChwYXJlbnQudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKG5vZGUpO1xuICAgICAgICAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAgIC8vIG5vZGUgZnJvbSB0aGUgdHJlZS5cbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IHZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgYWxyZWFkeSB2aXNpdGVkIHRoZW0uXG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gaW50byBhIHBvcnRhbCwgaXQgYmVjb21lcyB0aGUgcGFyZW50IHRvIHJlbW92ZSBmcm9tLlxuICAgICAgICAvLyBXZSB3aWxsIHJlYXNzaWduIGl0IGJhY2sgd2hlbiB3ZSBwb3AgdGhlIHBvcnRhbCBvbiB0aGUgd2F5IHVwLlxuICAgICAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSBwb3J0YWxzIG1pZ2h0IGNvbnRhaW4gaG9zdCBjb21wb25lbnRzLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWl0VW5tb3VudChub2RlKTtcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBtYXkgZmluZCBtb3JlIGhvc3QgY29tcG9uZW50cyBiZWxvdy5cbiAgICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSBnbyBvdXQgb2YgdGhlIHBvcnRhbCwgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBwYXJlbnQuXG4gICAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3Qga2VlcCBhIHN0YWNrIG9mIHRoZW0sIHdlIHdpbGwgc2VhcmNoIGZvciBpdC5cbiAgICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uKGN1cnJlbnQpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBkZWxldGUgYWxsIGhvc3Qgbm9kZXMgZnJvbSB0aGUgcGFyZW50LlxuICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpO1xuICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0V29yayhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuICAgICAgICAgICAgdmFyIG5ld1Byb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAgIC8vIHRoaXMgY2FzZS5cbiAgICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdQcm9wcztcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICAvLyBUT0RPOiBUeXBlIHRoZSB1cGRhdGVRdWV1ZSB0byBiZSBzcGVjaWZpYyB0byBob3N0IGNvbXBvbmVudHMuXG4gICAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgIShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1RleHQ7XG4gICAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0UmVzZXRUZXh0Q29udGVudChjdXJyZW50KSB7XG4gICAgcmVzZXRUZXh0Q29udGVudChjdXJyZW50LnN0YXRlTm9kZSk7XG4gIH1cblxuICBpZiAoZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQ6IGNvbW1pdFJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRQbGFjZW1lbnQ6IGNvbW1pdFBsYWNlbWVudCxcbiAgICAgIGNvbW1pdERlbGV0aW9uOiBjb21taXREZWxldGlvbixcbiAgICAgIGNvbW1pdFdvcms6IGNvbW1pdFdvcmssXG4gICAgICBjb21taXRMaWZlQ3ljbGVzOiBjb21taXRMaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICBjb21taXREZXRhY2hSZWY6IGNvbW1pdERldGFjaFJlZlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCAnTXV0YXRpbmcgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgfVxufTtcblxudmFyIE5PX0NPTlRFWFQgPSB7fTtcblxudmFyIFJlYWN0RmliZXJIb3N0Q29udGV4dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGdldENoaWxkSG9zdENvbnRleHQgPSBjb25maWcuZ2V0Q2hpbGRIb3N0Q29udGV4dCxcbiAgICAgIGdldFJvb3RIb3N0Q29udGV4dCA9IGNvbmZpZy5nZXRSb290SG9zdENvbnRleHQ7XG5cblxuICB2YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuICB2YXIgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG4gIHZhciByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcblxuICBmdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICAgICEoYyAhPT0gTk9fQ09OVEVYVCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSb290SG9zdENvbnRhaW5lcigpIHtcbiAgICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiByb290SW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICAgIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHJlc2V0IHJvb3Qgd2hlbiBwb3J0YWxzIGFyZSBwb3BwZWQuXG4gICAgcHVzaChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgbmV4dFJvb3RJbnN0YW5jZSwgZmliZXIpO1xuXG4gICAgdmFyIG5leHRSb290Q29udGV4dCA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTtcblxuICAgIC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dFJvb3RDb250ZXh0LCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gICAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlLCByb290SW5zdGFuY2UpO1xuXG4gICAgLy8gRG9uJ3QgcHVzaCB0aGlzIEZpYmVyJ3MgY29udGV4dCB1bmxlc3MgaXQncyB1bmlxdWUuXG4gICAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Q29udGV4dCwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICAvLyBEbyBub3QgcG9wIHVubGVzcyB0aGlzIEZpYmVyIHByb3ZpZGVkIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IGZpYmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRIb3N0Q29udGFpbmVyKCkge1xuICAgIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50ID0gTk9fQ09OVEVYVDtcbiAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50ID0gTk9fQ09OVEVYVDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0SG9zdENvbnRleHQ6IGdldEhvc3RDb250ZXh0LFxuICAgIGdldFJvb3RIb3N0Q29udGFpbmVyOiBnZXRSb290SG9zdENvbnRhaW5lcixcbiAgICBwb3BIb3N0Q29udGFpbmVyOiBwb3BIb3N0Q29udGFpbmVyLFxuICAgIHBvcEhvc3RDb250ZXh0OiBwb3BIb3N0Q29udGV4dCxcbiAgICBwdXNoSG9zdENvbnRhaW5lcjogcHVzaEhvc3RDb250YWluZXIsXG4gICAgcHVzaEhvc3RDb250ZXh0OiBwdXNoSG9zdENvbnRleHQsXG4gICAgcmVzZXRIb3N0Q29udGFpbmVyOiByZXNldEhvc3RDb250YWluZXJcbiAgfTtcbn07XG5cbnZhciBSZWFjdEZpYmVySHlkcmF0aW9uQ29udGV4dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIHNob3VsZFNldFRleHRDb250ZW50ID0gY29uZmlnLnNob3VsZFNldFRleHRDb250ZW50LFxuICAgICAgaHlkcmF0aW9uID0gY29uZmlnLmh5ZHJhdGlvbjtcblxuICAvLyBJZiB0aGlzIGRvZXNuJ3QgaGF2ZSBoeWRyYXRpb24gbW9kZS5cblxuICBpZiAoIWh5ZHJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBlbnRlckh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0sXG4gICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0sXG4gICAgICBwb3BIeWRyYXRpb25TdGF0ZTogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhbkh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5jYW5IeWRyYXRlSW5zdGFuY2UsXG4gICAgICBjYW5IeWRyYXRlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcgPSBoeWRyYXRpb24uZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nLFxuICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQgPSBoeWRyYXRpb24uZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQsXG4gICAgICBoeWRyYXRlSW5zdGFuY2UgPSBoeWRyYXRpb24uaHlkcmF0ZUluc3RhbmNlLFxuICAgICAgaHlkcmF0ZVRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5oeWRyYXRlVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RIeWRyYXRlSW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlO1xuXG4gIC8vIFRoZSBkZWVwZXN0IEZpYmVyIG9uIHRoZSBzdGFjayBpbnZvbHZlZCBpbiBhIGh5ZHJhdGlvbiBjb250ZXh0LlxuICAvLyBUaGlzIG1heSBoYXZlIGJlZW4gYW4gaW5zZXJ0aW9uIG9yIGEgaHlkcmF0aW9uLlxuXG4gIHZhciBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG4gIHZhciBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgdmFyIGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZW50ZXJIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChwYXJlbnRJbnN0YW5jZSk7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKSB7XG4gICAge1xuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UocmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8sIGluc3RhbmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShyZXR1cm5GaWJlci50eXBlLCByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzLCByZXR1cm5GaWJlci5zdGF0ZU5vZGUsIGluc3RhbmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCk7XG4gICAgY2hpbGRUb0RlbGV0ZS5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICBjaGlsZFRvRGVsZXRlWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIGNoaWxkVG9EZWxldGUuZWZmZWN0VGFnID0gRGVsZXRpb247XG5cbiAgICAvLyBUaGlzIG1pZ2h0IHNlZW0gbGlrZSBpdCBiZWxvbmdzIG9uIHByb2dyZXNzZWRGaXJzdERlbGV0aW9uLiBIb3dldmVyLFxuICAgIC8vIHRoZXNlIGNoaWxkcmVuIGFyZSBub3QgcGFydCBvZiB0aGUgcmVjb25jaWxpYXRpb24gbGlzdCBvZiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGlmIHdlIGFib3J0IGFuZCByZXJlY29uY2lsZSB0aGUgY2hpbGRyZW4sIHRoYXQgd2lsbCB0cnkgdG8gaHlkcmF0ZVxuICAgIC8vIGFnYWluIGFuZCB0aGUgbm9kZXMgYXJlIHN0aWxsIGluIHRoZSBob3N0IHRyZWUgc28gdGhlc2Ugd2lsbCBiZVxuICAgIC8vIHJlY3JlYXRlZC5cbiAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKSB7XG4gICAgZmliZXIuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcbiAgICB7XG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgdmFyIF90eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgX3Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdHlwZSwgX3Byb3BzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgICB2YXIgX3RleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdGV4dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkge1xuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNhbkh5ZHJhdGVJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBjYW5IeWRyYXRlVGV4dEluc3RhbmNlKG5leHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICAgICAgaWYgKHRleHRJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gdGV4dEluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyKSB7XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICBpZiAoIW5leHRJbnN0YW5jZSkge1xuICAgICAgLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbiAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAgIC8vIElmIHdlIGNhbid0IGh5ZHJhdGUgdGhpcyBpbnN0YW5jZSBsZXQncyB0cnkgdGhlIG5leHQgb25lLlxuICAgICAgLy8gV2UgdXNlIHRoaXMgYXMgYSBoZXVyaXN0aWMuIEl0J3MgYmFzZWQgb24gaW50dWl0aW9uIGFuZCBub3QgZGF0YSBzbyBpdFxuICAgICAgLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxuICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgICBpZiAoIW5leHRJbnN0YW5jZSB8fCAhdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIG5leHQgb25lLCB3ZSdsbCBub3cgYXNzdW1lIHRoYXQgdGhlIGZpcnN0IG9uZSB3YXNcbiAgICAgIC8vIHN1cGVyZmx1b3VzIGFuZCB3ZSdsbCBkZWxldGUgaXQuIFNpbmNlIHdlIGNhbid0IGVhZ2VybHkgZGVsZXRlIGl0XG4gICAgICAvLyB3ZSdsbCBoYXZlIHRvIHNjaGVkdWxlIGEgZGVsZXRpb24uIFRvIGRvIHRoYXQsIHRoaXMgbm9kZSBuZWVkcyBhIGR1bW15XG4gICAgICAvLyBmaWJlciBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpO1xuICAgIH1cbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChuZXh0SW5zdGFuY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZShmaWJlciwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgZmliZXIpO1xuICAgIC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuICAgIGZpYmVyLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAvLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS5cbiAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG4gICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgdGV4dENvbnRlbnQgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIGZpYmVyKTtcbiAgICB7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIGlzIGNhbGxlZCBpbiBhIGNvbnRleHQgd2hlcmUgdGhlXG4gICAgICAgIC8vIGh5ZHJhdGlvbiBwYXJlbnQgaXMgdGhlIHBhcmVudCBob3N0IGNvbXBvbmVudCBvZiB0aGlzIGhvc3QgdGV4dC5cbiAgICAgICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG4gICAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIHBhcmVudC50YWcgIT09IEhvc3RSb290KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IHBhcmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuICAgICAgLy8gV2UncmUgZGVlcGVyIHRoYW4gdGhlIGN1cnJlbnQgaHlkcmF0aW9uIGNvbnRleHQsIGluc2lkZSBhbiBpbnNlcnRlZFxuICAgICAgLy8gdHJlZS5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgLy8gSWYgd2UncmUgbm90IGN1cnJlbnRseSBoeWRyYXRpbmcgYnV0IHdlJ3JlIGluIGEgaHlkcmF0aW9uIGNvbnRleHQsIHRoZW5cbiAgICAgIC8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4gICAgICAvLyBzaWJsaW5ncy5cbiAgICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICAgIC8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbiAgICAvLyBXZSBvbmx5IGRvIHRoaXMgZGVlcGVyIHRoYW4gaGVhZCBhbmQgYm9keSBzaW5jZSB0aGV5IHRlbmQgdG8gaGF2ZSByYW5kb21cbiAgICAvLyBvdGhlciBub2RlcyBpbiB0aGVtLiBXZSBhbHNvIGlnbm9yZSBjb21wb25lbnRzIHdpdGggcHVyZSB0ZXh0IGNvbnRlbnQgaW5cbiAgICAvLyBzaWRlIG9mIHRoZW0uXG4gICAgLy8gVE9ETzogQmV0dGVyIGhldXJpc3RpYy5cbiAgICBpZiAoZmliZXIudGFnICE9PSBIb3N0Q29tcG9uZW50IHx8IHR5cGUgIT09ICdoZWFkJyAmJiB0eXBlICE9PSAnYm9keScgJiYgIXNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSB7XG4gICAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICAgIHdoaWxlIChuZXh0SW5zdGFuY2UpIHtcbiAgICAgICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXIgPyBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmliZXIuc3RhdGVOb2RlKSA6IG51bGw7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRlckh5ZHJhdGlvblN0YXRlOiBlbnRlckh5ZHJhdGlvblN0YXRlLFxuICAgIHJlc2V0SHlkcmF0aW9uU3RhdGU6IHJlc2V0SHlkcmF0aW9uU3RhdGUsXG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6IHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlLFxuICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6IHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UsXG4gICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2U6IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlLFxuICAgIHBvcEh5ZHJhdGlvblN0YXRlOiBwb3BIeWRyYXRpb25TdGF0ZVxuICB9O1xufTtcblxuLy8gVGhpcyBsZXRzIHVzIGhvb2sgaW50byBGaWJlciB0byBkZWJ1ZyB3aGF0IGl0J3MgZG9pbmcuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvODAzMy5cbi8vIFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEksIG5vdCBldmVuIGZvciBSZWFjdCBEZXZUb29scy5cbi8vIFlvdSBtYXkgb25seSBpbmplY3QgYSBkZWJ1Z1Rvb2wgaWYgeW91IHdvcmsgb24gUmVhY3QgRmliZXIgaXRzZWxmLlxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24gPSB7XG4gIGRlYnVnVG9vbDogbnVsbFxufTtcblxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMSA9IFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb247XG5cbnZhciBkZWZhdWx0U2hvd0RpYWxvZyA9IGZ1bmN0aW9uIChjYXB0dXJlZEVycm9yKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIHNob3dEaWFsb2cgPSBkZWZhdWx0U2hvd0RpYWxvZztcblxuZnVuY3Rpb24gbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKSB7XG4gIHZhciBsb2dFcnJvciA9IHNob3dEaWFsb2coY2FwdHVyZWRFcnJvcik7XG5cbiAgLy8gQWxsb3cgaW5qZWN0ZWQgc2hvd0RpYWxvZygpIHRvIHByZXZlbnQgZGVmYXVsdCBjb25zb2xlLmVycm9yIGxvZ2dpbmcuXG4gIC8vIFRoaXMgZW5hYmxlcyByZW5kZXJlcnMgbGlrZSBSZWFjdE5hdGl2ZSB0byBiZXR0ZXIgbWFuYWdlIHJlZGJveCBiZWhhdmlvci5cbiAgaWYgKGxvZ0Vycm9yID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlcnJvciA9IGNhcHR1cmVkRXJyb3IuZXJyb3I7XG4gIHZhciBzdXBwcmVzc0xvZ2dpbmcgPSBlcnJvciAmJiBlcnJvci5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nO1xuICBpZiAoc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY2FwdHVyZWRFcnJvci5jb21wb25lbnROYW1lLFxuICAgICAgICBjb21wb25lbnRTdGFjayA9IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50U3RhY2ssXG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5TmFtZSxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5Rm91bmQsXG4gICAgICAgIHdpbGxSZXRyeSA9IGNhcHR1cmVkRXJyb3Iud2lsbFJldHJ5O1xuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lID8gJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPCcgKyBjb21wb25lbnROYW1lICsgJz4gY29tcG9uZW50OicgOiAnVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHM6JztcblxuICAgIHZhciBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9IHZvaWQgMDtcbiAgICAvLyBlcnJvckJvdW5kYXJ5Rm91bmQgY2hlY2sgaXMgc3VmZmljaWVudDsgZXJyb3JCb3VuZGFyeU5hbWUgY2hlY2sgaXMgdG8gc2F0aXNmeSBGbG93LlxuICAgIGlmIChlcnJvckJvdW5kYXJ5Rm91bmQgJiYgZXJyb3JCb3VuZGFyeU5hbWUpIHtcbiAgICAgIGlmICh3aWxsUmV0cnkpIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnUmVhY3Qgd2lsbCB0cnkgdG8gcmVjcmVhdGUgdGhpcyBjb21wb25lbnQgdHJlZSBmcm9tIHNjcmF0Y2ggJyArICgndXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgJyArIGVycm9yQm91bmRhcnlOYW1lICsgJy4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ1RoaXMgZXJyb3Igd2FzIGluaXRpYWxseSBoYW5kbGVkIGJ5IHRoZSBlcnJvciBib3VuZGFyeSAnICsgZXJyb3JCb3VuZGFyeU5hbWUgKyAnLlxcbicgKyAnUmVjcmVhdGluZyB0aGUgdHJlZSBmcm9tIHNjcmF0Y2ggZmFpbGVkIHNvIFJlYWN0IHdpbGwgdW5tb3VudCB0aGUgdHJlZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nICsgJ1Zpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuJztcbiAgICB9XG4gICAgdmFyIGNvbWJpbmVkTWVzc2FnZSA9ICcnICsgY29tcG9uZW50TmFtZU1lc3NhZ2UgKyBjb21wb25lbnRTdGFjayArICdcXG5cXG4nICsgKCcnICsgZXJyb3JCb3VuZGFyeU1lc3NhZ2UpO1xuXG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIHByb3ZpZGUgb3VyIG93biBtZXNzYWdlIHdpdGgganVzdCB0aGUgY29tcG9uZW50IHN0YWNrLlxuICAgIC8vIFdlIGRvbid0IGluY2x1ZGUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2UgYW5kIEpTIHN0YWNrIGJlY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAvLyBoYXMgYWxyZWFkeSBwcmludGVkIGl0LiBFdmVuIGlmIHRoZSBhcHBsaWNhdGlvbiBzd2FsbG93cyB0aGUgZXJyb3IsIGl0IGlzIHN0aWxsXG4gICAgLy8gZGlzcGxheWVkIGJ5IHRoZSBicm93c2VyIHRoYW5rcyB0byB0aGUgREVWLW9ubHkgZmFrZSBldmVudCB0cmljayBpbiBSZWFjdEVycm9yVXRpbHMuXG4gICAgY29uc29sZS5lcnJvcihjb21iaW5lZE1lc3NhZ2UpO1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMSA9IFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2s7XG52YXIgaGFzQ2F1Z2h0RXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuaGFzQ2F1Z2h0RXJyb3I7XG52YXIgY2xlYXJDYXVnaHRFcnJvciA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IGZhbHNlO1xuICB2YXIgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG4gIHZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuICB2YXIgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdSZWFjdENsYXNzJztcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsICdDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nICcgKyAnY29tcG9uZW50LiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCBzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCAnICsgJ29yIGZvcmNlVXBkYXRlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuIFRoaXMgaXMgYSBuby1vcC5cXG5cXG5QbGVhc2UgJyArICdjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjb21wb25lbnROYW1lKTtcbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICB9O1xuXG4gIHZhciB3YXJuQWJvdXRJbnZhbGlkVXBkYXRlcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHN3aXRjaCAoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSkge1xuICAgICAgY2FzZSAnZ2V0Q2hpbGRDb250ZXh0JzpcbiAgICAgICAgaWYgKGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogQ2Fubm90IGNhbGwgc2V0U3RhdGUoKSBpbnNpZGUgZ2V0Q2hpbGRDb250ZXh0KCknKTtcbiAgICAgICAgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZW5kZXInOlxuICAgICAgICBpZiAoZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzIHdpdGhpbiAnICsgXCJgcmVuZGVyYCBvciBhbm90aGVyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIFwiICsgJ2JlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7IGNvbnN0cnVjdG9yIHNpZGUtZWZmZWN0cyBhcmUgJyArICdhbiBhbnRpLXBhdHRlcm4sIGJ1dCBjYW4gYmUgbW92ZWQgdG8gYGNvbXBvbmVudFdpbGxNb3VudGAuJyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFJlYWN0RmliZXJTY2hlZHVsZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBob3N0Q29udGV4dCA9IFJlYWN0RmliZXJIb3N0Q29udGV4dChjb25maWcpO1xuICB2YXIgaHlkcmF0aW9uQ29udGV4dCA9IFJlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0KGNvbmZpZyk7XG4gIHZhciBwb3BIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRhaW5lcixcbiAgICAgIHBvcEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRleHQsXG4gICAgICByZXNldEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5yZXNldEhvc3RDb250YWluZXI7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQmVnaW5Xb3JrID0gUmVhY3RGaWJlckJlZ2luV29yayhjb25maWcsIGhvc3RDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0LCBzY2hlZHVsZVdvcmssIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIpLFxuICAgICAgYmVnaW5Xb3JrID0gX1JlYWN0RmliZXJCZWdpbldvcmsuYmVnaW5Xb3JrLFxuICAgICAgYmVnaW5GYWlsZWRXb3JrID0gX1JlYWN0RmliZXJCZWdpbldvcmsuYmVnaW5GYWlsZWRXb3JrO1xuXG4gIHZhciBfUmVhY3RGaWJlckNvbXBsZXRlV28gPSBSZWFjdEZpYmVyQ29tcGxldGVXb3JrKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQpLFxuICAgICAgY29tcGxldGVXb3JrID0gX1JlYWN0RmliZXJDb21wbGV0ZVdvLmNvbXBsZXRlV29yaztcblxuICB2YXIgX1JlYWN0RmliZXJDb21taXRXb3JrID0gUmVhY3RGaWJlckNvbW1pdFdvcmsoY29uZmlnLCBjYXB0dXJlRXJyb3IpLFxuICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudCA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRSZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0UGxhY2VtZW50ID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFBsYWNlbWVudCxcbiAgICAgIGNvbW1pdERlbGV0aW9uID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdERlbGV0aW9uLFxuICAgICAgY29tbWl0V29yayA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRXb3JrLFxuICAgICAgY29tbWl0TGlmZUN5Y2xlcyA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRMaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0QXR0YWNoUmVmID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdEF0dGFjaFJlZixcbiAgICAgIGNvbW1pdERldGFjaFJlZiA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXREZXRhY2hSZWY7XG5cbiAgdmFyIG5vdyA9IGNvbmZpZy5ub3csXG4gICAgICBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2sgPSBjb25maWcuc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrLFxuICAgICAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjayA9IGNvbmZpZy5jYW5jZWxEZWZlcnJlZENhbGxiYWNrLFxuICAgICAgdXNlU3luY1NjaGVkdWxpbmcgPSBjb25maWcudXNlU3luY1NjaGVkdWxpbmcsXG4gICAgICBwcmVwYXJlRm9yQ29tbWl0ID0gY29uZmlnLnByZXBhcmVGb3JDb21taXQsXG4gICAgICByZXNldEFmdGVyQ29tbWl0ID0gY29uZmlnLnJlc2V0QWZ0ZXJDb21taXQ7XG5cbiAgLy8gUmVwcmVzZW50cyB0aGUgY3VycmVudCB0aW1lIGluIG1zLlxuXG4gIHZhciBzdGFydFRpbWUgPSBub3coKTtcbiAgdmFyIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZSgwKTtcblxuICAvLyBSZXByZXNlbnRzIHRoZSBleHBpcmF0aW9uIHRpbWUgdGhhdCBpbmNvbWluZyB1cGRhdGVzIHNob3VsZCB1c2UuIChJZiB0aGlzXG4gIC8vIGlzIE5vV29yaywgdXNlIHRoZSBkZWZhdWx0IHN0cmF0ZWd5OiBhc3luYyB1cGRhdGVzIGluIGFzeW5jIG1vZGUsIHN5bmNcbiAgLy8gdXBkYXRlcyBpbiBzeW5jIG1vZGUuKVxuICB2YXIgZXhwaXJhdGlvbkNvbnRleHQgPSBOb1dvcms7XG5cbiAgdmFyIGlzV29ya2luZyA9IGZhbHNlO1xuXG4gIC8vIFRoZSBuZXh0IHdvcmsgaW4gcHJvZ3Jlc3MgZmliZXIgdGhhdCB3ZSdyZSBjdXJyZW50bHkgd29ya2luZyBvbi5cbiAgdmFyIG5leHRVbml0T2ZXb3JrID0gbnVsbDtcbiAgdmFyIG5leHRSb290ID0gbnVsbDtcbiAgLy8gVGhlIHRpbWUgYXQgd2hpY2ggd2UncmUgY3VycmVudGx5IHJlbmRlcmluZyB3b3JrLlxuICB2YXIgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIC8vIFRoZSBuZXh0IGZpYmVyIHdpdGggYW4gZWZmZWN0IHRoYXQgd2UncmUgY3VycmVudGx5IGNvbW1pdHRpbmcuXG4gIHZhciBuZXh0RWZmZWN0ID0gbnVsbDtcblxuICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGZpYmVycyBoYXZlIGNhcHR1cmVkIGFuIGVycm9yIHRoYXQgbmVlZCB0byBiZSBoYW5kbGVkLlxuICAvLyBXb3JrIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGNvbGxlY3Rpb24gYWZ0ZXIgY29tcG9uZW50RGlkQ2F0Y2ggaXMgY2FsbGVkLlxuICB2YXIgY2FwdHVyZWRFcnJvcnMgPSBudWxsO1xuICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGZpYmVycyBoYXZlIGZhaWxlZCBkdXJpbmcgdGhlIGN1cnJlbnQgYmF0Y2ggb2Ygd29yay5cbiAgLy8gVGhpcyBpcyBhIGRpZmZlcmVudCBzZXQgdGhhbiBjYXB0dXJlZEVycm9ycywgYmVjYXVzZSBpdCBpcyBub3QgcmVzZXQgdW50aWxcbiAgLy8gdGhlIGVuZCBvZiB0aGUgYmF0Y2guIFRoaXMgaXMgbmVlZGVkIHRvIHByb3BhZ2F0ZSBlcnJvcnMgY29ycmVjdGx5IGlmIGFcbiAgLy8gc3VidHJlZSBmYWlscyBtb3JlIHRoYW4gb25jZS5cbiAgdmFyIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xuICAvLyBFcnJvciBib3VuZGFyaWVzIHRoYXQgY2FwdHVyZWQgYW4gZXJyb3IgZHVyaW5nIHRoZSBjdXJyZW50IGNvbW1pdC5cbiAgdmFyIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG51bGw7XG4gIHZhciBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuICB2YXIgZGlkRmF0YWwgPSBmYWxzZTtcblxuICB2YXIgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gIHZhciBpc1VubW91bnRpbmcgPSBmYWxzZTtcblxuICAvLyBVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy5cbiAgdmFyIGludGVycnVwdGVkQnkgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHJlc2V0Q29udGV4dFN0YWNrKCkge1xuICAgIC8vIFJlc2V0IHRoZSBzdGFja1xuICAgIHJlc2V0JDEoKTtcbiAgICAvLyBSZXNldCB0aGUgY3Vyc29yc1xuICAgIHJlc2V0Q29udGV4dCgpO1xuICAgIHJlc2V0SG9zdENvbnRhaW5lcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QWxsSG9zdEVmZmVjdHMoKSB7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIobmV4dEVmZmVjdCk7XG4gICAgICB9XG4gICAgICByZWNvcmRFZmZlY3QoKTtcblxuICAgICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuICAgICAgaWYgKGVmZmVjdFRhZyAmIENvbnRlbnRSZXNldCkge1xuICAgICAgICBjb21taXRSZXNldFRleHRDb250ZW50KG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgUmVmKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgc3dpdGNoIHN0YXRlbWVudCBpcyBvbmx5IGNvbmNlcm5lZCBhYm91dCBwbGFjZW1lbnQsXG4gICAgICAvLyB1cGRhdGVzLCBhbmQgZGVsZXRpb25zLiBUbyBhdm9pZCBuZWVkaW5nIHRvIGFkZCBhIGNhc2UgZm9yIGV2ZXJ5XG4gICAgICAvLyBwb3NzaWJsZSBiaXRtYXAgdmFsdWUsIHdlIHJlbW92ZSB0aGUgc2Vjb25kYXJ5IGVmZmVjdHMgZnJvbSB0aGVcbiAgICAgIC8vIGVmZmVjdCB0YWcgYW5kIHN3aXRjaCBvbiB0aGF0IHZhbHVlLlxuICAgICAgdmFyIHByaW1hcnlFZmZlY3RUYWcgPSBlZmZlY3RUYWcgJiB+KENhbGxiYWNrIHwgRXJyIHwgQ29udGVudFJlc2V0IHwgUmVmIHwgUGVyZm9ybWVkV29yayk7XG4gICAgICBzd2l0Y2ggKHByaW1hcnlFZmZlY3RUYWcpIHtcbiAgICAgICAgY2FzZSBQbGFjZW1lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgICAgLy8gYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgICAgICAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkXG4gICAgICAgICAgICAvLyBkb2VzIGFuZCBpc01vdW50ZWQgaXMgZGVwcmVjYXRlZCBhbnl3YXkgc28gd2Ugc2hvdWxkIGJlIGFibGVcbiAgICAgICAgICAgIC8vIHRvIGtpbGwgdGhpcy5cbiAgICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUGxhY2VtZW50QW5kVXBkYXRlOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFBsYWNlbWVudFxuICAgICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgICAgLy8gYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgICAgICAgICBuZXh0RWZmZWN0LmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuXG4gICAgICAgICAgICAvLyBVcGRhdGVcbiAgICAgICAgICAgIHZhciBfY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgY29tbWl0V29yayhfY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgVXBkYXRlOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3VycmVudDIgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQyLCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBEZWxldGlvbjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpc1VubW91bnRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29tbWl0RGVsZXRpb24obmV4dEVmZmVjdCk7XG4gICAgICAgICAgICBpc1VubW91bnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgfVxuXG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEFsbExpZmVDeWNsZXMoKSB7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBlZmZlY3RUYWcgPSBuZXh0RWZmZWN0LmVmZmVjdFRhZztcblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIChVcGRhdGUgfCBDYWxsYmFjaykpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgIGNvbW1pdExpZmVDeWNsZXMoY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIGNvbW1pdEF0dGFjaFJlZihuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIEVycikge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgY29tbWl0RXJyb3JIYW5kbGluZyhuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHQgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBjbGVhbiB0aGVzZSB1cCBzbyB0aGF0IHdlIGRvbid0IGFjY2lkZW50YWxseSBrZWVwIHRoZW0uXG4gICAgICAvLyBJJ20gbm90IGFjdHVhbGx5IHN1cmUgdGhpcyBtYXR0ZXJzIGJlY2F1c2Ugd2UgY2FuJ3QgcmVzZXQgZmlyc3RFZmZlY3RcbiAgICAgIC8vIGFuZCBsYXN0RWZmZWN0IHNpbmNlIHRoZXkncmUgb24gZXZlcnkgbm9kZSwgbm90IGp1c3QgdGhlIGVmZmVjdGZ1bFxuICAgICAgLy8gb25lcy4gU28gd2UgaGF2ZSB0byBjbGVhbiBldmVyeXRoaW5nIGFzIHdlIHJldXNlIG5vZGVzIGFueXdheS5cbiAgICAgIG5leHRFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXNldCB0aGUgZWZmZWN0VGFnIGhlcmUgc28gdGhhdCB3ZSBjYW4gcmVseSBvbiBlZmZlY3RcbiAgICAgIC8vIHRhZ3MgdG8gcmVhc29uIGFib3V0IHRoZSBjdXJyZW50IGxpZmUtY3ljbGUuXG4gICAgICBuZXh0RWZmZWN0ID0gbmV4dDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRSb290KGZpbmlzaGVkV29yaykge1xuICAgIC8vIFdlIGtlZXAgdHJhY2sgb2YgdGhpcyBzbyB0aGF0IGNhcHR1cmVFcnJvciBjYW4gY29sbGVjdCBhbnkgYm91bmRhcmllc1xuICAgIC8vIHRoYXQgY2FwdHVyZSBhbiBlcnJvciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZS4gVGhlIHJlYXNvbiB0aGVzZSBhcmVuJ3RcbiAgICAvLyBsb2NhbCB0byB0aGlzIGZ1bmN0aW9uIGlzIGJlY2F1c2UgZXJyb3JzIHRoYXQgb2NjdXIgZHVyaW5nIGNXVSBhcmVcbiAgICAvLyBjYXB0dXJlZCBlbHNld2hlcmUsIHRvIHByZXZlbnQgdGhlIHVubW91bnQgZnJvbSBiZWluZyBpbnRlcnJ1cHRlZC5cbiAgICBpc1dvcmtpbmcgPSB0cnVlO1xuICAgIGlzQ29tbWl0dGluZyA9IHRydWU7XG4gICAgc3RhcnRDb21taXRUaW1lcigpO1xuXG4gICAgdmFyIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICEocm9vdC5jdXJyZW50ICE9PSBmaW5pc2hlZFdvcmspID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyByZWxhdGVkIHRvIHRoZSByZXR1cm4gZmllbGQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gZmFsc2U7XG5cbiAgICAvLyBSZXNldCB0aGlzIHRvIG51bGwgYmVmb3JlIGNhbGxpbmcgbGlmZWN5Y2xlc1xuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gdm9pZCAwO1xuICAgIGlmIChmaW5pc2hlZFdvcmsuZWZmZWN0VGFnID4gUGVyZm9ybWVkV29yaykge1xuICAgICAgLy8gQSBmaWJlcidzIGVmZmVjdCBsaXN0IGNvbnNpc3RzIG9ubHkgb2YgaXRzIGNoaWxkcmVuLCBub3QgaXRzZWxmLiBTbyBpZlxuICAgICAgLy8gdGhlIHJvb3QgaGFzIGFuIGVmZmVjdCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC4gVGhlXG4gICAgICAvLyByZXN1bHRpbmcgbGlzdCBpcyB0aGUgc2V0IHRoYXQgd291bGQgYmVsb25nIHRvIHRoZSByb290J3MgcGFyZW50LCBpZlxuICAgICAgLy8gaXQgaGFkIG9uZTsgdGhhdCBpcywgYWxsIHRoZSBlZmZlY3RzIGluIHRoZSB0cmVlIGluY2x1ZGluZyB0aGUgcm9vdC5cbiAgICAgIGlmIChmaW5pc2hlZFdvcmsubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICBmaW5pc2hlZFdvcmsubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSBpcyBubyBlZmZlY3Qgb24gdGhlIHJvb3QuXG4gICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICB9XG5cbiAgICBwcmVwYXJlRm9yQ29tbWl0KCk7XG5cbiAgICAvLyBDb21taXQgYWxsIHRoZSBzaWRlLWVmZmVjdHMgd2l0aGluIGEgdHJlZS4gV2UnbGwgZG8gdGhpcyBpbiB0d28gcGFzc2VzLlxuICAgIC8vIFRoZSBmaXJzdCBwYXNzIHBlcmZvcm1zIGFsbCB0aGUgaG9zdCBpbnNlcnRpb25zLCB1cGRhdGVzLCBkZWxldGlvbnMgYW5kXG4gICAgLy8gcmVmIHVubW91bnRzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2Vycm9yID0gdm9pZCAwO1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCBjb21taXRBbGxIb3N0RWZmZWN0cywgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9lcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2FwdHVyZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcik7XG4gICAgICAgIC8vIENsZWFuLXVwXG4gICAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lcigpO1xuXG4gICAgcmVzZXRBZnRlckNvbW1pdCgpO1xuXG4gICAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgICAvLyB0aGUgZmlyc3QgcGFzcyBvZiB0aGUgY29tbWl0IHBoYXNlLCBzbyB0aGF0IHRoZSBwcmV2aW91cyB0cmVlIGlzIHN0aWxsXG4gICAgLy8gY3VycmVudCBkdXJpbmcgY29tcG9uZW50V2lsbFVubW91bnQsIGJ1dCBiZWZvcmUgdGhlIHNlY29uZCBwYXNzLCBzbyB0aGF0XG4gICAgLy8gdGhlIGZpbmlzaGVkIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yaztcblxuICAgIC8vIEluIHRoZSBzZWNvbmQgcGFzcyB3ZSdsbCBwZXJmb3JtIGFsbCBsaWZlLWN5Y2xlcyBhbmQgcmVmIGNhbGxiYWNrcy5cbiAgICAvLyBMaWZlLWN5Y2xlcyBoYXBwZW4gYXMgYSBzZXBhcmF0ZSBwYXNzIHNvIHRoYXQgYWxsIHBsYWNlbWVudHMsIHVwZGF0ZXMsXG4gICAgLy8gYW5kIGRlbGV0aW9ucyBpbiB0aGUgZW50aXJlIHRyZWUgaGF2ZSBhbHJlYWR5IGJlZW4gaW52b2tlZC5cbiAgICAvLyBUaGlzIHBhc3MgYWxzbyB0cmlnZ2VycyBhbnkgcmVuZGVyZXItc3BlY2lmaWMgaW5pdGlhbCBlZmZlY3RzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpO1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2RpZEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2Vycm9yMiA9IHZvaWQgMDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgY29tbWl0QWxsTGlmZUN5Y2xlcywgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgX2RpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBfZXJyb3IyID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX2RpZEVycm9yKSB7XG4gICAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2FwdHVyZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcjIpO1xuICAgICAgICBpZiAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbiAgICBpc1dvcmtpbmcgPSBmYWxzZTtcbiAgICBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyKCk7XG4gICAgc3RvcENvbW1pdFRpbWVyKCk7XG4gICAgaWYgKHR5cGVvZiBvbkNvbW1pdFJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9uQ29tbWl0Um9vdChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKTtcbiAgICB9XG4gICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbW1pdFdvcmsoZmluaXNoZWRXb3JrKTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBjYXVnaHQgYW55IGVycm9ycyBkdXJpbmcgdGhpcyBjb21taXQsIHNjaGVkdWxlIHRoZWlyIGJvdW5kYXJpZXNcbiAgICAvLyB0byB1cGRhdGUuXG4gICAgaWYgKGNvbW1pdFBoYXNlQm91bmRhcmllcykge1xuICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzLmZvckVhY2goc2NoZWR1bGVFcnJvclJlY292ZXJ5KTtcbiAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0VW5jYXVnaHRFcnJvciAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9lcnJvcjMgPSBmaXJzdFVuY2F1Z2h0RXJyb3I7XG4gICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgb25VbmNhdWdodEVycm9yKF9lcnJvcjMpO1xuICAgIH1cblxuICAgIHZhciByZW1haW5pbmdUaW1lID0gcm9vdC5jdXJyZW50LmV4cGlyYXRpb25UaW1lO1xuXG4gICAgaWYgKHJlbWFpbmluZ1RpbWUgPT09IE5vV29yaykge1xuICAgICAgY2FwdHVyZWRFcnJvcnMgPSBudWxsO1xuICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbWFpbmluZ1RpbWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzLCByZW5kZXJUaW1lKSB7XG4gICAgaWYgKHJlbmRlclRpbWUgIT09IE5ldmVyICYmIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgICAgLy8gVGhlIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9uZW50IGFyZSBoaWRkZW4uIERvbid0IGJ1YmJsZSB0aGVpclxuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgcGVuZGluZyB1cGRhdGVzLlxuICAgIHZhciBuZXdFeHBpcmF0aW9uVGltZSA9IGdldFVwZGF0ZUV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIFRPRE86IENhbGxzIG5lZWQgdG8gdmlzaXQgc3RhdGVOb2RlXG5cbiAgICAvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbiAgICB2YXIgY2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmIChjaGlsZC5leHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIChuZXdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5ld0V4cGlyYXRpb25UaW1lID4gY2hpbGQuZXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICAgIG5ld0V4cGlyYXRpb25UaW1lID0gY2hpbGQuZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gbmV3RXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgICAgLy8gcHJvZ3Jlc3MuXG4gICAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgdmFyIG5leHQgPSBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB7XG4gICAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3NbJ3JldHVybiddO1xuICAgICAgdmFyIHNpYmxpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzLnNpYmxpbmc7XG5cbiAgICAgIHJlc2V0RXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgY29tcGxldGluZyB0aGlzIHdvcmsgc3Bhd25lZCBuZXcgd29yaywgZG8gdGhhdCBuZXh0LiBXZSdsbCBjb21lXG4gICAgICAgIC8vIGJhY2sgaGVyZSBhZ2Fpbi5cbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBcHBlbmQgYWxsIHRoZSBlZmZlY3RzIG9mIHRoZSBzdWJ0cmVlIGFuZCB0aGlzIGZpYmVyIG9udG8gdGhlIGVmZmVjdFxuICAgICAgICAvLyBsaXN0IG9mIHRoZSBwYXJlbnQuIFRoZSBjb21wbGV0aW9uIG9yZGVyIG9mIHRoZSBjaGlsZHJlbiBhZmZlY3RzIHRoZVxuICAgICAgICAvLyBzaWRlLWVmZmVjdCBvcmRlci5cbiAgICAgICAgaWYgKHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGlzIGZpYmVyIGhhZCBzaWRlLWVmZmVjdHMsIHdlIGFwcGVuZCBpdCBBRlRFUiB0aGUgY2hpbGRyZW4nc1xuICAgICAgICAvLyBzaWRlLWVmZmVjdHMuIFdlIGNhbiBwZXJmb3JtIGNlcnRhaW4gc2lkZS1lZmZlY3RzIGVhcmxpZXIgaWZcbiAgICAgICAgLy8gbmVlZGVkLCBieSBkb2luZyBtdWx0aXBsZSBwYXNzZXMgb3ZlciB0aGUgZWZmZWN0IGxpc3QuIFdlIGRvbid0IHdhbnRcbiAgICAgICAgLy8gdG8gc2NoZWR1bGUgb3VyIG93biBzaWRlLWVmZmVjdCBvbiBvdXIgb3duIGxpc3QgYmVjYXVzZSBpZiBlbmQgdXBcbiAgICAgICAgLy8gcmV1c2luZyBjaGlsZHJlbiB3ZSdsbCBzY2hlZHVsZSB0aGlzIGVmZmVjdCBvbnRvIGl0c2VsZiBzaW5jZSB3ZSdyZVxuICAgICAgICAvLyBhdCB0aGUgZW5kLlxuICAgICAgICB2YXIgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICAvLyBTa2lwIGJvdGggTm9Xb3JrIGFuZCBQZXJmb3JtZWRXb3JrIHRhZ3Mgd2hlbiBjcmVhdGluZyB0aGUgZWZmZWN0IGxpc3QuXG4gICAgICAgIC8vIFBlcmZvcm1lZFdvcmsgZWZmZWN0IGlzIHJlYWQgYnkgUmVhY3QgRGV2VG9vbHMgYnV0IHNob3VsZG4ndCBiZSBjb21taXR0ZWQuXG4gICAgICAgIGlmIChlZmZlY3RUYWcgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICAgIHJldHVybiBzaWJsaW5nRmliZXI7XG4gICAgICB9IGVsc2UgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGluIHRoaXMgcmV0dXJuRmliZXIuIENvbXBsZXRlIHRoZSByZXR1cm5GaWJlci5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuICAgICAgICB2YXIgcm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2l0aG91dCB0aGlzIGV4cGxpY2l0IG51bGwgcmV0dXJuIEZsb3cgY29tcGxhaW5zIG9mIGludmFsaWQgcmV0dXJuIHR5cGVcbiAgICAvLyBUT0RPIFJlbW92ZSB0aGUgYWJvdmUgd2hpbGUodHJ1ZSkgbG9vcFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAvLyBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIC8vIFNlZSBpZiBiZWdpbm5pbmcgdGhpcyB3b3JrIHNwYXducyBtb3JlIHdvcmsuXG4gICAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25CZWdpbldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG4gICAgICBuZXh0ID0gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcblxuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAvLyBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIC8vIFNlZSBpZiBiZWdpbm5pbmcgdGhpcyB3b3JrIHNwYXducyBtb3JlIHdvcmsuXG4gICAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIG5leHQgPSBiZWdpbkZhaWxlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQmVnaW5Xb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgICAgbmV4dCA9IGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdvcmtMb29wKGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGNhcHR1cmVkRXJyb3JzICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgdW5oYW5kbGVkIGVycm9ycywgc3dpdGNoIHRvIHRoZSBzbG93IHdvcmsgbG9vcC5cbiAgICAgIC8vIFRPRE86IEhvdyB0byBhdm9pZCB0aGlzIGNoZWNrIGluIHRoZSBmYXN0IHBhdGg/IE1heWJlIHRoZSByZW5kZXJlclxuICAgICAgLy8gY291bGQga2VlcCB0cmFjayBvZiB3aGljaCByb290cyBoYXZlIHVuaGFuZGxlZCBlcnJvcnMgYW5kIGNhbGwgYVxuICAgICAgLy8gZm9ya2VkIHZlcnNpb24gb2YgcmVuZGVyUm9vdC5cbiAgICAgIHNsb3dXb3JrTG9vcFRoYXRDaGVja3NGb3JGYWlsZWRXb3JrKGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA8PSBtb3N0UmVjZW50Q3VycmVudFRpbWUpIHtcbiAgICAgIC8vIEZsdXNoIGFsbCBleHBpcmVkIHdvcmsuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jaHJvbm91cyB3b3JrIHVudGlsIHRoZSBkZWFkbGluZSBydW5zIG91dCBvZiB0aW1lLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNsb3dXb3JrTG9vcFRoYXRDaGVja3NGb3JGYWlsZWRXb3JrKGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA8PSBtb3N0UmVjZW50Q3VycmVudFRpbWUpIHtcbiAgICAgIC8vIEZsdXNoIGFsbCBleHBpcmVkIHdvcmsuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGhhc0NhcHR1cmVkRXJyb3IobmV4dFVuaXRPZldvcmspKSB7XG4gICAgICAgICAgLy8gVXNlIGEgZm9ya2VkIHZlcnNpb24gb2YgcGVyZm9ybVVuaXRPZldvcmtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGbHVzaCBhc3luY2hyb25vdXMgd29yayB1bnRpbCB0aGUgZGVhZGxpbmUgcnVucyBvdXQgb2YgdGltZS5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCAmJiAhc2hvdWxkWWllbGQoKSkge1xuICAgICAgICBpZiAoaGFzQ2FwdHVyZWRFcnJvcihuZXh0VW5pdE9mV29yaykpIHtcbiAgICAgICAgICAvLyBVc2UgYSBmb3JrZWQgdmVyc2lvbiBvZiBwZXJmb3JtVW5pdE9mV29ya1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUm9vdENhdGNoQmxvY2socm9vdCwgZmFpbGVkV29yaywgYm91bmRhcnksIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gV2UncmUgZ29pbmcgdG8gcmVzdGFydCB0aGUgZXJyb3IgYm91bmRhcnkgdGhhdCBjYXB0dXJlZCB0aGUgZXJyb3IuXG4gICAgLy8gQ29uY2VwdHVhbGx5LCB3ZSdyZSB1bndpbmRpbmcgdGhlIHN0YWNrLiBXZSBuZWVkIHRvIHVud2luZCB0aGVcbiAgICAvLyBjb250ZXh0IHN0YWNrLCB0b28uXG4gICAgdW53aW5kQ29udGV4dHMoZmFpbGVkV29yaywgYm91bmRhcnkpO1xuXG4gICAgLy8gUmVzdGFydCB0aGUgZXJyb3IgYm91bmRhcnkgdXNpbmcgYSBmb3JrZWQgdmVyc2lvbiBvZlxuICAgIC8vIHBlcmZvcm1Vbml0T2ZXb3JrIHRoYXQgZGVsZXRlcyB0aGUgYm91bmRhcnkncyBjaGlsZHJlbi4gVGhlIGVudGlyZVxuICAgIC8vIGZhaWxlZCBzdWJyZWUgd2lsbCBiZSB1bm1vdW50ZWQuIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCBhIHNwZWNpYWxcbiAgICAvLyBsaWZlY3ljbGUgbWV0aG9kIGlzIGNhbGxlZCBvbiB0aGUgZXJyb3IgYm91bmRhcnksIHdoaWNoIHRyaWdnZXJzXG4gICAgLy8gYSByZS1yZW5kZXIuXG4gICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayhib3VuZGFyeSk7XG5cbiAgICAvLyBDb250aW51ZSB3b3JraW5nLlxuICAgIHdvcmtMb29wKGV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlclJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAhIWlzV29ya2luZyA/IGludmFyaWFudChmYWxzZSwgJ3JlbmRlclJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICBpc1dvcmtpbmcgPSB0cnVlO1xuXG4gICAgLy8gV2UncmUgYWJvdXQgdG8gbXV0YXRlIHRoZSB3b3JrLWluLXByb2dyZXNzIHRyZWUuIElmIHRoZSByb290IHdhcyBwZW5kaW5nXG4gICAgLy8gY29tbWl0LCBpdCBubyBsb25nZXIgaXM6IHdlJ2xsIG5lZWQgdG8gY29tcGxldGUgaXQgYWdhaW4uXG4gICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBzdGFydGluZyBmcm9tIGEgZnJlc2ggc3RhY2ssIG9yIGlmIHdlJ3JlIHJlc3VtaW5nIGZyb21cbiAgICAvLyBwcmV2aW91c2x5IHlpZWxkZWQgd29yay5cbiAgICBpZiAocm9vdCAhPT0gbmV4dFJvb3QgfHwgZXhwaXJhdGlvblRpbWUgIT09IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSB8fCBuZXh0VW5pdE9mV29yayA9PT0gbnVsbCkge1xuICAgICAgLy8gUmVzZXQgdGhlIHN0YWNrIGFuZCBzdGFydCB3b3JraW5nIGZyb20gdGhlIHJvb3QuXG4gICAgICByZXNldENvbnRleHRTdGFjaygpO1xuICAgICAgbmV4dFJvb3QgPSByb290O1xuICAgICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICBuZXh0VW5pdE9mV29yayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKG5leHRSb290LmN1cnJlbnQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBzdGFydFdvcmtMb29wVGltZXIobmV4dFVuaXRPZldvcmspO1xuXG4gICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gbnVsbDtcbiAgICB7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCB3b3JrTG9vcCwgbnVsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbiBlcnJvciB3YXMgdGhyb3duIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIHdoaWxlIChkaWRFcnJvcikge1xuICAgICAgaWYgKGRpZEZhdGFsKSB7XG4gICAgICAgIC8vIFRoaXMgd2FzIGEgZmF0YWwgZXJyb3IuIERvbid0IGF0dGVtcHQgdG8gcmVjb3ZlciBmcm9tIGl0LlxuICAgICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWlsZWRXb3JrID0gbmV4dFVuaXRPZldvcms7XG4gICAgICBpZiAoZmFpbGVkV29yayA9PT0gbnVsbCkge1xuICAgICAgICAvLyBBbiBlcnJvciB3YXMgdGhyb3duIGJ1dCB0aGVyZSdzIG5vIGN1cnJlbnQgdW5pdCBvZiB3b3JrLiBUaGlzIGNhblxuICAgICAgICAvLyBoYXBwZW4gZHVyaW5nIHRoZSBjb21taXQgcGhhc2UgaWYgdGhlcmUncyBhIGJ1ZyBpbiB0aGUgcmVuZGVyZXIuXG4gICAgICAgIGRpZEZhdGFsID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFwiQ2FwdHVyZVwiIHRoZSBlcnJvciBieSBmaW5kaW5nIHRoZSBuZWFyZXN0IGJvdW5kYXJ5LiBJZiB0aGVyZSBpcyBub1xuICAgICAgLy8gZXJyb3IgYm91bmRhcnksIHdlIHVzZSB0aGUgcm9vdC5cbiAgICAgIHZhciBib3VuZGFyeSA9IGNhcHR1cmVFcnJvcihmYWlsZWRXb3JrLCBlcnJvcik7XG4gICAgICAhKGJvdW5kYXJ5ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIGZvdW5kIGFuIGVycm9yIGJvdW5kYXJ5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgICBpZiAoZGlkRmF0YWwpIHtcbiAgICAgICAgLy8gVGhlIGVycm9yIHdlIGp1c3QgY2FwdHVyZWQgd2FzIGEgZmF0YWwgZXJyb3IuIFRoaXMgaGFwcGVuc1xuICAgICAgICAvLyB3aGVuIHRoZSBlcnJvciBwcm9wYWdhdGVzIHRvIHRoZSByb290IG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIGVycm9yID0gbnVsbDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgcmVuZGVyUm9vdENhdGNoQmxvY2ssIG51bGwsIHJvb3QsIGZhaWxlZFdvcmssIGJvdW5kYXJ5LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSdyZSBmaW5pc2hlZCB3b3JraW5nLiBFeGl0IHRoZSBlcnJvciBsb29wLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHVuY2F1Z2h0RXJyb3IgPSBmaXJzdFVuY2F1Z2h0RXJyb3I7XG5cbiAgICAvLyBXZSdyZSBkb25lIHBlcmZvcm1pbmcgd29yay4gVGltZSB0byBjbGVhbiB1cC5cbiAgICBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5KTtcbiAgICBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcbiAgICBpc1dvcmtpbmcgPSBmYWxzZTtcbiAgICBkaWRGYXRhbCA9IGZhbHNlO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG5cbiAgICBpZiAodW5jYXVnaHRFcnJvciAhPT0gbnVsbCkge1xuICAgICAgb25VbmNhdWdodEVycm9yKHVuY2F1Z2h0RXJyb3IpO1xuICAgIH1cblxuICAgIHJldHVybiByb290LmlzUmVhZHlGb3JDb21taXQgPyByb290LmN1cnJlbnQuYWx0ZXJuYXRlIDogbnVsbDtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGJvdW5kYXJ5IHRoYXQgY2FwdHVyZWQgdGhlIGVycm9yLCBvciBudWxsIGlmIHRoZSBlcnJvciBpcyBpZ25vcmVkXG4gIGZ1bmN0aW9uIGNhcHR1cmVFcnJvcihmYWlsZWRXb3JrLCBlcnJvcikge1xuICAgIC8vIEl0IGlzIG5vIGxvbmdlciB2YWxpZCBiZWNhdXNlIHdlIGV4aXRlZCB0aGUgdXNlciBjb2RlLlxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG5cbiAgICAvLyBTZWFyY2ggZm9yIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5LlxuICAgIHZhciBib3VuZGFyeSA9IG51bGw7XG5cbiAgICAvLyBQYXNzZWQgdG8gbG9nQ2FwdHVyZWRFcnJvcigpXG4gICAgdmFyIGVycm9yQm91bmRhcnlGb3VuZCA9IGZhbHNlO1xuICAgIHZhciB3aWxsUmV0cnkgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3JCb3VuZGFyeU5hbWUgPSBudWxsO1xuXG4gICAgLy8gSG9zdCBjb250YWluZXJzIGFyZSBhIHNwZWNpYWwgY2FzZS4gSWYgdGhlIGZhaWxlZCB3b3JrIGl0c2VsZiBpcyBhIGhvc3RcbiAgICAvLyBjb250YWluZXIsIHRoZW4gaXQgYWN0cyBhcyBpdHMgb3duIGJvdW5kYXJ5LiBJbiBhbGwgb3RoZXIgY2FzZXMsIHdlXG4gICAgLy8gaWdub3JlIHRoZSB3b3JrIGl0c2VsZiBhbmQgb25seSBzZWFyY2ggdGhyb3VnaCB0aGUgcGFyZW50cy5cbiAgICBpZiAoZmFpbGVkV29yay50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICBib3VuZGFyeSA9IGZhaWxlZFdvcms7XG5cbiAgICAgIGlmIChpc0ZhaWxlZEJvdW5kYXJ5KGZhaWxlZFdvcmspKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcm9vdCBhbHJlYWR5IGZhaWxlZCwgdGhlcmUgbXVzdCBoYXZlIGJlZW4gYW4gZXJyb3Igd2hlblxuICAgICAgICAvLyBhdHRlbXB0aW5nIHRvIHVubW91bnQgaXQuIFRoaXMgaXMgYSB3b3JzdC1jYXNlIHNjZW5hcmlvIGFuZFxuICAgICAgICAvLyBzaG91bGQgb25seSBiZSBwb3NzaWJsZSBpZiB0aGVyZSdzIGEgYnVnIGluIHRoZSByZW5kZXJlci5cbiAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9kZSA9IGZhaWxlZFdvcmtbJ3JldHVybiddO1xuICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVycm9yQm91bmRhcnlGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IGdldENvbXBvbmVudE5hbWUobm9kZSk7XG5cbiAgICAgICAgICAgIC8vIEZvdW5kIGFuIGVycm9yIGJvdW5kYXJ5IVxuICAgICAgICAgICAgYm91bmRhcnkgPSBub2RlO1xuICAgICAgICAgICAgd2lsbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgICAgLy8gVHJlYXQgdGhlIHJvb3QgbGlrZSBhIG5vLW9wIGVycm9yIGJvdW5kYXJ5XG4gICAgICAgICAgYm91bmRhcnkgPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRmFpbGVkQm91bmRhcnkobm9kZSkpIHtcbiAgICAgICAgICAvLyBUaGlzIGJvdW5kYXJ5IGlzIGFscmVhZHkgaW4gYSBmYWlsZWQgc3RhdGUuXG5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgdW5tb3VudGluZywgdGhhdCBtZWFucyB0aGlzIGVycm9yIHdhc1xuICAgICAgICAgIC8vIHRocm93biB3aGlsZSB1bm1vdW50aW5nIGEgZmFpbGVkIHN1YnRyZWUuIFdlIHNob3VsZCBpZ25vcmVcbiAgICAgICAgICAvLyB0aGUgZXJyb3IuXG4gICAgICAgICAgaWYgKGlzVW5tb3VudGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgd2UncmUgaW4gdGhlIGNvbW1pdCBwaGFzZSwgd2Ugc2hvdWxkIGNoZWNrIHRvIHNlZSBpZlxuICAgICAgICAgIC8vIHRoaXMgYm91bmRhcnkgYWxyZWFkeSBjYXB0dXJlZCBhbiBlcnJvciBkdXJpbmcgdGhpcyBjb21taXQuXG4gICAgICAgICAgLy8gVGhpcyBjYXNlIGV4aXN0cyBiZWNhdXNlIG11bHRpcGxlIGVycm9ycyBjYW4gYmUgdGhyb3duIGR1cmluZ1xuICAgICAgICAgIC8vIGEgc2luZ2xlIGNvbW1pdCB3aXRob3V0IGludGVycnVwdGlvbi5cbiAgICAgICAgICBpZiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzICE9PSBudWxsICYmIChjb21taXRQaGFzZUJvdW5kYXJpZXMuaGFzKG5vZGUpIHx8IG5vZGUuYWx0ZXJuYXRlICE9PSBudWxsICYmIGNvbW1pdFBoYXNlQm91bmRhcmllcy5oYXMobm9kZS5hbHRlcm5hdGUpKSkge1xuICAgICAgICAgICAgLy8gSWYgc28sIHdlIHNob3VsZCBpZ25vcmUgdGhpcyBlcnJvci5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZSBlcnJvciBzaG91bGQgcHJvcGFnYXRlIHRvIHRoZSBuZXh0IGJvdW5kYXJ5IC3igJQgd2Uga2VlcCBsb29raW5nLlxuICAgICAgICAgIGJvdW5kYXJ5ID0gbnVsbDtcbiAgICAgICAgICB3aWxsUmV0cnkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYm91bmRhcnkgIT09IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0byB0aGUgY29sbGVjdGlvbiBvZiBmYWlsZWQgYm91bmRhcmllcy4gVGhpcyBsZXRzIHVzIGtub3cgdGhhdFxuICAgICAgLy8gc3Vic2VxdWVudCBlcnJvcnMgaW4gdGhpcyBzdWJ0cmVlIHNob3VsZCBwcm9wYWdhdGUgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gICAgICBpZiAoZmFpbGVkQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbmV3IFNldCgpO1xuICAgICAgfVxuICAgICAgZmFpbGVkQm91bmRhcmllcy5hZGQoYm91bmRhcnkpO1xuXG4gICAgICAvLyBUaGlzIG1ldGhvZCBpcyB1bnNhZmUgb3V0c2lkZSBvZiB0aGUgYmVnaW4gYW5kIGNvbXBsZXRlIHBoYXNlcy5cbiAgICAgIC8vIFdlIG1pZ2h0IGJlIGluIHRoZSBjb21taXQgcGhhc2Ugd2hlbiBhbiBlcnJvciBpcyBjYXB0dXJlZC5cbiAgICAgIC8vIFRoZSByaXNrIGlzIHRoYXQgdGhlIHJldHVybiBwYXRoIGZyb20gdGhpcyBGaWJlciBtYXkgbm90IGJlIGFjY3VyYXRlLlxuICAgICAgLy8gVGhhdCByaXNrIGlzIGFjY2VwdGFibGUgZ2l2ZW4gdGhlIGJlbmVmaXQgb2YgcHJvdmlkaW5nIHVzZXJzIG1vcmUgY29udGV4dC5cbiAgICAgIHZhciBfY29tcG9uZW50U3RhY2sgPSBnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyKGZhaWxlZFdvcmspO1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmYWlsZWRXb3JrKTtcblxuICAgICAgLy8gQWRkIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGNhcHR1cmVkIGVycm9ycy4gVGhpcyBpcyBzdG9yZWQgYXMgYSBnbG9iYWxcbiAgICAgIC8vIG1hcCBvZiBlcnJvcnMgYW5kIHRoZWlyIGNvbXBvbmVudCBzdGFjayBsb2NhdGlvbiBrZXllZCBieSB0aGUgYm91bmRhcmllc1xuICAgICAgLy8gdGhhdCBjYXB0dXJlIHRoZW0uIFdlIG1vc3RseSB1c2UgdGhpcyBNYXAgYXMgYSBTZXQ7IGl0J3MgYSBNYXAgb25seSB0b1xuICAgICAgLy8gYXZvaWQgYWRkaW5nIGEgZmllbGQgdG8gRmliZXIgdG8gc3RvcmUgdGhlIGVycm9yLlxuICAgICAgaWYgKGNhcHR1cmVkRXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgIGNhcHR1cmVkRXJyb3JzID0gbmV3IE1hcCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FwdHVyZWRFcnJvciA9IHtcbiAgICAgICAgY29tcG9uZW50TmFtZTogX2NvbXBvbmVudE5hbWUsXG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBfY29tcG9uZW50U3RhY2ssXG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgZXJyb3JCb3VuZGFyeTogZXJyb3JCb3VuZGFyeUZvdW5kID8gYm91bmRhcnkuc3RhdGVOb2RlIDogbnVsbCxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kOiBlcnJvckJvdW5kYXJ5Rm91bmQsXG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lOiBlcnJvckJvdW5kYXJ5TmFtZSxcbiAgICAgICAgd2lsbFJldHJ5OiB3aWxsUmV0cnlcbiAgICAgIH07XG5cbiAgICAgIGNhcHR1cmVkRXJyb3JzLnNldChib3VuZGFyeSwgY2FwdHVyZWRFcnJvcik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxvZ0NhcHR1cmVkRXJyb3IoY2FwdHVyZWRFcnJvcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFByZXZlbnQgY3ljbGUgaWYgbG9nQ2FwdHVyZWRFcnJvcigpIHRocm93cy5cbiAgICAgICAgLy8gQSBjeWNsZSBtYXkgc3RpbGwgb2NjdXIgaWYgbG9nQ2FwdHVyZWRFcnJvciByZW5kZXJzIGEgY29tcG9uZW50IHRoYXQgdGhyb3dzLlxuICAgICAgICB2YXIgc3VwcHJlc3NMb2dnaW5nID0gZSAmJiBlLnN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmc7XG4gICAgICAgIGlmICghc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgY29tbWl0IHBoYXNlLCBkZWZlciBzY2hlZHVsaW5nIGFuIHVwZGF0ZSBvbiB0aGVcbiAgICAgIC8vIGJvdW5kYXJ5IHVudGlsIGFmdGVyIHRoZSBjb21taXQgaXMgY29tcGxldGVcbiAgICAgIGlmIChpc0NvbW1pdHRpbmcpIHtcbiAgICAgICAgaWYgKGNvbW1pdFBoYXNlQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb21taXRQaGFzZUJvdW5kYXJpZXMuYWRkKGJvdW5kYXJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2NoZWR1bGUgYW4gdXBkYXRlIG5vdy5cbiAgICAgICAgLy8gVE9ETzogSXMgdGhpcyBhY3R1YWxseSBuZWNlc3NhcnkgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2U/IElzIGl0XG4gICAgICAgIC8vIHBvc3NpYmxlIHRvIHVud2luZCBhbmQgY29udGludWUgcmVuZGVyaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5LFxuICAgICAgICAvLyB3aXRob3V0IGNvcnJ1cHRpbmcgaW50ZXJuYWwgc3RhdGU/XG4gICAgICAgIHNjaGVkdWxlRXJyb3JSZWNvdmVyeShib3VuZGFyeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYm91bmRhcnk7XG4gICAgfSBlbHNlIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIG5vIGJvdW5kYXJ5IGlzIGZvdW5kLCB3ZSdsbCBuZWVkIHRvIHRocm93IHRoZSBlcnJvclxuICAgICAgZmlyc3RVbmNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQ2FwdHVyZWRFcnJvcihmaWJlcikge1xuICAgIC8vIFRPRE86IGNhcHR1cmVkRXJyb3JzIHNob3VsZCBzdG9yZSB0aGUgYm91bmRhcnkgaW5zdGFuY2UsIHRvIGF2b2lkIG5lZWRpbmdcbiAgICAvLyB0byBjaGVjayB0aGUgYWx0ZXJuYXRlLlxuICAgIHJldHVybiBjYXB0dXJlZEVycm9ycyAhPT0gbnVsbCAmJiAoY2FwdHVyZWRFcnJvcnMuaGFzKGZpYmVyKSB8fCBmaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiYgY2FwdHVyZWRFcnJvcnMuaGFzKGZpYmVyLmFsdGVybmF0ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGYWlsZWRCb3VuZGFyeShmaWJlcikge1xuICAgIC8vIFRPRE86IGZhaWxlZEJvdW5kYXJpZXMgc2hvdWxkIHN0b3JlIHRoZSBib3VuZGFyeSBpbnN0YW5jZSwgdG8gYXZvaWRcbiAgICAvLyBuZWVkaW5nIHRvIGNoZWNrIHRoZSBhbHRlcm5hdGUuXG4gICAgcmV0dXJuIGZhaWxlZEJvdW5kYXJpZXMgIT09IG51bGwgJiYgKGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyKSB8fCBmaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiYgZmFpbGVkQm91bmRhcmllcy5oYXMoZmliZXIuYWx0ZXJuYXRlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRFcnJvckhhbmRsaW5nKGVmZmVjdGZ1bEZpYmVyKSB7XG4gICAgdmFyIGNhcHR1cmVkRXJyb3IgPSB2b2lkIDA7XG4gICAgaWYgKGNhcHR1cmVkRXJyb3JzICE9PSBudWxsKSB7XG4gICAgICBjYXB0dXJlZEVycm9yID0gY2FwdHVyZWRFcnJvcnMuZ2V0KGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgIGNhcHR1cmVkRXJyb3JzWydkZWxldGUnXShlZmZlY3RmdWxGaWJlcik7XG4gICAgICBpZiAoY2FwdHVyZWRFcnJvciA9PSBudWxsKSB7XG4gICAgICAgIGlmIChlZmZlY3RmdWxGaWJlci5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICBlZmZlY3RmdWxGaWJlciA9IGVmZmVjdGZ1bEZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICBjYXB0dXJlZEVycm9yID0gY2FwdHVyZWRFcnJvcnMuZ2V0KGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgICAgICBjYXB0dXJlZEVycm9yc1snZGVsZXRlJ10oZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShjYXB0dXJlZEVycm9yICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnTm8gZXJyb3IgZm9yIGdpdmVuIHVuaXQgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHN3aXRjaCAoZWZmZWN0ZnVsRmliZXIudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBlZmZlY3RmdWxGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgY29tcG9uZW50U3RhY2s6IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50U3RhY2tcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBbGxvdyB0aGUgYm91bmRhcnkgdG8gaGFuZGxlIHRoZSBlcnJvciwgdXN1YWxseSBieSBzY2hlZHVsaW5nXG4gICAgICAgIC8vIGFuIHVwZGF0ZSB0byBpdHNlbGZcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2goY2FwdHVyZWRFcnJvci5lcnJvciwgaW5mbyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBjYXB0dXJlZEVycm9yLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdHlwZSBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVud2luZENvbnRleHRzKGZyb20sIHRvKSB7XG4gICAgdmFyIG5vZGUgPSBmcm9tO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgcG9wQ29udGV4dFByb3ZpZGVyKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gdG8gfHwgbm9kZS5hbHRlcm5hdGUgPT09IHRvKSB7XG4gICAgICAgIHN0b3BGYWlsZWRXb3JrVGltZXIobm9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcihub2RlKTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCkge1xuICAgIC8vIEdpdmVuIHRoZSBjdXJyZW50IGNsb2NrIHRpbWUsIHJldHVybnMgYW4gZXhwaXJhdGlvbiB0aW1lLiBXZSB1c2Ugcm91bmRpbmdcbiAgICAvLyB0byBiYXRjaCBsaWtlIHVwZGF0ZXMgdG9nZXRoZXIuXG4gICAgLy8gU2hvdWxkIGNvbXBsZXRlIHdpdGhpbiB+MTAwMG1zLiAxMjAwbXMgbWF4LlxuICAgIHZhciBjdXJyZW50VGltZSA9IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKTtcbiAgICB2YXIgZXhwaXJhdGlvbk1zID0gMTAwMDtcbiAgICB2YXIgYnVja2V0U2l6ZU1zID0gMjAwO1xuICAgIHJldHVybiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgZXhwaXJhdGlvbk1zLCBidWNrZXRTaXplTXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcikge1xuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IHZvaWQgMDtcbiAgICBpZiAoZXhwaXJhdGlvbkNvbnRleHQgIT09IE5vV29yaykge1xuICAgICAgLy8gQW4gZXhwbGljaXQgZXhwaXJhdGlvbiBjb250ZXh0IHdhcyBzZXQ7XG4gICAgICBleHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25Db250ZXh0O1xuICAgIH0gZWxzZSBpZiAoaXNXb3JraW5nKSB7XG4gICAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICAgIC8vIFVwZGF0ZXMgdGhhdCBvY2N1ciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSBzaG91bGQgaGF2ZSBzeW5jIHByaW9yaXR5XG4gICAgICAgIC8vIGJ5IGRlZmF1bHQuXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVwZGF0ZXMgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2Ugc2hvdWxkIGV4cGlyZSBhdCB0aGUgc2FtZSB0aW1lIGFzXG4gICAgICAgIC8vIHRoZSB3b3JrIHRoYXQgaXMgYmVpbmcgcmVuZGVyZWQuXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBleHBsaWNpdCBleHBpcmF0aW9uIGNvbnRleHQgd2FzIHNldCwgYW5kIHdlJ3JlIG5vdCBjdXJyZW50bHlcbiAgICAgIC8vIHBlcmZvcm1pbmcgd29yay4gQ2FsY3VsYXRlIGEgbmV3IGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmICh1c2VTeW5jU2NoZWR1bGluZyAmJiAhKGZpYmVyLmludGVybmFsQ29udGV4dFRhZyAmIEFzeW5jVXBkYXRlcykpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHN5bmMgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gYXN5bmMgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgcmV0dXJuIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIGV4cGlyYXRpb25UaW1lLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Jvb3ROZWVkc0NsZWFyaW5nKHJvb3QsIGZpYmVyLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmICghaXNXb3JraW5nICYmIHJvb3QgPT09IG5leHRSb290ICYmIGV4cGlyYXRpb25UaW1lIDwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBSZXN0YXJ0IHRoZSByb290IGZyb20gdGhlIHRvcC5cbiAgICAgIGlmIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGludGVycnVwdGlvbi4gKFVzZWQgZm9yIHBlcmZvcm1hbmNlIHRyYWNraW5nLilcbiAgICAgICAgaW50ZXJydXB0ZWRCeSA9IGZpYmVyO1xuICAgICAgfVxuICAgICAgbmV4dFJvb3QgPSBudWxsO1xuICAgICAgbmV4dFVuaXRPZldvcmsgPSBudWxsO1xuICAgICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIGV4cGlyYXRpb25UaW1lLCBpc0Vycm9yUmVjb3ZlcnkpIHtcbiAgICByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpO1xuXG4gICAge1xuICAgICAgaWYgKCFpc0Vycm9yUmVjb3ZlcnkgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIHdhcm5BYm91dEludmFsaWRVcGRhdGVzKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAvLyBXYWxrIHRoZSBwYXJlbnQgcGF0aCB0byB0aGUgcm9vdCBhbmQgdXBkYXRlIGVhY2ggbm9kZSdzXG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICBpZiAobm9kZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5vZGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICBub2RlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgIG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgICAgdmFyIHJvb3QgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGNoZWNrUm9vdE5lZWRzQ2xlYXJpbmcocm9vdCwgZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICByZXF1ZXN0V29yayhyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgY2hlY2tSb290TmVlZHNDbGVhcmluZyhyb290LCBmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghaXNFcnJvclJlY292ZXJ5ICYmIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQoZmliZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZUVycm9yUmVjb3ZlcnkoZmliZXIpIHtcbiAgICBzY2hlZHVsZVdvcmtJbXBsKGZpYmVyLCBTeW5jLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKSB7XG4gICAgLy8gU3VidHJhY3QgaW5pdGlhbCB0aW1lIHNvIGl0IGZpdHMgaW5zaWRlIDMyYml0c1xuICAgIHZhciBtcyA9IG5vdygpIC0gc3RhcnRUaW1lO1xuICAgIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZShtcyk7XG4gICAgcmV0dXJuIG1vc3RSZWNlbnRDdXJyZW50VGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmVycmVkVXBkYXRlcyhmbikge1xuICAgIHZhciBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0ID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgZXhwaXJhdGlvbkNvbnRleHQgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHBpcmF0aW9uQ29udGV4dCA9IHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3luY1VwZGF0ZXMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dCA9IGV4cGlyYXRpb25Db250ZXh0O1xuICAgIGV4cGlyYXRpb25Db250ZXh0ID0gU3luYztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4cGlyYXRpb25Db250ZXh0ID0gcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dDtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBFdmVyeXRoaW5nIGJlbG93IHRoaXMgaXMgd3JpdHRlbiBhcyBpZiBpdCBoYXMgYmVlbiBsaWZ0ZWQgdG8gdGhlXG4gIC8vIHJlbmRlcmVycy4gSSdsbCBkbyB0aGlzIGluIGEgZm9sbG93LXVwLlxuXG4gIC8vIExpbmtlZC1saXN0IG9mIHJvb3RzXG4gIHZhciBmaXJzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICB2YXIgbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuXG4gIHZhciBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB2YXIgY2FsbGJhY2tJRCA9IC0xO1xuICB2YXIgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgdmFyIG5leHRGbHVzaGVkUm9vdCA9IG51bGw7XG4gIHZhciBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB2YXIgZGVhZGxpbmVEaWRFeHBpcmUgPSBmYWxzZTtcbiAgdmFyIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gIHZhciB1bmhhbmRsZWRFcnJvciA9IG51bGw7XG4gIHZhciBkZWFkbGluZSA9IG51bGw7XG5cbiAgdmFyIGlzQmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gIHZhciBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG5cbiAgLy8gVXNlIHRoZXNlIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiBuZXN0ZWQgdXBkYXRlc1xuICB2YXIgTkVTVEVEX1VQREFURV9MSU1JVCA9IDEwMDA7XG4gIHZhciBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG5cbiAgdmFyIHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrID0gMTtcblxuICBmdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24oZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY2FsbGJhY2tFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICAvLyBBIGNhbGxiYWNrIGlzIGFscmVhZHkgc2NoZWR1bGVkLiBDaGVjayBpdHMgZXhwaXJhdGlvbiB0aW1lICh0aW1lb3V0KS5cbiAgICAgIGlmIChleHBpcmF0aW9uVGltZSA+IGNhbGxiYWNrRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgLy8gRXhpc3RpbmcgY2FsbGJhY2sgaGFzIHN1ZmZpY2llbnQgdGltZW91dC4gRXhpdC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXhpc3RpbmcgY2FsbGJhY2sgaGFzIGluc3VmZmljaWVudCB0aW1lb3V0LiBDYW5jZWwgYW5kIHNjaGVkdWxlIGFcbiAgICAgICAgLy8gbmV3IG9uZS5cbiAgICAgICAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjayhjYWxsYmFja0lEKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGNhbGxiYWNrIHRpbWVyIGlzIGFscmVhZHkgcnVubmluZy4gRG9uJ3Qgc3RhcnQgYSBuZXcgb25lLlxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyKCk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBhIHRpbWVvdXQgZm9yIHRoZSBnaXZlbiBleHBpcmF0aW9uIHRpbWUuXG4gICAgdmFyIGN1cnJlbnRNcyA9IG5vdygpIC0gc3RhcnRUaW1lO1xuICAgIHZhciBleHBpcmF0aW9uTXMgPSBleHBpcmF0aW9uVGltZVRvTXMoZXhwaXJhdGlvblRpbWUpO1xuICAgIHZhciB0aW1lb3V0ID0gZXhwaXJhdGlvbk1zIC0gY3VycmVudE1zO1xuXG4gICAgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIGNhbGxiYWNrSUQgPSBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2socGVyZm9ybUFzeW5jV29yaywgeyB0aW1lb3V0OiB0aW1lb3V0IH0pO1xuICB9XG5cbiAgLy8gcmVxdWVzdFdvcmsgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgd2hlbmV2ZXIgYSByb290IHJlY2VpdmVzIGFuIHVwZGF0ZS5cbiAgLy8gSXQncyB1cCB0byB0aGUgcmVuZGVyZXIgdG8gY2FsbCByZW5kZXJSb290IGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cbiAgZnVuY3Rpb24gcmVxdWVzdFdvcmsocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAobmVzdGVkVXBkYXRlQ291bnQgPiBORVNURURfVVBEQVRFX0xJTUlUKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgcmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciBjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuJyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSByb290IHRvIHRoZSBzY2hlZHVsZS5cbiAgICAvLyBDaGVjayBpZiB0aGlzIHJvb3QgaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBzY2hlZHVsZS5cbiAgICBpZiAocm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyByb290IGlzIG5vdCBhbHJlYWR5IHNjaGVkdWxlZC4gQWRkIGl0LlxuICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKGxhc3RTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgcm9vdCBpcyBhbHJlYWR5IHNjaGVkdWxlZCwgYnV0IGl0cyBwcmlvcml0eSBtYXkgaGF2ZSBpbmNyZWFzZWQuXG4gICAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgZXhwaXJhdGlvblRpbWUgPCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHByaW9yaXR5LlxuICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzUmVuZGVyaW5nKSB7XG4gICAgICAvLyBQcmV2ZW50IHJlZW50cmFuY3kuIFJlbWFpbmluZyB3b3JrIHdpbGwgYmUgc2NoZWR1bGVkIGF0IHRoZSBlbmQgb2ZcbiAgICAgIC8vIHRoZSBjdXJyZW50bHkgcmVuZGVyaW5nIGJhdGNoLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0JhdGNoaW5nVXBkYXRlcykge1xuICAgICAgLy8gRmx1c2ggd29yayBhdCB0aGUgZW5kIG9mIHRoZSBiYXRjaC5cbiAgICAgIGlmIChpc1VuYmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAgIC8vIC4uLnVubGVzcyB3ZSdyZSBpbnNpZGUgdW5iYXRjaGVkVXBkYXRlcywgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGRcbiAgICAgICAgLy8gZmx1c2ggaXQgbm93LlxuICAgICAgICBuZXh0Rmx1c2hlZFJvb3QgPSByb290O1xuICAgICAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgICAgcGVyZm9ybVdvcmtPblJvb3QobmV4dEZsdXNoZWRSb290LCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBHZXQgcmlkIG9mIFN5bmMgYW5kIHVzZSBjdXJyZW50IHRpbWU/XG4gICAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBTeW5jKSB7XG4gICAgICBwZXJmb3JtV29yayhTeW5jLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpIHtcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5V29yayA9IE5vV29yaztcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5Um9vdCA9IG51bGw7XG5cbiAgICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIHZhciByb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgICAgd2hpbGUgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmspIHtcbiAgICAgICAgICAvLyBUaGlzIHJvb3Qgbm8gbG9uZ2VyIGhhcyB3b3JrLiBSZW1vdmUgaXQgZnJvbSB0aGUgc2NoZWR1bGVyLlxuXG4gICAgICAgICAgLy8gVE9ETzogVGhpcyBjaGVjayBpcyByZWR1ZGFudCwgYnV0IEZsb3cgaXMgY29uZnVzZWQgYnkgdGhlIGJyYW5jaFxuICAgICAgICAgIC8vIGJlbG93IHdoZXJlIHdlIHNldCBsYXN0U2NoZWR1bGVkUm9vdCB0byBudWxsLCBldmVuIHRob3VnaCB3ZSBicmVha1xuICAgICAgICAgIC8vIGZyb20gdGhlIGxvb3AgcmlnaHQgYWZ0ZXIuXG4gICAgICAgICAgIShwcmV2aW91c1NjaGVkdWxlZFJvb3QgIT09IG51bGwgJiYgbGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgYSBwcmV2aW91cyBhbmQgbGFzdCByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgIGlmIChyb290ID09PSByb290Lm5leHRTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gZmlyc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgdmFyIG5leHQgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGxhc3Qgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcHJldmlvdXNTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91c1NjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvb3QgPSBwcmV2aW91c1NjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGhpZ2hlc3RQcmlvcml0eVdvcmsgPT09IE5vV29yayB8fCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA8IGhpZ2hlc3RQcmlvcml0eVdvcmspIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJpb3JpdHksIGlmIGl0J3MgaGlnaGVyXG4gICAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlXb3JrID0gcmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlSb290ID0gcm9vdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvb3QgPT09IGxhc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldmlvdXNTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgICByb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBuZXh0IHJvb3QgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIHJvb3QsIHRoaXMgaXMgYSBuZXN0ZWRcbiAgICAvLyB1cGRhdGUuIFRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCwgaW5jcmVtZW50IHRoZSBuZXN0ZWQgdXBkYXRlIGNvdW50LlxuICAgIHZhciBwcmV2aW91c0ZsdXNoZWRSb290ID0gbmV4dEZsdXNoZWRSb290O1xuICAgIGlmIChwcmV2aW91c0ZsdXNoZWRSb290ICE9PSBudWxsICYmIHByZXZpb3VzRmx1c2hlZFJvb3QgPT09IGhpZ2hlc3RQcmlvcml0eVJvb3QpIHtcbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc2V0IHdoZW5ldmVyIHdlIHN3aXRjaCByb290cy5cbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgICB9XG4gICAgbmV4dEZsdXNoZWRSb290ID0gaGlnaGVzdFByaW9yaXR5Um9vdDtcbiAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gaGlnaGVzdFByaW9yaXR5V29yaztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Bc3luY1dvcmsoZGwpIHtcbiAgICBwZXJmb3JtV29yayhOb1dvcmssIGRsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrKG1pbkV4cGlyYXRpb25UaW1lLCBkbCkge1xuICAgIGRlYWRsaW5lID0gZGw7XG5cbiAgICAvLyBLZWVwIHdvcmtpbmcgb24gcm9vdHMgdW50aWwgdGhlcmUncyBubyBtb3JlIHdvcmssIG9yIHVudGlsIHRoZSB3ZSByZWFjaFxuICAgIC8vIHRoZSBkZWFkbGluZS5cbiAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuXG4gICAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkgJiYgZGVhZGxpbmUgIT09IG51bGwpIHtcbiAgICAgIHZhciBkaWRFeHBpcmUgPSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lIDwgcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgICAgc3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyKGRpZEV4cGlyZSk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG1pbkV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA8PSBtaW5FeHBpcmF0aW9uVGltZSkgJiYgIWRlYWRsaW5lRGlkRXhwaXJlKSB7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChuZXh0Rmx1c2hlZFJvb3QsIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgLy8gRmluZCB0aGUgbmV4dCBoaWdoZXN0IHByaW9yaXR5IHdvcmsuXG4gICAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuICAgIH1cblxuICAgIC8vIFdlJ3JlIGRvbmUgZmx1c2hpbmcgd29yay4gRWl0aGVyIHdlIHJhbiBvdXQgb2YgdGltZSBpbiB0aGlzIGNhbGxiYWNrLFxuICAgIC8vIG9yIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGxlZnQgd2l0aCBzdWZmaWNpZW50IHByaW9yaXR5LlxuXG4gICAgLy8gSWYgd2UncmUgaW5zaWRlIGEgY2FsbGJhY2ssIHNldCB0aGlzIHRvIGZhbHNlIHNpbmNlIHdlIGp1c3QgY29tcGxldGVkIGl0LlxuICAgIGlmIChkZWFkbGluZSAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICAgIGNhbGxiYWNrSUQgPSAtMTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUncyB3b3JrIGxlZnQgb3Zlciwgc2NoZWR1bGUgYSBuZXcgY2FsbGJhY2suXG4gICAgaWYgKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykge1xuICAgICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIC8vIENsZWFuLXVwLlxuICAgIGRlYWRsaW5lID0gbnVsbDtcbiAgICBkZWFkbGluZURpZEV4cGlyZSA9IGZhbHNlO1xuICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblxuICAgIGlmIChoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgdmFyIF9lcnJvcjQgPSB1bmhhbmRsZWRFcnJvcjtcbiAgICAgIHVuaGFuZGxlZEVycm9yID0gbnVsbDtcbiAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gICAgICB0aHJvdyBfZXJyb3I0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ3BlcmZvcm1Xb3JrT25Sb290IHdhcyBjYWxsZWQgcmVjdXJzaXZlbHkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICBpc1JlbmRlcmluZyA9IHRydWU7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFzeW5jIHdvcmsgb3Igc3luYy9leHBpcmVkIHdvcmsuXG4gICAgLy8gVE9ETzogUGFzcyBjdXJyZW50IHRpbWUgYXMgYXJndW1lbnQgdG8gcmVuZGVyUm9vdCwgY29tbWl0Um9vdFxuICAgIGlmIChleHBpcmF0aW9uVGltZSA8PSByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCkpIHtcbiAgICAgIC8vIEZsdXNoIHN5bmMgd29yay5cbiAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoZmluaXNoZWRXb3JrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgZmluaXNoZWRXb3JrID0gcmVuZGVyUm9vdChyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENvbW1pdCBpdC5cbiAgICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jIHdvcmsuXG4gICAgICB2YXIgX2ZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoX2ZpbmlzaGVkV29yayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICAgIF9maW5pc2hlZFdvcmsgPSByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENoZWNrIHRoZSBkZWFkbGluZSBvbmUgbW9yZSB0aW1lXG4gICAgICAgICAgLy8gYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgaWYgKCFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgICAgICAvLyBTdGlsbCB0aW1lIGxlZnQuIENvbW1pdCB0aGUgcm9vdC5cbiAgICAgICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KF9maW5pc2hlZFdvcmspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSdzIG5vIHRpbWUgbGVmdC4gTWFyayB0aGlzIHJvb3QgYXMgY29tcGxldGUuIFdlJ2xsIGNvbWVcbiAgICAgICAgICAgIC8vIGJhY2sgYW5kIGNvbW1pdCBpdCBsYXRlci5cbiAgICAgICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gX2ZpbmlzaGVkV29yaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gV2hlbiB3b3JraW5nIG9uIGFzeW5jIHdvcmssIHRoZSByZWNvbmNpbGVyIGFza3MgdGhlIHJlbmRlcmVyIGlmIGl0IHNob3VsZFxuICAvLyB5aWVsZCBleGVjdXRpb24uIEZvciBET00sIHdlIGltcGxlbWVudCB0aGlzIHdpdGggcmVxdWVzdElkbGVDYWxsYmFjay5cbiAgZnVuY3Rpb24gc2hvdWxkWWllbGQoKSB7XG4gICAgaWYgKGRlYWRsaW5lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiB0aW1lSGV1cmlzdGljRm9yVW5pdE9mV29yaykge1xuICAgICAgLy8gRGlzcmVnYXJkIGRlYWRsaW5lLmRpZFRpbWVvdXQuIE9ubHkgZXhwaXJlZCB3b3JrIHNob3VsZCBiZSBmbHVzaGVkXG4gICAgICAvLyBkdXJpbmcgYSB0aW1lb3V0LiBUaGlzIHBhdGggaXMgb25seSBoaXQgZm9yIG5vbi1leHBpcmVkIHdvcmsuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlYWRsaW5lRGlkRXhwaXJlID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRPRE86IE5vdCBoYXBweSBhYm91dCB0aGlzIGhvb2suIENvbmNlcHR1YWxseSwgcmVuZGVyUm9vdCBzaG91bGQgcmV0dXJuIGFcbiAgLy8gdHVwbGUgb2YgKGlzUmVhZHlGb3JDb21taXQsIGRpZEVycm9yLCBlcnJvcilcbiAgZnVuY3Rpb24gb25VbmNhdWdodEVycm9yKGVycm9yKSB7XG4gICAgIShuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGJlIHdvcmtpbmcgb24gYSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIC8vIFVuc2NoZWR1bGUgdGhpcyByb290IHNvIHdlIGRvbid0IHdvcmsgb24gaXQgYWdhaW4gdW50aWwgdGhlcmUnc1xuICAgIC8vIGFub3RoZXIgdXBkYXRlLlxuICAgIG5leHRGbHVzaGVkUm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCBpbnNpZGVcbiAgLy8gdGhlIHJlY29uY2lsZXIuXG4gIGZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuICAvLyB0aGUgcmVjb25jaWxlci5cbiAgZnVuY3Rpb24gdW5iYXRjaGVkVXBkYXRlcyhmbikge1xuICAgIGlmIChpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNVbmJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZuKCk7XG4gIH1cblxuICAvLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3Qgd2l0aGluXG4gIC8vIHRoZSByZWNvbmNpbGVyLlxuICBmdW5jdGlvbiBmbHVzaFN5bmMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN5bmNVcGRhdGVzKGZuKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ2ZsdXNoU3luYyB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgbGlmZWN5Y2xlIG1ldGhvZC4gSXQgY2Fubm90IGJlIGNhbGxlZCB3aGVuIFJlYWN0IGlzIGFscmVhZHkgcmVuZGVyaW5nLicpIDogdm9pZCAwO1xuICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wdXRlQXN5bmNFeHBpcmF0aW9uOiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uLFxuICAgIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXI6IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsXG4gICAgc2NoZWR1bGVXb3JrOiBzY2hlZHVsZVdvcmssXG4gICAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuICAgIHVuYmF0Y2hlZFVwZGF0ZXM6IHVuYmF0Y2hlZFVwZGF0ZXMsXG4gICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG4gICAgZGVmZXJyZWRVcGRhdGVzOiBkZWZlcnJlZFVwZGF0ZXNcbiAgfTtcbn07XG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSBmYWxzZTtcbn1cblxuLy8gMCBpcyBQUk9ELCAxIGlzIERFVi5cbi8vIE1pZ2h0IGFkZCBQUk9GSUxFIGxhdGVyLlxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCkge1xuICBpZiAoIXBhcmVudENvbXBvbmVudCkge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChwYXJlbnRDb21wb25lbnQpO1xuICB2YXIgcGFyZW50Q29udGV4dCA9IGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKTtcbiAgcmV0dXJuIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSA/IHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIDogcGFyZW50Q29udGV4dDtcbn1cblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBnZXRQdWJsaWNJbnN0YW5jZSA9IGNvbmZpZy5nZXRQdWJsaWNJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJTY2hlZHVsZXIgPSBSZWFjdEZpYmVyU2NoZWR1bGVyKGNvbmZpZyksXG4gICAgICBjb21wdXRlQXN5bmNFeHBpcmF0aW9uID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuY29tcHV0ZUFzeW5jRXhwaXJhdGlvbixcbiAgICAgIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5jb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLFxuICAgICAgc2NoZWR1bGVXb3JrID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuc2NoZWR1bGVXb3JrLFxuICAgICAgYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5iYXRjaGVkVXBkYXRlcyxcbiAgICAgIHVuYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci51bmJhdGNoZWRVcGRhdGVzLFxuICAgICAgZmx1c2hTeW5jID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZmx1c2hTeW5jLFxuICAgICAgZGVmZXJyZWRVcGRhdGVzID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZGVmZXJyZWRVcGRhdGVzO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlVG9wTGV2ZWxVcGRhdGUoY3VycmVudCwgZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICB7XG4gICAgICBpZiAoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9PT0gJ3JlbmRlcicgJiYgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50ICE9PSBudWxsICYmICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7ICcgKyAndHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuICcgKyAnSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG4nICsgJ0NoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIGdldENvbXBvbmVudE5hbWUoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50KSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICB7XG4gICAgICB3YXJuaW5nKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJywgJ3JlbmRlciguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IHZvaWQgMDtcbiAgICAvLyBDaGVjayBpZiB0aGUgdG9wLWxldmVsIGVsZW1lbnQgaXMgYW4gYXN5bmMgd3JhcHBlciBjb21wb25lbnQuIElmIHNvLFxuICAgIC8vIHRyZWF0IHVwZGF0ZXMgdG8gdGhlIHJvb3QgYXMgYXN5bmMuIFRoaXMgaXMgYSBiaXQgd2VpcmQgYnV0IGxldHMgdXNcbiAgICAvLyBhdm9pZCBhIHNlcGFyYXRlIGByZW5kZXJBc3luY2AgQVBJLlxuICAgIGlmIChlbmFibGVBc3luY1N1YnRyZWVBUEkgJiYgZWxlbWVudCAhPSBudWxsICYmIGVsZW1lbnQudHlwZSAhPSBudWxsICYmIGVsZW1lbnQudHlwZS5wcm90b3R5cGUgIT0gbnVsbCAmJiBlbGVtZW50LnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9PT0gdHJ1ZSkge1xuICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50KTtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgcGFydGlhbFN0YXRlOiB7IGVsZW1lbnQ6IGVsZW1lbnQgfSxcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIGlzUmVwbGFjZTogZmFsc2UsXG4gICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoY3VycmVudCwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsoY3VycmVudCwgZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZShmaWJlcikge1xuICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG4gICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVDb250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXJJbmZvLCBoeWRyYXRlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIGh5ZHJhdGUpO1xuICAgIH0sXG4gICAgdXBkYXRlQ29udGFpbmVyOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgbmVzdGVkIGNvbnRhaW5lciwgdGhpcyB3b24ndCBiZSB0aGUgcm9vdC5cbiAgICAgIHZhciBjdXJyZW50ID0gY29udGFpbmVyLmN1cnJlbnQ7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Nb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVubW91bnRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVwZGF0ZUNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG4gICAgICBpZiAoY29udGFpbmVyLmNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgICAgY29udGFpbmVyLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnBlbmRpbmdDb250ZXh0ID0gY29udGV4dDtcbiAgICAgIH1cblxuICAgICAgc2NoZWR1bGVUb3BMZXZlbFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgfSxcblxuXG4gICAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuXG4gICAgdW5iYXRjaGVkVXBkYXRlczogdW5iYXRjaGVkVXBkYXRlcyxcblxuICAgIGRlZmVycmVkVXBkYXRlczogZGVmZXJyZWRVcGRhdGVzLFxuXG4gICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG5cbiAgICBnZXRQdWJsaWNSb290SW5zdGFuY2U6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgIHZhciBjb250YWluZXJGaWJlciA9IGNvbnRhaW5lci5jdXJyZW50O1xuICAgICAgaWYgKCFjb250YWluZXJGaWJlci5jaGlsZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY29udGFpbmVyRmliZXIuY2hpbGQudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH0sXG5cblxuICAgIGZpbmRIb3N0SW5zdGFuY2U6IGZpbmRIb3N0SW5zdGFuY2UsXG5cbiAgICBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFsczogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcbiAgICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgICB9LFxuICAgIGluamVjdEludG9EZXZUb29sczogZnVuY3Rpb24gKGRldlRvb2xzQ29uZmlnKSB7XG4gICAgICB2YXIgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgPSBkZXZUb29sc0NvbmZpZy5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTtcblxuICAgICAgcmV0dXJuIGluamVjdEludGVybmFscyhfYXNzaWduKHt9LCBkZXZUb29sc0NvbmZpZywge1xuICAgICAgICBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbmRIb3N0SW5zdGFuY2UoZmliZXIpO1xuICAgICAgICB9LFxuICAgICAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgaWYgKCFmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSkge1xuICAgICAgICAgICAgLy8gTWlnaHQgbm90IGJlIGltcGxlbWVudGVkIGJ5IHRoZSByZW5kZXJlci5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3RGaWJlclJlY29uY2lsZXIkMVxufSk7XG5cbnZhciBSZWFjdEZpYmVyUmVjb25jaWxlciQzID0gKCBSZWFjdEZpYmVyUmVjb25jaWxlciQyICYmIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgKSB8fCBSZWFjdEZpYmVyUmVjb25jaWxlciQyO1xuXG4vLyBUT0RPOiBidW5kbGUgRmxvdyB0eXBlcyB3aXRoIHRoZSBwYWNrYWdlLlxuXG5cblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3RSZWNvbmNpbGVyID0gUmVhY3RGaWJlclJlY29uY2lsZXIkM1snZGVmYXVsdCddID8gUmVhY3RGaWJlclJlY29uY2lsZXIkM1snZGVmYXVsdCddIDogUmVhY3RGaWJlclJlY29uY2lsZXIkMztcblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sXG4vLyBUT0RPOiBmaWd1cmUgb3V0IHRoZSBBUEkgZm9yIGNyb3NzLXJlbmRlcmVyIGltcGxlbWVudGF0aW9uLlxuaW1wbGVtZW50YXRpb24pIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBQb3J0YWxcbiAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAga2V5OiBrZXkgPT0gbnVsbCA/IG51bGwgOiAnJyArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn1cblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMi4wJztcblxuLy8gYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIHN0b3JpbmcgdGhlIHRpbWUgZm9yIHRoZSBzdGFydCBvZiB0aGUgZnJhbWUsIHRoZW5cbi8vIHNjaGVkdWxpbmcgYSBwb3N0TWVzc2FnZSB3aGljaCBnZXRzIHNjaGVkdWxlZCBhZnRlciBwYWludC4gV2l0aGluIHRoZVxuLy8gcG9zdE1lc3NhZ2UgaGFuZGxlciBkbyBhcyBtdWNoIHdvcmsgYXMgcG9zc2libGUgdW50aWwgdGltZSArIGZyYW1lIHJhdGUuXG4vLyBCeSBzZXBhcmF0aW5nIHRoZSBpZGxlIGNhbGwgaW50byBhIHNlcGFyYXRlIGV2ZW50IHRpY2sgd2UgZW5zdXJlIHRoYXRcbi8vIGxheW91dCwgcGFpbnQgYW5kIG90aGVyIGJyb3dzZXIgd29yayBpcyBjb3VudGVkIGFnYWluc3QgdGhlIGF2YWlsYWJsZSB0aW1lLlxuLy8gVGhlIGZyYW1lIHJhdGUgaXMgZHluYW1pY2FsbHkgYWRqdXN0ZWQuXG5cbntcbiAgaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRlcGVuZHMgb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHA6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxufVxuXG52YXIgaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbic7XG5cbnZhciBub3cgPSB2b2lkIDA7XG5pZiAoaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cpIHtcbiAgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfTtcbn1cblxuLy8gVE9ETzogVGhlcmUncyBubyB3YXkgdG8gY2FuY2VsLCBiZWNhdXNlIEZpYmVyIGRvZXNuJ3QgYXRtLlxudmFyIHJJQyA9IHZvaWQgMDtcbnZhciBjSUMgPSB2b2lkIDA7XG5cbmlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHJJQyA9IGZ1bmN0aW9uIChmcmFtZUNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZnJhbWVDYWxsYmFjayh7XG4gICAgICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBjSUMgPSBmdW5jdGlvbiAodGltZW91dElEKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjYW5jZWxJZGxlQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgLy8gUG9seWZpbGwgcmVxdWVzdElkbGVDYWxsYmFjayBhbmQgY2FuY2VsSWRsZUNhbGxiYWNrXG5cbiAgdmFyIHNjaGVkdWxlZFJJQ0NhbGxiYWNrID0gbnVsbDtcbiAgdmFyIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgdGltZW91dFRpbWUgPSAtMTtcblxuICB2YXIgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIHZhciBmcmFtZURlYWRsaW5lID0gMDtcbiAgLy8gV2Ugc3RhcnQgb3V0IGFzc3VtaW5nIHRoYXQgd2UgcnVuIGF0IDMwZnBzIGJ1dCB0aGVuIHRoZSBoZXVyaXN0aWMgdHJhY2tpbmdcbiAgLy8gd2lsbCBhZGp1c3QgdGhpcyB2YWx1ZSB0byBhIGZhc3RlciBmcHMgaWYgd2UgZ2V0IG1vcmUgZnJlcXVlbnQgYW5pbWF0aW9uXG4gIC8vIGZyYW1lcy5cbiAgdmFyIHByZXZpb3VzRnJhbWVUaW1lID0gMzM7XG4gIHZhciBhY3RpdmVGcmFtZVRpbWUgPSAzMztcblxuICB2YXIgZnJhbWVEZWFkbGluZU9iamVjdDtcbiAgaWYgKGhhc05hdGl2ZVBlcmZvcm1hbmNlTm93KSB7XG4gICAgZnJhbWVEZWFkbGluZU9iamVjdCA9IHtcbiAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBpZiB3ZSBoYXZlIGEgcGVyZm9ybWFuY2UgdGltZXIgdGhhdCB0aGUgckFGIGNhbGxiYWNrXG4gICAgICAgIC8vIGdldHMgYSBwZXJmb3JtYW5jZSB0aW1lciB2YWx1ZS4gTm90IHN1cmUgaWYgdGhpcyBpcyBhbHdheXMgdHJ1ZS5cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGZyYW1lRGVhZGxpbmUgLSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZyA+IDAgPyByZW1haW5pbmcgOiAwO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZnJhbWVEZWFkbGluZU9iamVjdCA9IHtcbiAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBGYWxsYmFjayB0byBEYXRlLm5vdygpXG4gICAgICAgIHZhciByZW1haW5pbmcgPSBmcmFtZURlYWRsaW5lIC0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZyA+IDAgPyByZW1haW5pbmcgOiAwO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBXZSB1c2UgdGhlIHBvc3RNZXNzYWdlIHRyaWNrIHRvIGRlZmVyIGlkbGUgd29yayB1bnRpbCBhZnRlciB0aGUgcmVwYWludC5cbiAgdmFyIG1lc3NhZ2VLZXkgPSAnX19yZWFjdElkbGVDYWxsYmFjayQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG4gIHZhciBpZGxlVGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5zb3VyY2UgIT09IHdpbmRvdyB8fCBldmVudC5kYXRhICE9PSBtZXNzYWdlS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICB2YXIgY3VycmVudFRpbWUgPSBub3coKTtcbiAgICBpZiAoZnJhbWVEZWFkbGluZSAtIGN1cnJlbnRUaW1lIDw9IDApIHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0IGluIHRoaXMgaWRsZSBwZXJpb2QuIENoZWNrIGlmIHRoZSBjYWxsYmFjayBoYXNcbiAgICAgIC8vIGEgdGltZW91dCBhbmQgd2hldGhlciBpdCdzIGJlZW4gZXhjZWVkZWQuXG4gICAgICBpZiAodGltZW91dFRpbWUgIT09IC0xICYmIHRpbWVvdXRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIC8vIEV4Y2VlZGVkIHRoZSB0aW1lb3V0LiBJbnZva2UgdGhlIGNhbGxiYWNrIGV2ZW4gdGhvdWdoIHRoZXJlJ3Mgbm9cbiAgICAgICAgLy8gdGltZSBsZWZ0LlxuICAgICAgICBmcmFtZURlYWRsaW5lT2JqZWN0LmRpZFRpbWVvdXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gdGltZW91dC5cbiAgICAgICAgaWYgKCFpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkKSB7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgYW5vdGhlciBhbmltYXRpb24gY2FsbGJhY2sgc28gd2UgcmV0cnkgbGF0ZXIuXG4gICAgICAgICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblRpY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4aXQgd2l0aG91dCBpbnZva2luZyB0aGUgY2FsbGJhY2suXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUncyBzdGlsbCB0aW1lIGxlZnQgaW4gdGhpcyBpZGxlIHBlcmlvZC5cbiAgICAgIGZyYW1lRGVhZGxpbmVPYmplY3QuZGlkVGltZW91dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRpbWVvdXRUaW1lID0gLTE7XG4gICAgdmFyIGNhbGxiYWNrID0gc2NoZWR1bGVkUklDQ2FsbGJhY2s7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2soZnJhbWVEZWFkbGluZU9iamVjdCk7XG4gICAgfVxuICB9O1xuICAvLyBBc3N1bWVzIHRoYXQgd2UgaGF2ZSBhZGRFdmVudExpc3RlbmVyIGluIHRoaXMgZW52aXJvbm1lbnQuIE1pZ2h0IG5lZWRcbiAgLy8gc29tZXRoaW5nIGJldHRlciBmb3Igb2xkIElFLlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGlkbGVUaWNrLCBmYWxzZSk7XG5cbiAgdmFyIGFuaW1hdGlvblRpY2sgPSBmdW5jdGlvbiAocmFmVGltZSkge1xuICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dEZyYW1lVGltZSA9IHJhZlRpbWUgLSBmcmFtZURlYWRsaW5lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lICYmIHByZXZpb3VzRnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lKSB7XG4gICAgICBpZiAobmV4dEZyYW1lVGltZSA8IDgpIHtcbiAgICAgICAgLy8gRGVmZW5zaXZlIGNvZGluZy4gV2UgZG9uJ3Qgc3VwcG9ydCBoaWdoZXIgZnJhbWUgcmF0ZXMgdGhhbiAxMjBoei5cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGxvd2VyIHRoYW4gdGhhdCwgaXQgaXMgcHJvYmFibHkgYSBidWcuXG4gICAgICAgIG5leHRGcmFtZVRpbWUgPSA4O1xuICAgICAgfVxuICAgICAgLy8gSWYgb25lIGZyYW1lIGdvZXMgbG9uZywgdGhlbiB0aGUgbmV4dCBvbmUgY2FuIGJlIHNob3J0IHRvIGNhdGNoIHVwLlxuICAgICAgLy8gSWYgdHdvIGZyYW1lcyBhcmUgc2hvcnQgaW4gYSByb3csIHRoZW4gdGhhdCdzIGFuIGluZGljYXRpb24gdGhhdCB3ZVxuICAgICAgLy8gYWN0dWFsbHkgaGF2ZSBhIGhpZ2hlciBmcmFtZSByYXRlIHRoYW4gd2hhdCB3ZSdyZSBjdXJyZW50bHkgb3B0aW1pemluZy5cbiAgICAgIC8vIFdlIGFkanVzdCBvdXIgaGV1cmlzdGljIGR5bmFtaWNhbGx5IGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgd2UncmVcbiAgICAgIC8vIHJ1bm5pbmcgb24gMTIwaHogZGlzcGxheSBvciA5MGh6IFZSIGRpc3BsYXkuXG4gICAgICAvLyBUYWtlIHRoZSBtYXggb2YgdGhlIHR3byBpbiBjYXNlIG9uZSBvZiB0aGVtIHdhcyBhbiBhbm9tYWx5IGR1ZSB0b1xuICAgICAgLy8gbWlzc2VkIGZyYW1lIGRlYWRsaW5lcy5cbiAgICAgIGFjdGl2ZUZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWUgPCBwcmV2aW91c0ZyYW1lVGltZSA/IHByZXZpb3VzRnJhbWVUaW1lIDogbmV4dEZyYW1lVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXNGcmFtZVRpbWUgPSBuZXh0RnJhbWVUaW1lO1xuICAgIH1cbiAgICBmcmFtZURlYWRsaW5lID0gcmFmVGltZSArIGFjdGl2ZUZyYW1lVGltZTtcbiAgICBpZiAoIWlzSWRsZVNjaGVkdWxlZCkge1xuICAgICAgaXNJZGxlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlS2V5LCAnKicpO1xuICAgIH1cbiAgfTtcblxuICBySUMgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAvLyBUaGlzIGFzc3VtZXMgdGhhdCB3ZSBvbmx5IHNjaGVkdWxlIG9uZSBjYWxsYmFjayBhdCBhIHRpbWUgYmVjYXVzZSB0aGF0J3NcbiAgICAvLyBob3cgRmliZXIgdXNlcyBpdC5cbiAgICBzY2hlZHVsZWRSSUNDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMudGltZW91dCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRpbWVvdXRUaW1lID0gbm93KCkgKyBvcHRpb25zLnRpbWVvdXQ7XG4gICAgfVxuICAgIGlmICghaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCkge1xuICAgICAgLy8gSWYgckFGIGRpZG4ndCBhbHJlYWR5IHNjaGVkdWxlIG9uZSwgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGZyYW1lLlxuICAgICAgLy8gVE9ETzogSWYgdGhpcyByQUYgZG9lc24ndCBtYXRlcmlhbGl6ZSBiZWNhdXNlIHRoZSBicm93c2VyIHRocm90dGxlcywgd2VcbiAgICAgIC8vIG1pZ2h0IHdhbnQgdG8gc3RpbGwgaGF2ZSBzZXRUaW1lb3V0IHRyaWdnZXIgcklDIGFzIGEgYmFja3VwIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB3ZSBrZWVwIHBlcmZvcm1pbmcgd29yay5cbiAgICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblRpY2spO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICBjSUMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHRpbWVvdXRUaW1lID0gLTE7XG4gIH07XG59IGVsc2Uge1xuICBySUMgPSB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaztcbiAgY0lDID0gd2luZG93LmNhbmNlbElkbGVDYWxsYmFjaztcbn1cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBmYmpzL3dhcm5pbmc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvX19mb3Jrc19fL3dhcm5pbmcuanNcbiAqXG4gKiBPbmx5IGNoYW5nZSBpcyB3ZSB1c2UgY29uc29sZS53YXJuIGluc3RlYWQgb2YgY29uc29sZS5lcnJvcixcbiAqIGFuZCBkbyBub3RoaW5nIHdoZW4gJ2NvbnNvbGUnIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBUaGlzIHJlYWxseSBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICogLS0tXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGxvd1ByaW9yaXR5V2FybmluZztcblxuLy8gaXNBdHRyaWJ1dGVOYW1lU2FmZSgpIGlzIGN1cnJlbnRseSBkdXBsaWNhdGVkIGluIERPTU1hcmt1cE9wZXJhdGlvbnMuXG4vLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHBsYWNlIGZvciB0aGlzLlxudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNob3VsZElnbm9yZVZhbHVlKCkgaXMgY3VycmVudGx5IGR1cGxpY2F0ZWQgaW4gRE9NTWFya3VwT3BlcmF0aW9ucy5cbi8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgcGxhY2UgZm9yIHRoaXMuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgJiYgIXZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgJiYgaXNOYU4odmFsdWUpIHx8IHByb3BlcnR5SW5mby5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSAmJiB2YWx1ZSA8IDEgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IGZhbHNlO1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBET00gcHJvcGVydGllcy5cbiAqL1xuXG5cblxuXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIFwiZXhwZWN0ZWRcIiBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy5cbiAqIFNvbWUgcHJvcGVydGllcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIGV4cGVjdGVkKSB7XG4gIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCB8fCBwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBub2RlW3Byb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcblxuICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSBudWxsO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSkge1xuICAgICAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAvLyBXZSBoYWQgYW4gYXR0cmlidXRlIGJ1dCBzaG91bGRuJ3QgaGF2ZSBoYWQgb25lLCBzbyByZWFkIGl0XG4gICAgICAgICAgICAvLyBmb3IgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIHdhcyBhIGJvb2xlYW4sIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIHZhbHVlIGlzXG4gICAgICAgICAgICAvLyB0aGUgZmFjdCB0aGF0IHdlIGhhdmUgaXQgaXMgdGhlIHNhbWUgYXMgdGhlIGV4cGVjdGVkLlxuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBFdmVuIGlmIHRoaXMgcHJvcGVydHkgdXNlcyBhIG5hbWVzcGFjZSB3ZSB1c2UgZ2V0QXR0cmlidXRlXG4gICAgICAgICAgLy8gYmVjYXVzZSB3ZSBhc3N1bWUgaXRzIG5hbWVzcGFjZWQgbmFtZSBpcyB0aGUgc2FtZSBhcyBvdXIgY29uZmlnLlxuICAgICAgICAgIC8vIFRvIHVzZSBnZXRBdHRyaWJ1dGVOUyB3ZSBuZWVkIHRoZSBsb2NhbCBuYW1lIHdoaWNoIHdlIGRvbid0IGhhdmVcbiAgICAgICAgICAvLyBpbiBvdXIgY29uZmlnIGF0bS5cbiAgICAgICAgICBzdHJpbmdWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlID09PSBudWxsID8gZXhwZWN0ZWQgOiBzdHJpbmdWYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpbmdWYWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIGF0dHJpYnV0ZSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIHRoaXJkIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLiBTb21lXG4gKiBhdHRyaWJ1dGVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIGV4cGVjdGVkKSB7XG4gIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBpZiAodmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuXG4gIGlmIChwcm9wZXJ0eUluZm8gJiYgc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSkge1xuICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICBkZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgbm9kZVtwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7XG4gICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAvLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSA/IHZhbHVlIDogbnVsbCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIFxuICB9XG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnICsgdmFsdWUpO1xuICB9XG5cbiAge1xuICAgIFxuICB9XG59XG5cbi8qKlxuICogRGVsZXRlcyBhbiBhdHRyaWJ1dGVzIGZyb20gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZnVuY3Rpb24gZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSkge1xuICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbn1cblxuLyoqXG4gKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5mdW5jdGlvbiBkZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpIHtcbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUpIHtcbiAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVbcHJvcE5hbWVdID0gJyc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzID0ge1xuICBjaGVja1Byb3BUeXBlczogbnVsbFxufTtcblxue1xuICB2YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgICBidXR0b246IHRydWUsXG4gICAgY2hlY2tib3g6IHRydWUsXG4gICAgaW1hZ2U6IHRydWUsXG4gICAgaGlkZGVuOiB0cnVlLFxuICAgIHJhZGlvOiB0cnVlLFxuICAgIHJlc2V0OiB0cnVlLFxuICAgIHN1Ym1pdDogdHJ1ZVxuICB9O1xuXG4gIHZhciBwcm9wVHlwZXMgPSB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH0sXG4gICAgY2hlY2tlZDogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBsaW5rZWQgYHZhbHVlYCBhdHRyaWJ1dGUgZm9yIGNvbnRyb2xsZWQgZm9ybXMuIFlvdSBzaG91bGQgbm90IHVzZVxuICAgKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxuICAgKi9cbiAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcHMsIGdldFN0YWNrKSB7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBwcm9wcywgJ3Byb3AnLCB0YWdOYW1lLCBnZXRTdGFjayk7XG4gIH07XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMyA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcblxuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7XG4gICAgLy8gTWFrZSBzdXJlIHdlIHNldCAudHlwZSBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMgKHNldHRpbmcgLnZhbHVlXG4gICAgLy8gYmVmb3JlIC50eXBlIG1lYW5zIC52YWx1ZSBpcyBsb3N0IGluIElFMTEgYW5kIGJlbG93KVxuICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5zdGVwIGJlZm9yZSAudmFsdWUgKHNldHRpbmcgLnZhbHVlIGJlZm9yZSAuc3RlcFxuICAgIC8vIG1lYW5zIC52YWx1ZSBpcyByb3VuZGVkIG9uIG1vdW50LCBiYXNlZCB1cG9uIHN0ZXAgcHJlY2lzaW9uKVxuICAgIHN0ZXA6IHVuZGVmaW5lZCxcbiAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5taW4gJiAubWF4IGJlZm9yZSAudmFsdWUgKHRvIGVuc3VyZSBwcm9wZXIgb3JkZXJcbiAgICAvLyBpbiBjb3JuZXIgY2FzZXMgc3VjaCBhcyBtaW4gb3IgbWF4IGRlcml2aW5nIGZyb20gdmFsdWUsIGUuZy4gSXNzdWUgIzcxNzApXG4gICAgbWluOiB1bmRlZmluZWQsXG4gICAgbWF4OiB1bmRlZmluZWRcbiAgfSwgcHJvcHMsIHtcbiAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgIHZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgIGNoZWNrZWQ6IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWRcbiAgfSk7XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZShlbGVtZW50LCBwcm9wcykge1xuICB7XG4gICAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMyk7XG5cbiAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcbiAgICAgIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMigpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsQ2hlY2tlZDogcHJvcHMuY2hlY2tlZCAhPSBudWxsID8gcHJvcHMuY2hlY2tlZCA6IHByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgIGluaXRpYWxWYWx1ZTogcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlLFxuICAgIGNvbnRyb2xsZWQ6IGlzQ29udHJvbGxlZChwcm9wcylcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgJ2NoZWNrZWQnLCBjaGVja2VkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAge1xuICAgIHZhciBjb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcblxuICAgIGlmICghbm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJXMnLCBwcm9wcy50eXBlLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMoKSk7XG4gICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmICFjb250cm9sbGVkICYmICFkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYSBjb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgdW5jb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cyVzJywgcHJvcHMudHlwZSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzKCkpO1xuICAgICAgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcyk7XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgaWYgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnKSB7XG4gICAgICBub2RlLnZhbHVlID0gJzAnO1xuICAgICAgLy8gTm90ZTogSUU5IHJlcG9ydHMgYSBudW1iZXIgaW5wdXRzIGFzICd0ZXh0Jywgc28gY2hlY2sgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBTaW11bGF0ZSBgaW5wdXQudmFsdWVBc051bWJlcmAuIElFOSBkb2VzIG5vdCBzdXBwb3J0IGl0XG4gICAgICB2YXIgdmFsdWVBc051bWJlciA9IHBhcnNlRmxvYXQobm9kZS52YWx1ZSkgfHwgMDtcblxuICAgICAgaWYgKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICB2YWx1ZSAhPSB2YWx1ZUFzTnVtYmVyIHx8XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIHZhbHVlID09IHZhbHVlQXNOdW1iZXIgJiYgbm9kZS52YWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSAhPT0gJycgKyB2YWx1ZSkge1xuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvcHMudmFsdWUgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgLy8gSW4gQ2hyb21lLCBhc3NpZ25pbmcgZGVmYXVsdFZhbHVlIHRvIGNlcnRhaW4gaW5wdXQgdHlwZXMgdHJpZ2dlcnMgaW5wdXQgdmFsaWRhdGlvbi5cbiAgICAgIC8vIEZvciBudW1iZXIgaW5wdXRzLCB0aGUgZGlzcGxheSB2YWx1ZSBsb3NlcyB0cmFpbGluZyBkZWNpbWFsIHBvaW50cy4gRm9yIGVtYWlsIGlucHV0cyxcbiAgICAgIC8vIENocm9tZSByYWlzZXMgXCJUaGUgc3BlY2lmaWVkIHZhbHVlIDx4PiBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIuXG4gICAgICAvL1xuICAgICAgLy8gSGVyZSB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGRlZmF1bHRWYWx1ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZCwgYXZvaWRpbmcgdGhlc2UgcHJvYmxlbXNcbiAgICAgIC8vIHdoZW4gdGhlIHVzZXIgaXMgaW5wdXR0aW5nIHRleHRcbiAgICAgIC8vXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTNcbiAgICAgIGlmIChub2RlLmRlZmF1bHRWYWx1ZSAhPT0gJycgKyBwcm9wcy5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAgLy8gRGV0YWNoIHZhbHVlIGZyb20gZGVmYXVsdFZhbHVlLiBXZSB3b24ndCBkbyBhbnl0aGluZyBpZiB3ZSdyZSB3b3JraW5nIG9uXG4gIC8vIHN1Ym1pdCBvciByZXNldCBpbnB1dHMgYXMgdGhvc2UgdmFsdWVzICYgZGVmYXVsdFZhbHVlcyBhcmUgbGlua2VkLiBUaGV5XG4gIC8vIGFyZSBub3QgcmVzZXRhYmxlIG5vZGVzIHNvIHRoaXMgb3BlcmF0aW9uIGRvZXNuJ3QgbWF0dGVyIGFuZCBhY3R1YWxseVxuICAvLyByZW1vdmVzIGJyb3dzZXItZGVmYXVsdCB2YWx1ZXMgKGVnIFwiU3VibWl0IFF1ZXJ5XCIpIHdoZW4gbm8gdmFsdWUgaXNcbiAgLy8gcHJvdmlkZWQuXG5cbiAgc3dpdGNoIChwcm9wcy50eXBlKSB7XG4gICAgY2FzZSAnc3VibWl0JzpcbiAgICBjYXNlICdyZXNldCc6XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjb2xvcic6XG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgIGNhc2UgJ2RhdGV0aW1lLWxvY2FsJzpcbiAgICBjYXNlICdtb250aCc6XG4gICAgY2FzZSAndGltZSc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgICAvLyBUaGlzIGZpeGVzIHRoZSBuby1zaG93IGlzc3VlIG9uIGlPUyBTYWZhcmkgYW5kIEFuZHJvaWQgQ2hyb21lOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjMzXG4gICAgICBub2RlLnZhbHVlID0gJyc7XG4gICAgICBub2RlLnZhbHVlID0gbm9kZS5kZWZhdWx0VmFsdWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbm9kZS52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXG4gIC8vIHRoaXMgaXMgbmVlZGVkIHRvIHdvcmsgYXJvdW5kIGEgY2hyb21lIGJ1ZyB3aGVyZSBzZXR0aW5nIGRlZmF1bHRDaGVja2VkXG4gIC8vIHdpbGwgc29tZXRpbWVzIGluZmx1ZW5jZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCAoZXZlbiBhZnRlciBkZXRhY2htZW50KS5cbiAgLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcbiAgLy8gV2UgbmVlZCB0byB0ZW1wb3JhcmlseSB1bnNldCBuYW1lIHRvIGF2b2lkIGRpc3J1cHRpbmcgcmFkaW8gYnV0dG9uIGdyb3Vwcy5cbiAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9ICcnO1xuICB9XG4gIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHVwZGF0ZVdyYXBwZXIobm9kZSwgcHJvcHMpO1xuICB1cGRhdGVOYW1lZENvdXNpbnMobm9kZSwgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVOYW1lZENvdXNpbnMocm9vdE5vZGUsIHByb3BzKSB7XG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLiBJdCBtaWdodCBub3QgZXZlbiBiZSBpbiB0aGVcbiAgICAvLyBkb2N1bWVudC4gTGV0J3MganVzdCB1c2UgdGhlIGxvY2FsIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3RcbiAgICAvLyBtaXNzIGFueXRoaW5nLlxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3QgcmFkaW8gYnV0dG9ucyB3aXRoIG5vbi1SZWFjdCBvbmVzLlxuICAgICAgdmFyIG90aGVyUHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEob3RoZXJOb2RlKTtcbiAgICAgICFvdGhlclByb3BzID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiB2b2lkIDA7XG5cbiAgICAgIC8vIFdlIG5lZWQgdXBkYXRlIHRoZSB0cmFja2VkIHZhbHVlIG9uIHRoZSBuYW1lZCBjb3VzaW4gc2luY2UgdGhlIHZhbHVlXG4gICAgICAvLyB3YXMgY2hhbmdlZCBidXQgdGhlIGlucHV0IHNhdyBubyBldmVudCBvciB2YWx1ZSBzZXRcbiAgICAgIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG90aGVyTm9kZSk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgdXBkYXRlV3JhcHBlcihvdGhlck5vZGUsIG90aGVyUHJvcHMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgLy8gV2UgY2FuIHNpbGVudGx5IHNraXAgdGhlbSBiZWNhdXNlIGludmFsaWQgRE9NIG5lc3Rpbmcgd2FybmluZ1xuICAvLyBjYXRjaGVzIHRoZXNlIGNhc2VzIGluIEZpYmVyLlxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAge1xuICAgIHdhcm5pbmcocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcbiAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBwcm9wcy52YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oeyBjaGlsZHJlbjogdW5kZWZpbmVkIH0sIHByb3BzKTtcbiAgdmFyIGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gIGlmIChjb250ZW50KSB7XG4gICAgaG9zdFByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgfVxuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMyA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxuXG57XG4gIHZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMygpO1xuICBpZiAob3duZXJOYW1lKSB7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcykge1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKG5vZGUsIG11bHRpcGxlLCBwcm9wVmFsdWUsIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICB2YXIgb3B0aW9ucyA9IG5vZGUub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSBwcm9wVmFsdWU7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBQcmVmaXggdG8gYXZvaWQgY2hhb3Mgd2l0aCBzcGVjaWFsIGtleXMuXG4gICAgICBzZWxlY3RlZFZhbHVlWyckJyArIHNlbGVjdGVkVmFsdWVzW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBvcHRpb25zLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eSgnJCcgKyBvcHRpb25zW19pXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tfaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0ZWQgJiYgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICB2YXIgX3NlbGVjdGVkVmFsdWUgPSAnJyArIHByb3BWYWx1ZTtcbiAgICB2YXIgZGVmYXVsdFNlbGVjdGVkID0gbnVsbDtcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBvcHRpb25zLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIGlmIChvcHRpb25zW19pMl0udmFsdWUgPT09IF9zZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbX2kyXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGlmIChzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgICBvcHRpb25zW19pMl0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFNlbGVjdGVkID09PSBudWxsICYmICFvcHRpb25zW19pMl0uZGlzYWJsZWQpIHtcbiAgICAgICAgZGVmYXVsdFNlbGVjdGVkID0gb3B0aW9uc1tfaTJdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdFNlbGVjdGVkICE9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0U2VsZWN0ZWQuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMihlbGVtZW50LCBwcm9wcykge1xuICByZXR1cm4gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICB3YXNNdWx0aXBsZTogISFwcm9wcy5tdWx0aXBsZVxuICB9O1xuXG4gIHtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICBub2RlLm11bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gQWZ0ZXIgdGhlIGluaXRpYWwgbW91bnQsIHdlIGNvbnRyb2wgc2VsZWN0ZWQtbmVzcyBtYW51YWxseSBzbyBkb24ndCBwYXNzXG4gIC8vIHRoaXMgdmFsdWUgZG93blxuICBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gIHZhciB3YXNNdWx0aXBsZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09ICEhcHJvcHMubXVsdGlwbGUpIHtcbiAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnLCBmYWxzZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IGZhbHNlO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gICEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IHZvaWQgMDtcblxuICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcbiAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK1NvcGhpZSBzZWVtZWQgdG8gbGlrZSB0aGlzXG4gIC8vIHNvbHV0aW9uLiBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZFxuICAvLyB0byBiZSBhIHN0cmluZy5cbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGlsZHJlbjogJycgKyBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ1KTtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbERlZmF1bHRWYWwpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG4gICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluaXRpYWxWYWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIC8vIE9ubHkgYm90aGVyIGZldGNoaW5nIGRlZmF1bHQgdmFsdWUgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGl0XG4gIGlmIChpbml0aWFsVmFsdWUgPT0gbnVsbCkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICB9XG4gICAgICAhKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IHZvaWQgMDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG4gICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxWYWx1ZTogJycgKyBpbml0aWFsVmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgdmFyIG5ld1ZhbHVlID0gJycgKyB2YWx1ZTtcblxuICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcblxuICAvLyBPbmx5IHNldCBub2RlLnZhbHVlIGlmIHRleHRDb250ZW50IGlzIGVxdWFsIHRvIHRoZSBleHBlY3RlZFxuICAvLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMTUyNS9cbiAgaWYgKHRleHRDb250ZW50ID09PSBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKSB7XG4gICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpO1xufVxuXG52YXIgSFRNTF9OQU1FU1BBQ0UkMSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxudmFyIE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFJDEsXG4gIG1hdGhtbDogTUFUSF9OQU1FU1BBQ0UsXG4gIHN2ZzogU1ZHX05BTUVTUEFDRVxufTtcblxuLy8gQXNzdW1lcyB0aGVyZSBpcyBubyBwYXJlbnQgbmFtZXNwYWNlLlxuZnVuY3Rpb24gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBTVkdfTkFNRVNQQUNFO1xuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0UkMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpIHtcbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PSBudWxsIHx8IHBhcmVudE5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgIC8vIE5vIChvciBkZWZhdWx0KSBwYXJlbnQgbmFtZXNwYWNlOiBwb3RlbnRpYWwgZW50cnkgcG9pbnQuXG4gICAgcmV0dXJuIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBTVkdfTkFNRVNQQUNFICYmIHR5cGUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIFdlJ3JlIGxlYXZpbmcgU1ZHLlxuICAgIHJldHVybiBIVE1MX05BTUVTUEFDRSQxO1xuICB9XG4gIC8vIEJ5IGRlZmF1bHQsIHBhc3MgbmFtZXNwYWNlIGJlbG93LlxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG4vLyBTVkcgdGVtcCBjb250YWluZXIgZm9yIElFIGxhY2tpbmcgaW5uZXJIVE1MXG52YXIgcmV1c2FibGVTVkdDb250YWluZXIgPSB2b2lkIDA7XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAvLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4gIC8vIHRoZSB0YXJnZXQgbm9kZVxuXG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gTmFtZXNwYWNlcy5zdmcgJiYgISgnaW5uZXJIVE1MJyBpbiBub2RlKSkge1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gcmV1c2FibGVTVkdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwgKyAnPC9zdmc+JztcbiAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN2Z05vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufSk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LiBpbm5lclRleHQgaXMgYSBwb29yIHN1YnN0aXR1dGUgZm9yIHRleHRDb250ZW50IGFuZCwgYW1vbmcgbWFueVxuICogaXNzdWVzLCBpbnNlcnRzIDxicj4gaW5zdGVhZCBvZiB0aGUgbGl0ZXJhbCBuZXdsaW5lIGNoYXJzLiBpbm5lckhUTUwgYmVoYXZlc1xuICogYXMgaXQgc2hvdWxkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgY29sdW1uczogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hhcnJheTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICghaXNDdXN0b21Qcm9wZXJ0eSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwICYmICEoaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gIH1cblxuICByZXR1cm4gKCcnICsgdmFsdWUpLnRyaW0oKTtcbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlID0gZW1wdHlGdW5jdGlvbjtcblxue1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG4gIHZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsIFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLiVzJywgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNOYU4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ2BJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LiVzJywgbmFtZSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIFRoaXMgY3JlYXRlcyBhIHN0cmluZyB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHN0eWxlXG4gKiBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGJ5IHNlcnZlci1zaWRlIHJlbmRlcmluZy4gSXQgYnktcGFzc2VzIHdhcm5pbmdzIGFuZFxuICogc2VjdXJpdHkgY2hlY2tzIHNvIGl0J3Mgbm90IHNhZmUgdG8gdXNlIHRoaXMgdmFsdWUgZm9yIGFueXRoaW5nIG90aGVyIHRoYW5cbiAqIGNvbXBhcmlzb24uIEl0IGlzIG9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMoc3R5bGVzKSB7XG4gIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIHZhciBkZWxpbWl0ZXIgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICAgICAgc2VyaWFsaXplZCArPSBkZWxpbWl0ZXIgKyBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG5cbiAgICAgICAgZGVsaW1pdGVyID0gJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGVzKG5vZGUsIHN0eWxlcywgZ2V0U3RhY2spIHtcbiAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgIHtcbiAgICAgIGlmICghaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZSQxKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGdldFN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgIHN0eWxlTmFtZSA9ICdjc3NGbG9hdCc7XG4gICAgfVxuICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gIGFyZWE6IHRydWUsXG4gIGJhc2U6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlXG59O1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgbWVudWl0ZW06IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG52YXIgSFRNTCQxID0gJ19faHRtbCc7XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcywgZ2V0U3RhY2spIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAodm9pZEVsZW1lbnRUYWdzW3RhZ10pIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgdGFnLCBnZXRTdGFjaygpKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCQxIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSA/IGludmFyaWFudChmYWxzZSwgJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWludmFyaWFudC1kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IHZvaWQgMDtcbiAgfVxuICB7XG4gICAgd2FybmluZyhwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgfHwgIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsLCAnQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLiVzJywgZ2V0U3RhY2soKSk7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuIHVzaW5nIEpTWC4lcycsIGdldFN0YWNrKCkpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZyc7XG4gIH1cbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLlxuICAgIC8vIFdlIGRvbid0IG1pbmQgdGhpcyB3aGl0ZWxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbnZhciBhcmlhUHJvcGVydGllcyA9IHtcbiAgJ2FyaWEtY3VycmVudCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWRldGFpbHMnOiAwLFxuICAnYXJpYS1kaXNhYmxlZCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWhpZGRlbic6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWludmFsaWQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1rZXlzaG9ydGN1dHMnOiAwLFxuICAnYXJpYS1sYWJlbCc6IDAsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gIC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4gICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICdhcmlhLWNoZWNrZWQnOiAwLFxuICAnYXJpYS1leHBhbmRlZCc6IDAsXG4gICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAnYXJpYS1tb2RhbCc6IDAsXG4gICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICdhcmlhLW9yaWVudGF0aW9uJzogMCxcbiAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgJ2FyaWEtcmVhZG9ubHknOiAwLFxuICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgJ2FyaWEtc29ydCc6IDAsXG4gICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXRvbWljJzogMCxcbiAgJ2FyaWEtYnVzeSc6IDAsXG4gICdhcmlhLWxpdmUnOiAwLFxuICAnYXJpYS1yZWxldmFudCc6IDAsXG4gIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgJ2FyaWEtZ3JhYmJlZCc6IDAsXG4gIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAnYXJpYS1jb2xjb3VudCc6IDAsXG4gICdhcmlhLWNvbGluZGV4JzogMCxcbiAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICdhcmlhLWNvbnRyb2xzJzogMCxcbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAnYXJpYS1mbG93dG8nOiAwLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgJ2FyaWEtb3ducyc6IDAsXG4gICdhcmlhLXBvc2luc2V0JzogMCxcbiAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICdhcmlhLXJvd3NwYW4nOiAwLFxuICAnYXJpYS1zZXRzaXplJzogMFxufTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIHJBUklBQ2FtZWwgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0oKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAockFSSUFDYW1lbC50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgY29ycmVjdE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShhcmlhTmFtZSkgPyBhcmlhTmFtZSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKGNvcnJlY3ROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gY29ycmVjdE5hbWUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgY29ycmVjdE5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG4gICAgaWYgKG5hbWUgIT09IHN0YW5kYXJkTmFtZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCBzdGFuZGFyZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcykge1xuICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcblxuICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcykge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKTtcbn1cblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bSQxKCkge1xuICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgcmV0dXJuIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcykge1xuICBpZiAodHlwZSAhPT0gJ2lucHV0JyAmJiB0eXBlICE9PSAndGV4dGFyZWEnICYmIHR5cGUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByb3BzICE9IG51bGwgJiYgcHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcbiAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMubXVsdGlwbGUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgYXJyYXkgd2hlbiBgbXVsdGlwbGVgIGlzIHNldCB0byBgdHJ1ZWAgJyArICd0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgIGZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGUgSFRNTCBvciBTVkcgd2hpdGVsaXN0LCBiZSBzdXJlIHRvXG4vLyBhbHNvIGFkZCB0aGVtIHRvIHRoaXMgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdCBuYW1lXG4vLyB3YXJuaW5ncy5cbnZhciBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsdDogJ2FsdCcsXG4gIGFzOiAnYXMnLFxuICBhc3luYzogJ2FzeW5jJyxcbiAgYXV0b2NhcGl0YWxpemU6ICdhdXRvQ2FwaXRhbGl6ZScsXG4gIGF1dG9jb21wbGV0ZTogJ2F1dG9Db21wbGV0ZScsXG4gIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnLFxuICBhdXRvcGxheTogJ2F1dG9QbGF5JyxcbiAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gIGNhcHR1cmU6ICdjYXB0dXJlJyxcbiAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gIGNlbGxzcGFjaW5nOiAnY2VsbFNwYWNpbmcnLFxuICBjaGFsbGVuZ2U6ICdjaGFsbGVuZ2UnLFxuICBjaGFyc2V0OiAnY2hhclNldCcsXG4gIGNoZWNrZWQ6ICdjaGVja2VkJyxcbiAgY2hpbGRyZW46ICdjaGlsZHJlbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gICdkZWZhdWx0JzogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICAnZm9yJzogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub25jZTogJ25vbmNlJyxcbiAgbm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuICBvcGVuOiAnb3BlbicsXG4gIG9wdGltdW06ICdvcHRpbXVtJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwbGFjZWhvbGRlcjogJ3BsYWNlaG9sZGVyJyxcbiAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gIHBvc3RlcjogJ3Bvc3RlcicsXG4gIHByZWxvYWQ6ICdwcmVsb2FkJyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICByYWRpb2dyb3VwOiAncmFkaW9Hcm91cCcsXG4gIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICByZWZlcnJlcnBvbGljeTogJ3JlZmVycmVyUG9saWN5JyxcbiAgcmVsOiAncmVsJyxcbiAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gIHJldmVyc2VkOiAncmV2ZXJzZWQnLFxuICByb2xlOiAncm9sZScsXG4gIHJvd3M6ICdyb3dzJyxcbiAgcm93c3BhbjogJ3Jvd1NwYW4nLFxuICBzYW5kYm94OiAnc2FuZGJveCcsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBzY29wZWQ6ICdzY29wZWQnLFxuICBzY3JvbGxpbmc6ICdzY3JvbGxpbmcnLFxuICBzZWFtbGVzczogJ3NlYW1sZXNzJyxcbiAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCcsXG4gIHNoYXBlOiAnc2hhcGUnLFxuICBzaXplOiAnc2l6ZScsXG4gIHNpemVzOiAnc2l6ZXMnLFxuICBzcGFuOiAnc3BhbicsXG4gIHNwZWxsY2hlY2s6ICdzcGVsbENoZWNrJyxcbiAgc3JjOiAnc3JjJyxcbiAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgc3JjbGFuZzogJ3NyY0xhbmcnLFxuICBzcmNzZXQ6ICdzcmNTZXQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgc3RlcDogJ3N0ZXAnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgdGFyZ2V0OiAndGFyZ2V0JyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHR5cGU6ICd0eXBlJyxcbiAgdXNlbWFwOiAndXNlTWFwJyxcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIHdpZHRoOiAnd2lkdGgnLFxuICB3bW9kZTogJ3dtb2RlJyxcbiAgd3JhcDogJ3dyYXAnLFxuXG4gIC8vIFNWR1xuICBhYm91dDogJ2Fib3V0JyxcbiAgYWNjZW50aGVpZ2h0OiAnYWNjZW50SGVpZ2h0JyxcbiAgJ2FjY2VudC1oZWlnaHQnOiAnYWNjZW50SGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogJ2FjY3VtdWxhdGUnLFxuICBhZGRpdGl2ZTogJ2FkZGl0aXZlJyxcbiAgYWxpZ25tZW50YmFzZWxpbmU6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICBhbGxvd3Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAnYWxwaGFiZXRpYycsXG4gIGFtcGxpdHVkZTogJ2FtcGxpdHVkZScsXG4gIGFyYWJpY2Zvcm06ICdhcmFiaWNGb3JtJyxcbiAgJ2FyYWJpYy1mb3JtJzogJ2FyYWJpY0Zvcm0nLFxuICBhc2NlbnQ6ICdhc2NlbnQnLFxuICBhdHRyaWJ1dGVuYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZXR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b3JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6ICdhemltdXRoJyxcbiAgYmFzZWZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlbGluZXNoaWZ0OiAnYmFzZWxpbmVTaGlmdCcsXG4gICdiYXNlbGluZS1zaGlmdCc6ICdiYXNlbGluZVNoaWZ0JyxcbiAgYmFzZXByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJib3g6ICdiYm94JyxcbiAgYmVnaW46ICdiZWdpbicsXG4gIGJpYXM6ICdiaWFzJyxcbiAgYnk6ICdieScsXG4gIGNhbGNtb2RlOiAnY2FsY01vZGUnLFxuICBjYXBoZWlnaHQ6ICdjYXBIZWlnaHQnLFxuICAnY2FwLWhlaWdodCc6ICdjYXBIZWlnaHQnLFxuICBjbGlwOiAnY2xpcCcsXG4gIGNsaXBwYXRoOiAnY2xpcFBhdGgnLFxuICAnY2xpcC1wYXRoJzogJ2NsaXBQYXRoJyxcbiAgY2xpcHBhdGh1bml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjbGlwcnVsZTogJ2NsaXBSdWxlJyxcbiAgJ2NsaXAtcnVsZSc6ICdjbGlwUnVsZScsXG4gIGNvbG9yOiAnY29sb3InLFxuICBjb2xvcmludGVycG9sYXRpb246ICdjb2xvckludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6ICdjb2xvckludGVycG9sYXRpb24nLFxuICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gIGNvbG9ycHJvZmlsZTogJ2NvbG9yUHJvZmlsZScsXG4gICdjb2xvci1wcm9maWxlJzogJ2NvbG9yUHJvZmlsZScsXG4gIGNvbG9ycmVuZGVyaW5nOiAnY29sb3JSZW5kZXJpbmcnLFxuICAnY29sb3ItcmVuZGVyaW5nJzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgY29udGVudHNjcmlwdHR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRzdHlsZXR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAnY3Vyc29yJyxcbiAgY3g6ICdjeCcsXG4gIGN5OiAnY3knLFxuICBkOiAnZCcsXG4gIGRhdGF0eXBlOiAnZGF0YXR5cGUnLFxuICBkZWNlbGVyYXRlOiAnZGVjZWxlcmF0ZScsXG4gIGRlc2NlbnQ6ICdkZXNjZW50JyxcbiAgZGlmZnVzZWNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAnZGlyZWN0aW9uJyxcbiAgZGlzcGxheTogJ2Rpc3BsYXknLFxuICBkaXZpc29yOiAnZGl2aXNvcicsXG4gIGRvbWluYW50YmFzZWxpbmU6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2RvbWluYW50QmFzZWxpbmUnLFxuICBkdXI6ICdkdXInLFxuICBkeDogJ2R4JyxcbiAgZHk6ICdkeScsXG4gIGVkZ2Vtb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246ICdlbGV2YXRpb24nLFxuICBlbmFibGViYWNrZ3JvdW5kOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgZW5kOiAnZW5kJyxcbiAgZXhwb25lbnQ6ICdleHBvbmVudCcsXG4gIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogJ2ZpbGwnLFxuICBmaWxsb3BhY2l0eTogJ2ZpbGxPcGFjaXR5JyxcbiAgJ2ZpbGwtb3BhY2l0eSc6ICdmaWxsT3BhY2l0eScsXG4gIGZpbGxydWxlOiAnZmlsbFJ1bGUnLFxuICAnZmlsbC1ydWxlJzogJ2ZpbGxSdWxlJyxcbiAgZmlsdGVyOiAnZmlsdGVyJyxcbiAgZmlsdGVycmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVydW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kb3BhY2l0eTogJ2Zsb29kT3BhY2l0eScsXG4gICdmbG9vZC1vcGFjaXR5JzogJ2Zsb29kT3BhY2l0eScsXG4gIGZsb29kY29sb3I6ICdmbG9vZENvbG9yJyxcbiAgJ2Zsb29kLWNvbG9yJzogJ2Zsb29kQ29sb3InLFxuICBmb2N1c2FibGU6ICdmb2N1c2FibGUnLFxuICBmb250ZmFtaWx5OiAnZm9udEZhbWlseScsXG4gICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgZm9udHNpemU6ICdmb250U2l6ZScsXG4gICdmb250LXNpemUnOiAnZm9udFNpemUnLFxuICBmb250c2l6ZWFkanVzdDogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAnZm9udFNpemVBZGp1c3QnLFxuICBmb250c3RyZXRjaDogJ2ZvbnRTdHJldGNoJyxcbiAgJ2ZvbnQtc3RyZXRjaCc6ICdmb250U3RyZXRjaCcsXG4gIGZvbnRzdHlsZTogJ2ZvbnRTdHlsZScsXG4gICdmb250LXN0eWxlJzogJ2ZvbnRTdHlsZScsXG4gIGZvbnR2YXJpYW50OiAnZm9udFZhcmlhbnQnLFxuICAnZm9udC12YXJpYW50JzogJ2ZvbnRWYXJpYW50JyxcbiAgZm9udHdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAnZm9udC13ZWlnaHQnOiAnZm9udFdlaWdodCcsXG4gIGZvcm1hdDogJ2Zvcm1hdCcsXG4gIGZyb206ICdmcm9tJyxcbiAgZng6ICdmeCcsXG4gIGZ5OiAnZnknLFxuICBnMTogJ2cxJyxcbiAgZzI6ICdnMicsXG4gIGdseXBobmFtZTogJ2dseXBoTmFtZScsXG4gICdnbHlwaC1uYW1lJzogJ2dseXBoTmFtZScsXG4gIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICBnbHlwaHJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnR0cmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50dW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogJ2hhbmdpbmcnLFxuICBob3JpemFkdng6ICdob3JpekFkdlgnLFxuICAnaG9yaXotYWR2LXgnOiAnaG9yaXpBZHZYJyxcbiAgaG9yaXpvcmlnaW54OiAnaG9yaXpPcmlnaW5YJyxcbiAgJ2hvcml6LW9yaWdpbi14JzogJ2hvcml6T3JpZ2luWCcsXG4gIGlkZW9ncmFwaGljOiAnaWRlb2dyYXBoaWMnLFxuICBpbWFnZXJlbmRlcmluZzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlbmRlcmluZyc6ICdpbWFnZVJlbmRlcmluZycsXG4gIGluMjogJ2luMicsXG4gICdpbic6ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gICd0eXBlb2YnOiAndHlwZW9mJyxcbiAgdTE6ICd1MScsXG4gIHUyOiAndTInLFxuICB1bmRlcmxpbmVwb3NpdGlvbjogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgJ3VuZGVybGluZS1wb3NpdGlvbic6ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gIHVuZGVybGluZXRoaWNrbmVzczogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gICd1bmRlcmxpbmUtdGhpY2tuZXNzJzogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gIHVuaWNvZGU6ICd1bmljb2RlJyxcbiAgdW5pY29kZWJpZGk6ICd1bmljb2RlQmlkaScsXG4gICd1bmljb2RlLWJpZGknOiAndW5pY29kZUJpZGknLFxuICB1bmljb2RlcmFuZ2U6ICd1bmljb2RlUmFuZ2UnLFxuICAndW5pY29kZS1yYW5nZSc6ICd1bmljb2RlUmFuZ2UnLFxuICB1bml0c3BlcmVtOiAndW5pdHNQZXJFbScsXG4gICd1bml0cy1wZXItZW0nOiAndW5pdHNQZXJFbScsXG4gIHVuc2VsZWN0YWJsZTogJ3Vuc2VsZWN0YWJsZScsXG4gIHZhbHBoYWJldGljOiAndkFscGhhYmV0aWMnLFxuICAndi1hbHBoYWJldGljJzogJ3ZBbHBoYWJldGljJyxcbiAgdmFsdWVzOiAndmFsdWVzJyxcbiAgdmVjdG9yZWZmZWN0OiAndmVjdG9yRWZmZWN0JyxcbiAgJ3ZlY3Rvci1lZmZlY3QnOiAndmVjdG9yRWZmZWN0JyxcbiAgdmVyc2lvbjogJ3ZlcnNpb24nLFxuICB2ZXJ0YWR2eTogJ3ZlcnRBZHZZJyxcbiAgJ3ZlcnQtYWR2LXknOiAndmVydEFkdlknLFxuICB2ZXJ0b3JpZ2lueDogJ3ZlcnRPcmlnaW5YJyxcbiAgJ3ZlcnQtb3JpZ2luLXgnOiAndmVydE9yaWdpblgnLFxuICB2ZXJ0b3JpZ2lueTogJ3ZlcnRPcmlnaW5ZJyxcbiAgJ3ZlcnQtb3JpZ2luLXknOiAndmVydE9yaWdpblknLFxuICB2aGFuZ2luZzogJ3ZIYW5naW5nJyxcbiAgJ3YtaGFuZ2luZyc6ICd2SGFuZ2luZycsXG4gIHZpZGVvZ3JhcGhpYzogJ3ZJZGVvZ3JhcGhpYycsXG4gICd2LWlkZW9ncmFwaGljJzogJ3ZJZGVvZ3JhcGhpYycsXG4gIHZpZXdib3g6ICd2aWV3Qm94JyxcbiAgdmlld3RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAndmlzaWJpbGl0eScsXG4gIHZtYXRoZW1hdGljYWw6ICd2TWF0aGVtYXRpY2FsJyxcbiAgJ3YtbWF0aGVtYXRpY2FsJzogJ3ZNYXRoZW1hdGljYWwnLFxuICB2b2NhYjogJ3ZvY2FiJyxcbiAgd2lkdGhzOiAnd2lkdGhzJyxcbiAgd29yZHNwYWNpbmc6ICd3b3JkU3BhY2luZycsXG4gICd3b3JkLXNwYWNpbmcnOiAnd29yZFNwYWNpbmcnLFxuICB3cml0aW5nbW9kZTogJ3dyaXRpbmdNb2RlJyxcbiAgJ3dyaXRpbmctbW9kZSc6ICd3cml0aW5nTW9kZScsXG4gIHgxOiAneDEnLFxuICB4MjogJ3gyJyxcbiAgeDogJ3gnLFxuICB4Y2hhbm5lbHNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhoZWlnaHQ6ICd4SGVpZ2h0JyxcbiAgJ3gtaGVpZ2h0JzogJ3hIZWlnaHQnLFxuICB4bGlua2FjdHVhdGU6ICd4bGlua0FjdHVhdGUnLFxuICAneGxpbms6YWN0dWF0ZSc6ICd4bGlua0FjdHVhdGUnLFxuICB4bGlua2FyY3JvbGU6ICd4bGlua0FyY3JvbGUnLFxuICAneGxpbms6YXJjcm9sZSc6ICd4bGlua0FyY3JvbGUnLFxuICB4bGlua2hyZWY6ICd4bGlua0hyZWYnLFxuICAneGxpbms6aHJlZic6ICd4bGlua0hyZWYnLFxuICB4bGlua3JvbGU6ICd4bGlua1JvbGUnLFxuICAneGxpbms6cm9sZSc6ICd4bGlua1JvbGUnLFxuICB4bGlua3Nob3c6ICd4bGlua1Nob3cnLFxuICAneGxpbms6c2hvdyc6ICd4bGlua1Nob3cnLFxuICB4bGlua3RpdGxlOiAneGxpbmtUaXRsZScsXG4gICd4bGluazp0aXRsZSc6ICd4bGlua1RpdGxlJyxcbiAgeGxpbmt0eXBlOiAneGxpbmtUeXBlJyxcbiAgJ3hsaW5rOnR5cGUnOiAneGxpbmtUeXBlJyxcbiAgeG1sYmFzZTogJ3htbEJhc2UnLFxuICAneG1sOmJhc2UnOiAneG1sQmFzZScsXG4gIHhtbGxhbmc6ICd4bWxMYW5nJyxcbiAgJ3htbDpsYW5nJzogJ3htbExhbmcnLFxuICB4bWxuczogJ3htbG5zJyxcbiAgJ3htbDpzcGFjZSc6ICd4bWxTcGFjZScsXG4gIHhtbG5zeGxpbms6ICd4bWxuc1hsaW5rJyxcbiAgJ3htbG5zOnhsaW5rJzogJ3htbG5zWGxpbmsnLFxuICB4bWxzcGFjZTogJ3htbFNwYWNlJyxcbiAgeTE6ICd5MScsXG4gIHkyOiAneTInLFxuICB5OiAneScsXG4gIHljaGFubmVsc2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogJ3onLFxuICB6b29tYW5kcGFuOiAnem9vbUFuZFBhbidcbn07XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0kMigpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxue1xuICB2YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG4gIHZhciBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVggPSAvXm9uW15BLVpdLztcbiAgdmFyIHJBUklBJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbiAgdmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuICB2YXIgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQxLmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3VzaW4nIHx8IGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c291dCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuICAgIGlmIChjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgLy8gSWYgbm8gZXZlbnQgcGx1Z2lucyBoYXZlIGJlZW4gaW5qZWN0ZWQsIHdlIGFyZSBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgICAgIC8vIFNvIHdlIGNhbid0IHRlbGwgaWYgdGhlIGV2ZW50IG5hbWUgaXMgY29ycmVjdCBmb3Igc3VyZSwgYnV0IHdlIGNhbiBmaWx0ZXJcbiAgICAgIC8vIG91dCBrbm93biBiYWQgb25lcyBsaWtlIGBvbmNsaWNrYC4gV2UgY2FuJ3Qgc3VnZ2VzdCBhIHNwZWNpZmljIHJlcGxhY2VtZW50IHRob3VnaC5cbiAgICAgIGlmIChJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuICcgKyAnUmVhY3QgZXZlbnRzIHVzZSB0aGUgY2FtZWxDYXNlIG5hbWluZyBjb252ZW50aW9uLCBmb3IgZXhhbXBsZSBgb25DbGlja2AuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB9XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaXMnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJXMnLCB0eXBlb2YgdmFsdWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZXNlcnZlZCA9IGlzUmVzZXJ2ZWRQcm9wKG5hbWUpO1xuXG4gICAgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cbiAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV07XG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LiVzJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgJiYgIXNob3VsZEF0dHJpYnV0ZUFjY2VwdEJvb2xlYW5WYWx1ZShuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJXMnLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4lcycsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgbmFtZSwgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgfVxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE5vdyB0aGF0IHdlJ3ZlIHZhbGlkYXRlZCBjYXNpbmcsIGRvIG5vdCB2YWxpZGF0ZVxuICAgIC8vIGRhdGEgdHlwZXMgZm9yIHJlc2VydmVkIHByb3BzXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdhcm4gd2hlbiBhIGtub3duIGF0dHJpYnV0ZSBpcyBhIGJhZCB0eXBlXG4gICAgaWYgKCFzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICB2YXIgdW5rbm93blByb3BzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSwgcHJvcHNba2V5XSwgY2FuVXNlRXZlbnRTeXN0ZW0pO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG4gIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWF0dHJpYnV0ZS1iZWhhdmlvciVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHZhbHVlcyBmb3IgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1hdHRyaWJ1dGUtYmVoYXZpb3IlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pO1xufVxuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlck93bmVyTmFtZTtcbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5TaGFkeURPTSA9IGZhbHNlO1xuXG52YXIgREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgPSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnO1xudmFyIFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyA9ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnO1xudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbnZhciBBVVRPRk9DVVMgPSAnYXV0b0ZvY3VzJztcbnZhciBDSElMRFJFTiA9ICdjaGlsZHJlbic7XG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIEhUTUwgPSAnX19odG1sJztcblxudmFyIEhUTUxfTkFNRVNQQUNFID0gTmFtZXNwYWNlcy5odG1sO1xuXG5cbnZhciBnZXRTdGFjayA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMoJycpO1xuXG57XG4gIGdldFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyO1xuXG4gIHZhciB3YXJuZWRVbmtub3duVGFncyA9IHtcbiAgICAvLyBDaHJvbWUgaXMgdGhlIG9ubHkgbWFqb3IgYnJvd3NlciBub3Qgc2hpcHBpbmcgPHRpbWU+LiBCdXQgYXMgb2YgSnVseVxuICAgIC8vIDIwMTcgaXQgaW50ZW5kcyB0byBzaGlwIGl0IGR1ZSB0byB3aWRlc3ByZWFkIHVzYWdlLiBXZSBpbnRlbnRpb25hbGx5XG4gICAgLy8gKmRvbid0KiB3YXJuIGZvciA8dGltZT4gZXZlbiBpZiBpdCdzIHVucmVjb2duaXplZCBieSBDaHJvbWUgYmVjYXVzZVxuICAgIC8vIGl0IHNvb24gd2lsbCBiZSwgYW5kIG1hbnkgYXBwcyBoYXZlIGJlZW4gdXNpbmcgaXQgYW55d2F5LlxuICAgIHRpbWU6IHRydWUsXG4gICAgLy8gVGhlcmUgYXJlIHdvcmtpbmcgcG9seWZpbGxzIGZvciA8ZGlhbG9nPi4gTGV0IHBlb3BsZSB1c2UgaXQuXG4gICAgZGlhbG9nOiB0cnVlXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgLyogY2FuVXNlRXZlbnRTeXN0ZW0gKi90cnVlKTtcbiAgfTtcblxuICAvLyBIVE1MIHBhcnNpbmcgbm9ybWFsaXplcyBDUiBhbmQgQ1JMRiB0byBMRi5cbiAgLy8gSXQgYWxzbyBjYW4gdHVybiBcXHUwMDAwIGludG8gXFx1RkZGRCBpbnNpZGUgYXR0cmlidXRlcy5cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3NpbmdsZS1wYWdlLmh0bWwjcHJlcHJvY2Vzc2luZy10aGUtaW5wdXQtc3RyZWFtXG4gIC8vIElmIHdlIGhhdmUgYSBtaXNtYXRjaCwgaXQgbWlnaHQgYmUgY2F1c2VkIGJ5IHRoYXQuXG4gIC8vIFdlIHdpbGwgc3RpbGwgcGF0Y2ggdXAgaW4gdGhpcyBjYXNlIGJ1dCBub3QgZmlyZSB0aGUgd2FybmluZy5cbiAgdmFyIE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCA9IC9cXHJcXG4/L2c7XG4gIHZhciBOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVggPSAvXFx1MDAwMHxcXHVGRkZEL2c7XG5cbiAgdmFyIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgbWFya3VwU3RyaW5nID0gdHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycgPyBtYXJrdXAgOiAnJyArIG1hcmt1cDtcbiAgICByZXR1cm4gbWFya3VwU3RyaW5nLnJlcGxhY2UoTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYLCAnXFxuJykucmVwbGFjZShOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVgsICcnKTtcbiAgfTtcblxuICB2YXIgd2FybkZvclRleHREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHNlcnZlclRleHQsIGNsaWVudFRleHQpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFRleHQpO1xuICAgIHZhciBub3JtYWxpemVkU2VydmVyVGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJUZXh0KTtcbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclRleHQgPT09IG5vcm1hbGl6ZWRDbGllbnRUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnVGV4dCBjb250ZW50IGRpZCBub3QgbWF0Y2guIFNlcnZlcjogXCIlc1wiIENsaWVudDogXCIlc1wiJywgbm9ybWFsaXplZFNlcnZlclRleHQsIG5vcm1hbGl6ZWRDbGllbnRUZXh0KTtcbiAgfTtcblxuICB2YXIgd2FybkZvclByb3BEaWZmZXJlbmNlID0gZnVuY3Rpb24gKHByb3BOYW1lLCBzZXJ2ZXJWYWx1ZSwgY2xpZW50VmFsdWUpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRWYWx1ZSk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJWYWx1ZSk7XG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9PT0gbm9ybWFsaXplZENsaWVudFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnUHJvcCBgJXNgIGRpZCBub3QgbWF0Y2guIFNlcnZlcjogJXMgQ2xpZW50OiAlcycsIHByb3BOYW1lLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VydmVyVmFsdWUpLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkQ2xpZW50VmFsdWUpKTtcbiAgfTtcblxuICB2YXIgd2FybkZvckV4dHJhQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lcykge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgYXR0cmlidXRlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgbmFtZXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXh0cmEgYXR0cmlidXRlcyBmcm9tIHRoZSBzZXJ2ZXI6ICVzJywgbmFtZXMpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAocmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIgPT09IGZhbHNlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBgZmFsc2VgLlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJXMnLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYCVzYCB0eXBlLiVzJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFBhcnNlIHRoZSBIVE1MIGFuZCByZWFkIGl0IGJhY2sgdG8gbm9ybWFsaXplIHRoZSBIVE1MIHN0cmluZyBzbyB0aGF0IGl0XG4gIC8vIGNhbiBiZSB1c2VkIGZvciBjb21wYXJpc29uLlxuICB2YXIgbm9ybWFsaXplSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQsIGh0bWwpIHtcbiAgICAvLyBXZSBjb3VsZCBoYXZlIGNyZWF0ZWQgYSBzZXBhcmF0ZSBkb2N1bWVudCBoZXJlIHRvIGF2b2lkXG4gICAgLy8gcmUtaW5pdGlhbGl6aW5nIGN1c3RvbSBlbGVtZW50cyBpZiB0aGV5IGV4aXN0LiBCdXQgdGhpcyBicmVha3NcbiAgICAvLyBob3cgPG5vc2NyaXB0PiBpcyBiZWluZyBoYW5kbGVkLiBTbyB3ZSB1c2UgdGhlIHNhbWUgZG9jdW1lbnQuXG4gICAgLy8gU2VlIHRoZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExMTU3LlxuICAgIHZhciB0ZXN0RWxlbWVudCA9IHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFID8gcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChwYXJlbnQudGFnTmFtZSkgOiBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocGFyZW50Lm5hbWVzcGFjZVVSSSwgcGFyZW50LnRhZ05hbWUpO1xuICAgIHRlc3RFbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIHRlc3RFbGVtZW50LmlubmVySFRNTDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGlzRG9jdW1lbnRPckZyYWdtZW50ID0gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG4gIHZhciBkb2MgPSBpc0RvY3VtZW50T3JGcmFnbWVudCA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHJldHVybiByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbn1cblxuLy8gVGhlcmUgYXJlIHNvIG1hbnkgbWVkaWEgZXZlbnRzLCBpdCBtYWtlcyBzZW5zZSB0byBqdXN0XG4vLyBtYWludGFpbiBhIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRlIGEgYHRyYXBCdWJibGVkRXZlbnRgIGZvciBlYWNoXG52YXIgbWVkaWFFdmVudHMgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZydcbn07XG5cbmZ1bmN0aW9uIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KG5vZGUpIHtcbiAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IGVtcHR5RnVuY3Rpb247XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIG5leHRQcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIG5leHRQcm9wLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHNldElubmVySFRNTChkb21FbGVtZW50LCBuZXh0SHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQXZvaWQgc2V0dGluZyBpbml0aWFsIHRleHRDb250ZW50IHdoZW4gdGhlIHRleHQgaXMgZW1wdHkuIEluIElFMTEgc2V0dGluZ1xuICAgICAgICAvLyB0ZXh0Q29udGVudCBvbiBhIDx0ZXh0YXJlYT4gd2lsbCBjYXVzZSB0aGUgcGxhY2Vob2xkZXIgdG8gbm90XG4gICAgICAgIC8vIHNob3cgd2l0aGluIHRoZSA8dGV4dGFyZWE+IHVudGlsIGl0IGhhcyBiZWVuIGZvY3VzZWQgYW5kIGJsdXJyZWQgYWdhaW4uXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjczMSNpc3N1ZWNvbW1lbnQtMjU0ODc0NTUzXG4gICAgICAgIHZhciBjYW5TZXRUZXh0Q29udGVudCA9IHRhZyAhPT0gJ3RleHRhcmVhJyB8fCBuZXh0UHJvcCAhPT0gJyc7XG4gICAgICAgIGlmIChjYW5TZXRUZXh0Q29udGVudCkge1xuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykge1xuICAgICAgLy8gV2UgcG9seWZpbGwgaXQgc2VwYXJhdGVseSBvbiB0aGUgY2xpZW50IGR1cmluZyBjb21taXQuXG4gICAgICAvLyBXZSBibGFja2xpc3QgaXQgaGVyZSByYXRoZXIgdGhhbiBpbiB0aGUgcHJvcGVydHkgbGlzdCBiZWNhdXNlIHdlIGVtaXQgaXQgaW4gU1NSLlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgIHNldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHVwZGF0aW5nIHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwcm9wZXJ0eVxuICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGVudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICAgIHNldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgLy8gVE9ETzogSGFuZGxlIHdhc0N1c3RvbUNvbXBvbmVudFRhZ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZVBheWxvYWQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgcHJvcEtleSA9IHVwZGF0ZVBheWxvYWRbaV07XG4gICAgdmFyIHByb3BWYWx1ZSA9IHVwZGF0ZVBheWxvYWRbaSArIDFdO1xuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgcHJvcFZhbHVlLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHNldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0ZW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVyRWxlbWVudCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gIC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICB2YXIgZG9tRWxlbWVudDtcbiAgdmFyIG5hbWVzcGFjZVVSSSA9IHBhcmVudE5hbWVzcGFjZTtcbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICBuYW1lc3BhY2VVUkkgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICB7XG4gICAgICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcyk7XG4gICAgICAvLyBTaG91bGQgdGhpcyBjaGVjayBiZSBnYXRlZCBieSBwYXJlbnQgbmFtZXNwYWNlPyBOb3Qgc3VyZSB3ZSB3YW50IHRvXG4gICAgICAvLyBhbGxvdyA8U1ZHPiBvciA8bUFUSD4uXG4gICAgICB3YXJuaW5nKGlzQ3VzdG9tQ29tcG9uZW50VGFnIHx8IHR5cGUgPT09IHR5cGUudG9Mb3dlckNhc2UoKSwgJzwlcyAvPiBpcyB1c2luZyB1cHBlcmNhc2UgSFRNTC4gQWx3YXlzIHVzZSBsb3dlcmNhc2UgSFRNTCB0YWdzICcgKyAnaW4gUmVhY3QuJywgdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzY3JpcHQnKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gJzxzY3JpcHQ+PCcgKyAnL3NjcmlwdD4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8geWllbGQgYSBzY3JpcHQgZWxlbWVudC5cbiAgICAgIHZhciBmaXJzdENoaWxkID0gZGl2LmZpcnN0Q2hpbGQ7XG4gICAgICBkb21FbGVtZW50ID0gZGl2LnJlbW92ZUNoaWxkKGZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gJEZsb3dJc3N1ZSBgY3JlYXRlRWxlbWVudGAgc2hvdWxkIGJlIHVwZGF0ZWQgZm9yIFdlYiBDb21wb25lbnRzXG4gICAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUsIHsgaXM6IHByb3BzLmlzIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY2F1c2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgIC8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHR5cGUpO1xuICB9XG5cbiAge1xuICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICBpZiAoIWlzQ3VzdG9tQ29tcG9uZW50VGFnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb21FbGVtZW50KSA9PT0gJ1tvYmplY3QgSFRNTFVua25vd25FbGVtZW50XScgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRVbmtub3duVGFncywgdHlwZSkpIHtcbiAgICAgICAgd2FybmVkVW5rbm93blRhZ3NbdHlwZV0gPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIHRhZyA8JXM+IGlzIHVucmVjb2duaXplZCBpbiB0aGlzIGJyb3dzZXIuICcgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIFJlYWN0IGNvbXBvbmVudCwgc3RhcnQgaXRzIG5hbWUgd2l0aCAnICsgJ2FuIHVwcGVyY2FzZSBsZXR0ZXIuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlJDEodGV4dCwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCByYXdQcm9wcyk7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIHZhciBwcm9wcztcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFN1Ym1pdCcsICdzdWJtaXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFRvZ2dsZScsICd0b2dnbGUnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzLCBnZXRTdGFjayk7XG5cbiAgc2V0SW5pdGlhbERPTVByb3BlcnRpZXModGFnLCBkb21FbGVtZW50LCByb290Q29udGFpbmVyRWxlbWVudCwgcHJvcHMsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuLy8gQ2FsY3VsYXRlIHRoZSBkaWZmIGJldHdlZW4gdGhlIHR3byBvYmplY3RzLlxuZnVuY3Rpb24gZGlmZlByb3BlcnRpZXMkMShkb21FbGVtZW50LCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgdXBkYXRlUGF5bG9hZCA9IG51bGw7XG5cbiAgdmFyIGxhc3RQcm9wcztcbiAgdmFyIG5leHRQcm9wcztcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbGFzdFByb3BzID0gbGFzdFJhd1Byb3BzO1xuICAgICAgbmV4dFByb3BzID0gbmV4dFJhd1Byb3BzO1xuICAgICAgaWYgKHR5cGVvZiBsYXN0UHJvcHMub25DbGljayAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbmV4dFByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBuZXh0UHJvcHMsIGdldFN0YWNrKTtcblxuICB2YXIgcHJvcEtleTtcbiAgdmFyIHN0eWxlTmFtZTtcbiAgdmFyIHN0eWxlVXBkYXRlcyA9IG51bGw7XG4gIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbGFzdFByb3BzW3Byb3BLZXldID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHZhciBsYXN0U3R5bGUgPSBsYXN0UHJvcHNbcHJvcEtleV07XG4gICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCB8fCBwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gTm9vcC4gVGhpcyBpcyBoYW5kbGVkIGJ5IHRoZSBjbGVhciB0ZXh0IG1lY2hhbmlzbS5cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxKSB7XG4gICAgICAvLyBOb29wXG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBBVVRPRk9DVVMpIHtcbiAgICAgIC8vIE5vb3AuIEl0IGRvZXNuJ3Qgd29yayBvbiB1cGRhdGVzIGFueXdheS5cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgZmliZXIgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbGwgb3RoZXIgZGVsZXRlZCBwcm9wZXJ0aWVzIHdlIGFkZCBpdCB0byB0aGUgcXVldWUuIFdlIHVzZVxuICAgICAgLy8gdGhlIHdoaXRlbGlzdCBpbiB0aGUgY29tbWl0IHBoYXNlIGluc3RlYWQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbnVsbCk7XG4gICAgfVxuICB9XG4gIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgdmFyIGxhc3RQcm9wID0gbGFzdFByb3BzICE9IG51bGwgPyBsYXN0UHJvcHNbcHJvcEtleV0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKCFuZXh0UHJvcCB8fCAhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gbmV4dFByb3Bbc3R5bGVOYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkLnB1c2gocHJvcEtleSwgc3R5bGVVcGRhdGVzKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3AgPyBsYXN0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcbiAgICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0SHRtbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IEl0IG1pZ2h0IGJlIHRvbyBsYXRlIHRvIGNsZWFyIHRoaXMgaWYgd2UgaGF2ZSBjaGlsZHJlblxuICAgICAgICAvLyBpbnNlcnRlZCBhbHJlYWR5LlxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmIChsYXN0UHJvcCAhPT0gbmV4dFByb3AgJiYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBlYWdlcmx5IGxpc3RlbiB0byB0aGlzIGV2ZW4gdGhvdWdoIHdlIGhhdmVuJ3QgY29tbWl0dGVkIHlldC5cbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgICBpZiAoIXVwZGF0ZVBheWxvYWQgJiYgbGFzdFByb3AgIT09IG5leHRQcm9wKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAgIC8vIHRoYXQgdGhlIFwiY3VycmVudFwiIHByb3BzIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbiAgICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYW55IG90aGVyIHByb3BlcnR5IHdlIGFsd2F5cyBhZGQgaXQgdG8gdGhlIHF1ZXVlIGFuZCB0aGVuIHdlXG4gICAgICAvLyBmaWx0ZXIgaXQgb3V0IHVzaW5nIHRoZSB3aGl0ZWxpc3QgZHVyaW5nIHRoZSBjb21taXQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH1cbiAgfVxuICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKFNUWUxFLCBzdHlsZVVwZGF0ZXMpO1xuICB9XG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufVxuXG4vLyBBcHBseSB0aGUgZGlmZi5cbmZ1bmN0aW9uIHVwZGF0ZVByb3BlcnRpZXMkMShkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzKSB7XG4gIC8vIFVwZGF0ZSBjaGVja2VkICpiZWZvcmUqIG5hbWUuXG4gIC8vIEluIHRoZSBtaWRkbGUgb2YgYW4gdXBkYXRlLCBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIG11bHRpcGxlIGNoZWNrZWQuXG4gIC8vIFdoZW4gYSBjaGVja2VkIHJhZGlvIHRyaWVzIHRvIGNoYW5nZSBuYW1lLCBicm93c2VyIG1ha2VzIGFub3RoZXIgcmFkaW8ncyBjaGVja2VkIGZhbHNlLlxuICBpZiAodGFnID09PSAnaW5wdXQnICYmIG5leHRSYXdQcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5leHRSYXdQcm9wcy5uYW1lICE9IG51bGwpIHtcbiAgICB1cGRhdGVDaGVja2VkKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgd2FzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCBsYXN0UmF3UHJvcHMpO1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIG5leHRSYXdQcm9wcyk7XG4gIC8vIEFwcGx5IHRoZSBkaWZmLlxuICB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuXG4gIC8vIFRPRE86IEVuc3VyZSB0aGF0IGFuIHVwZGF0ZSBnZXRzIHNjaGVkdWxlZCBpZiBhbnkgb2YgdGhlIHNwZWNpYWwgcHJvcHNcbiAgLy8gY2hhbmdlZC5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZXIgYXJvdW5kIGlucHV0cyAqYWZ0ZXIqIHVwZGF0aW5nIHByb3BzLiBUaGlzIGhhcyB0b1xuICAgICAgLy8gaGFwcGVuIGFmdGVyIGB1cGRhdGVET01Qcm9wZXJ0aWVzYC4gT3RoZXJ3aXNlIEhUTUw1IGlucHV0IHZhbGlkYXRpb25zXG4gICAgICAvLyByYWlzZSB3YXJuaW5ncyBhbmQgcHJldmVudCB0aGUgbmV3IHZhbHVlIGZyb20gYmVpbmcgYXNzaWduZWQuXG4gICAgICB1cGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICB1cGRhdGVXcmFwcGVyJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICBwb3N0VXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHRhZywgcmF3UHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAge1xuICAgIHZhciBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgPSByYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSA9PT0gdHJ1ZTtcbiAgICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFN1Ym1pdCcsICdzdWJtaXQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wVG9nZ2xlJywgJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgdmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCByYXdQcm9wcywgZ2V0U3RhY2spO1xuXG4gIHtcbiAgICB2YXIgZXh0cmFBdHRyaWJ1dGVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGRvbUVsZW1lbnQuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlc1tpXS5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgLy8gQnVpbHQtaW4gU1NSIGF0dHJpYnV0ZSBpcyB3aGl0ZWxpc3RlZFxuICAgICAgICBjYXNlICdkYXRhLXJlYWN0cm9vdCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuICAgICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgdXNlIHRoZSBvcmlnaW5hbCBuYW1lLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEwNjc2LlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuYWRkKGF0dHJpYnV0ZXNbaV0ubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuICBmb3IgKHZhciBwcm9wS2V5IGluIHJhd1Byb3BzKSB7XG4gICAgaWYgKCFyYXdQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IHJhd1Byb3BzW3Byb3BLZXldO1xuICAgIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gRm9yIHRleHQgY29udGVudCBjaGlsZHJlbiB3ZSBjb21wYXJlIGFnYWluc3QgdGV4dENvbnRlbnQuIFRoaXNcbiAgICAgIC8vIG1pZ2h0IG1hdGNoIGFkZGl0aW9uYWwgSFRNTCB0aGF0IGlzIGhpZGRlbiB3aGVuIHdlIHJlYWQgaXQgdXNpbmdcbiAgICAgIC8vIHRleHRDb250ZW50LiBFLmcuIFwiZm9vXCIgd2lsbCBtYXRjaCBcImY8c3Bhbj5vbzwvc3Bhbj5cIiBidXQgdGhhdCBzdGlsbFxuICAgICAgLy8gc2F0aXNmaWVzIG91ciByZXF1aXJlbWVudC4gT3VyIHJlcXVpcmVtZW50IGlzIG5vdCB0byBwcm9kdWNlIHBlcmZlY3RcbiAgICAgIC8vIEhUTUwgYW5kIGF0dHJpYnV0ZXMuIElkZWFsbHkgd2Ugc2hvdWxkIHByZXNlcnZlIHN0cnVjdHVyZSBidXQgaXQnc1xuICAgICAgLy8gb2sgbm90IHRvIGlmIHRoZSB2aXNpYmxlIGNvbnRlbnQgaXMgc3RpbGwgZW5vdWdoIHRvIGluZGljYXRlIHdoYXRcbiAgICAgIC8vIGV2ZW4gbGlzdGVuZXJzIHRoZXNlIG5vZGVzIG1pZ2h0IGJlIHdpcmVkIHVwIHRvLlxuICAgICAgLy8gVE9ETzogV2FybiBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gYSBzaW5nbGUgdGV4dE5vZGUgYXMgYSBjaGlsZC5cbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSB1c2UgZG9tRWxlbWVudC5maXJzdENoaWxkLm5vZGVWYWx1ZSB0byBjb21wYXJlP1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09IG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHRydWUgJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtDSElMRFJFTiwgbmV4dFByb3BdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09ICcnICsgbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAodHJ1ZSAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCAnJyArIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gdGhlaXIgZXhwZWN0ZWQgdmFsdWVzLlxuICAgICAgdmFyIHNlcnZlclZhbHVlO1xuICAgICAgdmFyIHByb3BlcnR5SW5mbztcbiAgICAgIGlmIChzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZy4gV2UncmUgaWdub3JpbmcgYWxsIHRoZXNlIHdhcm5pbmdzLlxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSB8fFxuICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgIHByb3BLZXkgPT09ICd2YWx1ZScgfHwgcHJvcEtleSA9PT0gJ2NoZWNrZWQnIHx8IHByb3BLZXkgPT09ICdzZWxlY3RlZCcpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgcmF3SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gfHwgJycgOiAnJztcbiAgICAgICAgdmFyIHNlcnZlckhUTUwgPSBkb21FbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgdmFyIGV4cGVjdGVkSFRNTCA9IG5vcm1hbGl6ZUhUTUwoZG9tRWxlbWVudCwgcmF3SHRtbCk7XG4gICAgICAgIGlmIChleHBlY3RlZEhUTUwgIT09IHNlcnZlckhUTUwpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BLZXkpO1xuICAgICAgICB2YXIgZXhwZWN0ZWRTdHlsZSA9IGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhuZXh0UHJvcCk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIGlmIChleHBlY3RlZFN0eWxlICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgZXhwZWN0ZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkU2V0QXR0cmlidXRlKHByb3BLZXksIG5leHRQcm9wKSkge1xuICAgICAgICBpZiAocHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKHByb3BLZXkpKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvd25OYW1lc3BhY2UgPSBwYXJlbnROYW1lc3BhY2U7XG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgIG93bk5hbWVzcGFjZSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0YWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3duTmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICBpZiAoZXh0cmFBdHRyaWJ1dGVOYW1lcy5zaXplID4gMCAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzKGV4dHJhQXR0cmlidXRlTmFtZXMpO1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgLy8gRm9yIGlucHV0IGFuZCB0ZXh0YXJlYSB3ZSBjdXJyZW50IGFsd2F5cyBzZXQgdGhlIHZhbHVlIHByb3BlcnR5IGF0XG4gICAgICAvLyBwb3N0IG1vdW50IHRvIGZvcmNlIGl0IHRvIGRpdmVyZ2UgZnJvbSBhdHRyaWJ1dGVzLiBIb3dldmVyLCBmb3JcbiAgICAgIC8vIG9wdGlvbiBhbmQgc2VsZWN0IHdlIGRvbid0IHF1aXRlIGRvIHRoZSBzYW1lIHRoaW5nIGFuZCBzZWxlY3RcbiAgICAgIC8vIGlzIG5vdCByZXNpbGllbnQgdG8gdGhlIERPTSBzdGF0ZSBjaGFuZ2luZyBzbyB3ZSBkb24ndCBkbyB0aGF0IGhlcmUuXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciBub3QgZG9pbmcgdGhpcyBmb3IgaW5wdXQgYW5kIHRleHRhcmVhLlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0eXBlb2YgcmF3UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbmZ1bmN0aW9uIGRpZmZIeWRyYXRlZFRleHQkMSh0ZXh0Tm9kZSwgdGV4dCkge1xuICB2YXIgaXNEaWZmZXJlbnQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWUgIT09IHRleHQ7XG4gIHJldHVybiBpc0RpZmZlcmVudDtcbn1cblxuZnVuY3Rpb24gd2FybkZvclVubWF0Y2hlZFRleHQkMSh0ZXh0Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgd2FybkZvclRleHREaWZmZXJlbmNlKHRleHROb2RlLm5vZGVWYWx1ZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxKHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgPCVzPiBpbiA8JXM+LicsIGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxKHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIHRoZSB0ZXh0IG5vZGUgXCIlc1wiIGluIDwlcz4uJywgY2hpbGQubm9kZVZhbHVlLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxKHBhcmVudE5vZGUsIHRhZywgcHJvcHMpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyA8JXM+IGluIDwlcz4uJywgdGFnLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxKHBhcmVudE5vZGUsIHRleHQpIHtcbiAge1xuICAgIGlmICh0ZXh0ID09PSAnJykge1xuICAgICAgLy8gV2UgZXhwZWN0IHRvIGluc2VydCBlbXB0eSB0ZXh0IG5vZGVzIHNpbmNlIHRoZXkncmUgbm90IHJlcHJlc2VudGVkIGluXG4gICAgICAvLyB0aGUgSFRNTC5cbiAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBpZiB3ZSBjYW4ganVzdCBhdm9pZCBpbnNlcnRpbmcgZW1wdHlcbiAgICAgIC8vIHRleHQgbm9kZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyB0ZXh0IG5vZGUgZm9yIFwiJXNcIiBpbiA8JXM+LicsIHRleHQsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShkb21FbGVtZW50LCB0YWcsIHByb3BzKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICB9XG59XG5cbnZhciBSZWFjdERPTUZpYmVyQ29tcG9uZW50ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlJDEsXG5cdHNldEluaXRpYWxQcm9wZXJ0aWVzOiBzZXRJbml0aWFsUHJvcGVydGllcyQxLFxuXHRkaWZmUHJvcGVydGllczogZGlmZlByb3BlcnRpZXMkMSxcblx0dXBkYXRlUHJvcGVydGllczogdXBkYXRlUHJvcGVydGllcyQxLFxuXHRkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzOiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEsXG5cdGRpZmZIeWRyYXRlZFRleHQ6IGRpZmZIeWRyYXRlZFRleHQkMSxcblx0d2FybkZvclVubWF0Y2hlZFRleHQ6IHdhcm5Gb3JVbm1hdGNoZWRUZXh0JDEsXG5cdHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQ6IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQkMSxcblx0d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dDogd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxLFxuXHR3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQ6IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxLFxuXHR3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQ6IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxLFxuXHRyZXN0b3JlQ29udHJvbGxlZFN0YXRlOiByZXN0b3JlQ29udHJvbGxlZFN0YXRlXG59KTtcblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGVtcHR5RnVuY3Rpb247XG5cbntcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvJDEgPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnLCBpbnN0YW5jZSkge1xuICAgIHZhciBhbmNlc3RvckluZm8gPSBfYXNzaWduKHt9LCBvbGRJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW5mbyA9IHsgdGFnOiB0YWcsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xuXG4gICAgaWYgKGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNlc3RvckluZm8uY3VycmVudCA9IGluZm87XG5cbiAgICBpZiAodGFnID09PSAnZm9ybScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbm9icicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnZGQnIHx8IHRhZyA9PT0gJ2R0Jykge1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICBjYXNlICdvcHRncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbiAgICAgIC8vIGJ1dFxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuICAgICAgLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY2FwdGlvbicgfHwgdGFnID09PSAnY29sZ3JvdXAnIHx8IHRhZyA9PT0gJ3Rib2R5JyB8fCB0YWcgPT09ICd0Zm9vdCcgfHwgdGFnID09PSAndGhlYWQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keSc7XG4gICAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaHRtbCc7XG4gICAgfVxuXG4gICAgLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0ZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICBjYXNlICd0aCc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXG4gICAgICAgIC8vIHBhcnNpbmcgcnVsZXMgLS0gaWYgd2UncmUgZG93biBoZXJlLCB0aGVuIG5vbmUgb2YgdGhvc2UgbWF0Y2hlZCBhbmRcbiAgICAgICAgLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4gICAgICAgIC8vIGNhc2VzIGFyZSBpbnZhbGlkLlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnID09IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICBjYXNlICdhcnRpY2xlJzpcbiAgICAgIGNhc2UgJ2FzaWRlJzpcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGNhc2UgJ2Rpcic6XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAnZGwnOlxuICAgICAgY2FzZSAnZmllbGRzZXQnOlxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XG4gICAgICBjYXNlICdmaWd1cmUnOlxuICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBjYXNlICdoZ3JvdXAnOlxuICAgICAgY2FzZSAnbWFpbic6XG4gICAgICBjYXNlICdtZW51JzpcbiAgICAgIGNhc2UgJ25hdic6XG4gICAgICBjYXNlICdvbCc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBjYXNlICd1bCc6XG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICBjYXNlICdocic6XG4gICAgICBjYXNlICd4bXAnOlxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4gPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoY2hpbGRUYWcsIGNoaWxkVGV4dCwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICBpZiAoY2hpbGRUZXh0ICE9IG51bGwpIHtcbiAgICAgIHdhcm5pbmcoY2hpbGRUYWcgPT0gbnVsbCwgJ3ZhbGlkYXRlRE9NTmVzdGluZzogd2hlbiBjaGlsZFRleHQgaXMgcGFzc2VkLCBjaGlsZFRhZyBzaG91bGQgYmUgbnVsbCcpO1xuICAgICAgY2hpbGRUYWcgPSAnI3RleHQnO1xuICAgIH1cblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBpbnZhbGlkUGFyZW50T3JBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuICAgIGlmICghaW52YWxpZFBhcmVudE9yQW5jZXN0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYW5jZXN0b3JUYWcgPSBpbnZhbGlkUGFyZW50T3JBbmNlc3Rvci50YWc7XG4gICAgdmFyIGFkZGVuZHVtID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ2KCk7XG5cbiAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBhZGRlbmR1bTtcbiAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xuICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xuICAgIGlmIChjaGlsZFRhZyA9PT0gJyN0ZXh0Jykge1xuICAgICAgaWYgKC9cXFMvLnRlc3QoY2hpbGRUZXh0KSkge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdUZXh0IG5vZGVzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1doaXRlc3BhY2UgdGV4dCBub2Rlcyc7XG4gICAgICAgIHdoaXRlc3BhY2VJbmZvID0gXCIgTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiBcIiArICdlYWNoIGxpbmUgb2YgeW91ciBzb3VyY2UgY29kZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgIH1cblxuICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgIH1cbiAgICAgIHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uJXMlcyVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgaW5mbywgYWRkZW5kdW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4lcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUT0RPOiB0dXJuIHRoaXMgaW50byBhIG5hbWVkIGV4cG9ydFxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8kMTtcblxuICAvLyBGb3IgdGVzdGluZ1xuICB2YWxpZGF0ZURPTU5lc3RpbmcuaXNUYWdWYWxpZEluQ29udGV4dCA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuICAgIHJldHVybiBpc1RhZ1ZhbGlkV2l0aFBhcmVudCh0YWcsIHBhcmVudFRhZykgJiYgIWZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcodGFnLCBhbmNlc3RvckluZm8pO1xuICB9O1xufVxuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nJDEgPSB2YWxpZGF0ZURPTU5lc3Rpbmc7XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBjcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xudmFyIGNyZWF0ZVRleHROb2RlID0gY3JlYXRlVGV4dE5vZGUkMTtcbnZhciBzZXRJbml0aWFsUHJvcGVydGllcyA9IHNldEluaXRpYWxQcm9wZXJ0aWVzJDE7XG52YXIgZGlmZlByb3BlcnRpZXMgPSBkaWZmUHJvcGVydGllcyQxO1xudmFyIHVwZGF0ZVByb3BlcnRpZXMgPSB1cGRhdGVQcm9wZXJ0aWVzJDE7XG52YXIgZGlmZkh5ZHJhdGVkUHJvcGVydGllcyA9IGRpZmZIeWRyYXRlZFByb3BlcnRpZXMkMTtcbnZhciBkaWZmSHlkcmF0ZWRUZXh0ID0gZGlmZkh5ZHJhdGVkVGV4dCQxO1xudmFyIHdhcm5Gb3JVbm1hdGNoZWRUZXh0ID0gd2FybkZvclVubWF0Y2hlZFRleHQkMTtcbnZhciB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50ID0gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxO1xudmFyIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQgPSB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDE7XG52YXIgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50ID0gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDE7XG52YXIgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0ID0gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDE7XG52YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IHZhbGlkYXRlRE9NTmVzdGluZyQxLnVwZGF0ZWRBbmNlc3RvckluZm87XG52YXIgcHJlY2FjaGVGaWJlck5vZGUgPSBwcmVjYWNoZUZpYmVyTm9kZSQxO1xudmFyIHVwZGF0ZUZpYmVyUHJvcHMgPSB1cGRhdGVGaWJlclByb3BzJDE7XG5cblxue1xuICB2YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbiAgaWYgKHR5cGVvZiBNYXAgIT09ICdmdW5jdGlvbicgfHwgTWFwLnByb3RvdHlwZSA9PSBudWxsIHx8IHR5cGVvZiBNYXAucHJvdG90eXBlLmZvckVhY2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldCAhPT0gJ2Z1bmN0aW9uJyB8fCBTZXQucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuY2xlYXIgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkZXBlbmRzIG9uIE1hcCBhbmQgU2V0IGJ1aWx0LWluIHR5cGVzLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHA6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxufVxuXG5pbmplY3Rpb24kMy5pbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50KFJlYWN0RE9NRmliZXJDb21wb25lbnQpO1xuXG52YXIgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG52YXIgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgdmFsaWQgbm9kZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBpcyBhIHZhbGlkIERPTSBub2RlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUgJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtbW91bnQtcG9pbnQtdW5zdGFibGUgJykpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiAhIShyb290RWxlbWVudCAmJiByb290RWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHJvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZShST09UX0FUVFJJQlVURV9OQU1FKSk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYnV0dG9uJzpcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXR1cm4gISFwcm9wcy5hdXRvRm9jdXM7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgRE9NUmVuZGVyZXIgPSByZWFjdFJlY29uY2lsZXIoe1xuICBnZXRSb290SG9zdENvbnRleHQ6IGZ1bmN0aW9uIChyb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICB2YXIgdHlwZSA9IHZvaWQgMDtcbiAgICB2YXIgbmFtZXNwYWNlID0gdm9pZCAwO1xuICAgIHZhciBub2RlVHlwZSA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5ub2RlVHlwZTtcbiAgICBzd2l0Y2ggKG5vZGVUeXBlKSB7XG4gICAgICBjYXNlIERPQ1VNRU5UX05PREU6XG4gICAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlID0gbm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyAnI2RvY3VtZW50JyA6ICcjZnJhZ21lbnQnO1xuICAgICAgICAgIHZhciByb290ID0gcm9vdENvbnRhaW5lckluc3RhbmNlLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICBuYW1lc3BhY2UgPSByb290ID8gcm9vdC5uYW1lc3BhY2VVUkkgOiBnZXRDaGlsZE5hbWVzcGFjZShudWxsLCAnJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gbm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJJbnN0YW5jZS5wYXJlbnROb2RlIDogcm9vdENvbnRhaW5lckluc3RhbmNlO1xuICAgICAgICAgIHZhciBvd25OYW1lc3BhY2UgPSBjb250YWluZXIubmFtZXNwYWNlVVJJIHx8IG51bGw7XG4gICAgICAgICAgdHlwZSA9IGNvbnRhaW5lci50YWdOYW1lO1xuICAgICAgICAgIG5hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKG93bk5hbWVzcGFjZSwgdHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAge1xuICAgICAgdmFyIHZhbGlkYXRlZFRhZyA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBfYW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLCB2YWxpZGF0ZWRUYWcsIG51bGwpO1xuICAgICAgcmV0dXJuIHsgbmFtZXNwYWNlOiBuYW1lc3BhY2UsIGFuY2VzdG9ySW5mbzogX2FuY2VzdG9ySW5mbyB9O1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXNwYWNlO1xuICB9LFxuICBnZXRDaGlsZEhvc3RDb250ZXh0OiBmdW5jdGlvbiAocGFyZW50SG9zdENvbnRleHQsIHR5cGUpIHtcbiAgICB7XG4gICAgICB2YXIgcGFyZW50SG9zdENvbnRleHREZXYgPSBwYXJlbnRIb3N0Q29udGV4dDtcbiAgICAgIHZhciBfbmFtZXNwYWNlID0gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50SG9zdENvbnRleHREZXYubmFtZXNwYWNlLCB0eXBlKTtcbiAgICAgIHZhciBfYW5jZXN0b3JJbmZvMiA9IHVwZGF0ZWRBbmNlc3RvckluZm8ocGFyZW50SG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlLCBudWxsKTtcbiAgICAgIHJldHVybiB7IG5hbWVzcGFjZTogX25hbWVzcGFjZSwgYW5jZXN0b3JJbmZvOiBfYW5jZXN0b3JJbmZvMiB9O1xuICAgIH1cbiAgICB2YXIgcGFyZW50TmFtZXNwYWNlID0gcGFyZW50SG9zdENvbnRleHQ7XG4gICAgcmV0dXJuIGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgdHlwZSk7XG4gIH0sXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0sXG4gIHByZXBhcmVGb3JDb21taXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBldmVudHNFbmFibGVkID0gaXNFbmFibGVkKCk7XG4gICAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpO1xuICAgIHNldEVuYWJsZWQoZmFsc2UpO1xuICB9LFxuICByZXNldEFmdGVyQ29tbWl0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmVzdG9yZVNlbGVjdGlvbihzZWxlY3Rpb25JbmZvcm1hdGlvbik7XG4gICAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuICAgIHNldEVuYWJsZWQoZXZlbnRzRW5hYmxlZCk7XG4gICAgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG4gIH0sXG4gIGNyZWF0ZUluc3RhbmNlOiBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICB2YXIgcGFyZW50TmFtZXNwYWNlID0gdm9pZCAwO1xuICAgIHtcbiAgICAgIC8vIFRPRE86IHRha2UgbmFtZXNwYWNlIGludG8gYWNjb3VudCB3aGVuIHZhbGlkYXRpbmcuXG4gICAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKHR5cGUsIG51bGwsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIHByb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgICB9XG4gICAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gICAgfVxuICAgIHZhciBkb21FbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBwYXJlbnROYW1lc3BhY2UpO1xuICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGRvbUVsZW1lbnQpO1xuICAgIHVwZGF0ZUZpYmVyUHJvcHMoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgIHJldHVybiBkb21FbGVtZW50O1xuICB9LFxuICBhcHBlbmRJbml0aWFsQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH0sXG4gIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIHJldHVybiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIHByb3BzKTtcbiAgfSxcbiAgcHJlcGFyZVVwZGF0ZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAgIHtcbiAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgaWYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiAhPT0gdHlwZW9mIG9sZFByb3BzLmNoaWxkcmVuICYmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIG5ld1Byb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWZmUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIH0sXG4gIHNob3VsZFNldFRleHRDb250ZW50OiBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ3RleHRhcmVhJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPT0gbnVsbCAmJiB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sID09PSAnc3RyaW5nJztcbiAgfSxcbiAgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTogZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgcmV0dXJuICEhcHJvcHMuaGlkZGVuO1xuICB9LFxuICBjcmVhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uICh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAge1xuICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCB0ZXh0LCBob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8pO1xuICAgIH1cbiAgICB2YXIgdGV4dE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHROb2RlKTtcbiAgICByZXR1cm4gdGV4dE5vZGU7XG4gIH0sXG5cblxuICBub3c6IG5vdyxcblxuICBtdXRhdGlvbjoge1xuICAgIGNvbW1pdE1vdW50OiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIGRvbUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9LFxuICAgIGNvbW1pdFVwZGF0ZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgLy8gVXBkYXRlIHRoZSBwcm9wcyBoYW5kbGUgc28gdGhhdCB3ZSBrbm93IHdoaWNoIHByb3BzIGFyZSB0aGUgb25lcyB3aXRoXG4gICAgICAvLyB3aXRoIGN1cnJlbnQgZXZlbnQgaGFuZGxlcnMuXG4gICAgICB1cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsIG5ld1Byb3BzKTtcbiAgICAgIC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBET00gbm9kZS5cbiAgICAgIHVwZGF0ZVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKTtcbiAgICB9LFxuICAgIHJlc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChkb21FbGVtZW50KSB7XG4gICAgICBkb21FbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gICAgfSxcbiAgICBjb21taXRUZXh0VXBkYXRlOiBmdW5jdGlvbiAodGV4dEluc3RhbmNlLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gbmV3VGV4dDtcbiAgICB9LFxuICAgIGFwcGVuZENoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfSxcbiAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyOiBmdW5jdGlvbiAoY29udGFpbmVyLCBjaGlsZCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICB9LFxuICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlOiBmdW5jdGlvbiAoY29udGFpbmVyLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICBjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfSxcbiAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXIsIGNoaWxkKSB7XG4gICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaHlkcmF0aW9uOiB7XG4gICAgY2FuSHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IGluc3RhbmNlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGFuIGVsZW1lbnQgbm9kZS5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9LFxuICAgIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRleHQgPT09ICcnIHx8IGluc3RhbmNlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAgICAgLy8gRW1wdHkgc3RyaW5ncyBhcmUgbm90IHBhcnNlZCBieSBIVE1MIHNvIHRoZXJlIHdvbid0IGJlIGEgY29ycmVjdCBtYXRjaCBoZXJlLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYSB0ZXh0IG5vZGUuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSxcbiAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmc6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgdmFyIG5vZGUgPSBpbnN0YW5jZS5uZXh0U2libGluZztcbiAgICAgIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gICAgICB3aGlsZSAobm9kZSAmJiBub2RlLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgJiYgbm9kZS5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlKSB7XG4gICAgICB2YXIgbmV4dCA9IHBhcmVudEluc3RhbmNlLmZpcnN0Q2hpbGQ7XG4gICAgICAvLyBTa2lwIG5vbi1oeWRyYXRhYmxlIG5vZGVzLlxuICAgICAgd2hpbGUgKG5leHQgJiYgbmV4dC5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFICYmIG5leHQubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0sXG4gICAgaHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBpbnN0YW5jZSk7XG4gICAgICAvLyBUT0RPOiBQb3NzaWJseSBkZWZlciB0aGlzIHVudGlsIHRoZSBjb21taXQgcGhhc2Ugd2hlcmUgYWxsIHRoZSBldmVudHNcbiAgICAgIC8vIGdldCBhdHRhY2hlZC5cbiAgICAgIHVwZGF0ZUZpYmVyUHJvcHMoaW5zdGFuY2UsIHByb3BzKTtcbiAgICAgIHZhciBwYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgICB9LFxuICAgIGh5ZHJhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uICh0ZXh0SW5zdGFuY2UsIHRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHRJbnN0YW5jZSk7XG4gICAgICByZXR1cm4gZGlmZkh5ZHJhdGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgIH0sXG4gICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgdGV4dEluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICB3YXJuRm9yVW5tYXRjaGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSkge1xuICAgICAge1xuICAgICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcykge1xuICAgICAge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgdGV4dCkge1xuICAgICAge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gICAgICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjazogcklDLFxuICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrOiBjSUMsXG5cbiAgdXNlU3luY1NjaGVkdWxpbmc6ICFlbmFibGVBc3luY1NjaGVkdWxpbmdCeURlZmF1bHRJblJlYWN0RE9NXG59KTtcblxuaW5qZWN0aW9uJDQuaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlcyhET01SZW5kZXJlci5iYXRjaGVkVXBkYXRlcyk7XG5cbnZhciB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSBmYWxzZTtcblxuZnVuY3Rpb24gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUsIGNhbGxiYWNrKSB7XG4gICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gIHtcbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgJiYgY29udGFpbmVyLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBET01SZW5kZXJlci5maW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lci5jdXJyZW50KTtcbiAgICAgIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICAgICAgd2FybmluZyhob3N0SW5zdGFuY2UucGFyZW50Tm9kZSA9PT0gY29udGFpbmVyLCAncmVuZGVyKC4uLik6IEl0IGxvb2tzIGxpa2UgdGhlIFJlYWN0LXJlbmRlcmVkIGNvbnRlbnQgb2YgdGhpcyAnICsgJ2NvbnRhaW5lciB3YXMgcmVtb3ZlZCB3aXRob3V0IHVzaW5nIFJlYWN0LiBUaGlzIGlzIG5vdCAnICsgJ3N1cHBvcnRlZCBhbmQgd2lsbCBjYXVzZSBlcnJvcnMuIEluc3RlYWQsIGNhbGwgJyArICdSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlIHRvIGVtcHR5IGEgY29udGFpbmVyLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0ID0gISFjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEocm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUkMShyb290RWwpKTtcblxuICAgIHdhcm5pbmcoIWhhc05vblJvb3RSZWFjdENoaWxkIHx8IGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QsICdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpO1xuXG4gICAgd2FybmluZyhjb250YWluZXIubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCAhY29udGFpbmVyLnRhZ05hbWUgfHwgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0JPRFknLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKTtcbiAgfVxuXG4gIHZhciByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIGlmICghcm9vdCkge1xuICAgIHZhciBzaG91bGRIeWRyYXRlID0gZm9yY2VIeWRyYXRlIHx8IHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpO1xuICAgIC8vIEZpcnN0IGNsZWFyIGFueSBleGlzdGluZyBjb250ZW50LlxuICAgIGlmICghc2hvdWxkSHlkcmF0ZSkge1xuICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgICAgdmFyIHJvb3RTaWJsaW5nID0gdm9pZCAwO1xuICAgICAgd2hpbGUgKHJvb3RTaWJsaW5nID0gY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKCF3YXJuZWQgJiYgcm9vdFNpYmxpbmcubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290U2libGluZy5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpIHtcbiAgICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdFNpYmxpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICBpZiAoc2hvdWxkSHlkcmF0ZSAmJiAhZm9yY2VIeWRyYXRlICYmICF3YXJuZWRBYm91dEh5ZHJhdGVBUEkpIHtcbiAgICAgICAgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gdHJ1ZTtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdyZW5kZXIoKTogQ2FsbGluZyBSZWFjdERPTS5yZW5kZXIoKSB0byBoeWRyYXRlIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAgJyArICd3aWxsIHN0b3Agd29ya2luZyBpbiBSZWFjdCB2MTcuIFJlcGxhY2UgdGhlIFJlYWN0RE9NLnJlbmRlcigpIGNhbGwgJyArICd3aXRoIFJlYWN0RE9NLmh5ZHJhdGUoKSBpZiB5b3Ugd2FudCBSZWFjdCB0byBhdHRhY2ggdG8gdGhlIHNlcnZlciBIVE1MLicpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbmV3Um9vdCA9IERPTVJlbmRlcmVyLmNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIHNob3VsZEh5ZHJhdGUpO1xuICAgIHJvb3QgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IG5ld1Jvb3Q7XG4gICAgLy8gSW5pdGlhbCBtb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgRE9NUmVuZGVyZXIudW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIG5ld1Jvb3QsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIERPTVJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgcm9vdCwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gIH1cbiAgcmV0dXJuIERPTVJlbmRlcmVyLmdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIpIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcblxuICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAnVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IHZvaWQgMDtcbiAgLy8gVE9ETzogcGFzcyBSZWFjdERPTSBwb3J0YWwgaW1wbGVtZW50YXRpb24gYXMgdGhpcmQgYXJndW1lbnRcbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXIsIG51bGwsIGtleSk7XG59XG5cbmZ1bmN0aW9uIFJlYWN0Um9vdChjb250YWluZXIsIGh5ZHJhdGUpIHtcbiAgdmFyIHJvb3QgPSBET01SZW5kZXJlci5jcmVhdGVDb250YWluZXIoY29udGFpbmVyLCBoeWRyYXRlKTtcbiAgdGhpcy5fcmVhY3RSb290Q29udGFpbmVyID0gcm9vdDtcbn1cblJlYWN0Um9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBjYWxsYmFjaykge1xuICB2YXIgcm9vdCA9IHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBudWxsLCBjYWxsYmFjayk7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5fcmVhY3RSb290Q29udGFpbmVyO1xuICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIobnVsbCwgcm9vdCwgbnVsbCwgY2FsbGJhY2spO1xufTtcblxudmFyIFJlYWN0RE9NID0ge1xuICBjcmVhdGVQb3J0YWw6IGNyZWF0ZVBvcnRhbCxcblxuICBmaW5kRE9NTm9kZTogZnVuY3Rpb24gKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICAgIHtcbiAgICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHdhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtcbiAgICAgICAgd2FybmluZyh3YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lcikgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICAgIG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50Lm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIGluc3QgPSBnZXQoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgICBpZiAoaW5zdCkge1xuICAgICAgcmV0dXJuIERPTVJlbmRlcmVyLmZpbmRIb3N0SW5zdGFuY2UoaW5zdCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgYXBwZWFycyB0byBiZSBuZWl0aGVyIFJlYWN0Q29tcG9uZW50IG5vciBET01Ob2RlLiBLZXlzOiAlcycsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpO1xuICAgIH1cbiAgfSxcbiAgaHlkcmF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiB0aHJvdyBvciB3YXJuIGlmIHdlIGNvdWxkbid0IGh5ZHJhdGU/XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGNhbGxiYWNrKSB7XG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBoYXMocGFyZW50Q29tcG9uZW50KSkgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGZhbHNlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gICAgaWYgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgdmFyIHJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCA9IHJvb3RFbCAmJiAhZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKHJvb3RFbCk7XG4gICAgICAgIHdhcm5pbmcoIXJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gVW5tb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgICBET01SZW5kZXJlci51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbnVsbCwgY29udGFpbmVyLCBmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIElmIHlvdSBjYWxsIHVubW91bnRDb21wb25lbnRBdE5vZGUgdHdpY2UgaW4gcXVpY2sgc3VjY2Vzc2lvbiwgeW91J2xsXG4gICAgICAvLyBnZXQgYHRydWVgIHR3aWNlLiBUaGF0J3MgcHJvYmFibHkgZmluZT9cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHZhciBfcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIHZhciBoYXNOb25Sb290UmVhY3RDaGlsZCA9ICEhKF9yb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKF9yb290RWwpKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cbiAgICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIGlzVmFsaWRDb250YWluZXIoY29udGFpbmVyLnBhcmVudE5vZGUpICYmICEhY29udGFpbmVyLnBhcmVudE5vZGUuX3JlYWN0Um9vdENvbnRhaW5lcjtcblxuICAgICAgICB3YXJuaW5nKCFoYXNOb25Sb290UmVhY3RDaGlsZCwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuXG4gIC8vIFRlbXBvcmFyeSBhbGlhcyBzaW5jZSB3ZSBhbHJlYWR5IHNoaXBwZWQgUmVhY3QgMTYgUkMgd2l0aCBpdC5cbiAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LlxuICB1bnN0YWJsZV9jcmVhdGVQb3J0YWw6IGNyZWF0ZVBvcnRhbCxcblxuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG5cbiAgdW5zdGFibGVfZGVmZXJyZWRVcGRhdGVzOiBET01SZW5kZXJlci5kZWZlcnJlZFVwZGF0ZXMsXG5cbiAgZmx1c2hTeW5jOiBET01SZW5kZXJlci5mbHVzaFN5bmMsXG5cbiAgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6IHtcbiAgICAvLyBGb3IgVGFwRXZlbnRQbHVnaW4gd2hpY2ggaXMgcG9wdWxhciBpbiBvcGVuIHNvdXJjZVxuICAgIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1YixcbiAgICAvLyBVc2VkIGJ5IHRlc3QtdXRpbHNcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudFBsdWdpblJlZ2lzdHJ5LFxuICAgIEV2ZW50UHJvcGFnYXRvcnM6IEV2ZW50UHJvcGFnYXRvcnMsXG4gICAgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50OiBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQsXG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlOiBSZWFjdERPTUNvbXBvbmVudFRyZWUsXG4gICAgUmVhY3RET01FdmVudExpc3RlbmVyOiBSZWFjdERPTUV2ZW50TGlzdGVuZXJcbiAgfVxufTtcblxuaWYgKGVuYWJsZUNyZWF0ZVJvb3QpIHtcbiAgUmVhY3RET00uY3JlYXRlUm9vdCA9IGZ1bmN0aW9uIGNyZWF0ZVJvb3QoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgdmFyIGh5ZHJhdGUgPSBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5oeWRyYXRlID09PSB0cnVlO1xuICAgIHJldHVybiBuZXcgUmVhY3RSb290KGNvbnRhaW5lciwgaHlkcmF0ZSk7XG4gIH07XG59XG5cbnZhciBmb3VuZERldlRvb2xzID0gRE9NUmVuZGVyZXIuaW5qZWN0SW50b0RldlRvb2xzKHtcbiAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICBidW5kbGVUeXBlOiAxLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdyZWFjdC1kb20nXG59KTtcblxue1xuICBpZiAoIWZvdW5kRGV2VG9vbHMgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG4gICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgdmFyIHByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgLy8gRG9uJ3Qgd2FybiBpbiBleG90aWMgY2FzZXMgbGlrZSBjaHJvbWUtZXh0ZW5zaW9uOi8vLlxuICAgICAgaWYgKC9eKGh0dHBzP3xmaWxlKTokLy50ZXN0KHByb3RvY29sKSkge1xuICAgICAgICBjb25zb2xlLmluZm8oJyVjRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgKyAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycgKyAocHJvdG9jb2wgPT09ICdmaWxlOicgPyAnXFxuWW91IG1pZ2h0IG5lZWQgdG8gdXNlIGEgbG9jYWwgSFRUUCBzZXJ2ZXIgKGluc3RlYWQgb2YgZmlsZTovLyk6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scy1mYXEnIDogJycpLCAnZm9udC13ZWlnaHQ6Ym9sZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cblxudmFyIFJlYWN0RE9NJDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3RET01cbn0pO1xuXG52YXIgUmVhY3RET00kMyA9ICggUmVhY3RET00kMiAmJiBSZWFjdERPTSApIHx8IFJlYWN0RE9NJDI7XG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0RG9tID0gUmVhY3RET00kM1snZGVmYXVsdCddID8gUmVhY3RET00kM1snZGVmYXVsdCddIDogUmVhY3RET00kMztcblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdERvbTtcbiAgfSkoKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMi4wXG4gKiByZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vKlxuIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuKi9cbid1c2Ugc3RyaWN0Jzt2YXIgYWE9cmVxdWlyZShcInJlYWN0XCIpLGw9cmVxdWlyZShcImZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpLEI9cmVxdWlyZShcIm9iamVjdC1hc3NpZ25cIiksQz1yZXF1aXJlKFwiZmJqcy9saWIvZW1wdHlGdW5jdGlvblwiKSxiYT1yZXF1aXJlKFwiZmJqcy9saWIvRXZlbnRMaXN0ZW5lclwiKSxkYT1yZXF1aXJlKFwiZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudFwiKSxlYT1yZXF1aXJlKFwiZmJqcy9saWIvc2hhbGxvd0VxdWFsXCIpLGZhPXJlcXVpcmUoXCJmYmpzL2xpYi9jb250YWluc05vZGVcIiksaWE9cmVxdWlyZShcImZianMvbGliL2ZvY3VzTm9kZVwiKSxEPXJlcXVpcmUoXCJmYmpzL2xpYi9lbXB0eU9iamVjdFwiKTtcbmZ1bmN0aW9uIEUoYSl7Zm9yKHZhciBiPWFyZ3VtZW50cy5sZW5ndGgtMSxjPVwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiK2ErXCI7IHZpc2l0IGh0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50XFx4M2RcIithLGQ9MDtkPGI7ZCsrKWMrPVwiXFx4MjZhcmdzW11cXHgzZFwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbZCsxXSk7Yj1FcnJvcihjK1wiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy5cIik7Yi5uYW1lPVwiSW52YXJpYW50IFZpb2xhdGlvblwiO2IuZnJhbWVzVG9Qb3A9MTt0aHJvdyBiO31hYT92b2lkIDA6RShcIjIyN1wiKTtcbnZhciBvYT17Y2hpbGRyZW46ITAsZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6ITAsZGVmYXVsdFZhbHVlOiEwLGRlZmF1bHRDaGVja2VkOiEwLGlubmVySFRNTDohMCxzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6ITAsc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiEwLHN0eWxlOiEwfTtmdW5jdGlvbiBwYShhLGIpe3JldHVybihhJmIpPT09Yn1cbnZhciB0YT17TVVTVF9VU0VfUFJPUEVSVFk6MSxIQVNfQk9PTEVBTl9WQUxVRTo0LEhBU19OVU1FUklDX1ZBTFVFOjgsSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU6MjQsSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTozMixIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUU6NjQsaW5qZWN0RE9NUHJvcGVydHlDb25maWc6ZnVuY3Rpb24oYSl7dmFyIGI9dGEsYz1hLlByb3BlcnRpZXN8fHt9LGQ9YS5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzfHx7fSxlPWEuRE9NQXR0cmlidXRlTmFtZXN8fHt9O2E9YS5ET01NdXRhdGlvbk1ldGhvZHN8fHt9O2Zvcih2YXIgZiBpbiBjKXt1YS5oYXNPd25Qcm9wZXJ0eShmKT9FKFwiNDhcIixmKTp2b2lkIDA7dmFyIGc9Zi50b0xvd2VyQ2FzZSgpLGg9Y1tmXTtnPXthdHRyaWJ1dGVOYW1lOmcsYXR0cmlidXRlTmFtZXNwYWNlOm51bGwscHJvcGVydHlOYW1lOmYsbXV0YXRpb25NZXRob2Q6bnVsbCxtdXN0VXNlUHJvcGVydHk6cGEoaCxiLk1VU1RfVVNFX1BST1BFUlRZKSxcbmhhc0Jvb2xlYW5WYWx1ZTpwYShoLGIuSEFTX0JPT0xFQU5fVkFMVUUpLGhhc051bWVyaWNWYWx1ZTpwYShoLGIuSEFTX05VTUVSSUNfVkFMVUUpLGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOnBhKGgsYi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTpwYShoLGIuSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSksaGFzU3RyaW5nQm9vbGVhblZhbHVlOnBhKGgsYi5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUpfTsxPj1nLmhhc0Jvb2xlYW5WYWx1ZStnLmhhc051bWVyaWNWYWx1ZStnLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU/dm9pZCAwOkUoXCI1MFwiLGYpO2UuaGFzT3duUHJvcGVydHkoZikmJihnLmF0dHJpYnV0ZU5hbWU9ZVtmXSk7ZC5oYXNPd25Qcm9wZXJ0eShmKSYmKGcuYXR0cmlidXRlTmFtZXNwYWNlPWRbZl0pO2EuaGFzT3duUHJvcGVydHkoZikmJihnLm11dGF0aW9uTWV0aG9kPWFbZl0pO3VhW2ZdPWd9fX0sdWE9e307XG5mdW5jdGlvbiB2YShhLGIpe2lmKG9hLmhhc093blByb3BlcnR5KGEpfHwyPGEubGVuZ3RoJiYoXCJvXCI9PT1hWzBdfHxcIk9cIj09PWFbMF0pJiYoXCJuXCI9PT1hWzFdfHxcIk5cIj09PWFbMV0pKXJldHVybiExO2lmKG51bGw9PT1iKXJldHVybiEwO3N3aXRjaCh0eXBlb2YgYil7Y2FzZSBcImJvb2xlYW5cIjpyZXR1cm4gb2EuaGFzT3duUHJvcGVydHkoYSk/YT0hMDooYj13YShhKSk/YT1iLmhhc0Jvb2xlYW5WYWx1ZXx8Yi5oYXNTdHJpbmdCb29sZWFuVmFsdWV8fGIuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTooYT1hLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCw1KSxhPVwiZGF0YS1cIj09PWF8fFwiYXJpYS1cIj09PWEpLGE7Y2FzZSBcInVuZGVmaW5lZFwiOmNhc2UgXCJudW1iZXJcIjpjYXNlIFwic3RyaW5nXCI6Y2FzZSBcIm9iamVjdFwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIHdhKGEpe3JldHVybiB1YS5oYXNPd25Qcm9wZXJ0eShhKT91YVthXTpudWxsfVxudmFyIHhhPXRhLHlhPXhhLk1VU1RfVVNFX1BST1BFUlRZLEs9eGEuSEFTX0JPT0xFQU5fVkFMVUUsemE9eGEuSEFTX05VTUVSSUNfVkFMVUUsQWE9eGEuSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsQmE9eGEuSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxDYT14YS5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsRGE9e1Byb3BlcnRpZXM6e2FsbG93RnVsbFNjcmVlbjpLLGFzeW5jOkssYXV0b0ZvY3VzOkssYXV0b1BsYXk6SyxjYXB0dXJlOkJhLGNoZWNrZWQ6eWF8Syxjb2xzOkFhLGNvbnRlbnRFZGl0YWJsZTpDYSxjb250cm9sczpLLFwiZGVmYXVsdFwiOkssZGVmZXI6SyxkaXNhYmxlZDpLLGRvd25sb2FkOkJhLGRyYWdnYWJsZTpDYSxmb3JtTm9WYWxpZGF0ZTpLLGhpZGRlbjpLLGxvb3A6SyxtdWx0aXBsZTp5YXxLLG11dGVkOnlhfEssbm9WYWxpZGF0ZTpLLG9wZW46SyxwbGF5c0lubGluZTpLLHJlYWRPbmx5OksscmVxdWlyZWQ6SyxyZXZlcnNlZDpLLHJvd3M6QWEscm93U3Bhbjp6YSxcbnNjb3BlZDpLLHNlYW1sZXNzOkssc2VsZWN0ZWQ6eWF8SyxzaXplOkFhLHN0YXJ0OnphLHNwYW46QWEsc3BlbGxDaGVjazpDYSxzdHlsZTowLHRhYkluZGV4OjAsaXRlbVNjb3BlOkssYWNjZXB0Q2hhcnNldDowLGNsYXNzTmFtZTowLGh0bWxGb3I6MCxodHRwRXF1aXY6MCx2YWx1ZTpDYX0sRE9NQXR0cmlidXRlTmFtZXM6e2FjY2VwdENoYXJzZXQ6XCJhY2NlcHQtY2hhcnNldFwiLGNsYXNzTmFtZTpcImNsYXNzXCIsaHRtbEZvcjpcImZvclwiLGh0dHBFcXVpdjpcImh0dHAtZXF1aXZcIn0sRE9NTXV0YXRpb25NZXRob2RzOnt2YWx1ZTpmdW5jdGlvbihhLGIpe2lmKG51bGw9PWIpcmV0dXJuIGEucmVtb3ZlQXR0cmlidXRlKFwidmFsdWVcIik7XCJudW1iZXJcIiE9PWEudHlwZXx8ITE9PT1hLmhhc0F0dHJpYnV0ZShcInZhbHVlXCIpP2Euc2V0QXR0cmlidXRlKFwidmFsdWVcIixcIlwiK2IpOmEudmFsaWRpdHkmJiFhLnZhbGlkaXR5LmJhZElucHV0JiZhLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCE9PWEmJlxuYS5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLFwiXCIrYil9fX0sRWE9eGEuSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFLE09e3hsaW5rOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLHhtbDpcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwifSxHYT17UHJvcGVydGllczp7YXV0b1JldmVyc2U6RWEsZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDpFYSxwcmVzZXJ2ZUFscGhhOkVhfSxET01BdHRyaWJ1dGVOYW1lczp7YXV0b1JldmVyc2U6XCJhdXRvUmV2ZXJzZVwiLGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6XCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXCIscHJlc2VydmVBbHBoYTpcInByZXNlcnZlQWxwaGFcIn0sRE9NQXR0cmlidXRlTmFtZXNwYWNlczp7eGxpbmtBY3R1YXRlOk0ueGxpbmsseGxpbmtBcmNyb2xlOk0ueGxpbmsseGxpbmtIcmVmOk0ueGxpbmsseGxpbmtSb2xlOk0ueGxpbmsseGxpbmtTaG93Ok0ueGxpbmsseGxpbmtUaXRsZTpNLnhsaW5rLHhsaW5rVHlwZTpNLnhsaW5rLFxueG1sQmFzZTpNLnhtbCx4bWxMYW5nOk0ueG1sLHhtbFNwYWNlOk0ueG1sfX0sSGE9L1tcXC1cXDpdKFthLXpdKS9nO2Z1bmN0aW9uIElhKGEpe3JldHVybiBhWzFdLnRvVXBwZXJDYXNlKCl9XG5cImFjY2VudC1oZWlnaHQgYWxpZ25tZW50LWJhc2VsaW5lIGFyYWJpYy1mb3JtIGJhc2VsaW5lLXNoaWZ0IGNhcC1oZWlnaHQgY2xpcC1wYXRoIGNsaXAtcnVsZSBjb2xvci1pbnRlcnBvbGF0aW9uIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyBjb2xvci1wcm9maWxlIGNvbG9yLXJlbmRlcmluZyBkb21pbmFudC1iYXNlbGluZSBlbmFibGUtYmFja2dyb3VuZCBmaWxsLW9wYWNpdHkgZmlsbC1ydWxlIGZsb29kLWNvbG9yIGZsb29kLW9wYWNpdHkgZm9udC1mYW1pbHkgZm9udC1zaXplIGZvbnQtc2l6ZS1hZGp1c3QgZm9udC1zdHJldGNoIGZvbnQtc3R5bGUgZm9udC12YXJpYW50IGZvbnQtd2VpZ2h0IGdseXBoLW5hbWUgZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCBnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCBob3Jpei1hZHYteCBob3Jpei1vcmlnaW4teCBpbWFnZS1yZW5kZXJpbmcgbGV0dGVyLXNwYWNpbmcgbGlnaHRpbmctY29sb3IgbWFya2VyLWVuZCBtYXJrZXItbWlkIG1hcmtlci1zdGFydCBvdmVybGluZS1wb3NpdGlvbiBvdmVybGluZS10aGlja25lc3MgcGFpbnQtb3JkZXIgcGFub3NlLTEgcG9pbnRlci1ldmVudHMgcmVuZGVyaW5nLWludGVudCBzaGFwZS1yZW5kZXJpbmcgc3RvcC1jb2xvciBzdG9wLW9wYWNpdHkgc3RyaWtldGhyb3VnaC1wb3NpdGlvbiBzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyBzdHJva2UtZGFzaGFycmF5IHN0cm9rZS1kYXNob2Zmc2V0IHN0cm9rZS1saW5lY2FwIHN0cm9rZS1saW5lam9pbiBzdHJva2UtbWl0ZXJsaW1pdCBzdHJva2Utb3BhY2l0eSBzdHJva2Utd2lkdGggdGV4dC1hbmNob3IgdGV4dC1kZWNvcmF0aW9uIHRleHQtcmVuZGVyaW5nIHVuZGVybGluZS1wb3NpdGlvbiB1bmRlcmxpbmUtdGhpY2tuZXNzIHVuaWNvZGUtYmlkaSB1bmljb2RlLXJhbmdlIHVuaXRzLXBlci1lbSB2LWFscGhhYmV0aWMgdi1oYW5naW5nIHYtaWRlb2dyYXBoaWMgdi1tYXRoZW1hdGljYWwgdmVjdG9yLWVmZmVjdCB2ZXJ0LWFkdi15IHZlcnQtb3JpZ2luLXggdmVydC1vcmlnaW4teSB3b3JkLXNwYWNpbmcgd3JpdGluZy1tb2RlIHgtaGVpZ2h0IHhsaW5rOmFjdHVhdGUgeGxpbms6YXJjcm9sZSB4bGluazpocmVmIHhsaW5rOnJvbGUgeGxpbms6c2hvdyB4bGluazp0aXRsZSB4bGluazp0eXBlIHhtbDpiYXNlIHhtbG5zOnhsaW5rIHhtbDpsYW5nIHhtbDpzcGFjZVwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZShIYSxcbklhKTtHYS5Qcm9wZXJ0aWVzW2JdPTA7R2EuRE9NQXR0cmlidXRlTmFtZXNbYl09YX0pO3hhLmluamVjdERPTVByb3BlcnR5Q29uZmlnKERhKTt4YS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhHYSk7XG52YXIgUD17X2NhdWdodEVycm9yOm51bGwsX2hhc0NhdWdodEVycm9yOiExLF9yZXRocm93RXJyb3I6bnVsbCxfaGFzUmV0aHJvd0Vycm9yOiExLGluamVjdGlvbjp7aW5qZWN0RXJyb3JVdGlsczpmdW5jdGlvbihhKXtcImZ1bmN0aW9uXCIhPT10eXBlb2YgYS5pbnZva2VHdWFyZGVkQ2FsbGJhY2s/RShcIjE5N1wiKTp2b2lkIDA7SmE9YS5pbnZva2VHdWFyZGVkQ2FsbGJhY2t9fSxpbnZva2VHdWFyZGVkQ2FsbGJhY2s6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGspe0phLmFwcGx5KFAsYXJndW1lbnRzKX0saW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxrKXtQLmludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYoUC5oYXNDYXVnaHRFcnJvcigpKXt2YXIgcT1QLmNsZWFyQ2F1Z2h0RXJyb3IoKTtQLl9oYXNSZXRocm93RXJyb3J8fChQLl9oYXNSZXRocm93RXJyb3I9ITAsUC5fcmV0aHJvd0Vycm9yPVxucSl9fSxyZXRocm93Q2F1Z2h0RXJyb3I6ZnVuY3Rpb24oKXtyZXR1cm4gS2EuYXBwbHkoUCxhcmd1bWVudHMpfSxoYXNDYXVnaHRFcnJvcjpmdW5jdGlvbigpe3JldHVybiBQLl9oYXNDYXVnaHRFcnJvcn0sY2xlYXJDYXVnaHRFcnJvcjpmdW5jdGlvbigpe2lmKFAuX2hhc0NhdWdodEVycm9yKXt2YXIgYT1QLl9jYXVnaHRFcnJvcjtQLl9jYXVnaHRFcnJvcj1udWxsO1AuX2hhc0NhdWdodEVycm9yPSExO3JldHVybiBhfUUoXCIxOThcIil9fTtmdW5jdGlvbiBKYShhLGIsYyxkLGUsZixnLGgsayl7UC5faGFzQ2F1Z2h0RXJyb3I9ITE7UC5fY2F1Z2h0RXJyb3I9bnVsbDt2YXIgcT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMyk7dHJ5e2IuYXBwbHkoYyxxKX1jYXRjaCh2KXtQLl9jYXVnaHRFcnJvcj12LFAuX2hhc0NhdWdodEVycm9yPSEwfX1cbmZ1bmN0aW9uIEthKCl7aWYoUC5faGFzUmV0aHJvd0Vycm9yKXt2YXIgYT1QLl9yZXRocm93RXJyb3I7UC5fcmV0aHJvd0Vycm9yPW51bGw7UC5faGFzUmV0aHJvd0Vycm9yPSExO3Rocm93IGE7fX12YXIgTGE9bnVsbCxNYT17fTtcbmZ1bmN0aW9uIE5hKCl7aWYoTGEpZm9yKHZhciBhIGluIE1hKXt2YXIgYj1NYVthXSxjPUxhLmluZGV4T2YoYSk7LTE8Yz92b2lkIDA6RShcIjk2XCIsYSk7aWYoIU9hW2NdKXtiLmV4dHJhY3RFdmVudHM/dm9pZCAwOkUoXCI5N1wiLGEpO09hW2NdPWI7Yz1iLmV2ZW50VHlwZXM7Zm9yKHZhciBkIGluIGMpe3ZhciBlPXZvaWQgMDt2YXIgZj1jW2RdLGc9YixoPWQ7UGEuaGFzT3duUHJvcGVydHkoaCk/RShcIjk5XCIsaCk6dm9pZCAwO1BhW2hdPWY7dmFyIGs9Zi5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztpZihrKXtmb3IoZSBpbiBrKWsuaGFzT3duUHJvcGVydHkoZSkmJlFhKGtbZV0sZyxoKTtlPSEwfWVsc2UgZi5yZWdpc3RyYXRpb25OYW1lPyhRYShmLnJlZ2lzdHJhdGlvbk5hbWUsZyxoKSxlPSEwKTplPSExO2U/dm9pZCAwOkUoXCI5OFwiLGQsYSl9fX19XG5mdW5jdGlvbiBRYShhLGIsYyl7UmFbYV0/RShcIjEwMFwiLGEpOnZvaWQgMDtSYVthXT1iO1NhW2FdPWIuZXZlbnRUeXBlc1tjXS5kZXBlbmRlbmNpZXN9dmFyIE9hPVtdLFBhPXt9LFJhPXt9LFNhPXt9O2Z1bmN0aW9uIFRhKGEpe0xhP0UoXCIxMDFcIik6dm9pZCAwO0xhPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEpO05hKCl9ZnVuY3Rpb24gVWEoYSl7dmFyIGI9ITEsYztmb3IoYyBpbiBhKWlmKGEuaGFzT3duUHJvcGVydHkoYykpe3ZhciBkPWFbY107TWEuaGFzT3duUHJvcGVydHkoYykmJk1hW2NdPT09ZHx8KE1hW2NdP0UoXCIxMDJcIixjKTp2b2lkIDAsTWFbY109ZCxiPSEwKX1iJiZOYSgpfVxudmFyIFZhPU9iamVjdC5mcmVlemUoe3BsdWdpbnM6T2EsZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOlBhLHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOlJhLHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6U2EscG9zc2libGVSZWdpc3RyYXRpb25OYW1lczpudWxsLGluamVjdEV2ZW50UGx1Z2luT3JkZXI6VGEsaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOlVhfSksV2E9bnVsbCxYYT1udWxsLFlhPW51bGw7ZnVuY3Rpb24gWmEoYSxiLGMsZCl7Yj1hLnR5cGV8fFwidW5rbm93bi1ldmVudFwiO2EuY3VycmVudFRhcmdldD1ZYShkKTtQLmludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcihiLGMsdm9pZCAwLGEpO2EuY3VycmVudFRhcmdldD1udWxsfVxuZnVuY3Rpb24gJGEoYSxiKXtudWxsPT1iP0UoXCIzMFwiKTp2b2lkIDA7aWYobnVsbD09YSlyZXR1cm4gYjtpZihBcnJheS5pc0FycmF5KGEpKXtpZihBcnJheS5pc0FycmF5KGIpKXJldHVybiBhLnB1c2guYXBwbHkoYSxiKSxhO2EucHVzaChiKTtyZXR1cm4gYX1yZXR1cm4gQXJyYXkuaXNBcnJheShiKT9bYV0uY29uY2F0KGIpOlthLGJdfWZ1bmN0aW9uIGFiKGEsYixjKXtBcnJheS5pc0FycmF5KGEpP2EuZm9yRWFjaChiLGMpOmEmJmIuY2FsbChjLGEpfXZhciBiYj1udWxsO1xuZnVuY3Rpb24gY2IoYSxiKXtpZihhKXt2YXIgYz1hLl9kaXNwYXRjaExpc3RlbmVycyxkPWEuX2Rpc3BhdGNoSW5zdGFuY2VzO2lmKEFycmF5LmlzQXJyYXkoYykpZm9yKHZhciBlPTA7ZTxjLmxlbmd0aCYmIWEuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtlKyspWmEoYSxiLGNbZV0sZFtlXSk7ZWxzZSBjJiZaYShhLGIsYyxkKTthLl9kaXNwYXRjaExpc3RlbmVycz1udWxsO2EuX2Rpc3BhdGNoSW5zdGFuY2VzPW51bGw7YS5pc1BlcnNpc3RlbnQoKXx8YS5jb25zdHJ1Y3Rvci5yZWxlYXNlKGEpfX1mdW5jdGlvbiBkYihhKXtyZXR1cm4gY2IoYSwhMCl9ZnVuY3Rpb24gZ2IoYSl7cmV0dXJuIGNiKGEsITEpfXZhciBoYj17aW5qZWN0RXZlbnRQbHVnaW5PcmRlcjpUYSxpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6VWF9O1xuZnVuY3Rpb24gaWIoYSxiKXt2YXIgYz1hLnN0YXRlTm9kZTtpZighYylyZXR1cm4gbnVsbDt2YXIgZD1XYShjKTtpZighZClyZXR1cm4gbnVsbDtjPWRbYl07YTpzd2l0Y2goYil7Y2FzZSBcIm9uQ2xpY2tcIjpjYXNlIFwib25DbGlja0NhcHR1cmVcIjpjYXNlIFwib25Eb3VibGVDbGlja1wiOmNhc2UgXCJvbkRvdWJsZUNsaWNrQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlRG93blwiOmNhc2UgXCJvbk1vdXNlRG93bkNhcHR1cmVcIjpjYXNlIFwib25Nb3VzZU1vdmVcIjpjYXNlIFwib25Nb3VzZU1vdmVDYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VVcFwiOmNhc2UgXCJvbk1vdXNlVXBDYXB0dXJlXCI6KGQ9IWQuZGlzYWJsZWQpfHwoYT1hLnR5cGUsZD0hKFwiYnV0dG9uXCI9PT1hfHxcImlucHV0XCI9PT1hfHxcInNlbGVjdFwiPT09YXx8XCJ0ZXh0YXJlYVwiPT09YSkpO2E9IWQ7YnJlYWsgYTtkZWZhdWx0OmE9ITF9aWYoYSlyZXR1cm4gbnVsbDtjJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYz9FKFwiMjMxXCIsYix0eXBlb2YgYyk6dm9pZCAwO1xucmV0dXJuIGN9ZnVuY3Rpb24gamIoYSxiLGMsZCl7Zm9yKHZhciBlLGY9MDtmPE9hLmxlbmd0aDtmKyspe3ZhciBnPU9hW2ZdO2cmJihnPWcuZXh0cmFjdEV2ZW50cyhhLGIsYyxkKSkmJihlPSRhKGUsZykpfXJldHVybiBlfWZ1bmN0aW9uIGtiKGEpe2EmJihiYj0kYShiYixhKSl9ZnVuY3Rpb24gbGIoYSl7dmFyIGI9YmI7YmI9bnVsbDtiJiYoYT9hYihiLGRiKTphYihiLGdiKSxiYj9FKFwiOTVcIik6dm9pZCAwLFAucmV0aHJvd0NhdWdodEVycm9yKCkpfXZhciBtYj1PYmplY3QuZnJlZXplKHtpbmplY3Rpb246aGIsZ2V0TGlzdGVuZXI6aWIsZXh0cmFjdEV2ZW50czpqYixlbnF1ZXVlRXZlbnRzOmtiLHByb2Nlc3NFdmVudFF1ZXVlOmxifSksbmI9TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiksUT1cIl9fcmVhY3RJbnRlcm5hbEluc3RhbmNlJFwiK25iLG9iPVwiX19yZWFjdEV2ZW50SGFuZGxlcnMkXCIrbmI7XG5mdW5jdGlvbiBwYihhKXtpZihhW1FdKXJldHVybiBhW1FdO2Zvcih2YXIgYj1bXTshYVtRXTspaWYoYi5wdXNoKGEpLGEucGFyZW50Tm9kZSlhPWEucGFyZW50Tm9kZTtlbHNlIHJldHVybiBudWxsO3ZhciBjPXZvaWQgMCxkPWFbUV07aWYoNT09PWQudGFnfHw2PT09ZC50YWcpcmV0dXJuIGQ7Zm9yKDthJiYoZD1hW1FdKTthPWIucG9wKCkpYz1kO3JldHVybiBjfWZ1bmN0aW9uIHFiKGEpe2lmKDU9PT1hLnRhZ3x8Nj09PWEudGFnKXJldHVybiBhLnN0YXRlTm9kZTtFKFwiMzNcIil9ZnVuY3Rpb24gcmIoYSl7cmV0dXJuIGFbb2JdfHxudWxsfVxudmFyIHNiPU9iamVjdC5mcmVlemUoe3ByZWNhY2hlRmliZXJOb2RlOmZ1bmN0aW9uKGEsYil7YltRXT1hfSxnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTpwYixnZXRJbnN0YW5jZUZyb21Ob2RlOmZ1bmN0aW9uKGEpe2E9YVtRXTtyZXR1cm4hYXx8NSE9PWEudGFnJiY2IT09YS50YWc/bnVsbDphfSxnZXROb2RlRnJvbUluc3RhbmNlOnFiLGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU6cmIsdXBkYXRlRmliZXJQcm9wczpmdW5jdGlvbihhLGIpe2Fbb2JdPWJ9fSk7ZnVuY3Rpb24gdGIoYSl7ZG8gYT1hW1wicmV0dXJuXCJdO3doaWxlKGEmJjUhPT1hLnRhZyk7cmV0dXJuIGE/YTpudWxsfWZ1bmN0aW9uIHViKGEsYixjKXtmb3IodmFyIGQ9W107YTspZC5wdXNoKGEpLGE9dGIoYSk7Zm9yKGE9ZC5sZW5ndGg7MDxhLS07KWIoZFthXSxcImNhcHR1cmVkXCIsYyk7Zm9yKGE9MDthPGQubGVuZ3RoO2ErKyliKGRbYV0sXCJidWJibGVkXCIsYyl9XG5mdW5jdGlvbiB2YihhLGIsYyl7aWYoYj1pYihhLGMuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbYl0pKWMuX2Rpc3BhdGNoTGlzdGVuZXJzPSRhKGMuX2Rpc3BhdGNoTGlzdGVuZXJzLGIpLGMuX2Rpc3BhdGNoSW5zdGFuY2VzPSRhKGMuX2Rpc3BhdGNoSW5zdGFuY2VzLGEpfWZ1bmN0aW9uIHdiKGEpe2EmJmEuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMmJnViKGEuX3RhcmdldEluc3QsdmIsYSl9ZnVuY3Rpb24geGIoYSl7aWYoYSYmYS5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcyl7dmFyIGI9YS5fdGFyZ2V0SW5zdDtiPWI/dGIoYik6bnVsbDt1YihiLHZiLGEpfX1cbmZ1bmN0aW9uIHliKGEsYixjKXthJiZjJiZjLmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUmJihiPWliKGEsYy5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSkmJihjLl9kaXNwYXRjaExpc3RlbmVycz0kYShjLl9kaXNwYXRjaExpc3RlbmVycyxiKSxjLl9kaXNwYXRjaEluc3RhbmNlcz0kYShjLl9kaXNwYXRjaEluc3RhbmNlcyxhKSl9ZnVuY3Rpb24gemIoYSl7YSYmYS5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lJiZ5YihhLl90YXJnZXRJbnN0LG51bGwsYSl9ZnVuY3Rpb24gQWIoYSl7YWIoYSx3Yil9XG5mdW5jdGlvbiBCYihhLGIsYyxkKXtpZihjJiZkKWE6e3ZhciBlPWM7Zm9yKHZhciBmPWQsZz0wLGg9ZTtoO2g9dGIoaCkpZysrO2g9MDtmb3IodmFyIGs9ZjtrO2s9dGIoaykpaCsrO2Zvcig7MDxnLWg7KWU9dGIoZSksZy0tO2Zvcig7MDxoLWc7KWY9dGIoZiksaC0tO2Zvcig7Zy0tOyl7aWYoZT09PWZ8fGU9PT1mLmFsdGVybmF0ZSlicmVhayBhO2U9dGIoZSk7Zj10YihmKX1lPW51bGx9ZWxzZSBlPW51bGw7Zj1lO2ZvcihlPVtdO2MmJmMhPT1mOyl7Zz1jLmFsdGVybmF0ZTtpZihudWxsIT09ZyYmZz09PWYpYnJlYWs7ZS5wdXNoKGMpO2M9dGIoYyl9Zm9yKGM9W107ZCYmZCE9PWY7KXtnPWQuYWx0ZXJuYXRlO2lmKG51bGwhPT1nJiZnPT09ZilicmVhaztjLnB1c2goZCk7ZD10YihkKX1mb3IoZD0wO2Q8ZS5sZW5ndGg7ZCsrKXliKGVbZF0sXCJidWJibGVkXCIsYSk7Zm9yKGE9Yy5sZW5ndGg7MDxhLS07KXliKGNbYV0sXCJjYXB0dXJlZFwiLGIpfVxudmFyIENiPU9iamVjdC5mcmVlemUoe2FjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6QWIsYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQ6ZnVuY3Rpb24oYSl7YWIoYSx4Yil9LGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlczpCYixhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlczpmdW5jdGlvbihhKXthYihhLHpiKX19KSxEYj1udWxsO2Z1bmN0aW9uIEViKCl7IURiJiZsLmNhblVzZURPTSYmKERiPVwidGV4dENvbnRlbnRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudD9cInRleHRDb250ZW50XCI6XCJpbm5lclRleHRcIik7cmV0dXJuIERifXZhciBTPXtfcm9vdDpudWxsLF9zdGFydFRleHQ6bnVsbCxfZmFsbGJhY2tUZXh0Om51bGx9O1xuZnVuY3Rpb24gRmIoKXtpZihTLl9mYWxsYmFja1RleHQpcmV0dXJuIFMuX2ZhbGxiYWNrVGV4dDt2YXIgYSxiPVMuX3N0YXJ0VGV4dCxjPWIubGVuZ3RoLGQsZT1HYigpLGY9ZS5sZW5ndGg7Zm9yKGE9MDthPGMmJmJbYV09PT1lW2FdO2ErKyk7dmFyIGc9Yy1hO2ZvcihkPTE7ZDw9ZyYmYltjLWRdPT09ZVtmLWRdO2QrKyk7Uy5fZmFsbGJhY2tUZXh0PWUuc2xpY2UoYSwxPGQ/MS1kOnZvaWQgMCk7cmV0dXJuIFMuX2ZhbGxiYWNrVGV4dH1mdW5jdGlvbiBHYigpe3JldHVyblwidmFsdWVcImluIFMuX3Jvb3Q/Uy5fcm9vdC52YWx1ZTpTLl9yb290W0ViKCldfVxudmFyIEhiPVwiZGlzcGF0Y2hDb25maWcgX3RhcmdldEluc3QgbmF0aXZlRXZlbnQgaXNEZWZhdWx0UHJldmVudGVkIGlzUHJvcGFnYXRpb25TdG9wcGVkIF9kaXNwYXRjaExpc3RlbmVycyBfZGlzcGF0Y2hJbnN0YW5jZXNcIi5zcGxpdChcIiBcIiksSWI9e3R5cGU6bnVsbCx0YXJnZXQ6bnVsbCxjdXJyZW50VGFyZ2V0OkMudGhhdFJldHVybnNOdWxsLGV2ZW50UGhhc2U6bnVsbCxidWJibGVzOm51bGwsY2FuY2VsYWJsZTpudWxsLHRpbWVTdGFtcDpmdW5jdGlvbihhKXtyZXR1cm4gYS50aW1lU3RhbXB8fERhdGUubm93KCl9LGRlZmF1bHRQcmV2ZW50ZWQ6bnVsbCxpc1RydXN0ZWQ6bnVsbH07XG5mdW5jdGlvbiBUKGEsYixjLGQpe3RoaXMuZGlzcGF0Y2hDb25maWc9YTt0aGlzLl90YXJnZXRJbnN0PWI7dGhpcy5uYXRpdmVFdmVudD1jO2E9dGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7Zm9yKHZhciBlIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShlKSYmKChiPWFbZV0pP3RoaXNbZV09YihjKTpcInRhcmdldFwiPT09ZT90aGlzLnRhcmdldD1kOnRoaXNbZV09Y1tlXSk7dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9KG51bGwhPWMuZGVmYXVsdFByZXZlbnRlZD9jLmRlZmF1bHRQcmV2ZW50ZWQ6ITE9PT1jLnJldHVyblZhbHVlKT9DLnRoYXRSZXR1cm5zVHJ1ZTpDLnRoYXRSZXR1cm5zRmFsc2U7dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1DLnRoYXRSZXR1cm5zRmFsc2U7cmV0dXJuIHRoaXN9XG5CKFQucHJvdG90eXBlLHtwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe3RoaXMuZGVmYXVsdFByZXZlbnRlZD0hMDt2YXIgYT10aGlzLm5hdGl2ZUV2ZW50O2EmJihhLnByZXZlbnREZWZhdWx0P2EucHJldmVudERlZmF1bHQoKTpcInVua25vd25cIiE9PXR5cGVvZiBhLnJldHVyblZhbHVlJiYoYS5yZXR1cm5WYWx1ZT0hMSksdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9Qy50aGF0UmV0dXJuc1RydWUpfSxzdG9wUHJvcGFnYXRpb246ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm5hdGl2ZUV2ZW50O2EmJihhLnN0b3BQcm9wYWdhdGlvbj9hLnN0b3BQcm9wYWdhdGlvbigpOlwidW5rbm93blwiIT09dHlwZW9mIGEuY2FuY2VsQnViYmxlJiYoYS5jYW5jZWxCdWJibGU9ITApLHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQ9Qy50aGF0UmV0dXJuc1RydWUpfSxwZXJzaXN0OmZ1bmN0aW9uKCl7dGhpcy5pc1BlcnNpc3RlbnQ9Qy50aGF0UmV0dXJuc1RydWV9LGlzUGVyc2lzdGVudDpDLnRoYXRSZXR1cm5zRmFsc2UsXG5kZXN0cnVjdG9yOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2UsYjtmb3IoYiBpbiBhKXRoaXNbYl09bnVsbDtmb3IoYT0wO2E8SGIubGVuZ3RoO2ErKyl0aGlzW0hiW2FdXT1udWxsfX0pO1QuSW50ZXJmYWNlPUliO1QuYXVnbWVudENsYXNzPWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe31jLnByb3RvdHlwZT10aGlzLnByb3RvdHlwZTt2YXIgZD1uZXcgYztCKGQsYS5wcm90b3R5cGUpO2EucHJvdG90eXBlPWQ7YS5wcm90b3R5cGUuY29uc3RydWN0b3I9YTthLkludGVyZmFjZT1CKHt9LHRoaXMuSW50ZXJmYWNlLGIpO2EuYXVnbWVudENsYXNzPXRoaXMuYXVnbWVudENsYXNzO0piKGEpfTtKYihUKTtmdW5jdGlvbiBLYihhLGIsYyxkKXtpZih0aGlzLmV2ZW50UG9vbC5sZW5ndGgpe3ZhciBlPXRoaXMuZXZlbnRQb29sLnBvcCgpO3RoaXMuY2FsbChlLGEsYixjLGQpO3JldHVybiBlfXJldHVybiBuZXcgdGhpcyhhLGIsYyxkKX1cbmZ1bmN0aW9uIExiKGEpe2EgaW5zdGFuY2VvZiB0aGlzP3ZvaWQgMDpFKFwiMjIzXCIpO2EuZGVzdHJ1Y3RvcigpOzEwPnRoaXMuZXZlbnRQb29sLmxlbmd0aCYmdGhpcy5ldmVudFBvb2wucHVzaChhKX1mdW5jdGlvbiBKYihhKXthLmV2ZW50UG9vbD1bXTthLmdldFBvb2xlZD1LYjthLnJlbGVhc2U9TGJ9ZnVuY3Rpb24gTWIoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVQuYXVnbWVudENsYXNzKE1iLHtkYXRhOm51bGx9KTtmdW5jdGlvbiBOYihhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9VC5hdWdtZW50Q2xhc3MoTmIse2RhdGE6bnVsbH0pO3ZhciBQYj1bOSwxMywyNywzMl0sVmI9bC5jYW5Vc2VET00mJlwiQ29tcG9zaXRpb25FdmVudFwiaW4gd2luZG93LFdiPW51bGw7bC5jYW5Vc2VET00mJlwiZG9jdW1lbnRNb2RlXCJpbiBkb2N1bWVudCYmKFdiPWRvY3VtZW50LmRvY3VtZW50TW9kZSk7dmFyIFhiO1xuaWYoWGI9bC5jYW5Vc2VET00mJlwiVGV4dEV2ZW50XCJpbiB3aW5kb3cmJiFXYil7dmFyIFliPXdpbmRvdy5vcGVyYTtYYj0hKFwib2JqZWN0XCI9PT10eXBlb2YgWWImJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBZYi52ZXJzaW9uJiYxMj49cGFyc2VJbnQoWWIudmVyc2lvbigpLDEwKSl9XG52YXIgWmI9WGIsJGI9bC5jYW5Vc2VET00mJighVmJ8fFdiJiY4PFdiJiYxMT49V2IpLGFjPVN0cmluZy5mcm9tQ2hhckNvZGUoMzIpLGJjPXtiZWZvcmVJbnB1dDp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkJlZm9yZUlucHV0XCIsY2FwdHVyZWQ6XCJvbkJlZm9yZUlucHV0Q2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6W1widG9wQ29tcG9zaXRpb25FbmRcIixcInRvcEtleVByZXNzXCIsXCJ0b3BUZXh0SW5wdXRcIixcInRvcFBhc3RlXCJdfSxjb21wb3NpdGlvbkVuZDp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkNvbXBvc2l0aW9uRW5kXCIsY2FwdHVyZWQ6XCJvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJ0b3BCbHVyIHRvcENvbXBvc2l0aW9uRW5kIHRvcEtleURvd24gdG9wS2V5UHJlc3MgdG9wS2V5VXAgdG9wTW91c2VEb3duXCIuc3BsaXQoXCIgXCIpfSxjb21wb3NpdGlvblN0YXJ0OntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQ29tcG9zaXRpb25TdGFydFwiLFxuY2FwdHVyZWQ6XCJvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcInRvcEJsdXIgdG9wQ29tcG9zaXRpb25TdGFydCB0b3BLZXlEb3duIHRvcEtleVByZXNzIHRvcEtleVVwIHRvcE1vdXNlRG93blwiLnNwbGl0KFwiIFwiKX0sY29tcG9zaXRpb25VcGRhdGU6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25Db21wb3NpdGlvblVwZGF0ZVwiLGNhcHR1cmVkOlwib25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDb21wb3NpdGlvblVwZGF0ZSB0b3BLZXlEb3duIHRvcEtleVByZXNzIHRvcEtleVVwIHRvcE1vdXNlRG93blwiLnNwbGl0KFwiIFwiKX19LGNjPSExO1xuZnVuY3Rpb24gZGMoYSxiKXtzd2l0Y2goYSl7Y2FzZSBcInRvcEtleVVwXCI6cmV0dXJuLTEhPT1QYi5pbmRleE9mKGIua2V5Q29kZSk7Y2FzZSBcInRvcEtleURvd25cIjpyZXR1cm4gMjI5IT09Yi5rZXlDb2RlO2Nhc2UgXCJ0b3BLZXlQcmVzc1wiOmNhc2UgXCJ0b3BNb3VzZURvd25cIjpjYXNlIFwidG9wQmx1clwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIGVjKGEpe2E9YS5kZXRhaWw7cmV0dXJuXCJvYmplY3RcIj09PXR5cGVvZiBhJiZcImRhdGFcImluIGE/YS5kYXRhOm51bGx9dmFyIGZjPSExO2Z1bmN0aW9uIGdjKGEsYil7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BDb21wb3NpdGlvbkVuZFwiOnJldHVybiBlYyhiKTtjYXNlIFwidG9wS2V5UHJlc3NcIjppZigzMiE9PWIud2hpY2gpcmV0dXJuIG51bGw7Y2M9ITA7cmV0dXJuIGFjO2Nhc2UgXCJ0b3BUZXh0SW5wdXRcIjpyZXR1cm4gYT1iLmRhdGEsYT09PWFjJiZjYz9udWxsOmE7ZGVmYXVsdDpyZXR1cm4gbnVsbH19XG5mdW5jdGlvbiBoYyhhLGIpe2lmKGZjKXJldHVyblwidG9wQ29tcG9zaXRpb25FbmRcIj09PWF8fCFWYiYmZGMoYSxiKT8oYT1GYigpLFMuX3Jvb3Q9bnVsbCxTLl9zdGFydFRleHQ9bnVsbCxTLl9mYWxsYmFja1RleHQ9bnVsbCxmYz0hMSxhKTpudWxsO3N3aXRjaChhKXtjYXNlIFwidG9wUGFzdGVcIjpyZXR1cm4gbnVsbDtjYXNlIFwidG9wS2V5UHJlc3NcIjppZighKGIuY3RybEtleXx8Yi5hbHRLZXl8fGIubWV0YUtleSl8fGIuY3RybEtleSYmYi5hbHRLZXkpe2lmKGIuY2hhciYmMTxiLmNoYXIubGVuZ3RoKXJldHVybiBiLmNoYXI7aWYoYi53aGljaClyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShiLndoaWNoKX1yZXR1cm4gbnVsbDtjYXNlIFwidG9wQ29tcG9zaXRpb25FbmRcIjpyZXR1cm4gJGI/bnVsbDpiLmRhdGE7ZGVmYXVsdDpyZXR1cm4gbnVsbH19XG52YXIgaWM9e2V2ZW50VHlwZXM6YmMsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZTtpZihWYiliOntzd2l0Y2goYSl7Y2FzZSBcInRvcENvbXBvc2l0aW9uU3RhcnRcIjp2YXIgZj1iYy5jb21wb3NpdGlvblN0YXJ0O2JyZWFrIGI7Y2FzZSBcInRvcENvbXBvc2l0aW9uRW5kXCI6Zj1iYy5jb21wb3NpdGlvbkVuZDticmVhayBiO2Nhc2UgXCJ0b3BDb21wb3NpdGlvblVwZGF0ZVwiOmY9YmMuY29tcG9zaXRpb25VcGRhdGU7YnJlYWsgYn1mPXZvaWQgMH1lbHNlIGZjP2RjKGEsYykmJihmPWJjLmNvbXBvc2l0aW9uRW5kKTpcInRvcEtleURvd25cIj09PWEmJjIyOT09PWMua2V5Q29kZSYmKGY9YmMuY29tcG9zaXRpb25TdGFydCk7Zj8oJGImJihmY3x8ZiE9PWJjLmNvbXBvc2l0aW9uU3RhcnQ/Zj09PWJjLmNvbXBvc2l0aW9uRW5kJiZmYyYmKGU9RmIoKSk6KFMuX3Jvb3Q9ZCxTLl9zdGFydFRleHQ9R2IoKSxmYz0hMCkpLGY9TWIuZ2V0UG9vbGVkKGYsYixjLGQpLGU/Zi5kYXRhPVxuZTooZT1lYyhjKSxudWxsIT09ZSYmKGYuZGF0YT1lKSksQWIoZiksZT1mKTplPW51bGw7KGE9WmI/Z2MoYSxjKTpoYyhhLGMpKT8oYj1OYi5nZXRQb29sZWQoYmMuYmVmb3JlSW5wdXQsYixjLGQpLGIuZGF0YT1hLEFiKGIpKTpiPW51bGw7cmV0dXJuW2UsYl19fSxqYz1udWxsLGtjPW51bGwsbGM9bnVsbDtmdW5jdGlvbiBtYyhhKXtpZihhPVhhKGEpKXtqYyYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGpjLnJlc3RvcmVDb250cm9sbGVkU3RhdGU/dm9pZCAwOkUoXCIxOTRcIik7dmFyIGI9V2EoYS5zdGF0ZU5vZGUpO2pjLnJlc3RvcmVDb250cm9sbGVkU3RhdGUoYS5zdGF0ZU5vZGUsYS50eXBlLGIpfX12YXIgbmM9e2luamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQ6ZnVuY3Rpb24oYSl7amM9YX19O2Z1bmN0aW9uIG9jKGEpe2tjP2xjP2xjLnB1c2goYSk6bGM9W2FdOmtjPWF9XG5mdW5jdGlvbiBwYygpe2lmKGtjKXt2YXIgYT1rYyxiPWxjO2xjPWtjPW51bGw7bWMoYSk7aWYoYilmb3IoYT0wO2E8Yi5sZW5ndGg7YSsrKW1jKGJbYV0pfX12YXIgcWM9T2JqZWN0LmZyZWV6ZSh7aW5qZWN0aW9uOm5jLGVucXVldWVTdGF0ZVJlc3RvcmU6b2MscmVzdG9yZVN0YXRlSWZOZWVkZWQ6cGN9KTtmdW5jdGlvbiByYyhhLGIpe3JldHVybiBhKGIpfXZhciBzYz0hMTtmdW5jdGlvbiB0YyhhLGIpe2lmKHNjKXJldHVybiByYyhhLGIpO3NjPSEwO3RyeXtyZXR1cm4gcmMoYSxiKX1maW5hbGx5e3NjPSExLHBjKCl9fXZhciB1Yz17Y29sb3I6ITAsZGF0ZTohMCxkYXRldGltZTohMCxcImRhdGV0aW1lLWxvY2FsXCI6ITAsZW1haWw6ITAsbW9udGg6ITAsbnVtYmVyOiEwLHBhc3N3b3JkOiEwLHJhbmdlOiEwLHNlYXJjaDohMCx0ZWw6ITAsdGV4dDohMCx0aW1lOiEwLHVybDohMCx3ZWVrOiEwfTtcbmZ1bmN0aW9uIHZjKGEpe3ZhciBiPWEmJmEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm5cImlucHV0XCI9PT1iPyEhdWNbYS50eXBlXTpcInRleHRhcmVhXCI9PT1iPyEwOiExfWZ1bmN0aW9uIHdjKGEpe2E9YS50YXJnZXR8fGEuc3JjRWxlbWVudHx8d2luZG93O2EuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQmJihhPWEuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpO3JldHVybiAzPT09YS5ub2RlVHlwZT9hLnBhcmVudE5vZGU6YX12YXIgeGM7bC5jYW5Vc2VET00mJih4Yz1kb2N1bWVudC5pbXBsZW1lbnRhdGlvbiYmZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSYmITAhPT1kb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKFwiXCIsXCJcIikpO1xuZnVuY3Rpb24geWMoYSxiKXtpZighbC5jYW5Vc2VET018fGImJiEoXCJhZGRFdmVudExpc3RlbmVyXCJpbiBkb2N1bWVudCkpcmV0dXJuITE7Yj1cIm9uXCIrYTt2YXIgYz1iIGluIGRvY3VtZW50O2N8fChjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksYy5zZXRBdHRyaWJ1dGUoYixcInJldHVybjtcIiksYz1cImZ1bmN0aW9uXCI9PT10eXBlb2YgY1tiXSk7IWMmJnhjJiZcIndoZWVsXCI9PT1hJiYoYz1kb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKFwiRXZlbnRzLndoZWVsXCIsXCIzLjBcIikpO3JldHVybiBjfWZ1bmN0aW9uIHpjKGEpe3ZhciBiPWEudHlwZTtyZXR1cm4oYT1hLm5vZGVOYW1lKSYmXCJpbnB1dFwiPT09YS50b0xvd2VyQ2FzZSgpJiYoXCJjaGVja2JveFwiPT09Ynx8XCJyYWRpb1wiPT09Yil9XG5mdW5jdGlvbiBBYyhhKXt2YXIgYj16YyhhKT9cImNoZWNrZWRcIjpcInZhbHVlXCIsYz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGEuY29uc3RydWN0b3IucHJvdG90eXBlLGIpLGQ9XCJcIithW2JdO2lmKCFhLmhhc093blByb3BlcnR5KGIpJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5nZXQmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBjLnNldClyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsYix7ZW51bWVyYWJsZTpjLmVudW1lcmFibGUsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBjLmdldC5jYWxsKHRoaXMpfSxzZXQ6ZnVuY3Rpb24oYSl7ZD1cIlwiK2E7Yy5zZXQuY2FsbCh0aGlzLGEpfX0pLHtnZXRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiBkfSxzZXRWYWx1ZTpmdW5jdGlvbihhKXtkPVwiXCIrYX0sc3RvcFRyYWNraW5nOmZ1bmN0aW9uKCl7YS5fdmFsdWVUcmFja2VyPW51bGw7ZGVsZXRlIGFbYl19fX1cbmZ1bmN0aW9uIEJjKGEpe2EuX3ZhbHVlVHJhY2tlcnx8KGEuX3ZhbHVlVHJhY2tlcj1BYyhhKSl9ZnVuY3Rpb24gQ2MoYSl7aWYoIWEpcmV0dXJuITE7dmFyIGI9YS5fdmFsdWVUcmFja2VyO2lmKCFiKXJldHVybiEwO3ZhciBjPWIuZ2V0VmFsdWUoKTt2YXIgZD1cIlwiO2EmJihkPXpjKGEpP2EuY2hlY2tlZD9cInRydWVcIjpcImZhbHNlXCI6YS52YWx1ZSk7YT1kO3JldHVybiBhIT09Yz8oYi5zZXRWYWx1ZShhKSwhMCk6ITF9dmFyIERjPXtjaGFuZ2U6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25DaGFuZ2VcIixjYXB0dXJlZDpcIm9uQ2hhbmdlQ2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJ0b3BCbHVyIHRvcENoYW5nZSB0b3BDbGljayB0b3BGb2N1cyB0b3BJbnB1dCB0b3BLZXlEb3duIHRvcEtleVVwIHRvcFNlbGVjdGlvbkNoYW5nZVwiLnNwbGl0KFwiIFwiKX19O1xuZnVuY3Rpb24gRWMoYSxiLGMpe2E9VC5nZXRQb29sZWQoRGMuY2hhbmdlLGEsYixjKTthLnR5cGU9XCJjaGFuZ2VcIjtvYyhjKTtBYihhKTtyZXR1cm4gYX12YXIgRmM9bnVsbCxHYz1udWxsO2Z1bmN0aW9uIEhjKGEpe2tiKGEpO2xiKCExKX1mdW5jdGlvbiBJYyhhKXt2YXIgYj1xYihhKTtpZihDYyhiKSlyZXR1cm4gYX1mdW5jdGlvbiBKYyhhLGIpe2lmKFwidG9wQ2hhbmdlXCI9PT1hKXJldHVybiBifXZhciBLYz0hMTtsLmNhblVzZURPTSYmKEtjPXljKFwiaW5wdXRcIikmJighZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw5PGRvY3VtZW50LmRvY3VtZW50TW9kZSkpO2Z1bmN0aW9uIExjKCl7RmMmJihGYy5kZXRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIixNYyksR2M9RmM9bnVsbCl9ZnVuY3Rpb24gTWMoYSl7XCJ2YWx1ZVwiPT09YS5wcm9wZXJ0eU5hbWUmJkljKEdjKSYmKGE9RWMoR2MsYSx3YyhhKSksdGMoSGMsYSkpfVxuZnVuY3Rpb24gTmMoYSxiLGMpe1widG9wRm9jdXNcIj09PWE/KExjKCksRmM9YixHYz1jLEZjLmF0dGFjaEV2ZW50KFwib25wcm9wZXJ0eWNoYW5nZVwiLE1jKSk6XCJ0b3BCbHVyXCI9PT1hJiZMYygpfWZ1bmN0aW9uIE9jKGEpe2lmKFwidG9wU2VsZWN0aW9uQ2hhbmdlXCI9PT1hfHxcInRvcEtleVVwXCI9PT1hfHxcInRvcEtleURvd25cIj09PWEpcmV0dXJuIEljKEdjKX1mdW5jdGlvbiBQYyhhLGIpe2lmKFwidG9wQ2xpY2tcIj09PWEpcmV0dXJuIEljKGIpfWZ1bmN0aW9uICRjKGEsYil7aWYoXCJ0b3BJbnB1dFwiPT09YXx8XCJ0b3BDaGFuZ2VcIj09PWEpcmV0dXJuIEljKGIpfVxudmFyIGFkPXtldmVudFR5cGVzOkRjLF9pc0lucHV0RXZlbnRTdXBwb3J0ZWQ6S2MsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1iP3FiKGIpOndpbmRvdyxmPWUubm9kZU5hbWUmJmUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtpZihcInNlbGVjdFwiPT09Znx8XCJpbnB1dFwiPT09ZiYmXCJmaWxlXCI9PT1lLnR5cGUpdmFyIGc9SmM7ZWxzZSBpZih2YyhlKSlpZihLYylnPSRjO2Vsc2V7Zz1PYzt2YXIgaD1OY31lbHNlIGY9ZS5ub2RlTmFtZSwhZnx8XCJpbnB1dFwiIT09Zi50b0xvd2VyQ2FzZSgpfHxcImNoZWNrYm94XCIhPT1lLnR5cGUmJlwicmFkaW9cIiE9PWUudHlwZXx8KGc9UGMpO2lmKGcmJihnPWcoYSxiKSkpcmV0dXJuIEVjKGcsYyxkKTtoJiZoKGEsZSxiKTtcInRvcEJsdXJcIj09PWEmJm51bGwhPWImJihhPWIuX3dyYXBwZXJTdGF0ZXx8ZS5fd3JhcHBlclN0YXRlKSYmYS5jb250cm9sbGVkJiZcIm51bWJlclwiPT09ZS50eXBlJiYoYT1cIlwiK2UudmFsdWUsZS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSE9PVxuYSYmZS5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLGEpKX19O2Z1bmN0aW9uIGJkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1ULmF1Z21lbnRDbGFzcyhiZCx7dmlldzpudWxsLGRldGFpbDpudWxsfSk7dmFyIGNkPXtBbHQ6XCJhbHRLZXlcIixDb250cm9sOlwiY3RybEtleVwiLE1ldGE6XCJtZXRhS2V5XCIsU2hpZnQ6XCJzaGlmdEtleVwifTtmdW5jdGlvbiBkZChhKXt2YXIgYj10aGlzLm5hdGl2ZUV2ZW50O3JldHVybiBiLmdldE1vZGlmaWVyU3RhdGU/Yi5nZXRNb2RpZmllclN0YXRlKGEpOihhPWNkW2FdKT8hIWJbYV06ITF9ZnVuY3Rpb24gZWQoKXtyZXR1cm4gZGR9ZnVuY3Rpb24gZmQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVxuYmQuYXVnbWVudENsYXNzKGZkLHtzY3JlZW5YOm51bGwsc2NyZWVuWTpudWxsLGNsaWVudFg6bnVsbCxjbGllbnRZOm51bGwscGFnZVg6bnVsbCxwYWdlWTpudWxsLGN0cmxLZXk6bnVsbCxzaGlmdEtleTpudWxsLGFsdEtleTpudWxsLG1ldGFLZXk6bnVsbCxnZXRNb2RpZmllclN0YXRlOmVkLGJ1dHRvbjpudWxsLGJ1dHRvbnM6bnVsbCxyZWxhdGVkVGFyZ2V0OmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlbGF0ZWRUYXJnZXR8fChhLmZyb21FbGVtZW50PT09YS5zcmNFbGVtZW50P2EudG9FbGVtZW50OmEuZnJvbUVsZW1lbnQpfX0pO1xudmFyIGdkPXttb3VzZUVudGVyOntyZWdpc3RyYXRpb25OYW1lOlwib25Nb3VzZUVudGVyXCIsZGVwZW5kZW5jaWVzOltcInRvcE1vdXNlT3V0XCIsXCJ0b3BNb3VzZU92ZXJcIl19LG1vdXNlTGVhdmU6e3JlZ2lzdHJhdGlvbk5hbWU6XCJvbk1vdXNlTGVhdmVcIixkZXBlbmRlbmNpZXM6W1widG9wTW91c2VPdXRcIixcInRvcE1vdXNlT3ZlclwiXX19LGhkPXtldmVudFR5cGVzOmdkLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7aWYoXCJ0b3BNb3VzZU92ZXJcIj09PWEmJihjLnJlbGF0ZWRUYXJnZXR8fGMuZnJvbUVsZW1lbnQpfHxcInRvcE1vdXNlT3V0XCIhPT1hJiZcInRvcE1vdXNlT3ZlclwiIT09YSlyZXR1cm4gbnVsbDt2YXIgZT1kLndpbmRvdz09PWQ/ZDooZT1kLm93bmVyRG9jdW1lbnQpP2UuZGVmYXVsdFZpZXd8fGUucGFyZW50V2luZG93OndpbmRvdztcInRvcE1vdXNlT3V0XCI9PT1hPyhhPWIsYj0oYj1jLnJlbGF0ZWRUYXJnZXR8fGMudG9FbGVtZW50KT9wYihiKTpudWxsKTphPW51bGw7aWYoYT09PVxuYilyZXR1cm4gbnVsbDt2YXIgZj1udWxsPT1hP2U6cWIoYSk7ZT1udWxsPT1iP2U6cWIoYik7dmFyIGc9ZmQuZ2V0UG9vbGVkKGdkLm1vdXNlTGVhdmUsYSxjLGQpO2cudHlwZT1cIm1vdXNlbGVhdmVcIjtnLnRhcmdldD1mO2cucmVsYXRlZFRhcmdldD1lO2M9ZmQuZ2V0UG9vbGVkKGdkLm1vdXNlRW50ZXIsYixjLGQpO2MudHlwZT1cIm1vdXNlZW50ZXJcIjtjLnRhcmdldD1lO2MucmVsYXRlZFRhcmdldD1mO0JiKGcsYyxhLGIpO3JldHVybltnLGNdfX0saWQ9YWEuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXI7ZnVuY3Rpb24gamQoYSl7YT1hLnR5cGU7cmV0dXJuXCJzdHJpbmdcIj09PXR5cGVvZiBhP2E6XCJmdW5jdGlvblwiPT09dHlwZW9mIGE/YS5kaXNwbGF5TmFtZXx8YS5uYW1lOm51bGx9XG5mdW5jdGlvbiBrZChhKXt2YXIgYj1hO2lmKGEuYWx0ZXJuYXRlKWZvcig7YltcInJldHVyblwiXTspYj1iW1wicmV0dXJuXCJdO2Vsc2V7aWYoMCE9PShiLmVmZmVjdFRhZyYyKSlyZXR1cm4gMTtmb3IoO2JbXCJyZXR1cm5cIl07KWlmKGI9YltcInJldHVyblwiXSwwIT09KGIuZWZmZWN0VGFnJjIpKXJldHVybiAxfXJldHVybiAzPT09Yi50YWc/MjozfWZ1bmN0aW9uIGxkKGEpe3JldHVybihhPWEuX3JlYWN0SW50ZXJuYWxGaWJlcik/Mj09PWtkKGEpOiExfWZ1bmN0aW9uIG1kKGEpezIhPT1rZChhKT9FKFwiMTg4XCIpOnZvaWQgMH1cbmZ1bmN0aW9uIG5kKGEpe3ZhciBiPWEuYWx0ZXJuYXRlO2lmKCFiKXJldHVybiBiPWtkKGEpLDM9PT1iP0UoXCIxODhcIik6dm9pZCAwLDE9PT1iP251bGw6YTtmb3IodmFyIGM9YSxkPWI7Oyl7dmFyIGU9Y1tcInJldHVyblwiXSxmPWU/ZS5hbHRlcm5hdGU6bnVsbDtpZighZXx8IWYpYnJlYWs7aWYoZS5jaGlsZD09PWYuY2hpbGQpe2Zvcih2YXIgZz1lLmNoaWxkO2c7KXtpZihnPT09YylyZXR1cm4gbWQoZSksYTtpZihnPT09ZClyZXR1cm4gbWQoZSksYjtnPWcuc2libGluZ31FKFwiMTg4XCIpfWlmKGNbXCJyZXR1cm5cIl0hPT1kW1wicmV0dXJuXCJdKWM9ZSxkPWY7ZWxzZXtnPSExO2Zvcih2YXIgaD1lLmNoaWxkO2g7KXtpZihoPT09Yyl7Zz0hMDtjPWU7ZD1mO2JyZWFrfWlmKGg9PT1kKXtnPSEwO2Q9ZTtjPWY7YnJlYWt9aD1oLnNpYmxpbmd9aWYoIWcpe2ZvcihoPWYuY2hpbGQ7aDspe2lmKGg9PT1jKXtnPSEwO2M9ZjtkPWU7YnJlYWt9aWYoaD09PWQpe2c9ITA7ZD1mO2M9ZTticmVha31oPWguc2libGluZ31nP1xudm9pZCAwOkUoXCIxODlcIil9fWMuYWx0ZXJuYXRlIT09ZD9FKFwiMTkwXCIpOnZvaWQgMH0zIT09Yy50YWc/RShcIjE4OFwiKTp2b2lkIDA7cmV0dXJuIGMuc3RhdGVOb2RlLmN1cnJlbnQ9PT1jP2E6Yn1mdW5jdGlvbiBvZChhKXthPW5kKGEpO2lmKCFhKXJldHVybiBudWxsO2Zvcih2YXIgYj1hOzspe2lmKDU9PT1iLnRhZ3x8Nj09PWIudGFnKXJldHVybiBiO2lmKGIuY2hpbGQpYi5jaGlsZFtcInJldHVyblwiXT1iLGI9Yi5jaGlsZDtlbHNle2lmKGI9PT1hKWJyZWFrO2Zvcig7IWIuc2libGluZzspe2lmKCFiW1wicmV0dXJuXCJdfHxiW1wicmV0dXJuXCJdPT09YSlyZXR1cm4gbnVsbDtiPWJbXCJyZXR1cm5cIl19Yi5zaWJsaW5nW1wicmV0dXJuXCJdPWJbXCJyZXR1cm5cIl07Yj1iLnNpYmxpbmd9fXJldHVybiBudWxsfVxuZnVuY3Rpb24gcGQoYSl7YT1uZChhKTtpZighYSlyZXR1cm4gbnVsbDtmb3IodmFyIGI9YTs7KXtpZig1PT09Yi50YWd8fDY9PT1iLnRhZylyZXR1cm4gYjtpZihiLmNoaWxkJiY0IT09Yi50YWcpYi5jaGlsZFtcInJldHVyblwiXT1iLGI9Yi5jaGlsZDtlbHNle2lmKGI9PT1hKWJyZWFrO2Zvcig7IWIuc2libGluZzspe2lmKCFiW1wicmV0dXJuXCJdfHxiW1wicmV0dXJuXCJdPT09YSlyZXR1cm4gbnVsbDtiPWJbXCJyZXR1cm5cIl19Yi5zaWJsaW5nW1wicmV0dXJuXCJdPWJbXCJyZXR1cm5cIl07Yj1iLnNpYmxpbmd9fXJldHVybiBudWxsfXZhciBxZD1bXTtcbmZ1bmN0aW9uIHJkKGEpe3ZhciBiPWEudGFyZ2V0SW5zdDtkb3tpZighYil7YS5hbmNlc3RvcnMucHVzaChiKTticmVha312YXIgYztmb3IoYz1iO2NbXCJyZXR1cm5cIl07KWM9Y1tcInJldHVyblwiXTtjPTMhPT1jLnRhZz9udWxsOmMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87aWYoIWMpYnJlYWs7YS5hbmNlc3RvcnMucHVzaChiKTtiPXBiKGMpfXdoaWxlKGIpO2ZvcihjPTA7YzxhLmFuY2VzdG9ycy5sZW5ndGg7YysrKWI9YS5hbmNlc3RvcnNbY10sc2QoYS50b3BMZXZlbFR5cGUsYixhLm5hdGl2ZUV2ZW50LHdjKGEubmF0aXZlRXZlbnQpKX12YXIgdGQ9ITAsc2Q9dm9pZCAwO2Z1bmN0aW9uIHVkKGEpe3RkPSEhYX1mdW5jdGlvbiBVKGEsYixjKXtyZXR1cm4gYz9iYS5saXN0ZW4oYyxiLHZkLmJpbmQobnVsbCxhKSk6bnVsbH1mdW5jdGlvbiB3ZChhLGIsYyl7cmV0dXJuIGM/YmEuY2FwdHVyZShjLGIsdmQuYmluZChudWxsLGEpKTpudWxsfVxuZnVuY3Rpb24gdmQoYSxiKXtpZih0ZCl7dmFyIGM9d2MoYik7Yz1wYihjKTtudWxsPT09Y3x8XCJudW1iZXJcIiE9PXR5cGVvZiBjLnRhZ3x8Mj09PWtkKGMpfHwoYz1udWxsKTtpZihxZC5sZW5ndGgpe3ZhciBkPXFkLnBvcCgpO2QudG9wTGV2ZWxUeXBlPWE7ZC5uYXRpdmVFdmVudD1iO2QudGFyZ2V0SW5zdD1jO2E9ZH1lbHNlIGE9e3RvcExldmVsVHlwZTphLG5hdGl2ZUV2ZW50OmIsdGFyZ2V0SW5zdDpjLGFuY2VzdG9yczpbXX07dHJ5e3RjKHJkLGEpfWZpbmFsbHl7YS50b3BMZXZlbFR5cGU9bnVsbCxhLm5hdGl2ZUV2ZW50PW51bGwsYS50YXJnZXRJbnN0PW51bGwsYS5hbmNlc3RvcnMubGVuZ3RoPTAsMTA+cWQubGVuZ3RoJiZxZC5wdXNoKGEpfX19XG52YXIgeGQ9T2JqZWN0LmZyZWV6ZSh7Z2V0IF9lbmFibGVkKCl7cmV0dXJuIHRkfSxnZXQgX2hhbmRsZVRvcExldmVsKCl7cmV0dXJuIHNkfSxzZXRIYW5kbGVUb3BMZXZlbDpmdW5jdGlvbihhKXtzZD1hfSxzZXRFbmFibGVkOnVkLGlzRW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiB0ZH0sdHJhcEJ1YmJsZWRFdmVudDpVLHRyYXBDYXB0dXJlZEV2ZW50OndkLGRpc3BhdGNoRXZlbnQ6dmR9KTtmdW5jdGlvbiB5ZChhLGIpe3ZhciBjPXt9O2NbYS50b0xvd2VyQ2FzZSgpXT1iLnRvTG93ZXJDYXNlKCk7Y1tcIldlYmtpdFwiK2FdPVwid2Via2l0XCIrYjtjW1wiTW96XCIrYV09XCJtb3pcIitiO2NbXCJtc1wiK2FdPVwiTVNcIitiO2NbXCJPXCIrYV09XCJvXCIrYi50b0xvd2VyQ2FzZSgpO3JldHVybiBjfVxudmFyIHpkPXthbmltYXRpb25lbmQ6eWQoXCJBbmltYXRpb25cIixcIkFuaW1hdGlvbkVuZFwiKSxhbmltYXRpb25pdGVyYXRpb246eWQoXCJBbmltYXRpb25cIixcIkFuaW1hdGlvbkl0ZXJhdGlvblwiKSxhbmltYXRpb25zdGFydDp5ZChcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uU3RhcnRcIiksdHJhbnNpdGlvbmVuZDp5ZChcIlRyYW5zaXRpb25cIixcIlRyYW5zaXRpb25FbmRcIil9LEFkPXt9LEJkPXt9O2wuY2FuVXNlRE9NJiYoQmQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZSxcIkFuaW1hdGlvbkV2ZW50XCJpbiB3aW5kb3d8fChkZWxldGUgemQuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbixkZWxldGUgemQuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbixkZWxldGUgemQuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uKSxcIlRyYW5zaXRpb25FdmVudFwiaW4gd2luZG93fHxkZWxldGUgemQudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uKTtcbmZ1bmN0aW9uIENkKGEpe2lmKEFkW2FdKXJldHVybiBBZFthXTtpZighemRbYV0pcmV0dXJuIGE7dmFyIGI9emRbYV0sYztmb3IoYyBpbiBiKWlmKGIuaGFzT3duUHJvcGVydHkoYykmJmMgaW4gQmQpcmV0dXJuIEFkW2FdPWJbY107cmV0dXJuXCJcIn1cbnZhciBEZD17dG9wQWJvcnQ6XCJhYm9ydFwiLHRvcEFuaW1hdGlvbkVuZDpDZChcImFuaW1hdGlvbmVuZFwiKXx8XCJhbmltYXRpb25lbmRcIix0b3BBbmltYXRpb25JdGVyYXRpb246Q2QoXCJhbmltYXRpb25pdGVyYXRpb25cIil8fFwiYW5pbWF0aW9uaXRlcmF0aW9uXCIsdG9wQW5pbWF0aW9uU3RhcnQ6Q2QoXCJhbmltYXRpb25zdGFydFwiKXx8XCJhbmltYXRpb25zdGFydFwiLHRvcEJsdXI6XCJibHVyXCIsdG9wQ2FuY2VsOlwiY2FuY2VsXCIsdG9wQ2FuUGxheTpcImNhbnBsYXlcIix0b3BDYW5QbGF5VGhyb3VnaDpcImNhbnBsYXl0aHJvdWdoXCIsdG9wQ2hhbmdlOlwiY2hhbmdlXCIsdG9wQ2xpY2s6XCJjbGlja1wiLHRvcENsb3NlOlwiY2xvc2VcIix0b3BDb21wb3NpdGlvbkVuZDpcImNvbXBvc2l0aW9uZW5kXCIsdG9wQ29tcG9zaXRpb25TdGFydDpcImNvbXBvc2l0aW9uc3RhcnRcIix0b3BDb21wb3NpdGlvblVwZGF0ZTpcImNvbXBvc2l0aW9udXBkYXRlXCIsdG9wQ29udGV4dE1lbnU6XCJjb250ZXh0bWVudVwiLHRvcENvcHk6XCJjb3B5XCIsXG50b3BDdXQ6XCJjdXRcIix0b3BEb3VibGVDbGljazpcImRibGNsaWNrXCIsdG9wRHJhZzpcImRyYWdcIix0b3BEcmFnRW5kOlwiZHJhZ2VuZFwiLHRvcERyYWdFbnRlcjpcImRyYWdlbnRlclwiLHRvcERyYWdFeGl0OlwiZHJhZ2V4aXRcIix0b3BEcmFnTGVhdmU6XCJkcmFnbGVhdmVcIix0b3BEcmFnT3ZlcjpcImRyYWdvdmVyXCIsdG9wRHJhZ1N0YXJ0OlwiZHJhZ3N0YXJ0XCIsdG9wRHJvcDpcImRyb3BcIix0b3BEdXJhdGlvbkNoYW5nZTpcImR1cmF0aW9uY2hhbmdlXCIsdG9wRW1wdGllZDpcImVtcHRpZWRcIix0b3BFbmNyeXB0ZWQ6XCJlbmNyeXB0ZWRcIix0b3BFbmRlZDpcImVuZGVkXCIsdG9wRXJyb3I6XCJlcnJvclwiLHRvcEZvY3VzOlwiZm9jdXNcIix0b3BJbnB1dDpcImlucHV0XCIsdG9wS2V5RG93bjpcImtleWRvd25cIix0b3BLZXlQcmVzczpcImtleXByZXNzXCIsdG9wS2V5VXA6XCJrZXl1cFwiLHRvcExvYWRlZERhdGE6XCJsb2FkZWRkYXRhXCIsdG9wTG9hZDpcImxvYWRcIix0b3BMb2FkZWRNZXRhZGF0YTpcImxvYWRlZG1ldGFkYXRhXCIsdG9wTG9hZFN0YXJ0OlwibG9hZHN0YXJ0XCIsXG50b3BNb3VzZURvd246XCJtb3VzZWRvd25cIix0b3BNb3VzZU1vdmU6XCJtb3VzZW1vdmVcIix0b3BNb3VzZU91dDpcIm1vdXNlb3V0XCIsdG9wTW91c2VPdmVyOlwibW91c2VvdmVyXCIsdG9wTW91c2VVcDpcIm1vdXNldXBcIix0b3BQYXN0ZTpcInBhc3RlXCIsdG9wUGF1c2U6XCJwYXVzZVwiLHRvcFBsYXk6XCJwbGF5XCIsdG9wUGxheWluZzpcInBsYXlpbmdcIix0b3BQcm9ncmVzczpcInByb2dyZXNzXCIsdG9wUmF0ZUNoYW5nZTpcInJhdGVjaGFuZ2VcIix0b3BTY3JvbGw6XCJzY3JvbGxcIix0b3BTZWVrZWQ6XCJzZWVrZWRcIix0b3BTZWVraW5nOlwic2Vla2luZ1wiLHRvcFNlbGVjdGlvbkNoYW5nZTpcInNlbGVjdGlvbmNoYW5nZVwiLHRvcFN0YWxsZWQ6XCJzdGFsbGVkXCIsdG9wU3VzcGVuZDpcInN1c3BlbmRcIix0b3BUZXh0SW5wdXQ6XCJ0ZXh0SW5wdXRcIix0b3BUaW1lVXBkYXRlOlwidGltZXVwZGF0ZVwiLHRvcFRvZ2dsZTpcInRvZ2dsZVwiLHRvcFRvdWNoQ2FuY2VsOlwidG91Y2hjYW5jZWxcIix0b3BUb3VjaEVuZDpcInRvdWNoZW5kXCIsdG9wVG91Y2hNb3ZlOlwidG91Y2htb3ZlXCIsXG50b3BUb3VjaFN0YXJ0OlwidG91Y2hzdGFydFwiLHRvcFRyYW5zaXRpb25FbmQ6Q2QoXCJ0cmFuc2l0aW9uZW5kXCIpfHxcInRyYW5zaXRpb25lbmRcIix0b3BWb2x1bWVDaGFuZ2U6XCJ2b2x1bWVjaGFuZ2VcIix0b3BXYWl0aW5nOlwid2FpdGluZ1wiLHRvcFdoZWVsOlwid2hlZWxcIn0sRWQ9e30sRmQ9MCxHZD1cIl9yZWFjdExpc3RlbmVyc0lEXCIrKFwiXCIrTWF0aC5yYW5kb20oKSkuc2xpY2UoMik7ZnVuY3Rpb24gSGQoYSl7T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsR2QpfHwoYVtHZF09RmQrKyxFZFthW0dkXV09e30pO3JldHVybiBFZFthW0dkXV19ZnVuY3Rpb24gSWQoYSl7Zm9yKDthJiZhLmZpcnN0Q2hpbGQ7KWE9YS5maXJzdENoaWxkO3JldHVybiBhfVxuZnVuY3Rpb24gSmQoYSxiKXt2YXIgYz1JZChhKTthPTA7Zm9yKHZhciBkO2M7KXtpZigzPT09Yy5ub2RlVHlwZSl7ZD1hK2MudGV4dENvbnRlbnQubGVuZ3RoO2lmKGE8PWImJmQ+PWIpcmV0dXJue25vZGU6YyxvZmZzZXQ6Yi1hfTthPWR9YTp7Zm9yKDtjOyl7aWYoYy5uZXh0U2libGluZyl7Yz1jLm5leHRTaWJsaW5nO2JyZWFrIGF9Yz1jLnBhcmVudE5vZGV9Yz12b2lkIDB9Yz1JZChjKX19ZnVuY3Rpb24gS2QoYSl7dmFyIGI9YSYmYS5ub2RlTmFtZSYmYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVybiBiJiYoXCJpbnB1dFwiPT09YiYmXCJ0ZXh0XCI9PT1hLnR5cGV8fFwidGV4dGFyZWFcIj09PWJ8fFwidHJ1ZVwiPT09YS5jb250ZW50RWRpdGFibGUpfVxudmFyIExkPWwuY2FuVXNlRE9NJiZcImRvY3VtZW50TW9kZVwiaW4gZG9jdW1lbnQmJjExPj1kb2N1bWVudC5kb2N1bWVudE1vZGUsTWQ9e3NlbGVjdDp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvblNlbGVjdFwiLGNhcHR1cmVkOlwib25TZWxlY3RDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcInRvcEJsdXIgdG9wQ29udGV4dE1lbnUgdG9wRm9jdXMgdG9wS2V5RG93biB0b3BLZXlVcCB0b3BNb3VzZURvd24gdG9wTW91c2VVcCB0b3BTZWxlY3Rpb25DaGFuZ2VcIi5zcGxpdChcIiBcIil9fSxOZD1udWxsLE9kPW51bGwsUGQ9bnVsbCxRZD0hMTtcbmZ1bmN0aW9uIFJkKGEsYil7aWYoUWR8fG51bGw9PU5kfHxOZCE9PWRhKCkpcmV0dXJuIG51bGw7dmFyIGM9TmQ7XCJzZWxlY3Rpb25TdGFydFwiaW4gYyYmS2QoYyk/Yz17c3RhcnQ6Yy5zZWxlY3Rpb25TdGFydCxlbmQ6Yy5zZWxlY3Rpb25FbmR9OndpbmRvdy5nZXRTZWxlY3Rpb24/KGM9d2luZG93LmdldFNlbGVjdGlvbigpLGM9e2FuY2hvck5vZGU6Yy5hbmNob3JOb2RlLGFuY2hvck9mZnNldDpjLmFuY2hvck9mZnNldCxmb2N1c05vZGU6Yy5mb2N1c05vZGUsZm9jdXNPZmZzZXQ6Yy5mb2N1c09mZnNldH0pOmM9dm9pZCAwO3JldHVybiBQZCYmZWEoUGQsYyk/bnVsbDooUGQ9YyxhPVQuZ2V0UG9vbGVkKE1kLnNlbGVjdCxPZCxhLGIpLGEudHlwZT1cInNlbGVjdFwiLGEudGFyZ2V0PU5kLEFiKGEpLGEpfVxudmFyIFNkPXtldmVudFR5cGVzOk1kLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9ZC53aW5kb3c9PT1kP2QuZG9jdW1lbnQ6OT09PWQubm9kZVR5cGU/ZDpkLm93bmVyRG9jdW1lbnQsZjtpZighKGY9IWUpKXthOntlPUhkKGUpO2Y9U2Eub25TZWxlY3Q7Zm9yKHZhciBnPTA7ZzxmLmxlbmd0aDtnKyspe3ZhciBoPWZbZ107aWYoIWUuaGFzT3duUHJvcGVydHkoaCl8fCFlW2hdKXtlPSExO2JyZWFrIGF9fWU9ITB9Zj0hZX1pZihmKXJldHVybiBudWxsO2U9Yj9xYihiKTp3aW5kb3c7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BGb2N1c1wiOmlmKHZjKGUpfHxcInRydWVcIj09PWUuY29udGVudEVkaXRhYmxlKU5kPWUsT2Q9YixQZD1udWxsO2JyZWFrO2Nhc2UgXCJ0b3BCbHVyXCI6UGQ9T2Q9TmQ9bnVsbDticmVhaztjYXNlIFwidG9wTW91c2VEb3duXCI6UWQ9ITA7YnJlYWs7Y2FzZSBcInRvcENvbnRleHRNZW51XCI6Y2FzZSBcInRvcE1vdXNlVXBcIjpyZXR1cm4gUWQ9ITEsUmQoYyxkKTtjYXNlIFwidG9wU2VsZWN0aW9uQ2hhbmdlXCI6aWYoTGQpYnJlYWs7XG5jYXNlIFwidG9wS2V5RG93blwiOmNhc2UgXCJ0b3BLZXlVcFwiOnJldHVybiBSZChjLGQpfXJldHVybiBudWxsfX07ZnVuY3Rpb24gVGQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVQuYXVnbWVudENsYXNzKFRkLHthbmltYXRpb25OYW1lOm51bGwsZWxhcHNlZFRpbWU6bnVsbCxwc2V1ZG9FbGVtZW50Om51bGx9KTtmdW5jdGlvbiBVZChhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9VC5hdWdtZW50Q2xhc3MoVWQse2NsaXBib2FyZERhdGE6ZnVuY3Rpb24oYSl7cmV0dXJuXCJjbGlwYm9hcmREYXRhXCJpbiBhP2EuY2xpcGJvYXJkRGF0YTp3aW5kb3cuY2xpcGJvYXJkRGF0YX19KTtmdW5jdGlvbiBWZChhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9YmQuYXVnbWVudENsYXNzKFZkLHtyZWxhdGVkVGFyZ2V0Om51bGx9KTtcbmZ1bmN0aW9uIFdkKGEpe3ZhciBiPWEua2V5Q29kZTtcImNoYXJDb2RlXCJpbiBhPyhhPWEuY2hhckNvZGUsMD09PWEmJjEzPT09YiYmKGE9MTMpKTphPWI7cmV0dXJuIDMyPD1hfHwxMz09PWE/YTowfVxudmFyIFhkPXtFc2M6XCJFc2NhcGVcIixTcGFjZWJhcjpcIiBcIixMZWZ0OlwiQXJyb3dMZWZ0XCIsVXA6XCJBcnJvd1VwXCIsUmlnaHQ6XCJBcnJvd1JpZ2h0XCIsRG93bjpcIkFycm93RG93blwiLERlbDpcIkRlbGV0ZVwiLFdpbjpcIk9TXCIsTWVudTpcIkNvbnRleHRNZW51XCIsQXBwczpcIkNvbnRleHRNZW51XCIsU2Nyb2xsOlwiU2Nyb2xsTG9ja1wiLE1velByaW50YWJsZUtleTpcIlVuaWRlbnRpZmllZFwifSxZZD17ODpcIkJhY2tzcGFjZVwiLDk6XCJUYWJcIiwxMjpcIkNsZWFyXCIsMTM6XCJFbnRlclwiLDE2OlwiU2hpZnRcIiwxNzpcIkNvbnRyb2xcIiwxODpcIkFsdFwiLDE5OlwiUGF1c2VcIiwyMDpcIkNhcHNMb2NrXCIsMjc6XCJFc2NhcGVcIiwzMjpcIiBcIiwzMzpcIlBhZ2VVcFwiLDM0OlwiUGFnZURvd25cIiwzNTpcIkVuZFwiLDM2OlwiSG9tZVwiLDM3OlwiQXJyb3dMZWZ0XCIsMzg6XCJBcnJvd1VwXCIsMzk6XCJBcnJvd1JpZ2h0XCIsNDA6XCJBcnJvd0Rvd25cIiw0NTpcIkluc2VydFwiLDQ2OlwiRGVsZXRlXCIsMTEyOlwiRjFcIiwxMTM6XCJGMlwiLDExNDpcIkYzXCIsMTE1OlwiRjRcIixcbjExNjpcIkY1XCIsMTE3OlwiRjZcIiwxMTg6XCJGN1wiLDExOTpcIkY4XCIsMTIwOlwiRjlcIiwxMjE6XCJGMTBcIiwxMjI6XCJGMTFcIiwxMjM6XCJGMTJcIiwxNDQ6XCJOdW1Mb2NrXCIsMTQ1OlwiU2Nyb2xsTG9ja1wiLDIyNDpcIk1ldGFcIn07ZnVuY3Rpb24gWmQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVxuYmQuYXVnbWVudENsYXNzKFpkLHtrZXk6ZnVuY3Rpb24oYSl7aWYoYS5rZXkpe3ZhciBiPVhkW2Eua2V5XXx8YS5rZXk7aWYoXCJVbmlkZW50aWZpZWRcIiE9PWIpcmV0dXJuIGJ9cmV0dXJuXCJrZXlwcmVzc1wiPT09YS50eXBlPyhhPVdkKGEpLDEzPT09YT9cIkVudGVyXCI6U3RyaW5nLmZyb21DaGFyQ29kZShhKSk6XCJrZXlkb3duXCI9PT1hLnR5cGV8fFwia2V5dXBcIj09PWEudHlwZT9ZZFthLmtleUNvZGVdfHxcIlVuaWRlbnRpZmllZFwiOlwiXCJ9LGxvY2F0aW9uOm51bGwsY3RybEtleTpudWxsLHNoaWZ0S2V5Om51bGwsYWx0S2V5Om51bGwsbWV0YUtleTpudWxsLHJlcGVhdDpudWxsLGxvY2FsZTpudWxsLGdldE1vZGlmaWVyU3RhdGU6ZWQsY2hhckNvZGU6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlwcmVzc1wiPT09YS50eXBlP1dkKGEpOjB9LGtleUNvZGU6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlkb3duXCI9PT1hLnR5cGV8fFwia2V5dXBcIj09PWEudHlwZT9hLmtleUNvZGU6MH0sd2hpY2g6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlwcmVzc1wiPT09XG5hLnR5cGU/V2QoYSk6XCJrZXlkb3duXCI9PT1hLnR5cGV8fFwia2V5dXBcIj09PWEudHlwZT9hLmtleUNvZGU6MH19KTtmdW5jdGlvbiAkZChhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9ZmQuYXVnbWVudENsYXNzKCRkLHtkYXRhVHJhbnNmZXI6bnVsbH0pO2Z1bmN0aW9uIGFlKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1iZC5hdWdtZW50Q2xhc3MoYWUse3RvdWNoZXM6bnVsbCx0YXJnZXRUb3VjaGVzOm51bGwsY2hhbmdlZFRvdWNoZXM6bnVsbCxhbHRLZXk6bnVsbCxtZXRhS2V5Om51bGwsY3RybEtleTpudWxsLHNoaWZ0S2V5Om51bGwsZ2V0TW9kaWZpZXJTdGF0ZTplZH0pO2Z1bmN0aW9uIGJlKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1ULmF1Z21lbnRDbGFzcyhiZSx7cHJvcGVydHlOYW1lOm51bGwsZWxhcHNlZFRpbWU6bnVsbCxwc2V1ZG9FbGVtZW50Om51bGx9KTtcbmZ1bmN0aW9uIGNlKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1mZC5hdWdtZW50Q2xhc3MoY2Use2RlbHRhWDpmdW5jdGlvbihhKXtyZXR1cm5cImRlbHRhWFwiaW4gYT9hLmRlbHRhWDpcIndoZWVsRGVsdGFYXCJpbiBhPy1hLndoZWVsRGVsdGFYOjB9LGRlbHRhWTpmdW5jdGlvbihhKXtyZXR1cm5cImRlbHRhWVwiaW4gYT9hLmRlbHRhWTpcIndoZWVsRGVsdGFZXCJpbiBhPy1hLndoZWVsRGVsdGFZOlwid2hlZWxEZWx0YVwiaW4gYT8tYS53aGVlbERlbHRhOjB9LGRlbHRhWjpudWxsLGRlbHRhTW9kZTpudWxsfSk7dmFyIGRlPXt9LGVlPXt9O1xuXCJhYm9ydCBhbmltYXRpb25FbmQgYW5pbWF0aW9uSXRlcmF0aW9uIGFuaW1hdGlvblN0YXJ0IGJsdXIgY2FuY2VsIGNhblBsYXkgY2FuUGxheVRocm91Z2ggY2xpY2sgY2xvc2UgY29udGV4dE1lbnUgY29weSBjdXQgZG91YmxlQ2xpY2sgZHJhZyBkcmFnRW5kIGRyYWdFbnRlciBkcmFnRXhpdCBkcmFnTGVhdmUgZHJhZ092ZXIgZHJhZ1N0YXJ0IGRyb3AgZHVyYXRpb25DaGFuZ2UgZW1wdGllZCBlbmNyeXB0ZWQgZW5kZWQgZXJyb3IgZm9jdXMgaW5wdXQgaW52YWxpZCBrZXlEb3duIGtleVByZXNzIGtleVVwIGxvYWQgbG9hZGVkRGF0YSBsb2FkZWRNZXRhZGF0YSBsb2FkU3RhcnQgbW91c2VEb3duIG1vdXNlTW92ZSBtb3VzZU91dCBtb3VzZU92ZXIgbW91c2VVcCBwYXN0ZSBwYXVzZSBwbGF5IHBsYXlpbmcgcHJvZ3Jlc3MgcmF0ZUNoYW5nZSByZXNldCBzY3JvbGwgc2Vla2VkIHNlZWtpbmcgc3RhbGxlZCBzdWJtaXQgc3VzcGVuZCB0aW1lVXBkYXRlIHRvZ2dsZSB0b3VjaENhbmNlbCB0b3VjaEVuZCB0b3VjaE1vdmUgdG91Y2hTdGFydCB0cmFuc2l0aW9uRW5kIHZvbHVtZUNoYW5nZSB3YWl0aW5nIHdoZWVsXCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YVswXS50b1VwcGVyQ2FzZSgpK1xuYS5zbGljZSgxKSxjPVwib25cIitiO2I9XCJ0b3BcIitiO2M9e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOmMsY2FwdHVyZWQ6YytcIkNhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOltiXX07ZGVbYV09YztlZVtiXT1jfSk7XG52YXIgZmU9e2V2ZW50VHlwZXM6ZGUsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1lZVthXTtpZighZSlyZXR1cm4gbnVsbDtzd2l0Y2goYSl7Y2FzZSBcInRvcEtleVByZXNzXCI6aWYoMD09PVdkKGMpKXJldHVybiBudWxsO2Nhc2UgXCJ0b3BLZXlEb3duXCI6Y2FzZSBcInRvcEtleVVwXCI6YT1aZDticmVhaztjYXNlIFwidG9wQmx1clwiOmNhc2UgXCJ0b3BGb2N1c1wiOmE9VmQ7YnJlYWs7Y2FzZSBcInRvcENsaWNrXCI6aWYoMj09PWMuYnV0dG9uKXJldHVybiBudWxsO2Nhc2UgXCJ0b3BEb3VibGVDbGlja1wiOmNhc2UgXCJ0b3BNb3VzZURvd25cIjpjYXNlIFwidG9wTW91c2VNb3ZlXCI6Y2FzZSBcInRvcE1vdXNlVXBcIjpjYXNlIFwidG9wTW91c2VPdXRcIjpjYXNlIFwidG9wTW91c2VPdmVyXCI6Y2FzZSBcInRvcENvbnRleHRNZW51XCI6YT1mZDticmVhaztjYXNlIFwidG9wRHJhZ1wiOmNhc2UgXCJ0b3BEcmFnRW5kXCI6Y2FzZSBcInRvcERyYWdFbnRlclwiOmNhc2UgXCJ0b3BEcmFnRXhpdFwiOmNhc2UgXCJ0b3BEcmFnTGVhdmVcIjpjYXNlIFwidG9wRHJhZ092ZXJcIjpjYXNlIFwidG9wRHJhZ1N0YXJ0XCI6Y2FzZSBcInRvcERyb3BcIjphPVxuJGQ7YnJlYWs7Y2FzZSBcInRvcFRvdWNoQ2FuY2VsXCI6Y2FzZSBcInRvcFRvdWNoRW5kXCI6Y2FzZSBcInRvcFRvdWNoTW92ZVwiOmNhc2UgXCJ0b3BUb3VjaFN0YXJ0XCI6YT1hZTticmVhaztjYXNlIFwidG9wQW5pbWF0aW9uRW5kXCI6Y2FzZSBcInRvcEFuaW1hdGlvbkl0ZXJhdGlvblwiOmNhc2UgXCJ0b3BBbmltYXRpb25TdGFydFwiOmE9VGQ7YnJlYWs7Y2FzZSBcInRvcFRyYW5zaXRpb25FbmRcIjphPWJlO2JyZWFrO2Nhc2UgXCJ0b3BTY3JvbGxcIjphPWJkO2JyZWFrO2Nhc2UgXCJ0b3BXaGVlbFwiOmE9Y2U7YnJlYWs7Y2FzZSBcInRvcENvcHlcIjpjYXNlIFwidG9wQ3V0XCI6Y2FzZSBcInRvcFBhc3RlXCI6YT1VZDticmVhaztkZWZhdWx0OmE9VH1iPWEuZ2V0UG9vbGVkKGUsYixjLGQpO0FiKGIpO3JldHVybiBifX07c2Q9ZnVuY3Rpb24oYSxiLGMsZCl7YT1qYihhLGIsYyxkKTtrYihhKTtsYighMSl9O2hiLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoXCJSZXNwb25kZXJFdmVudFBsdWdpbiBTaW1wbGVFdmVudFBsdWdpbiBUYXBFdmVudFBsdWdpbiBFbnRlckxlYXZlRXZlbnRQbHVnaW4gQ2hhbmdlRXZlbnRQbHVnaW4gU2VsZWN0RXZlbnRQbHVnaW4gQmVmb3JlSW5wdXRFdmVudFBsdWdpblwiLnNwbGl0KFwiIFwiKSk7XG5XYT1zYi5nZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlO1hhPXNiLmdldEluc3RhbmNlRnJvbU5vZGU7WWE9c2IuZ2V0Tm9kZUZyb21JbnN0YW5jZTtoYi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoe1NpbXBsZUV2ZW50UGx1Z2luOmZlLEVudGVyTGVhdmVFdmVudFBsdWdpbjpoZCxDaGFuZ2VFdmVudFBsdWdpbjphZCxTZWxlY3RFdmVudFBsdWdpbjpTZCxCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOmljfSk7dmFyIGdlPVtdLGhlPS0xO2Z1bmN0aW9uIFYoYSl7MD5oZXx8KGEuY3VycmVudD1nZVtoZV0sZ2VbaGVdPW51bGwsaGUtLSl9ZnVuY3Rpb24gVyhhLGIpe2hlKys7Z2VbaGVdPWEuY3VycmVudDthLmN1cnJlbnQ9Yn1uZXcgU2V0O3ZhciBpZT17Y3VycmVudDpEfSxYPXtjdXJyZW50OiExfSxqZT1EO2Z1bmN0aW9uIGtlKGEpe3JldHVybiBsZShhKT9qZTppZS5jdXJyZW50fVxuZnVuY3Rpb24gbWUoYSxiKXt2YXIgYz1hLnR5cGUuY29udGV4dFR5cGVzO2lmKCFjKXJldHVybiBEO3ZhciBkPWEuc3RhdGVOb2RlO2lmKGQmJmQuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD09PWIpcmV0dXJuIGQuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7dmFyIGU9e30sZjtmb3IoZiBpbiBjKWVbZl09YltmXTtkJiYoYT1hLnN0YXRlTm9kZSxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9YixhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0PWUpO3JldHVybiBlfWZ1bmN0aW9uIGxlKGEpe3JldHVybiAyPT09YS50YWcmJm51bGwhPWEudHlwZS5jaGlsZENvbnRleHRUeXBlc31mdW5jdGlvbiBuZShhKXtsZShhKSYmKFYoWCxhKSxWKGllLGEpKX1cbmZ1bmN0aW9uIG9lKGEsYixjKXtudWxsIT1pZS5jdXJzb3I/RShcIjE2OFwiKTp2b2lkIDA7VyhpZSxiLGEpO1coWCxjLGEpfWZ1bmN0aW9uIHBlKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGUsZD1hLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIGMuZ2V0Q2hpbGRDb250ZXh0KXJldHVybiBiO2M9Yy5nZXRDaGlsZENvbnRleHQoKTtmb3IodmFyIGUgaW4gYyllIGluIGQ/dm9pZCAwOkUoXCIxMDhcIixqZChhKXx8XCJVbmtub3duXCIsZSk7cmV0dXJuIEIoe30sYixjKX1mdW5jdGlvbiBxZShhKXtpZighbGUoYSkpcmV0dXJuITE7dmFyIGI9YS5zdGF0ZU5vZGU7Yj1iJiZiLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0fHxEO2plPWllLmN1cnJlbnQ7VyhpZSxiLGEpO1coWCxYLmN1cnJlbnQsYSk7cmV0dXJuITB9XG5mdW5jdGlvbiByZShhLGIpe3ZhciBjPWEuc3RhdGVOb2RlO2M/dm9pZCAwOkUoXCIxNjlcIik7aWYoYil7dmFyIGQ9cGUoYSxqZSk7Yy5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dD1kO1YoWCxhKTtWKGllLGEpO1coaWUsZCxhKX1lbHNlIFYoWCxhKTtXKFgsYixhKX1cbmZ1bmN0aW9uIFkoYSxiLGMpe3RoaXMudGFnPWE7dGhpcy5rZXk9Yjt0aGlzLnN0YXRlTm9kZT10aGlzLnR5cGU9bnVsbDt0aGlzLnNpYmxpbmc9dGhpcy5jaGlsZD10aGlzW1wicmV0dXJuXCJdPW51bGw7dGhpcy5pbmRleD0wO3RoaXMubWVtb2l6ZWRTdGF0ZT10aGlzLnVwZGF0ZVF1ZXVlPXRoaXMubWVtb2l6ZWRQcm9wcz10aGlzLnBlbmRpbmdQcm9wcz10aGlzLnJlZj1udWxsO3RoaXMuaW50ZXJuYWxDb250ZXh0VGFnPWM7dGhpcy5lZmZlY3RUYWc9MDt0aGlzLmxhc3RFZmZlY3Q9dGhpcy5maXJzdEVmZmVjdD10aGlzLm5leHRFZmZlY3Q9bnVsbDt0aGlzLmV4cGlyYXRpb25UaW1lPTA7dGhpcy5hbHRlcm5hdGU9bnVsbH1cbmZ1bmN0aW9uIHNlKGEsYixjKXt2YXIgZD1hLmFsdGVybmF0ZTtudWxsPT09ZD8oZD1uZXcgWShhLnRhZyxhLmtleSxhLmludGVybmFsQ29udGV4dFRhZyksZC50eXBlPWEudHlwZSxkLnN0YXRlTm9kZT1hLnN0YXRlTm9kZSxkLmFsdGVybmF0ZT1hLGEuYWx0ZXJuYXRlPWQpOihkLmVmZmVjdFRhZz0wLGQubmV4dEVmZmVjdD1udWxsLGQuZmlyc3RFZmZlY3Q9bnVsbCxkLmxhc3RFZmZlY3Q9bnVsbCk7ZC5leHBpcmF0aW9uVGltZT1jO2QucGVuZGluZ1Byb3BzPWI7ZC5jaGlsZD1hLmNoaWxkO2QubWVtb2l6ZWRQcm9wcz1hLm1lbW9pemVkUHJvcHM7ZC5tZW1vaXplZFN0YXRlPWEubWVtb2l6ZWRTdGF0ZTtkLnVwZGF0ZVF1ZXVlPWEudXBkYXRlUXVldWU7ZC5zaWJsaW5nPWEuc2libGluZztkLmluZGV4PWEuaW5kZXg7ZC5yZWY9YS5yZWY7cmV0dXJuIGR9XG5mdW5jdGlvbiB0ZShhLGIsYyl7dmFyIGQ9dm9pZCAwLGU9YS50eXBlLGY9YS5rZXk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGU/KGQ9ZS5wcm90b3R5cGUmJmUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ/bmV3IFkoMixmLGIpOm5ldyBZKDAsZixiKSxkLnR5cGU9ZSxkLnBlbmRpbmdQcm9wcz1hLnByb3BzKTpcInN0cmluZ1wiPT09dHlwZW9mIGU/KGQ9bmV3IFkoNSxmLGIpLGQudHlwZT1lLGQucGVuZGluZ1Byb3BzPWEucHJvcHMpOlwib2JqZWN0XCI9PT10eXBlb2YgZSYmbnVsbCE9PWUmJlwibnVtYmVyXCI9PT10eXBlb2YgZS50YWc/KGQ9ZSxkLnBlbmRpbmdQcm9wcz1hLnByb3BzKTpFKFwiMTMwXCIsbnVsbD09ZT9lOnR5cGVvZiBlLFwiXCIpO2QuZXhwaXJhdGlvblRpbWU9YztyZXR1cm4gZH1mdW5jdGlvbiB1ZShhLGIsYyxkKXtiPW5ldyBZKDEwLGQsYik7Yi5wZW5kaW5nUHJvcHM9YTtiLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGJ9XG5mdW5jdGlvbiB2ZShhLGIsYyl7Yj1uZXcgWSg2LG51bGwsYik7Yi5wZW5kaW5nUHJvcHM9YTtiLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGJ9ZnVuY3Rpb24gd2UoYSxiLGMpe2I9bmV3IFkoNyxhLmtleSxiKTtiLnR5cGU9YS5oYW5kbGVyO2IucGVuZGluZ1Byb3BzPWE7Yi5leHBpcmF0aW9uVGltZT1jO3JldHVybiBifWZ1bmN0aW9uIHhlKGEsYixjKXthPW5ldyBZKDksbnVsbCxiKTthLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGF9ZnVuY3Rpb24geWUoYSxiLGMpe2I9bmV3IFkoNCxhLmtleSxiKTtiLnBlbmRpbmdQcm9wcz1hLmNoaWxkcmVufHxbXTtiLmV4cGlyYXRpb25UaW1lPWM7Yi5zdGF0ZU5vZGU9e2NvbnRhaW5lckluZm86YS5jb250YWluZXJJbmZvLHBlbmRpbmdDaGlsZHJlbjpudWxsLGltcGxlbWVudGF0aW9uOmEuaW1wbGVtZW50YXRpb259O3JldHVybiBifXZhciB6ZT1udWxsLEFlPW51bGw7XG5mdW5jdGlvbiBCZShhKXtyZXR1cm4gZnVuY3Rpb24oYil7dHJ5e3JldHVybiBhKGIpfWNhdGNoKGMpe319fWZ1bmN0aW9uIENlKGEpe2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fKXJldHVybiExO3ZhciBiPV9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztpZihiLmlzRGlzYWJsZWR8fCFiLnN1cHBvcnRzRmliZXIpcmV0dXJuITA7dHJ5e3ZhciBjPWIuaW5qZWN0KGEpO3plPUJlKGZ1bmN0aW9uKGEpe3JldHVybiBiLm9uQ29tbWl0RmliZXJSb290KGMsYSl9KTtBZT1CZShmdW5jdGlvbihhKXtyZXR1cm4gYi5vbkNvbW1pdEZpYmVyVW5tb3VudChjLGEpfSl9Y2F0Y2goZCl7fXJldHVybiEwfWZ1bmN0aW9uIERlKGEpe1wiZnVuY3Rpb25cIj09PXR5cGVvZiB6ZSYmemUoYSl9ZnVuY3Rpb24gRWUoYSl7XCJmdW5jdGlvblwiPT09dHlwZW9mIEFlJiZBZShhKX1cbmZ1bmN0aW9uIEZlKGEpe3JldHVybntiYXNlU3RhdGU6YSxleHBpcmF0aW9uVGltZTowLGZpcnN0Om51bGwsbGFzdDpudWxsLGNhbGxiYWNrTGlzdDpudWxsLGhhc0ZvcmNlVXBkYXRlOiExLGlzSW5pdGlhbGl6ZWQ6ITF9fWZ1bmN0aW9uIEdlKGEsYil7bnVsbD09PWEubGFzdD9hLmZpcnN0PWEubGFzdD1iOihhLmxhc3QubmV4dD1iLGEubGFzdD1iKTtpZigwPT09YS5leHBpcmF0aW9uVGltZXx8YS5leHBpcmF0aW9uVGltZT5iLmV4cGlyYXRpb25UaW1lKWEuZXhwaXJhdGlvblRpbWU9Yi5leHBpcmF0aW9uVGltZX1cbmZ1bmN0aW9uIEhlKGEsYil7dmFyIGM9YS5hbHRlcm5hdGUsZD1hLnVwZGF0ZVF1ZXVlO251bGw9PT1kJiYoZD1hLnVwZGF0ZVF1ZXVlPUZlKG51bGwpKTtudWxsIT09Yz8oYT1jLnVwZGF0ZVF1ZXVlLG51bGw9PT1hJiYoYT1jLnVwZGF0ZVF1ZXVlPUZlKG51bGwpKSk6YT1udWxsO2E9YSE9PWQ/YTpudWxsO251bGw9PT1hP0dlKGQsYik6bnVsbD09PWQubGFzdHx8bnVsbD09PWEubGFzdD8oR2UoZCxiKSxHZShhLGIpKTooR2UoZCxiKSxhLmxhc3Q9Yil9ZnVuY3Rpb24gSWUoYSxiLGMsZCl7YT1hLnBhcnRpYWxTdGF0ZTtyZXR1cm5cImZ1bmN0aW9uXCI9PT10eXBlb2YgYT9hLmNhbGwoYixjLGQpOmF9XG5mdW5jdGlvbiBKZShhLGIsYyxkLGUsZil7bnVsbCE9PWEmJmEudXBkYXRlUXVldWU9PT1jJiYoYz1iLnVwZGF0ZVF1ZXVlPXtiYXNlU3RhdGU6Yy5iYXNlU3RhdGUsZXhwaXJhdGlvblRpbWU6Yy5leHBpcmF0aW9uVGltZSxmaXJzdDpjLmZpcnN0LGxhc3Q6Yy5sYXN0LGlzSW5pdGlhbGl6ZWQ6Yy5pc0luaXRpYWxpemVkLGNhbGxiYWNrTGlzdDpudWxsLGhhc0ZvcmNlVXBkYXRlOiExfSk7Yy5leHBpcmF0aW9uVGltZT0wO2MuaXNJbml0aWFsaXplZD9hPWMuYmFzZVN0YXRlOihhPWMuYmFzZVN0YXRlPWIubWVtb2l6ZWRTdGF0ZSxjLmlzSW5pdGlhbGl6ZWQ9ITApO2Zvcih2YXIgZz0hMCxoPWMuZmlyc3Qsaz0hMTtudWxsIT09aDspe3ZhciBxPWguZXhwaXJhdGlvblRpbWU7aWYocT5mKXt2YXIgdj1jLmV4cGlyYXRpb25UaW1lO2lmKDA9PT12fHx2PnEpYy5leHBpcmF0aW9uVGltZT1xO2t8fChrPSEwLGMuYmFzZVN0YXRlPWEpfWVsc2V7a3x8KGMuZmlyc3Q9aC5uZXh0LG51bGw9PT1cbmMuZmlyc3QmJihjLmxhc3Q9bnVsbCkpO2lmKGguaXNSZXBsYWNlKWE9SWUoaCxkLGEsZSksZz0hMDtlbHNlIGlmKHE9SWUoaCxkLGEsZSkpYT1nP0Ioe30sYSxxKTpCKGEscSksZz0hMTtoLmlzRm9yY2VkJiYoYy5oYXNGb3JjZVVwZGF0ZT0hMCk7bnVsbCE9PWguY2FsbGJhY2smJihxPWMuY2FsbGJhY2tMaXN0LG51bGw9PT1xJiYocT1jLmNhbGxiYWNrTGlzdD1bXSkscS5wdXNoKGgpKX1oPWgubmV4dH1udWxsIT09Yy5jYWxsYmFja0xpc3Q/Yi5lZmZlY3RUYWd8PTMyOm51bGwhPT1jLmZpcnN0fHxjLmhhc0ZvcmNlVXBkYXRlfHwoYi51cGRhdGVRdWV1ZT1udWxsKTtrfHwoYy5iYXNlU3RhdGU9YSk7cmV0dXJuIGF9XG5mdW5jdGlvbiBLZShhLGIpe3ZhciBjPWEuY2FsbGJhY2tMaXN0O2lmKG51bGwhPT1jKWZvcihhLmNhbGxiYWNrTGlzdD1udWxsLGE9MDthPGMubGVuZ3RoO2ErKyl7dmFyIGQ9Y1thXSxlPWQuY2FsbGJhY2s7ZC5jYWxsYmFjaz1udWxsO1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBlP0UoXCIxOTFcIixlKTp2b2lkIDA7ZS5jYWxsKGIpfX1cbmZ1bmN0aW9uIExlKGEsYixjLGQpe2Z1bmN0aW9uIGUoYSxiKXtiLnVwZGF0ZXI9ZjthLnN0YXRlTm9kZT1iO2IuX3JlYWN0SW50ZXJuYWxGaWJlcj1hfXZhciBmPXtpc01vdW50ZWQ6bGQsZW5xdWV1ZVNldFN0YXRlOmZ1bmN0aW9uKGMsZCxlKXtjPWMuX3JlYWN0SW50ZXJuYWxGaWJlcjtlPXZvaWQgMD09PWU/bnVsbDplO3ZhciBnPWIoYyk7SGUoYyx7ZXhwaXJhdGlvblRpbWU6ZyxwYXJ0aWFsU3RhdGU6ZCxjYWxsYmFjazplLGlzUmVwbGFjZTohMSxpc0ZvcmNlZDohMSxuZXh0Q2FsbGJhY2s6bnVsbCxuZXh0Om51bGx9KTthKGMsZyl9LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oYyxkLGUpe2M9Yy5fcmVhY3RJbnRlcm5hbEZpYmVyO2U9dm9pZCAwPT09ZT9udWxsOmU7dmFyIGc9YihjKTtIZShjLHtleHBpcmF0aW9uVGltZTpnLHBhcnRpYWxTdGF0ZTpkLGNhbGxiYWNrOmUsaXNSZXBsYWNlOiEwLGlzRm9yY2VkOiExLG5leHRDYWxsYmFjazpudWxsLG5leHQ6bnVsbH0pO1xuYShjLGcpfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oYyxkKXtjPWMuX3JlYWN0SW50ZXJuYWxGaWJlcjtkPXZvaWQgMD09PWQ/bnVsbDpkO3ZhciBlPWIoYyk7SGUoYyx7ZXhwaXJhdGlvblRpbWU6ZSxwYXJ0aWFsU3RhdGU6bnVsbCxjYWxsYmFjazpkLGlzUmVwbGFjZTohMSxpc0ZvcmNlZDohMCxuZXh0Q2FsbGJhY2s6bnVsbCxuZXh0Om51bGx9KTthKGMsZSl9fTtyZXR1cm57YWRvcHRDbGFzc0luc3RhbmNlOmUsY29uc3RydWN0Q2xhc3NJbnN0YW5jZTpmdW5jdGlvbihhLGIpe3ZhciBjPWEudHlwZSxkPWtlKGEpLGY9Mj09PWEudGFnJiZudWxsIT1hLnR5cGUuY29udGV4dFR5cGVzLGc9Zj9tZShhLGQpOkQ7Yj1uZXcgYyhiLGcpO2UoYSxiKTtmJiYoYT1hLnN0YXRlTm9kZSxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9ZCxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0PWcpO3JldHVybiBifSxtb3VudENsYXNzSW5zdGFuY2U6ZnVuY3Rpb24oYSxcbmIpe3ZhciBjPWEuYWx0ZXJuYXRlLGQ9YS5zdGF0ZU5vZGUsZT1kLnN0YXRlfHxudWxsLGc9YS5wZW5kaW5nUHJvcHM7Zz92b2lkIDA6RShcIjE1OFwiKTt2YXIgaD1rZShhKTtkLnByb3BzPWc7ZC5zdGF0ZT1hLm1lbW9pemVkU3RhdGU9ZTtkLnJlZnM9RDtkLmNvbnRleHQ9bWUoYSxoKTtudWxsIT1hLnR5cGUmJm51bGwhPWEudHlwZS5wcm90b3R5cGUmJiEwPT09YS50eXBlLnByb3RvdHlwZS51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQmJihhLmludGVybmFsQ29udGV4dFRhZ3w9MSk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGQuY29tcG9uZW50V2lsbE1vdW50JiYoZT1kLnN0YXRlLGQuY29tcG9uZW50V2lsbE1vdW50KCksZSE9PWQuc3RhdGUmJmYuZW5xdWV1ZVJlcGxhY2VTdGF0ZShkLGQuc3RhdGUsbnVsbCksZT1hLnVwZGF0ZVF1ZXVlLG51bGwhPT1lJiYoZC5zdGF0ZT1KZShjLGEsZSxkLGcsYikpKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5jb21wb25lbnREaWRNb3VudCYmKGEuZWZmZWN0VGFnfD1cbjQpfSx1cGRhdGVDbGFzc0luc3RhbmNlOmZ1bmN0aW9uKGEsYixlKXt2YXIgZz1iLnN0YXRlTm9kZTtnLnByb3BzPWIubWVtb2l6ZWRQcm9wcztnLnN0YXRlPWIubWVtb2l6ZWRTdGF0ZTt2YXIgaD1iLm1lbW9pemVkUHJvcHMsaz1iLnBlbmRpbmdQcm9wcztrfHwoaz1oLG51bGw9PWs/RShcIjE1OVwiKTp2b2lkIDApO3ZhciB1PWcuY29udGV4dCx6PWtlKGIpO3o9bWUoYix6KTtcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzfHxoPT09ayYmdT09PXp8fCh1PWcuc3RhdGUsZy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKGsseiksZy5zdGF0ZSE9PXUmJmYuZW5xdWV1ZVJlcGxhY2VTdGF0ZShnLGcuc3RhdGUsbnVsbCkpO3U9Yi5tZW1vaXplZFN0YXRlO2U9bnVsbCE9PWIudXBkYXRlUXVldWU/SmUoYSxiLGIudXBkYXRlUXVldWUsZyxrLGUpOnU7aWYoIShoIT09a3x8dSE9PWV8fFguY3VycmVudHx8bnVsbCE9PWIudXBkYXRlUXVldWUmJmIudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpKXJldHVyblwiZnVuY3Rpb25cIiE9PVxudHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlfHxoPT09YS5tZW1vaXplZFByb3BzJiZ1PT09YS5tZW1vaXplZFN0YXRlfHwoYi5lZmZlY3RUYWd8PTQpLCExO3ZhciBHPWs7aWYobnVsbD09PWh8fG51bGwhPT1iLnVwZGF0ZVF1ZXVlJiZiLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKUc9ITA7ZWxzZXt2YXIgST1iLnN0YXRlTm9kZSxMPWIudHlwZTtHPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBJLnNob3VsZENvbXBvbmVudFVwZGF0ZT9JLnNob3VsZENvbXBvbmVudFVwZGF0ZShHLGUseik6TC5wcm90b3R5cGUmJkwucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50PyFlYShoLEcpfHwhZWEodSxlKTohMH1HPyhcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnRXaWxsVXBkYXRlJiZnLmNvbXBvbmVudFdpbGxVcGRhdGUoayxlLHopLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudERpZFVwZGF0ZSYmKGIuZWZmZWN0VGFnfD00KSk6KFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudERpZFVwZGF0ZXx8XG5oPT09YS5tZW1vaXplZFByb3BzJiZ1PT09YS5tZW1vaXplZFN0YXRlfHwoYi5lZmZlY3RUYWd8PTQpLGMoYixrKSxkKGIsZSkpO2cucHJvcHM9aztnLnN0YXRlPWU7Zy5jb250ZXh0PXo7cmV0dXJuIEd9fX12YXIgUWU9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sW1wiZm9yXCJdLFJlPVFlP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmVsZW1lbnRcIik6NjAxMDMsU2U9UWU/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuY2FsbFwiKTo2MDEwNCxUZT1RZT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5yZXR1cm5cIik6NjAxMDUsVWU9UWU/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QucG9ydGFsXCIpOjYwMTA2LFZlPVFlP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmZyYWdtZW50XCIpOjYwMTA3LFdlPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcjtcbmZ1bmN0aW9uIFhlKGEpe2lmKG51bGw9PT1hfHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEpcmV0dXJuIG51bGw7YT1XZSYmYVtXZV18fGFbXCJAQGl0ZXJhdG9yXCJdO3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2E6bnVsbH12YXIgWWU9QXJyYXkuaXNBcnJheTtcbmZ1bmN0aW9uIFplKGEsYil7dmFyIGM9Yi5yZWY7aWYobnVsbCE9PWMmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjKXtpZihiLl9vd25lcil7Yj1iLl9vd25lcjt2YXIgZD12b2lkIDA7YiYmKDIhPT1iLnRhZz9FKFwiMTEwXCIpOnZvaWQgMCxkPWIuc3RhdGVOb2RlKTtkP3ZvaWQgMDpFKFwiMTQ3XCIsYyk7dmFyIGU9XCJcIitjO2lmKG51bGwhPT1hJiZudWxsIT09YS5yZWYmJmEucmVmLl9zdHJpbmdSZWY9PT1lKXJldHVybiBhLnJlZjthPWZ1bmN0aW9uKGEpe3ZhciBiPWQucmVmcz09PUQ/ZC5yZWZzPXt9OmQucmVmcztudWxsPT09YT9kZWxldGUgYltlXTpiW2VdPWF9O2EuX3N0cmluZ1JlZj1lO3JldHVybiBhfVwic3RyaW5nXCIhPT10eXBlb2YgYz9FKFwiMTQ4XCIpOnZvaWQgMDtiLl9vd25lcj92b2lkIDA6RShcIjE0OVwiLGMpfXJldHVybiBjfVxuZnVuY3Rpb24gJGUoYSxiKXtcInRleHRhcmVhXCIhPT1hLnR5cGUmJkUoXCIzMVwiLFwiW29iamVjdCBPYmplY3RdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYik/XCJvYmplY3Qgd2l0aCBrZXlzIHtcIitPYmplY3Qua2V5cyhiKS5qb2luKFwiLCBcIikrXCJ9XCI6YixcIlwiKX1cbmZ1bmN0aW9uIGFmKGEpe2Z1bmN0aW9uIGIoYixjKXtpZihhKXt2YXIgZD1iLmxhc3RFZmZlY3Q7bnVsbCE9PWQ/KGQubmV4dEVmZmVjdD1jLGIubGFzdEVmZmVjdD1jKTpiLmZpcnN0RWZmZWN0PWIubGFzdEVmZmVjdD1jO2MubmV4dEVmZmVjdD1udWxsO2MuZWZmZWN0VGFnPTh9fWZ1bmN0aW9uIGMoYyxkKXtpZighYSlyZXR1cm4gbnVsbDtmb3IoO251bGwhPT1kOyliKGMsZCksZD1kLnNpYmxpbmc7cmV0dXJuIG51bGx9ZnVuY3Rpb24gZChhLGIpe2ZvcihhPW5ldyBNYXA7bnVsbCE9PWI7KW51bGwhPT1iLmtleT9hLnNldChiLmtleSxiKTphLnNldChiLmluZGV4LGIpLGI9Yi5zaWJsaW5nO3JldHVybiBhfWZ1bmN0aW9uIGUoYSxiLGMpe2E9c2UoYSxiLGMpO2EuaW5kZXg9MDthLnNpYmxpbmc9bnVsbDtyZXR1cm4gYX1mdW5jdGlvbiBmKGIsYyxkKXtiLmluZGV4PWQ7aWYoIWEpcmV0dXJuIGM7ZD1iLmFsdGVybmF0ZTtpZihudWxsIT09ZClyZXR1cm4gZD1kLmluZGV4LGQ8Yz8oYi5lZmZlY3RUYWc9XG4yLGMpOmQ7Yi5lZmZlY3RUYWc9MjtyZXR1cm4gY31mdW5jdGlvbiBnKGIpe2EmJm51bGw9PT1iLmFsdGVybmF0ZSYmKGIuZWZmZWN0VGFnPTIpO3JldHVybiBifWZ1bmN0aW9uIGgoYSxiLGMsZCl7aWYobnVsbD09PWJ8fDYhPT1iLnRhZylyZXR1cm4gYj12ZShjLGEuaW50ZXJuYWxDb250ZXh0VGFnLGQpLGJbXCJyZXR1cm5cIl09YSxiO2I9ZShiLGMsZCk7YltcInJldHVyblwiXT1hO3JldHVybiBifWZ1bmN0aW9uIGsoYSxiLGMsZCl7aWYobnVsbCE9PWImJmIudHlwZT09PWMudHlwZSlyZXR1cm4gZD1lKGIsYy5wcm9wcyxkKSxkLnJlZj1aZShiLGMpLGRbXCJyZXR1cm5cIl09YSxkO2Q9dGUoYyxhLmludGVybmFsQ29udGV4dFRhZyxkKTtkLnJlZj1aZShiLGMpO2RbXCJyZXR1cm5cIl09YTtyZXR1cm4gZH1mdW5jdGlvbiBxKGEsYixjLGQpe2lmKG51bGw9PT1ifHw3IT09Yi50YWcpcmV0dXJuIGI9d2UoYyxhLmludGVybmFsQ29udGV4dFRhZyxkKSxiW1wicmV0dXJuXCJdPWEsYjtiPWUoYixjLGQpO1xuYltcInJldHVyblwiXT1hO3JldHVybiBifWZ1bmN0aW9uIHYoYSxiLGMsZCl7aWYobnVsbD09PWJ8fDkhPT1iLnRhZylyZXR1cm4gYj14ZShjLGEuaW50ZXJuYWxDb250ZXh0VGFnLGQpLGIudHlwZT1jLnZhbHVlLGJbXCJyZXR1cm5cIl09YSxiO2I9ZShiLG51bGwsZCk7Yi50eXBlPWMudmFsdWU7YltcInJldHVyblwiXT1hO3JldHVybiBifWZ1bmN0aW9uIHkoYSxiLGMsZCl7aWYobnVsbD09PWJ8fDQhPT1iLnRhZ3x8Yi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyE9PWMuY29udGFpbmVySW5mb3x8Yi5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24hPT1jLmltcGxlbWVudGF0aW9uKXJldHVybiBiPXllKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCksYltcInJldHVyblwiXT1hLGI7Yj1lKGIsYy5jaGlsZHJlbnx8W10sZCk7YltcInJldHVyblwiXT1hO3JldHVybiBifWZ1bmN0aW9uIHUoYSxiLGMsZCxmKXtpZihudWxsPT09Ynx8MTAhPT1iLnRhZylyZXR1cm4gYj11ZShjLGEuaW50ZXJuYWxDb250ZXh0VGFnLFxuZCxmKSxiW1wicmV0dXJuXCJdPWEsYjtiPWUoYixjLGQpO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiB6KGEsYixjKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIGJ8fFwibnVtYmVyXCI9PT10eXBlb2YgYilyZXR1cm4gYj12ZShcIlwiK2IsYS5pbnRlcm5hbENvbnRleHRUYWcsYyksYltcInJldHVyblwiXT1hLGI7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBiJiZudWxsIT09Yil7c3dpdGNoKGIuJCR0eXBlb2Ype2Nhc2UgUmU6aWYoYi50eXBlPT09VmUpcmV0dXJuIGI9dWUoYi5wcm9wcy5jaGlsZHJlbixhLmludGVybmFsQ29udGV4dFRhZyxjLGIua2V5KSxiW1wicmV0dXJuXCJdPWEsYjtjPXRlKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsYyk7Yy5yZWY9WmUobnVsbCxiKTtjW1wicmV0dXJuXCJdPWE7cmV0dXJuIGM7Y2FzZSBTZTpyZXR1cm4gYj13ZShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMpLGJbXCJyZXR1cm5cIl09YSxiO2Nhc2UgVGU6cmV0dXJuIGM9eGUoYixhLmludGVybmFsQ29udGV4dFRhZyxcbmMpLGMudHlwZT1iLnZhbHVlLGNbXCJyZXR1cm5cIl09YSxjO2Nhc2UgVWU6cmV0dXJuIGI9eWUoYixhLmludGVybmFsQ29udGV4dFRhZyxjKSxiW1wicmV0dXJuXCJdPWEsYn1pZihZZShiKXx8WGUoYikpcmV0dXJuIGI9dWUoYixhLmludGVybmFsQ29udGV4dFRhZyxjLG51bGwpLGJbXCJyZXR1cm5cIl09YSxiOyRlKGEsYil9cmV0dXJuIG51bGx9ZnVuY3Rpb24gRyhhLGIsYyxkKXt2YXIgZT1udWxsIT09Yj9iLmtleTpudWxsO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgY3x8XCJudW1iZXJcIj09PXR5cGVvZiBjKXJldHVybiBudWxsIT09ZT9udWxsOmgoYSxiLFwiXCIrYyxkKTtpZihcIm9iamVjdFwiPT09dHlwZW9mIGMmJm51bGwhPT1jKXtzd2l0Y2goYy4kJHR5cGVvZil7Y2FzZSBSZTpyZXR1cm4gYy5rZXk9PT1lP2MudHlwZT09PVZlP3UoYSxiLGMucHJvcHMuY2hpbGRyZW4sZCxlKTprKGEsYixjLGQpOm51bGw7Y2FzZSBTZTpyZXR1cm4gYy5rZXk9PT1lP3EoYSxiLGMsZCk6bnVsbDtjYXNlIFRlOnJldHVybiBudWxsPT09XG5lP3YoYSxiLGMsZCk6bnVsbDtjYXNlIFVlOnJldHVybiBjLmtleT09PWU/eShhLGIsYyxkKTpudWxsfWlmKFllKGMpfHxYZShjKSlyZXR1cm4gbnVsbCE9PWU/bnVsbDp1KGEsYixjLGQsbnVsbCk7JGUoYSxjKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBJKGEsYixjLGQsZSl7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBkfHxcIm51bWJlclwiPT09dHlwZW9mIGQpcmV0dXJuIGE9YS5nZXQoYyl8fG51bGwsaChiLGEsXCJcIitkLGUpO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgZCYmbnVsbCE9PWQpe3N3aXRjaChkLiQkdHlwZW9mKXtjYXNlIFJlOnJldHVybiBhPWEuZ2V0KG51bGw9PT1kLmtleT9jOmQua2V5KXx8bnVsbCxkLnR5cGU9PT1WZT91KGIsYSxkLnByb3BzLmNoaWxkcmVuLGUsZC5rZXkpOmsoYixhLGQsZSk7Y2FzZSBTZTpyZXR1cm4gYT1hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwscShiLGEsZCxlKTtjYXNlIFRlOnJldHVybiBhPWEuZ2V0KGMpfHxudWxsLHYoYixhLGQsZSk7Y2FzZSBVZTpyZXR1cm4gYT1cbmEuZ2V0KG51bGw9PT1kLmtleT9jOmQua2V5KXx8bnVsbCx5KGIsYSxkLGUpfWlmKFllKGQpfHxYZShkKSlyZXR1cm4gYT1hLmdldChjKXx8bnVsbCx1KGIsYSxkLGUsbnVsbCk7JGUoYixkKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBMKGUsZyxtLEEpe2Zvcih2YXIgaD1udWxsLHI9bnVsbCxuPWcsdz1nPTAsaz1udWxsO251bGwhPT1uJiZ3PG0ubGVuZ3RoO3crKyl7bi5pbmRleD53PyhrPW4sbj1udWxsKTprPW4uc2libGluZzt2YXIgeD1HKGUsbixtW3ddLEEpO2lmKG51bGw9PT14KXtudWxsPT09biYmKG49ayk7YnJlYWt9YSYmbiYmbnVsbD09PXguYWx0ZXJuYXRlJiZiKGUsbik7Zz1mKHgsZyx3KTtudWxsPT09cj9oPXg6ci5zaWJsaW5nPXg7cj14O249a31pZih3PT09bS5sZW5ndGgpcmV0dXJuIGMoZSxuKSxoO2lmKG51bGw9PT1uKXtmb3IoO3c8bS5sZW5ndGg7dysrKWlmKG49eihlLG1bd10sQSkpZz1mKG4sZyx3KSxudWxsPT09cj9oPW46ci5zaWJsaW5nPW4scj1uO3JldHVybiBofWZvcihuPVxuZChlLG4pO3c8bS5sZW5ndGg7dysrKWlmKGs9SShuLGUsdyxtW3ddLEEpKXtpZihhJiZudWxsIT09ay5hbHRlcm5hdGUpbltcImRlbGV0ZVwiXShudWxsPT09ay5rZXk/dzprLmtleSk7Zz1mKGssZyx3KTtudWxsPT09cj9oPWs6ci5zaWJsaW5nPWs7cj1rfWEmJm4uZm9yRWFjaChmdW5jdGlvbihhKXtyZXR1cm4gYihlLGEpfSk7cmV0dXJuIGh9ZnVuY3Rpb24gTihlLGcsbSxBKXt2YXIgaD1YZShtKTtcImZ1bmN0aW9uXCIhPT10eXBlb2YgaD9FKFwiMTUwXCIpOnZvaWQgMDttPWguY2FsbChtKTtudWxsPT1tP0UoXCIxNTFcIik6dm9pZCAwO2Zvcih2YXIgcj1oPW51bGwsbj1nLHc9Zz0wLGs9bnVsbCx4PW0ubmV4dCgpO251bGwhPT1uJiYheC5kb25lO3crKyx4PW0ubmV4dCgpKXtuLmluZGV4Pnc/KGs9bixuPW51bGwpOms9bi5zaWJsaW5nO3ZhciBKPUcoZSxuLHgudmFsdWUsQSk7aWYobnVsbD09PUope258fChuPWspO2JyZWFrfWEmJm4mJm51bGw9PT1KLmFsdGVybmF0ZSYmYihlLG4pO2c9ZihKLFxuZyx3KTtudWxsPT09cj9oPUo6ci5zaWJsaW5nPUo7cj1KO249a31pZih4LmRvbmUpcmV0dXJuIGMoZSxuKSxoO2lmKG51bGw9PT1uKXtmb3IoOyF4LmRvbmU7dysrLHg9bS5uZXh0KCkpeD16KGUseC52YWx1ZSxBKSxudWxsIT09eCYmKGc9Zih4LGcsdyksbnVsbD09PXI/aD14OnIuc2libGluZz14LHI9eCk7cmV0dXJuIGh9Zm9yKG49ZChlLG4pOyF4LmRvbmU7dysrLHg9bS5uZXh0KCkpaWYoeD1JKG4sZSx3LHgudmFsdWUsQSksbnVsbCE9PXgpe2lmKGEmJm51bGwhPT14LmFsdGVybmF0ZSluW1wiZGVsZXRlXCJdKG51bGw9PT14LmtleT93Ongua2V5KTtnPWYoeCxnLHcpO251bGw9PT1yP2g9eDpyLnNpYmxpbmc9eDtyPXh9YSYmbi5mb3JFYWNoKGZ1bmN0aW9uKGEpe3JldHVybiBiKGUsYSl9KTtyZXR1cm4gaH1yZXR1cm4gZnVuY3Rpb24oYSxkLGYsaCl7XCJvYmplY3RcIj09PXR5cGVvZiBmJiZudWxsIT09ZiYmZi50eXBlPT09VmUmJm51bGw9PT1mLmtleSYmKGY9Zi5wcm9wcy5jaGlsZHJlbik7XG52YXIgbT1cIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mO2lmKG0pc3dpdGNoKGYuJCR0eXBlb2Ype2Nhc2UgUmU6YTp7dmFyIHI9Zi5rZXk7Zm9yKG09ZDtudWxsIT09bTspe2lmKG0ua2V5PT09cilpZigxMD09PW0udGFnP2YudHlwZT09PVZlOm0udHlwZT09PWYudHlwZSl7YyhhLG0uc2libGluZyk7ZD1lKG0sZi50eXBlPT09VmU/Zi5wcm9wcy5jaGlsZHJlbjpmLnByb3BzLGgpO2QucmVmPVplKG0sZik7ZFtcInJldHVyblwiXT1hO2E9ZDticmVhayBhfWVsc2V7YyhhLG0pO2JyZWFrfWVsc2UgYihhLG0pO209bS5zaWJsaW5nfWYudHlwZT09PVZlPyhkPXVlKGYucHJvcHMuY2hpbGRyZW4sYS5pbnRlcm5hbENvbnRleHRUYWcsaCxmLmtleSksZFtcInJldHVyblwiXT1hLGE9ZCk6KGg9dGUoZixhLmludGVybmFsQ29udGV4dFRhZyxoKSxoLnJlZj1aZShkLGYpLGhbXCJyZXR1cm5cIl09YSxhPWgpfXJldHVybiBnKGEpO2Nhc2UgU2U6YTp7Zm9yKG09Zi5rZXk7bnVsbCE9PWQ7KXtpZihkLmtleT09PVxubSlpZig3PT09ZC50YWcpe2MoYSxkLnNpYmxpbmcpO2Q9ZShkLGYsaCk7ZFtcInJldHVyblwiXT1hO2E9ZDticmVhayBhfWVsc2V7YyhhLGQpO2JyZWFrfWVsc2UgYihhLGQpO2Q9ZC5zaWJsaW5nfWQ9d2UoZixhLmludGVybmFsQ29udGV4dFRhZyxoKTtkW1wicmV0dXJuXCJdPWE7YT1kfXJldHVybiBnKGEpO2Nhc2UgVGU6YTp7aWYobnVsbCE9PWQpaWYoOT09PWQudGFnKXtjKGEsZC5zaWJsaW5nKTtkPWUoZCxudWxsLGgpO2QudHlwZT1mLnZhbHVlO2RbXCJyZXR1cm5cIl09YTthPWQ7YnJlYWsgYX1lbHNlIGMoYSxkKTtkPXhlKGYsYS5pbnRlcm5hbENvbnRleHRUYWcsaCk7ZC50eXBlPWYudmFsdWU7ZFtcInJldHVyblwiXT1hO2E9ZH1yZXR1cm4gZyhhKTtjYXNlIFVlOmE6e2ZvcihtPWYua2V5O251bGwhPT1kOyl7aWYoZC5rZXk9PT1tKWlmKDQ9PT1kLnRhZyYmZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbz09PWYuY29udGFpbmVySW5mbyYmZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb249PT1cbmYuaW1wbGVtZW50YXRpb24pe2MoYSxkLnNpYmxpbmcpO2Q9ZShkLGYuY2hpbGRyZW58fFtdLGgpO2RbXCJyZXR1cm5cIl09YTthPWQ7YnJlYWsgYX1lbHNle2MoYSxkKTticmVha31lbHNlIGIoYSxkKTtkPWQuc2libGluZ31kPXllKGYsYS5pbnRlcm5hbENvbnRleHRUYWcsaCk7ZFtcInJldHVyblwiXT1hO2E9ZH1yZXR1cm4gZyhhKX1pZihcInN0cmluZ1wiPT09dHlwZW9mIGZ8fFwibnVtYmVyXCI9PT10eXBlb2YgZilyZXR1cm4gZj1cIlwiK2YsbnVsbCE9PWQmJjY9PT1kLnRhZz8oYyhhLGQuc2libGluZyksZD1lKGQsZixoKSk6KGMoYSxkKSxkPXZlKGYsYS5pbnRlcm5hbENvbnRleHRUYWcsaCkpLGRbXCJyZXR1cm5cIl09YSxhPWQsZyhhKTtpZihZZShmKSlyZXR1cm4gTChhLGQsZixoKTtpZihYZShmKSlyZXR1cm4gTihhLGQsZixoKTttJiYkZShhLGYpO2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgZilzd2l0Y2goYS50YWcpe2Nhc2UgMjpjYXNlIDE6aD1hLnR5cGUsRShcIjE1MlwiLGguZGlzcGxheU5hbWV8fFxuaC5uYW1lfHxcIkNvbXBvbmVudFwiKX1yZXR1cm4gYyhhLGQpfX12YXIgYmY9YWYoITApLGNmPWFmKCExKTtcbmZ1bmN0aW9uIGRmKGEsYixjLGQsZSl7ZnVuY3Rpb24gZihhLGIsYyl7dmFyIGQ9Yi5leHBpcmF0aW9uVGltZTtiLmNoaWxkPW51bGw9PT1hP2NmKGIsbnVsbCxjLGQpOmJmKGIsYS5jaGlsZCxjLGQpfWZ1bmN0aW9uIGcoYSxiKXt2YXIgYz1iLnJlZjtudWxsPT09Y3x8YSYmYS5yZWY9PT1jfHwoYi5lZmZlY3RUYWd8PTEyOCl9ZnVuY3Rpb24gaChhLGIsYyxkKXtnKGEsYik7aWYoIWMpcmV0dXJuIGQmJnJlKGIsITEpLHEoYSxiKTtjPWIuc3RhdGVOb2RlO2lkLmN1cnJlbnQ9Yjt2YXIgZT1jLnJlbmRlcigpO2IuZWZmZWN0VGFnfD0xO2YoYSxiLGUpO2IubWVtb2l6ZWRTdGF0ZT1jLnN0YXRlO2IubWVtb2l6ZWRQcm9wcz1jLnByb3BzO2QmJnJlKGIsITApO3JldHVybiBiLmNoaWxkfWZ1bmN0aW9uIGsoYSl7dmFyIGI9YS5zdGF0ZU5vZGU7Yi5wZW5kaW5nQ29udGV4dD9vZShhLGIucGVuZGluZ0NvbnRleHQsYi5wZW5kaW5nQ29udGV4dCE9PWIuY29udGV4dCk6Yi5jb250ZXh0JiZvZShhLFxuYi5jb250ZXh0LCExKTtJKGEsYi5jb250YWluZXJJbmZvKX1mdW5jdGlvbiBxKGEsYil7bnVsbCE9PWEmJmIuY2hpbGQhPT1hLmNoaWxkP0UoXCIxNTNcIik6dm9pZCAwO2lmKG51bGwhPT1iLmNoaWxkKXthPWIuY2hpbGQ7dmFyIGM9c2UoYSxhLnBlbmRpbmdQcm9wcyxhLmV4cGlyYXRpb25UaW1lKTtiLmNoaWxkPWM7Zm9yKGNbXCJyZXR1cm5cIl09YjtudWxsIT09YS5zaWJsaW5nOylhPWEuc2libGluZyxjPWMuc2libGluZz1zZShhLGEucGVuZGluZ1Byb3BzLGEuZXhwaXJhdGlvblRpbWUpLGNbXCJyZXR1cm5cIl09YjtjLnNpYmxpbmc9bnVsbH1yZXR1cm4gYi5jaGlsZH1mdW5jdGlvbiB2KGEsYil7c3dpdGNoKGIudGFnKXtjYXNlIDM6ayhiKTticmVhaztjYXNlIDI6cWUoYik7YnJlYWs7Y2FzZSA0OkkoYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKX1yZXR1cm4gbnVsbH12YXIgeT1hLnNob3VsZFNldFRleHRDb250ZW50LHU9YS51c2VTeW5jU2NoZWR1bGluZyx6PWEuc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSxcbkc9Yi5wdXNoSG9zdENvbnRleHQsST1iLnB1c2hIb3N0Q29udGFpbmVyLEw9Yy5lbnRlckh5ZHJhdGlvblN0YXRlLE49Yy5yZXNldEh5ZHJhdGlvblN0YXRlLEo9Yy50cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTthPUxlKGQsZSxmdW5jdGlvbihhLGIpe2EubWVtb2l6ZWRQcm9wcz1ifSxmdW5jdGlvbihhLGIpe2EubWVtb2l6ZWRTdGF0ZT1ifSk7dmFyIHc9YS5hZG9wdENsYXNzSW5zdGFuY2UsbT1hLmNvbnN0cnVjdENsYXNzSW5zdGFuY2UsQT1hLm1vdW50Q2xhc3NJbnN0YW5jZSxPYj1hLnVwZGF0ZUNsYXNzSW5zdGFuY2U7cmV0dXJue2JlZ2luV29yazpmdW5jdGlvbihhLGIsYyl7aWYoMD09PWIuZXhwaXJhdGlvblRpbWV8fGIuZXhwaXJhdGlvblRpbWU+YylyZXR1cm4gdihhLGIpO3N3aXRjaChiLnRhZyl7Y2FzZSAwOm51bGwhPT1hP0UoXCIxNTVcIik6dm9pZCAwO3ZhciBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLHI9a2UoYik7cj1tZShiLHIpO2Q9ZChlLHIpO2IuZWZmZWN0VGFnfD1cbjE7XCJvYmplY3RcIj09PXR5cGVvZiBkJiZudWxsIT09ZCYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGQucmVuZGVyPyhiLnRhZz0yLGU9cWUoYiksdyhiLGQpLEEoYixjKSxiPWgoYSxiLCEwLGUpKTooYi50YWc9MSxmKGEsYixkKSxiLm1lbW9pemVkUHJvcHM9ZSxiPWIuY2hpbGQpO3JldHVybiBiO2Nhc2UgMTphOntlPWIudHlwZTtjPWIucGVuZGluZ1Byb3BzO2Q9Yi5tZW1vaXplZFByb3BzO2lmKFguY3VycmVudCludWxsPT09YyYmKGM9ZCk7ZWxzZSBpZihudWxsPT09Y3x8ZD09PWMpe2I9cShhLGIpO2JyZWFrIGF9ZD1rZShiKTtkPW1lKGIsZCk7ZT1lKGMsZCk7Yi5lZmZlY3RUYWd8PTE7ZihhLGIsZSk7Yi5tZW1vaXplZFByb3BzPWM7Yj1iLmNoaWxkfXJldHVybiBiO2Nhc2UgMjpyZXR1cm4gZT1xZShiKSxkPXZvaWQgMCxudWxsPT09YT9iLnN0YXRlTm9kZT9FKFwiMTUzXCIpOihtKGIsYi5wZW5kaW5nUHJvcHMpLEEoYixjKSxkPSEwKTpkPU9iKGEsYixjKSxoKGEsYixkLGUpO2Nhc2UgMzpyZXR1cm4gayhiKSxcbmU9Yi51cGRhdGVRdWV1ZSxudWxsIT09ZT8oZD1iLm1lbW9pemVkU3RhdGUsZT1KZShhLGIsZSxudWxsLG51bGwsYyksZD09PWU/KE4oKSxiPXEoYSxiKSk6KGQ9ZS5lbGVtZW50LHI9Yi5zdGF0ZU5vZGUsKG51bGw9PT1hfHxudWxsPT09YS5jaGlsZCkmJnIuaHlkcmF0ZSYmTChiKT8oYi5lZmZlY3RUYWd8PTIsYi5jaGlsZD1jZihiLG51bGwsZCxjKSk6KE4oKSxmKGEsYixkKSksYi5tZW1vaXplZFN0YXRlPWUsYj1iLmNoaWxkKSk6KE4oKSxiPXEoYSxiKSksYjtjYXNlIDU6RyhiKTtudWxsPT09YSYmSihiKTtlPWIudHlwZTt2YXIgbj1iLm1lbW9pemVkUHJvcHM7ZD1iLnBlbmRpbmdQcm9wcztudWxsPT09ZCYmKGQ9bixudWxsPT09ZD9FKFwiMTU0XCIpOnZvaWQgMCk7cj1udWxsIT09YT9hLm1lbW9pemVkUHJvcHM6bnVsbDtYLmN1cnJlbnR8fG51bGwhPT1kJiZuIT09ZD8obj1kLmNoaWxkcmVuLHkoZSxkKT9uPW51bGw6ciYmeShlLHIpJiYoYi5lZmZlY3RUYWd8PTE2KSxnKGEsYiksXG4yMTQ3NDgzNjQ3IT09YyYmIXUmJnooZSxkKT8oYi5leHBpcmF0aW9uVGltZT0yMTQ3NDgzNjQ3LGI9bnVsbCk6KGYoYSxiLG4pLGIubWVtb2l6ZWRQcm9wcz1kLGI9Yi5jaGlsZCkpOmI9cShhLGIpO3JldHVybiBiO2Nhc2UgNjpyZXR1cm4gbnVsbD09PWEmJkooYiksYT1iLnBlbmRpbmdQcm9wcyxudWxsPT09YSYmKGE9Yi5tZW1vaXplZFByb3BzKSxiLm1lbW9pemVkUHJvcHM9YSxudWxsO2Nhc2UgODpiLnRhZz03O2Nhc2UgNzplPWIucGVuZGluZ1Byb3BzO2lmKFguY3VycmVudCludWxsPT09ZSYmKGU9YSYmYS5tZW1vaXplZFByb3BzLG51bGw9PT1lP0UoXCIxNTRcIik6dm9pZCAwKTtlbHNlIGlmKG51bGw9PT1lfHxiLm1lbW9pemVkUHJvcHM9PT1lKWU9Yi5tZW1vaXplZFByb3BzO2Q9ZS5jaGlsZHJlbjtiLnN0YXRlTm9kZT1udWxsPT09YT9jZihiLGIuc3RhdGVOb2RlLGQsYyk6YmYoYixiLnN0YXRlTm9kZSxkLGMpO2IubWVtb2l6ZWRQcm9wcz1lO3JldHVybiBiLnN0YXRlTm9kZTtcbmNhc2UgOTpyZXR1cm4gbnVsbDtjYXNlIDQ6YTp7SShiLGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO2U9Yi5wZW5kaW5nUHJvcHM7aWYoWC5jdXJyZW50KW51bGw9PT1lJiYoZT1hJiZhLm1lbW9pemVkUHJvcHMsbnVsbD09ZT9FKFwiMTU0XCIpOnZvaWQgMCk7ZWxzZSBpZihudWxsPT09ZXx8Yi5tZW1vaXplZFByb3BzPT09ZSl7Yj1xKGEsYik7YnJlYWsgYX1udWxsPT09YT9iLmNoaWxkPWJmKGIsbnVsbCxlLGMpOmYoYSxiLGUpO2IubWVtb2l6ZWRQcm9wcz1lO2I9Yi5jaGlsZH1yZXR1cm4gYjtjYXNlIDEwOmE6e2M9Yi5wZW5kaW5nUHJvcHM7aWYoWC5jdXJyZW50KW51bGw9PT1jJiYoYz1iLm1lbW9pemVkUHJvcHMpO2Vsc2UgaWYobnVsbD09PWN8fGIubWVtb2l6ZWRQcm9wcz09PWMpe2I9cShhLGIpO2JyZWFrIGF9ZihhLGIsYyk7Yi5tZW1vaXplZFByb3BzPWM7Yj1iLmNoaWxkfXJldHVybiBiO2RlZmF1bHQ6RShcIjE1NlwiKX19LGJlZ2luRmFpbGVkV29yazpmdW5jdGlvbihhLGIsXG5jKXtzd2l0Y2goYi50YWcpe2Nhc2UgMjpxZShiKTticmVhaztjYXNlIDM6ayhiKTticmVhaztkZWZhdWx0OkUoXCIxNTdcIil9Yi5lZmZlY3RUYWd8PTY0O251bGw9PT1hP2IuY2hpbGQ9bnVsbDpiLmNoaWxkIT09YS5jaGlsZCYmKGIuY2hpbGQ9YS5jaGlsZCk7aWYoMD09PWIuZXhwaXJhdGlvblRpbWV8fGIuZXhwaXJhdGlvblRpbWU+YylyZXR1cm4gdihhLGIpO2IuZmlyc3RFZmZlY3Q9bnVsbDtiLmxhc3RFZmZlY3Q9bnVsbDtiLmNoaWxkPW51bGw9PT1hP2NmKGIsbnVsbCxudWxsLGMpOmJmKGIsYS5jaGlsZCxudWxsLGMpOzI9PT1iLnRhZyYmKGE9Yi5zdGF0ZU5vZGUsYi5tZW1vaXplZFByb3BzPWEucHJvcHMsYi5tZW1vaXplZFN0YXRlPWEuc3RhdGUpO3JldHVybiBiLmNoaWxkfX19XG5mdW5jdGlvbiBlZihhLGIsYyl7ZnVuY3Rpb24gZChhKXthLmVmZmVjdFRhZ3w9NH12YXIgZT1hLmNyZWF0ZUluc3RhbmNlLGY9YS5jcmVhdGVUZXh0SW5zdGFuY2UsZz1hLmFwcGVuZEluaXRpYWxDaGlsZCxoPWEuZmluYWxpemVJbml0aWFsQ2hpbGRyZW4saz1hLnByZXBhcmVVcGRhdGUscT1hLnBlcnNpc3RlbmNlLHY9Yi5nZXRSb290SG9zdENvbnRhaW5lcix5PWIucG9wSG9zdENvbnRleHQsdT1iLmdldEhvc3RDb250ZXh0LHo9Yi5wb3BIb3N0Q29udGFpbmVyLEc9Yy5wcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlLEk9Yy5wcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSxMPWMucG9wSHlkcmF0aW9uU3RhdGUsTj12b2lkIDAsSj12b2lkIDAsdz12b2lkIDA7YS5tdXRhdGlvbj8oTj1mdW5jdGlvbigpe30sSj1mdW5jdGlvbihhLGIsYyl7KGIudXBkYXRlUXVldWU9YykmJmQoYil9LHc9ZnVuY3Rpb24oYSxiLGMsZSl7YyE9PWUmJmQoYil9KTpxP0UoXCIyMzVcIik6RShcIjIzNlwiKTtcbnJldHVybntjb21wbGV0ZVdvcms6ZnVuY3Rpb24oYSxiLGMpe3ZhciBtPWIucGVuZGluZ1Byb3BzO2lmKG51bGw9PT1tKW09Yi5tZW1vaXplZFByb3BzO2Vsc2UgaWYoMjE0NzQ4MzY0NyE9PWIuZXhwaXJhdGlvblRpbWV8fDIxNDc0ODM2NDc9PT1jKWIucGVuZGluZ1Byb3BzPW51bGw7c3dpdGNoKGIudGFnKXtjYXNlIDE6cmV0dXJuIG51bGw7Y2FzZSAyOnJldHVybiBuZShiKSxudWxsO2Nhc2UgMzp6KGIpO1YoWCxiKTtWKGllLGIpO209Yi5zdGF0ZU5vZGU7bS5wZW5kaW5nQ29udGV4dCYmKG0uY29udGV4dD1tLnBlbmRpbmdDb250ZXh0LG0ucGVuZGluZ0NvbnRleHQ9bnVsbCk7aWYobnVsbD09PWF8fG51bGw9PT1hLmNoaWxkKUwoYiksYi5lZmZlY3RUYWcmPS0zO04oYik7cmV0dXJuIG51bGw7Y2FzZSA1OnkoYik7Yz12KCk7dmFyIEE9Yi50eXBlO2lmKG51bGwhPT1hJiZudWxsIT1iLnN0YXRlTm9kZSl7dmFyIHA9YS5tZW1vaXplZFByb3BzLHE9Yi5zdGF0ZU5vZGUseD11KCk7cT1cbmsocSxBLHAsbSxjLHgpO0ooYSxiLHEsQSxwLG0sYyk7YS5yZWYhPT1iLnJlZiYmKGIuZWZmZWN0VGFnfD0xMjgpfWVsc2V7aWYoIW0pcmV0dXJuIG51bGw9PT1iLnN0YXRlTm9kZT9FKFwiMTY2XCIpOnZvaWQgMCxudWxsO2E9dSgpO2lmKEwoYikpRyhiLGMsYSkmJmQoYik7ZWxzZXthPWUoQSxtLGMsYSxiKTthOmZvcihwPWIuY2hpbGQ7bnVsbCE9PXA7KXtpZig1PT09cC50YWd8fDY9PT1wLnRhZylnKGEscC5zdGF0ZU5vZGUpO2Vsc2UgaWYoNCE9PXAudGFnJiZudWxsIT09cC5jaGlsZCl7cC5jaGlsZFtcInJldHVyblwiXT1wO3A9cC5jaGlsZDtjb250aW51ZX1pZihwPT09YilicmVhaztmb3IoO251bGw9PT1wLnNpYmxpbmc7KXtpZihudWxsPT09cFtcInJldHVyblwiXXx8cFtcInJldHVyblwiXT09PWIpYnJlYWsgYTtwPXBbXCJyZXR1cm5cIl19cC5zaWJsaW5nW1wicmV0dXJuXCJdPXBbXCJyZXR1cm5cIl07cD1wLnNpYmxpbmd9aChhLEEsbSxjKSYmZChiKTtiLnN0YXRlTm9kZT1hfW51bGwhPT1iLnJlZiYmXG4oYi5lZmZlY3RUYWd8PTEyOCl9cmV0dXJuIG51bGw7Y2FzZSA2OmlmKGEmJm51bGwhPWIuc3RhdGVOb2RlKXcoYSxiLGEubWVtb2l6ZWRQcm9wcyxtKTtlbHNle2lmKFwic3RyaW5nXCIhPT10eXBlb2YgbSlyZXR1cm4gbnVsbD09PWIuc3RhdGVOb2RlP0UoXCIxNjZcIik6dm9pZCAwLG51bGw7YT12KCk7Yz11KCk7TChiKT9JKGIpJiZkKGIpOmIuc3RhdGVOb2RlPWYobSxhLGMsYil9cmV0dXJuIG51bGw7Y2FzZSA3OihtPWIubWVtb2l6ZWRQcm9wcyk/dm9pZCAwOkUoXCIxNjVcIik7Yi50YWc9ODtBPVtdO2E6Zm9yKChwPWIuc3RhdGVOb2RlKSYmKHBbXCJyZXR1cm5cIl09Yik7bnVsbCE9PXA7KXtpZig1PT09cC50YWd8fDY9PT1wLnRhZ3x8ND09PXAudGFnKUUoXCIyNDdcIik7ZWxzZSBpZig5PT09cC50YWcpQS5wdXNoKHAudHlwZSk7ZWxzZSBpZihudWxsIT09cC5jaGlsZCl7cC5jaGlsZFtcInJldHVyblwiXT1wO3A9cC5jaGlsZDtjb250aW51ZX1mb3IoO251bGw9PT1wLnNpYmxpbmc7KXtpZihudWxsPT09XG5wW1wicmV0dXJuXCJdfHxwW1wicmV0dXJuXCJdPT09YilicmVhayBhO3A9cFtcInJldHVyblwiXX1wLnNpYmxpbmdbXCJyZXR1cm5cIl09cFtcInJldHVyblwiXTtwPXAuc2libGluZ31wPW0uaGFuZGxlcjttPXAobS5wcm9wcyxBKTtiLmNoaWxkPWJmKGIsbnVsbCE9PWE/YS5jaGlsZDpudWxsLG0sYyk7cmV0dXJuIGIuY2hpbGQ7Y2FzZSA4OnJldHVybiBiLnRhZz03LG51bGw7Y2FzZSA5OnJldHVybiBudWxsO2Nhc2UgMTA6cmV0dXJuIG51bGw7Y2FzZSA0OnJldHVybiB6KGIpLE4oYiksbnVsbDtjYXNlIDA6RShcIjE2N1wiKTtkZWZhdWx0OkUoXCIxNTZcIil9fX19XG5mdW5jdGlvbiBmZihhLGIpe2Z1bmN0aW9uIGMoYSl7dmFyIGM9YS5yZWY7aWYobnVsbCE9PWMpdHJ5e2MobnVsbCl9Y2F0Y2goQSl7YihhLEEpfX1mdW5jdGlvbiBkKGEpe1wiZnVuY3Rpb25cIj09PXR5cGVvZiBFZSYmRWUoYSk7c3dpdGNoKGEudGFnKXtjYXNlIDI6YyhhKTt2YXIgZD1hLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5jb21wb25lbnRXaWxsVW5tb3VudCl0cnl7ZC5wcm9wcz1hLm1lbW9pemVkUHJvcHMsZC5zdGF0ZT1hLm1lbW9pemVkU3RhdGUsZC5jb21wb25lbnRXaWxsVW5tb3VudCgpfWNhdGNoKEEpe2IoYSxBKX1icmVhaztjYXNlIDU6YyhhKTticmVhaztjYXNlIDc6ZShhLnN0YXRlTm9kZSk7YnJlYWs7Y2FzZSA0OmsmJmcoYSl9fWZ1bmN0aW9uIGUoYSl7Zm9yKHZhciBiPWE7OylpZihkKGIpLG51bGw9PT1iLmNoaWxkfHxrJiY0PT09Yi50YWcpe2lmKGI9PT1hKWJyZWFrO2Zvcig7bnVsbD09PWIuc2libGluZzspe2lmKG51bGw9PT1iW1wicmV0dXJuXCJdfHxcbmJbXCJyZXR1cm5cIl09PT1hKXJldHVybjtiPWJbXCJyZXR1cm5cIl19Yi5zaWJsaW5nW1wicmV0dXJuXCJdPWJbXCJyZXR1cm5cIl07Yj1iLnNpYmxpbmd9ZWxzZSBiLmNoaWxkW1wicmV0dXJuXCJdPWIsYj1iLmNoaWxkfWZ1bmN0aW9uIGYoYSl7cmV0dXJuIDU9PT1hLnRhZ3x8Mz09PWEudGFnfHw0PT09YS50YWd9ZnVuY3Rpb24gZyhhKXtmb3IodmFyIGI9YSxjPSExLGY9dm9pZCAwLGc9dm9pZCAwOzspe2lmKCFjKXtjPWJbXCJyZXR1cm5cIl07YTpmb3IoOzspe251bGw9PT1jP0UoXCIxNjBcIik6dm9pZCAwO3N3aXRjaChjLnRhZyl7Y2FzZSA1OmY9Yy5zdGF0ZU5vZGU7Zz0hMTticmVhayBhO2Nhc2UgMzpmPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87Zz0hMDticmVhayBhO2Nhc2UgNDpmPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87Zz0hMDticmVhayBhfWM9Y1tcInJldHVyblwiXX1jPSEwfWlmKDU9PT1iLnRhZ3x8Nj09PWIudGFnKWUoYiksZz9KKGYsYi5zdGF0ZU5vZGUpOk4oZixiLnN0YXRlTm9kZSk7XG5lbHNlIGlmKDQ9PT1iLnRhZz9mPWIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm86ZChiKSxudWxsIT09Yi5jaGlsZCl7Yi5jaGlsZFtcInJldHVyblwiXT1iO2I9Yi5jaGlsZDtjb250aW51ZX1pZihiPT09YSlicmVhaztmb3IoO251bGw9PT1iLnNpYmxpbmc7KXtpZihudWxsPT09YltcInJldHVyblwiXXx8YltcInJldHVyblwiXT09PWEpcmV0dXJuO2I9YltcInJldHVyblwiXTs0PT09Yi50YWcmJihjPSExKX1iLnNpYmxpbmdbXCJyZXR1cm5cIl09YltcInJldHVyblwiXTtiPWIuc2libGluZ319dmFyIGg9YS5nZXRQdWJsaWNJbnN0YW5jZSxrPWEubXV0YXRpb247YT1hLnBlcnNpc3RlbmNlO2t8fChhP0UoXCIyMzVcIik6RShcIjIzNlwiKSk7dmFyIHE9ay5jb21taXRNb3VudCx2PWsuY29tbWl0VXBkYXRlLHk9ay5yZXNldFRleHRDb250ZW50LHU9ay5jb21taXRUZXh0VXBkYXRlLHo9ay5hcHBlbmRDaGlsZCxHPWsuYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcixJPWsuaW5zZXJ0QmVmb3JlLEw9ay5pbnNlcnRJbkNvbnRhaW5lckJlZm9yZSxcbk49ay5yZW1vdmVDaGlsZCxKPWsucmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyO3JldHVybntjb21taXRSZXNldFRleHRDb250ZW50OmZ1bmN0aW9uKGEpe3koYS5zdGF0ZU5vZGUpfSxjb21taXRQbGFjZW1lbnQ6ZnVuY3Rpb24oYSl7YTp7Zm9yKHZhciBiPWFbXCJyZXR1cm5cIl07bnVsbCE9PWI7KXtpZihmKGIpKXt2YXIgYz1iO2JyZWFrIGF9Yj1iW1wicmV0dXJuXCJdfUUoXCIxNjBcIik7Yz12b2lkIDB9dmFyIGQ9Yj12b2lkIDA7c3dpdGNoKGMudGFnKXtjYXNlIDU6Yj1jLnN0YXRlTm9kZTtkPSExO2JyZWFrO2Nhc2UgMzpiPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87ZD0hMDticmVhaztjYXNlIDQ6Yj1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2Q9ITA7YnJlYWs7ZGVmYXVsdDpFKFwiMTYxXCIpfWMuZWZmZWN0VGFnJjE2JiYoeShiKSxjLmVmZmVjdFRhZyY9LTE3KTthOmI6Zm9yKGM9YTs7KXtmb3IoO251bGw9PT1jLnNpYmxpbmc7KXtpZihudWxsPT09Y1tcInJldHVyblwiXXx8ZihjW1wicmV0dXJuXCJdKSl7Yz1cbm51bGw7YnJlYWsgYX1jPWNbXCJyZXR1cm5cIl19Yy5zaWJsaW5nW1wicmV0dXJuXCJdPWNbXCJyZXR1cm5cIl07Zm9yKGM9Yy5zaWJsaW5nOzUhPT1jLnRhZyYmNiE9PWMudGFnOyl7aWYoYy5lZmZlY3RUYWcmMiljb250aW51ZSBiO2lmKG51bGw9PT1jLmNoaWxkfHw0PT09Yy50YWcpY29udGludWUgYjtlbHNlIGMuY2hpbGRbXCJyZXR1cm5cIl09YyxjPWMuY2hpbGR9aWYoIShjLmVmZmVjdFRhZyYyKSl7Yz1jLnN0YXRlTm9kZTticmVhayBhfX1mb3IodmFyIGU9YTs7KXtpZig1PT09ZS50YWd8fDY9PT1lLnRhZyljP2Q/TChiLGUuc3RhdGVOb2RlLGMpOkkoYixlLnN0YXRlTm9kZSxjKTpkP0coYixlLnN0YXRlTm9kZSk6eihiLGUuc3RhdGVOb2RlKTtlbHNlIGlmKDQhPT1lLnRhZyYmbnVsbCE9PWUuY2hpbGQpe2UuY2hpbGRbXCJyZXR1cm5cIl09ZTtlPWUuY2hpbGQ7Y29udGludWV9aWYoZT09PWEpYnJlYWs7Zm9yKDtudWxsPT09ZS5zaWJsaW5nOyl7aWYobnVsbD09PWVbXCJyZXR1cm5cIl18fGVbXCJyZXR1cm5cIl09PT1cbmEpcmV0dXJuO2U9ZVtcInJldHVyblwiXX1lLnNpYmxpbmdbXCJyZXR1cm5cIl09ZVtcInJldHVyblwiXTtlPWUuc2libGluZ319LGNvbW1pdERlbGV0aW9uOmZ1bmN0aW9uKGEpe2coYSk7YVtcInJldHVyblwiXT1udWxsO2EuY2hpbGQ9bnVsbDthLmFsdGVybmF0ZSYmKGEuYWx0ZXJuYXRlLmNoaWxkPW51bGwsYS5hbHRlcm5hdGVbXCJyZXR1cm5cIl09bnVsbCl9LGNvbW1pdFdvcms6ZnVuY3Rpb24oYSxiKXtzd2l0Y2goYi50YWcpe2Nhc2UgMjpicmVhaztjYXNlIDU6dmFyIGM9Yi5zdGF0ZU5vZGU7aWYobnVsbCE9Yyl7dmFyIGQ9Yi5tZW1vaXplZFByb3BzO2E9bnVsbCE9PWE/YS5tZW1vaXplZFByb3BzOmQ7dmFyIGU9Yi50eXBlLGY9Yi51cGRhdGVRdWV1ZTtiLnVwZGF0ZVF1ZXVlPW51bGw7bnVsbCE9PWYmJnYoYyxmLGUsYSxkLGIpfWJyZWFrO2Nhc2UgNjpudWxsPT09Yi5zdGF0ZU5vZGU/RShcIjE2MlwiKTp2b2lkIDA7Yz1iLm1lbW9pemVkUHJvcHM7dShiLnN0YXRlTm9kZSxudWxsIT09YT9hLm1lbW9pemVkUHJvcHM6XG5jLGMpO2JyZWFrO2Nhc2UgMzpicmVhaztkZWZhdWx0OkUoXCIxNjNcIil9fSxjb21taXRMaWZlQ3ljbGVzOmZ1bmN0aW9uKGEsYil7c3dpdGNoKGIudGFnKXtjYXNlIDI6dmFyIGM9Yi5zdGF0ZU5vZGU7aWYoYi5lZmZlY3RUYWcmNClpZihudWxsPT09YSljLnByb3BzPWIubWVtb2l6ZWRQcm9wcyxjLnN0YXRlPWIubWVtb2l6ZWRTdGF0ZSxjLmNvbXBvbmVudERpZE1vdW50KCk7ZWxzZXt2YXIgZD1hLm1lbW9pemVkUHJvcHM7YT1hLm1lbW9pemVkU3RhdGU7Yy5wcm9wcz1iLm1lbW9pemVkUHJvcHM7Yy5zdGF0ZT1iLm1lbW9pemVkU3RhdGU7Yy5jb21wb25lbnREaWRVcGRhdGUoZCxhKX1iPWIudXBkYXRlUXVldWU7bnVsbCE9PWImJktlKGIsYyk7YnJlYWs7Y2FzZSAzOmM9Yi51cGRhdGVRdWV1ZTtudWxsIT09YyYmS2UoYyxudWxsIT09Yi5jaGlsZD9iLmNoaWxkLnN0YXRlTm9kZTpudWxsKTticmVhaztjYXNlIDU6Yz1iLnN0YXRlTm9kZTtudWxsPT09YSYmYi5lZmZlY3RUYWcmNCYmcShjLFxuYi50eXBlLGIubWVtb2l6ZWRQcm9wcyxiKTticmVhaztjYXNlIDY6YnJlYWs7Y2FzZSA0OmJyZWFrO2RlZmF1bHQ6RShcIjE2M1wiKX19LGNvbW1pdEF0dGFjaFJlZjpmdW5jdGlvbihhKXt2YXIgYj1hLnJlZjtpZihudWxsIT09Yil7dmFyIGM9YS5zdGF0ZU5vZGU7c3dpdGNoKGEudGFnKXtjYXNlIDU6YihoKGMpKTticmVhaztkZWZhdWx0OmIoYyl9fX0sY29tbWl0RGV0YWNoUmVmOmZ1bmN0aW9uKGEpe2E9YS5yZWY7bnVsbCE9PWEmJmEobnVsbCl9fX12YXIgZ2Y9e307XG5mdW5jdGlvbiBoZihhKXtmdW5jdGlvbiBiKGEpe2E9PT1nZj9FKFwiMTc0XCIpOnZvaWQgMDtyZXR1cm4gYX12YXIgYz1hLmdldENoaWxkSG9zdENvbnRleHQsZD1hLmdldFJvb3RIb3N0Q29udGV4dCxlPXtjdXJyZW50OmdmfSxmPXtjdXJyZW50OmdmfSxnPXtjdXJyZW50OmdmfTtyZXR1cm57Z2V0SG9zdENvbnRleHQ6ZnVuY3Rpb24oKXtyZXR1cm4gYihlLmN1cnJlbnQpfSxnZXRSb290SG9zdENvbnRhaW5lcjpmdW5jdGlvbigpe3JldHVybiBiKGcuY3VycmVudCl9LHBvcEhvc3RDb250YWluZXI6ZnVuY3Rpb24oYSl7VihlLGEpO1YoZixhKTtWKGcsYSl9LHBvcEhvc3RDb250ZXh0OmZ1bmN0aW9uKGEpe2YuY3VycmVudD09PWEmJihWKGUsYSksVihmLGEpKX0scHVzaEhvc3RDb250YWluZXI6ZnVuY3Rpb24oYSxiKXtXKGcsYixhKTtiPWQoYik7VyhmLGEsYSk7VyhlLGIsYSl9LHB1c2hIb3N0Q29udGV4dDpmdW5jdGlvbihhKXt2YXIgZD1iKGcuY3VycmVudCksaD1iKGUuY3VycmVudCk7XG5kPWMoaCxhLnR5cGUsZCk7aCE9PWQmJihXKGYsYSxhKSxXKGUsZCxhKSl9LHJlc2V0SG9zdENvbnRhaW5lcjpmdW5jdGlvbigpe2UuY3VycmVudD1nZjtnLmN1cnJlbnQ9Z2Z9fX1cbmZ1bmN0aW9uIGpmKGEpe2Z1bmN0aW9uIGIoYSxiKXt2YXIgYz1uZXcgWSg1LG51bGwsMCk7Yy50eXBlPVwiREVMRVRFRFwiO2Muc3RhdGVOb2RlPWI7Y1tcInJldHVyblwiXT1hO2MuZWZmZWN0VGFnPTg7bnVsbCE9PWEubGFzdEVmZmVjdD8oYS5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YyxhLmxhc3RFZmZlY3Q9Yyk6YS5maXJzdEVmZmVjdD1hLmxhc3RFZmZlY3Q9Y31mdW5jdGlvbiBjKGEsYil7c3dpdGNoKGEudGFnKXtjYXNlIDU6cmV0dXJuIGI9ZihiLGEudHlwZSxhLnBlbmRpbmdQcm9wcyksbnVsbCE9PWI/KGEuc3RhdGVOb2RlPWIsITApOiExO2Nhc2UgNjpyZXR1cm4gYj1nKGIsYS5wZW5kaW5nUHJvcHMpLG51bGwhPT1iPyhhLnN0YXRlTm9kZT1iLCEwKTohMTtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBkKGEpe2ZvcihhPWFbXCJyZXR1cm5cIl07bnVsbCE9PWEmJjUhPT1hLnRhZyYmMyE9PWEudGFnOylhPWFbXCJyZXR1cm5cIl07eT1hfXZhciBlPWEuc2hvdWxkU2V0VGV4dENvbnRlbnQ7XG5hPWEuaHlkcmF0aW9uO2lmKCFhKXJldHVybntlbnRlckh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuITF9LHJlc2V0SHlkcmF0aW9uU3RhdGU6ZnVuY3Rpb24oKXt9LHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlOmZ1bmN0aW9uKCl7fSxwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlOmZ1bmN0aW9uKCl7RShcIjE3NVwiKX0scHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oKXtFKFwiMTc2XCIpfSxwb3BIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbigpe3JldHVybiExfX07dmFyIGY9YS5jYW5IeWRyYXRlSW5zdGFuY2UsZz1hLmNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UsaD1hLmdldE5leHRIeWRyYXRhYmxlU2libGluZyxrPWEuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQscT1hLmh5ZHJhdGVJbnN0YW5jZSx2PWEuaHlkcmF0ZVRleHRJbnN0YW5jZSx5PW51bGwsdT1udWxsLHo9ITE7cmV0dXJue2VudGVySHlkcmF0aW9uU3RhdGU6ZnVuY3Rpb24oYSl7dT1cbmsoYS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7eT1hO3JldHVybiB6PSEwfSxyZXNldEh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKCl7dT15PW51bGw7ej0hMX0sdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6ZnVuY3Rpb24oYSl7aWYoeil7dmFyIGQ9dTtpZihkKXtpZighYyhhLGQpKXtkPWgoZCk7aWYoIWR8fCFjKGEsZCkpe2EuZWZmZWN0VGFnfD0yO3o9ITE7eT1hO3JldHVybn1iKHksdSl9eT1hO3U9ayhkKX1lbHNlIGEuZWZmZWN0VGFnfD0yLHo9ITEseT1hfX0scHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTpmdW5jdGlvbihhLGIsYyl7Yj1xKGEuc3RhdGVOb2RlLGEudHlwZSxhLm1lbW9pemVkUHJvcHMsYixjLGEpO2EudXBkYXRlUXVldWU9YjtyZXR1cm4gbnVsbCE9PWI/ITA6ITF9LHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlOmZ1bmN0aW9uKGEpe3JldHVybiB2KGEuc3RhdGVOb2RlLGEubWVtb2l6ZWRQcm9wcyxhKX0scG9wSHlkcmF0aW9uU3RhdGU6ZnVuY3Rpb24oYSl7aWYoYSE9PVxueSlyZXR1cm4hMTtpZigheilyZXR1cm4gZChhKSx6PSEwLCExO3ZhciBjPWEudHlwZTtpZig1IT09YS50YWd8fFwiaGVhZFwiIT09YyYmXCJib2R5XCIhPT1jJiYhZShjLGEubWVtb2l6ZWRQcm9wcykpZm9yKGM9dTtjOyliKGEsYyksYz1oKGMpO2QoYSk7dT15P2goYS5zdGF0ZU5vZGUpOm51bGw7cmV0dXJuITB9fX1cbmZ1bmN0aW9uIGtmKGEpe2Z1bmN0aW9uIGIoYSl7UWI9amE9ITA7dmFyIGI9YS5zdGF0ZU5vZGU7Yi5jdXJyZW50PT09YT9FKFwiMTc3XCIpOnZvaWQgMDtiLmlzUmVhZHlGb3JDb21taXQ9ITE7aWQuY3VycmVudD1udWxsO2lmKDE8YS5lZmZlY3RUYWcpaWYobnVsbCE9PWEubGFzdEVmZmVjdCl7YS5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YTt2YXIgYz1hLmZpcnN0RWZmZWN0fWVsc2UgYz1hO2Vsc2UgYz1hLmZpcnN0RWZmZWN0O3lnKCk7Zm9yKHQ9YztudWxsIT09dDspe3ZhciBkPSExLGU9dm9pZCAwO3RyeXtmb3IoO251bGwhPT10Oyl7dmFyIGY9dC5lZmZlY3RUYWc7ZiYxNiYmemcodCk7aWYoZiYxMjgpe3ZhciBnPXQuYWx0ZXJuYXRlO251bGwhPT1nJiZBZyhnKX1zd2l0Y2goZiYtMjQyKXtjYXNlIDI6TmUodCk7dC5lZmZlY3RUYWcmPS0zO2JyZWFrO2Nhc2UgNjpOZSh0KTt0LmVmZmVjdFRhZyY9LTM7T2UodC5hbHRlcm5hdGUsdCk7YnJlYWs7Y2FzZSA0Ok9lKHQuYWx0ZXJuYXRlLFxudCk7YnJlYWs7Y2FzZSA4OlNjPSEwLEJnKHQpLFNjPSExfXQ9dC5uZXh0RWZmZWN0fX1jYXRjaChUYyl7ZD0hMCxlPVRjfWQmJihudWxsPT09dD9FKFwiMTc4XCIpOnZvaWQgMCxoKHQsZSksbnVsbCE9PXQmJih0PXQubmV4dEVmZmVjdCkpfUNnKCk7Yi5jdXJyZW50PWE7Zm9yKHQ9YztudWxsIT09dDspe2M9ITE7ZD12b2lkIDA7dHJ5e2Zvcig7bnVsbCE9PXQ7KXt2YXIgaz10LmVmZmVjdFRhZztrJjM2JiZEZyh0LmFsdGVybmF0ZSx0KTtrJjEyOCYmRWcodCk7aWYoayY2NClzd2l0Y2goZT10LGY9dm9pZCAwLG51bGwhPT1SJiYoZj1SLmdldChlKSxSW1wiZGVsZXRlXCJdKGUpLG51bGw9PWYmJm51bGwhPT1lLmFsdGVybmF0ZSYmKGU9ZS5hbHRlcm5hdGUsZj1SLmdldChlKSxSW1wiZGVsZXRlXCJdKGUpKSksbnVsbD09Zj9FKFwiMTg0XCIpOnZvaWQgMCxlLnRhZyl7Y2FzZSAyOmUuc3RhdGVOb2RlLmNvbXBvbmVudERpZENhdGNoKGYuZXJyb3Ise2NvbXBvbmVudFN0YWNrOmYuY29tcG9uZW50U3RhY2t9KTtcbmJyZWFrO2Nhc2UgMzpudWxsPT09Y2EmJihjYT1mLmVycm9yKTticmVhaztkZWZhdWx0OkUoXCIxNTdcIil9dmFyIFFjPXQubmV4dEVmZmVjdDt0Lm5leHRFZmZlY3Q9bnVsbDt0PVFjfX1jYXRjaChUYyl7Yz0hMCxkPVRjfWMmJihudWxsPT09dD9FKFwiMTc4XCIpOnZvaWQgMCxoKHQsZCksbnVsbCE9PXQmJih0PXQubmV4dEVmZmVjdCkpfWphPVFiPSExO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBEZSYmRGUoYS5zdGF0ZU5vZGUpO2hhJiYoaGEuZm9yRWFjaChHKSxoYT1udWxsKTtudWxsIT09Y2EmJihhPWNhLGNhPW51bGwsT2IoYSkpO2I9Yi5jdXJyZW50LmV4cGlyYXRpb25UaW1lOzA9PT1iJiYocWE9Uj1udWxsKTtyZXR1cm4gYn1mdW5jdGlvbiBjKGEpe2Zvcig7Oyl7dmFyIGI9RmcoYS5hbHRlcm5hdGUsYSxIKSxjPWFbXCJyZXR1cm5cIl0sZD1hLnNpYmxpbmc7dmFyIGU9YTtpZigyMTQ3NDgzNjQ3PT09SHx8MjE0NzQ4MzY0NyE9PWUuZXhwaXJhdGlvblRpbWUpe2lmKDIhPT1lLnRhZyYmMyE9PVxuZS50YWcpdmFyIGY9MDtlbHNlIGY9ZS51cGRhdGVRdWV1ZSxmPW51bGw9PT1mPzA6Zi5leHBpcmF0aW9uVGltZTtmb3IodmFyIGc9ZS5jaGlsZDtudWxsIT09ZzspMCE9PWcuZXhwaXJhdGlvblRpbWUmJigwPT09Znx8Zj5nLmV4cGlyYXRpb25UaW1lKSYmKGY9Zy5leHBpcmF0aW9uVGltZSksZz1nLnNpYmxpbmc7ZS5leHBpcmF0aW9uVGltZT1mfWlmKG51bGwhPT1iKXJldHVybiBiO251bGwhPT1jJiYobnVsbD09PWMuZmlyc3RFZmZlY3QmJihjLmZpcnN0RWZmZWN0PWEuZmlyc3RFZmZlY3QpLG51bGwhPT1hLmxhc3RFZmZlY3QmJihudWxsIT09Yy5sYXN0RWZmZWN0JiYoYy5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YS5maXJzdEVmZmVjdCksYy5sYXN0RWZmZWN0PWEubGFzdEVmZmVjdCksMTxhLmVmZmVjdFRhZyYmKG51bGwhPT1jLmxhc3RFZmZlY3Q/Yy5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YTpjLmZpcnN0RWZmZWN0PWEsYy5sYXN0RWZmZWN0PWEpKTtpZihudWxsIT09ZClyZXR1cm4gZDtcbmlmKG51bGwhPT1jKWE9YztlbHNle2Euc3RhdGVOb2RlLmlzUmVhZHlGb3JDb21taXQ9ITA7YnJlYWt9fXJldHVybiBudWxsfWZ1bmN0aW9uIGQoYSl7dmFyIGI9cmcoYS5hbHRlcm5hdGUsYSxIKTtudWxsPT09YiYmKGI9YyhhKSk7aWQuY3VycmVudD1udWxsO3JldHVybiBifWZ1bmN0aW9uIGUoYSl7dmFyIGI9R2coYS5hbHRlcm5hdGUsYSxIKTtudWxsPT09YiYmKGI9YyhhKSk7aWQuY3VycmVudD1udWxsO3JldHVybiBifWZ1bmN0aW9uIGYoYSl7aWYobnVsbCE9PVIpe2lmKCEoMD09PUh8fEg+YSkpaWYoSDw9VWMpZm9yKDtudWxsIT09RjspRj1rKEYpP2UoRik6ZChGKTtlbHNlIGZvcig7bnVsbCE9PUYmJiFBKCk7KUY9ayhGKT9lKEYpOmQoRil9ZWxzZSBpZighKDA9PT1IfHxIPmEpKWlmKEg8PVVjKWZvcig7bnVsbCE9PUY7KUY9ZChGKTtlbHNlIGZvcig7bnVsbCE9PUYmJiFBKCk7KUY9ZChGKX1mdW5jdGlvbiBnKGEsYil7amE/RShcIjI0M1wiKTp2b2lkIDA7amE9ITA7YS5pc1JlYWR5Rm9yQ29tbWl0PVxuITE7aWYoYSE9PXJhfHxiIT09SHx8bnVsbD09PUYpe2Zvcig7LTE8aGU7KWdlW2hlXT1udWxsLGhlLS07amU9RDtpZS5jdXJyZW50PUQ7WC5jdXJyZW50PSExO3goKTtyYT1hO0g9YjtGPXNlKHJhLmN1cnJlbnQsbnVsbCxiKX12YXIgYz0hMSxkPW51bGw7dHJ5e2YoYil9Y2F0Y2goUmMpe2M9ITAsZD1SY31mb3IoO2M7KXtpZihlYil7Y2E9ZDticmVha312YXIgZz1GO2lmKG51bGw9PT1nKWViPSEwO2Vsc2V7dmFyIGs9aChnLGQpO251bGw9PT1rP0UoXCIxODNcIik6dm9pZCAwO2lmKCFlYil7dHJ5e2M9aztkPWI7Zm9yKGs9YztudWxsIT09Zzspe3N3aXRjaChnLnRhZyl7Y2FzZSAyOm5lKGcpO2JyZWFrO2Nhc2UgNTpxZyhnKTticmVhaztjYXNlIDM6cChnKTticmVhaztjYXNlIDQ6cChnKX1pZihnPT09a3x8Zy5hbHRlcm5hdGU9PT1rKWJyZWFrO2c9Z1tcInJldHVyblwiXX1GPWUoYyk7ZihkKX1jYXRjaChSYyl7Yz0hMDtkPVJjO2NvbnRpbnVlfWJyZWFrfX19Yj1jYTtlYj1qYT0hMTtjYT1cbm51bGw7bnVsbCE9PWImJk9iKGIpO3JldHVybiBhLmlzUmVhZHlGb3JDb21taXQ/YS5jdXJyZW50LmFsdGVybmF0ZTpudWxsfWZ1bmN0aW9uIGgoYSxiKXt2YXIgYz1pZC5jdXJyZW50PW51bGwsZD0hMSxlPSExLGY9bnVsbDtpZigzPT09YS50YWcpYz1hLHEoYSkmJihlYj0hMCk7ZWxzZSBmb3IodmFyIGc9YVtcInJldHVyblwiXTtudWxsIT09ZyYmbnVsbD09PWM7KXsyPT09Zy50YWc/XCJmdW5jdGlvblwiPT09dHlwZW9mIGcuc3RhdGVOb2RlLmNvbXBvbmVudERpZENhdGNoJiYoZD0hMCxmPWpkKGcpLGM9ZyxlPSEwKTozPT09Zy50YWcmJihjPWcpO2lmKHEoZykpe2lmKFNjfHxudWxsIT09aGEmJihoYS5oYXMoZyl8fG51bGwhPT1nLmFsdGVybmF0ZSYmaGEuaGFzKGcuYWx0ZXJuYXRlKSkpcmV0dXJuIG51bGw7Yz1udWxsO2U9ITF9Zz1nW1wicmV0dXJuXCJdfWlmKG51bGwhPT1jKXtudWxsPT09cWEmJihxYT1uZXcgU2V0KTtxYS5hZGQoYyk7dmFyIGg9XCJcIjtnPWE7ZG97YTpzd2l0Y2goZy50YWcpe2Nhc2UgMDpjYXNlIDE6Y2FzZSAyOmNhc2UgNTp2YXIgaz1cbmcuX2RlYnVnT3duZXIsUWM9Zy5fZGVidWdTb3VyY2U7dmFyIG09amQoZyk7dmFyIG49bnVsbDtrJiYobj1qZChrKSk7az1RYzttPVwiXFxuICAgIGluIFwiKyhtfHxcIlVua25vd25cIikrKGs/XCIgKGF0IFwiK2suZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLyxcIlwiKStcIjpcIitrLmxpbmVOdW1iZXIrXCIpXCI6bj9cIiAoY3JlYXRlZCBieSBcIituK1wiKVwiOlwiXCIpO2JyZWFrIGE7ZGVmYXVsdDptPVwiXCJ9aCs9bTtnPWdbXCJyZXR1cm5cIl19d2hpbGUoZyk7Zz1oO2E9amQoYSk7bnVsbD09PVImJihSPW5ldyBNYXApO2I9e2NvbXBvbmVudE5hbWU6YSxjb21wb25lbnRTdGFjazpnLGVycm9yOmIsZXJyb3JCb3VuZGFyeTpkP2Muc3RhdGVOb2RlOm51bGwsZXJyb3JCb3VuZGFyeUZvdW5kOmQsZXJyb3JCb3VuZGFyeU5hbWU6Zix3aWxsUmV0cnk6ZX07Ui5zZXQoYyxiKTt0cnl7dmFyIHA9Yi5lcnJvcjtwJiZwLnN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmd8fGNvbnNvbGUuZXJyb3IocCl9Y2F0Y2goVmMpe1ZjJiZcblZjLnN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmd8fGNvbnNvbGUuZXJyb3IoVmMpfVFiPyhudWxsPT09aGEmJihoYT1uZXcgU2V0KSxoYS5hZGQoYykpOkcoYyk7cmV0dXJuIGN9bnVsbD09PWNhJiYoY2E9Yik7cmV0dXJuIG51bGx9ZnVuY3Rpb24gayhhKXtyZXR1cm4gbnVsbCE9PVImJihSLmhhcyhhKXx8bnVsbCE9PWEuYWx0ZXJuYXRlJiZSLmhhcyhhLmFsdGVybmF0ZSkpfWZ1bmN0aW9uIHEoYSl7cmV0dXJuIG51bGwhPT1xYSYmKHFhLmhhcyhhKXx8bnVsbCE9PWEuYWx0ZXJuYXRlJiZxYS5oYXMoYS5hbHRlcm5hdGUpKX1mdW5jdGlvbiB2KCl7cmV0dXJuIDIwKigoKEkoKSsxMDApLzIwfDApKzEpfWZ1bmN0aW9uIHkoYSl7cmV0dXJuIDAhPT1rYT9rYTpqYT9RYj8xOkg6IUhnfHxhLmludGVybmFsQ29udGV4dFRhZyYxP3YoKToxfWZ1bmN0aW9uIHUoYSxiKXtyZXR1cm4geihhLGIsITEpfWZ1bmN0aW9uIHooYSxiKXtmb3IoO251bGwhPT1hOyl7aWYoMD09PWEuZXhwaXJhdGlvblRpbWV8fFxuYS5leHBpcmF0aW9uVGltZT5iKWEuZXhwaXJhdGlvblRpbWU9YjtudWxsIT09YS5hbHRlcm5hdGUmJigwPT09YS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWV8fGEuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lPmIpJiYoYS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWU9Yik7aWYobnVsbD09PWFbXCJyZXR1cm5cIl0paWYoMz09PWEudGFnKXt2YXIgYz1hLnN0YXRlTm9kZTshamEmJmM9PT1yYSYmYjxIJiYoRj1yYT1udWxsLEg9MCk7dmFyIGQ9YyxlPWI7UmI+SWcmJkUoXCIxODVcIik7aWYobnVsbD09PWQubmV4dFNjaGVkdWxlZFJvb3QpZC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1lLG51bGw9PT1PPyhzYT1PPWQsZC5uZXh0U2NoZWR1bGVkUm9vdD1kKTooTz1PLm5leHRTY2hlZHVsZWRSb290PWQsTy5uZXh0U2NoZWR1bGVkUm9vdD1zYSk7ZWxzZXt2YXIgZj1kLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO2lmKDA9PT1mfHxlPGYpZC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1lfUZhfHwobGE/XG5TYiYmKG1hPWQsbmE9MSxtKG1hLG5hKSk6MT09PWU/dygxLG51bGwpOkwoZSkpOyFqYSYmYz09PXJhJiZiPEgmJihGPXJhPW51bGwsSD0wKX1lbHNlIGJyZWFrO2E9YVtcInJldHVyblwiXX19ZnVuY3Rpb24gRyhhKXt6KGEsMSwhMCl9ZnVuY3Rpb24gSSgpe3JldHVybiBVYz0oKFdjKCktUGUpLzEwfDApKzJ9ZnVuY3Rpb24gTChhKXtpZigwIT09VGIpe2lmKGE+VGIpcmV0dXJuO0pnKFhjKX12YXIgYj1XYygpLVBlO1RiPWE7WGM9S2coSix7dGltZW91dDoxMCooYS0yKS1ifSl9ZnVuY3Rpb24gTigpe3ZhciBhPTAsYj1udWxsO2lmKG51bGwhPT1PKWZvcih2YXIgYz1PLGQ9c2E7bnVsbCE9PWQ7KXt2YXIgZT1kLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO2lmKDA9PT1lKXtudWxsPT09Y3x8bnVsbD09PU8/RShcIjI0NFwiKTp2b2lkIDA7aWYoZD09PWQubmV4dFNjaGVkdWxlZFJvb3Qpe3NhPU89ZC5uZXh0U2NoZWR1bGVkUm9vdD1udWxsO2JyZWFrfWVsc2UgaWYoZD09PXNhKXNhPWU9ZC5uZXh0U2NoZWR1bGVkUm9vdCxcbk8ubmV4dFNjaGVkdWxlZFJvb3Q9ZSxkLm5leHRTY2hlZHVsZWRSb290PW51bGw7ZWxzZSBpZihkPT09Tyl7Tz1jO08ubmV4dFNjaGVkdWxlZFJvb3Q9c2E7ZC5uZXh0U2NoZWR1bGVkUm9vdD1udWxsO2JyZWFrfWVsc2UgYy5uZXh0U2NoZWR1bGVkUm9vdD1kLm5leHRTY2hlZHVsZWRSb290LGQubmV4dFNjaGVkdWxlZFJvb3Q9bnVsbDtkPWMubmV4dFNjaGVkdWxlZFJvb3R9ZWxzZXtpZigwPT09YXx8ZTxhKWE9ZSxiPWQ7aWYoZD09PU8pYnJlYWs7Yz1kO2Q9ZC5uZXh0U2NoZWR1bGVkUm9vdH19Yz1tYTtudWxsIT09YyYmYz09PWI/UmIrKzpSYj0wO21hPWI7bmE9YX1mdW5jdGlvbiBKKGEpe3coMCxhKX1mdW5jdGlvbiB3KGEsYil7ZmI9Yjtmb3IoTigpO251bGwhPT1tYSYmMCE9PW5hJiYoMD09PWF8fG5hPD1hKSYmIVljOyltKG1hLG5hKSxOKCk7bnVsbCE9PWZiJiYoVGI9MCxYYz0tMSk7MCE9PW5hJiZMKG5hKTtmYj1udWxsO1ljPSExO1JiPTA7aWYoVWIpdGhyb3cgYT1aYyxaYz1cbm51bGwsVWI9ITEsYTt9ZnVuY3Rpb24gbShhLGMpe0ZhP0UoXCIyNDVcIik6dm9pZCAwO0ZhPSEwO2lmKGM8PUkoKSl7dmFyIGQ9YS5maW5pc2hlZFdvcms7bnVsbCE9PWQ/KGEuZmluaXNoZWRXb3JrPW51bGwsYS5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1iKGQpKTooYS5maW5pc2hlZFdvcms9bnVsbCxkPWcoYSxjKSxudWxsIT09ZCYmKGEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9YihkKSkpfWVsc2UgZD1hLmZpbmlzaGVkV29yayxudWxsIT09ZD8oYS5maW5pc2hlZFdvcms9bnVsbCxhLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWIoZCkpOihhLmZpbmlzaGVkV29yaz1udWxsLGQ9ZyhhLGMpLG51bGwhPT1kJiYoQSgpP2EuZmluaXNoZWRXb3JrPWQ6YS5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1iKGQpKSk7RmE9ITF9ZnVuY3Rpb24gQSgpe3JldHVybiBudWxsPT09ZmJ8fGZiLnRpbWVSZW1haW5pbmcoKT5MZz8hMTpZYz0hMH1mdW5jdGlvbiBPYihhKXtudWxsPT09bWE/RShcIjI0NlwiKTpcbnZvaWQgMDttYS5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT0wO1VifHwoVWI9ITAsWmM9YSl9dmFyIHI9aGYoYSksbj1qZihhKSxwPXIucG9wSG9zdENvbnRhaW5lcixxZz1yLnBvcEhvc3RDb250ZXh0LHg9ci5yZXNldEhvc3RDb250YWluZXIsTWU9ZGYoYSxyLG4sdSx5KSxyZz1NZS5iZWdpbldvcmssR2c9TWUuYmVnaW5GYWlsZWRXb3JrLEZnPWVmKGEscixuKS5jb21wbGV0ZVdvcms7cj1mZihhLGgpO3ZhciB6Zz1yLmNvbW1pdFJlc2V0VGV4dENvbnRlbnQsTmU9ci5jb21taXRQbGFjZW1lbnQsQmc9ci5jb21taXREZWxldGlvbixPZT1yLmNvbW1pdFdvcmssRGc9ci5jb21taXRMaWZlQ3ljbGVzLEVnPXIuY29tbWl0QXR0YWNoUmVmLEFnPXIuY29tbWl0RGV0YWNoUmVmLFdjPWEubm93LEtnPWEuc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrLEpnPWEuY2FuY2VsRGVmZXJyZWRDYWxsYmFjayxIZz1hLnVzZVN5bmNTY2hlZHVsaW5nLHlnPWEucHJlcGFyZUZvckNvbW1pdCxDZz1hLnJlc2V0QWZ0ZXJDb21taXQsXG5QZT1XYygpLFVjPTIsa2E9MCxqYT0hMSxGPW51bGwscmE9bnVsbCxIPTAsdD1udWxsLFI9bnVsbCxxYT1udWxsLGhhPW51bGwsY2E9bnVsbCxlYj0hMSxRYj0hMSxTYz0hMSxzYT1udWxsLE89bnVsbCxUYj0wLFhjPS0xLEZhPSExLG1hPW51bGwsbmE9MCxZYz0hMSxVYj0hMSxaYz1udWxsLGZiPW51bGwsbGE9ITEsU2I9ITEsSWc9MUUzLFJiPTAsTGc9MTtyZXR1cm57Y29tcHV0ZUFzeW5jRXhwaXJhdGlvbjp2LGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXI6eSxzY2hlZHVsZVdvcms6dSxiYXRjaGVkVXBkYXRlczpmdW5jdGlvbihhLGIpe3ZhciBjPWxhO2xhPSEwO3RyeXtyZXR1cm4gYShiKX1maW5hbGx5eyhsYT1jKXx8RmF8fHcoMSxudWxsKX19LHVuYmF0Y2hlZFVwZGF0ZXM6ZnVuY3Rpb24oYSl7aWYobGEmJiFTYil7U2I9ITA7dHJ5e3JldHVybiBhKCl9ZmluYWxseXtTYj0hMX19cmV0dXJuIGEoKX0sZmx1c2hTeW5jOmZ1bmN0aW9uKGEpe3ZhciBiPWxhO2xhPSEwO3RyeXthOnt2YXIgYz1cbmthO2thPTE7dHJ5e3ZhciBkPWEoKTticmVhayBhfWZpbmFsbHl7a2E9Y31kPXZvaWQgMH1yZXR1cm4gZH1maW5hbGx5e2xhPWIsRmE/RShcIjE4N1wiKTp2b2lkIDAsdygxLG51bGwpfX0sZGVmZXJyZWRVcGRhdGVzOmZ1bmN0aW9uKGEpe3ZhciBiPWthO2thPXYoKTt0cnl7cmV0dXJuIGEoKX1maW5hbGx5e2thPWJ9fX19XG5mdW5jdGlvbiBsZihhKXtmdW5jdGlvbiBiKGEpe2E9b2QoYSk7cmV0dXJuIG51bGw9PT1hP251bGw6YS5zdGF0ZU5vZGV9dmFyIGM9YS5nZXRQdWJsaWNJbnN0YW5jZTthPWtmKGEpO3ZhciBkPWEuY29tcHV0ZUFzeW5jRXhwaXJhdGlvbixlPWEuY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcixmPWEuc2NoZWR1bGVXb3JrO3JldHVybntjcmVhdGVDb250YWluZXI6ZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgWSgzLG51bGwsMCk7YT17Y3VycmVudDpjLGNvbnRhaW5lckluZm86YSxwZW5kaW5nQ2hpbGRyZW46bnVsbCxyZW1haW5pbmdFeHBpcmF0aW9uVGltZTowLGlzUmVhZHlGb3JDb21taXQ6ITEsZmluaXNoZWRXb3JrOm51bGwsY29udGV4dDpudWxsLHBlbmRpbmdDb250ZXh0Om51bGwsaHlkcmF0ZTpiLG5leHRTY2hlZHVsZWRSb290Om51bGx9O3JldHVybiBjLnN0YXRlTm9kZT1hfSx1cGRhdGVDb250YWluZXI6ZnVuY3Rpb24oYSxiLGMscSl7dmFyIGc9Yi5jdXJyZW50O2lmKGMpe2M9XG5jLl9yZWFjdEludGVybmFsRmliZXI7dmFyIGg7Yjp7Mj09PWtkKGMpJiYyPT09Yy50YWc/dm9pZCAwOkUoXCIxNzBcIik7Zm9yKGg9YzszIT09aC50YWc7KXtpZihsZShoKSl7aD1oLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDticmVhayBifShoPWhbXCJyZXR1cm5cIl0pP3ZvaWQgMDpFKFwiMTcxXCIpfWg9aC5zdGF0ZU5vZGUuY29udGV4dH1jPWxlKGMpP3BlKGMsaCk6aH1lbHNlIGM9RDtudWxsPT09Yi5jb250ZXh0P2IuY29udGV4dD1jOmIucGVuZGluZ0NvbnRleHQ9YztiPXE7Yj12b2lkIDA9PT1iP251bGw6YjtxPW51bGwhPWEmJm51bGwhPWEudHlwZSYmbnVsbCE9YS50eXBlLnByb3RvdHlwZSYmITA9PT1hLnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudD9kKCk6ZShnKTtIZShnLHtleHBpcmF0aW9uVGltZTpxLHBhcnRpYWxTdGF0ZTp7ZWxlbWVudDphfSxjYWxsYmFjazpiLGlzUmVwbGFjZTohMSxpc0ZvcmNlZDohMSxcbm5leHRDYWxsYmFjazpudWxsLG5leHQ6bnVsbH0pO2YoZyxxKX0sYmF0Y2hlZFVwZGF0ZXM6YS5iYXRjaGVkVXBkYXRlcyx1bmJhdGNoZWRVcGRhdGVzOmEudW5iYXRjaGVkVXBkYXRlcyxkZWZlcnJlZFVwZGF0ZXM6YS5kZWZlcnJlZFVwZGF0ZXMsZmx1c2hTeW5jOmEuZmx1c2hTeW5jLGdldFB1YmxpY1Jvb3RJbnN0YW5jZTpmdW5jdGlvbihhKXthPWEuY3VycmVudDtpZighYS5jaGlsZClyZXR1cm4gbnVsbDtzd2l0Y2goYS5jaGlsZC50YWcpe2Nhc2UgNTpyZXR1cm4gYyhhLmNoaWxkLnN0YXRlTm9kZSk7ZGVmYXVsdDpyZXR1cm4gYS5jaGlsZC5zdGF0ZU5vZGV9fSxmaW5kSG9zdEluc3RhbmNlOmIsZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHM6ZnVuY3Rpb24oYSl7YT1wZChhKTtyZXR1cm4gbnVsbD09PWE/bnVsbDphLnN0YXRlTm9kZX0saW5qZWN0SW50b0RldlRvb2xzOmZ1bmN0aW9uKGEpe3ZhciBjPWEuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U7cmV0dXJuIENlKEIoe30sXG5hLHtmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjpmdW5jdGlvbihhKXtyZXR1cm4gYihhKX0sZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6ZnVuY3Rpb24oYSl7cmV0dXJuIGM/YyhhKTpudWxsfX0pKX19fXZhciBtZj1PYmplY3QuZnJlZXplKHtkZWZhdWx0OmxmfSksbmY9bWYmJmxmfHxtZixvZj1uZltcImRlZmF1bHRcIl0/bmZbXCJkZWZhdWx0XCJdOm5mO2Z1bmN0aW9uIHBmKGEsYixjKXt2YXIgZD0zPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106bnVsbDtyZXR1cm57JCR0eXBlb2Y6VWUsa2V5Om51bGw9PWQ/bnVsbDpcIlwiK2QsY2hpbGRyZW46YSxjb250YWluZXJJbmZvOmIsaW1wbGVtZW50YXRpb246Y319dmFyIHFmPVwib2JqZWN0XCI9PT10eXBlb2YgcGVyZm9ybWFuY2UmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBwZXJmb3JtYW5jZS5ub3cscmY9dm9pZCAwO3JmPXFmP2Z1bmN0aW9uKCl7cmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpfTpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfTtcbnZhciBzZj12b2lkIDAsdGY9dm9pZCAwO1xuaWYobC5jYW5Vc2VET00paWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2t8fFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjYW5jZWxJZGxlQ2FsbGJhY2spe3ZhciB1Zj1udWxsLHZmPSExLHdmPS0xLHhmPSExLHlmPTAsemY9MzMsQWY9MzMsQmY7QmY9cWY/e2RpZFRpbWVvdXQ6ITEsdGltZVJlbWFpbmluZzpmdW5jdGlvbigpe3ZhciBhPXlmLXBlcmZvcm1hbmNlLm5vdygpO3JldHVybiAwPGE/YTowfX06e2RpZFRpbWVvdXQ6ITEsdGltZVJlbWFpbmluZzpmdW5jdGlvbigpe3ZhciBhPXlmLURhdGUubm93KCk7cmV0dXJuIDA8YT9hOjB9fTt2YXIgQ2Y9XCJfX3JlYWN0SWRsZUNhbGxiYWNrJFwiK01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGZ1bmN0aW9uKGEpe2lmKGEuc291cmNlPT09d2luZG93JiZhLmRhdGE9PT1DZil7dmY9ITE7YT1yZigpO2lmKDA+PXlmLWEpaWYoLTEhPT13ZiYmd2Y8PVxuYSlCZi5kaWRUaW1lb3V0PSEwO2Vsc2V7eGZ8fCh4Zj0hMCxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoRGYpKTtyZXR1cm59ZWxzZSBCZi5kaWRUaW1lb3V0PSExO3dmPS0xO2E9dWY7dWY9bnVsbDtudWxsIT09YSYmYShCZil9fSwhMSk7dmFyIERmPWZ1bmN0aW9uKGEpe3hmPSExO3ZhciBiPWEteWYrQWY7YjxBZiYmemY8QWY/KDg+YiYmKGI9OCksQWY9Yjx6Zj96ZjpiKTp6Zj1iO3lmPWErQWY7dmZ8fCh2Zj0hMCx3aW5kb3cucG9zdE1lc3NhZ2UoQ2YsXCIqXCIpKX07c2Y9ZnVuY3Rpb24oYSxiKXt1Zj1hO251bGwhPWImJlwibnVtYmVyXCI9PT10eXBlb2YgYi50aW1lb3V0JiYod2Y9cmYoKStiLnRpbWVvdXQpO3hmfHwoeGY9ITAscmVxdWVzdEFuaW1hdGlvbkZyYW1lKERmKSk7cmV0dXJuIDB9O3RmPWZ1bmN0aW9uKCl7dWY9bnVsbDt2Zj0hMTt3Zj0tMX19ZWxzZSBzZj13aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayx0Zj13aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrO2Vsc2Ugc2Y9ZnVuY3Rpb24oYSl7cmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXthKHt0aW1lUmVtYWluaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIEluZmluaXR5fX0pfSl9LFxudGY9ZnVuY3Rpb24oYSl7Y2xlYXJUaW1lb3V0KGEpfTt2YXIgRWY9L15bOkEtWl9hLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdWzpBLVpfYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXFwtLjAtOVxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDBdKiQvLEZmPXt9LEdmPXt9O1xuZnVuY3Rpb24gSGYoYSl7aWYoR2YuaGFzT3duUHJvcGVydHkoYSkpcmV0dXJuITA7aWYoRmYuaGFzT3duUHJvcGVydHkoYSkpcmV0dXJuITE7aWYoRWYudGVzdChhKSlyZXR1cm4gR2ZbYV09ITA7RmZbYV09ITA7cmV0dXJuITF9XG5mdW5jdGlvbiBJZihhLGIsYyl7dmFyIGQ9d2EoYik7aWYoZCYmdmEoYixjKSl7dmFyIGU9ZC5tdXRhdGlvbk1ldGhvZDtlP2UoYSxjKTpudWxsPT1jfHxkLmhhc0Jvb2xlYW5WYWx1ZSYmIWN8fGQuaGFzTnVtZXJpY1ZhbHVlJiZpc05hTihjKXx8ZC5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSYmMT5jfHxkLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUmJiExPT09Yz9KZihhLGIpOmQubXVzdFVzZVByb3BlcnR5P2FbZC5wcm9wZXJ0eU5hbWVdPWM6KGI9ZC5hdHRyaWJ1dGVOYW1lLChlPWQuYXR0cmlidXRlTmFtZXNwYWNlKT9hLnNldEF0dHJpYnV0ZU5TKGUsYixcIlwiK2MpOmQuaGFzQm9vbGVhblZhbHVlfHxkLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUmJiEwPT09Yz9hLnNldEF0dHJpYnV0ZShiLFwiXCIpOmEuc2V0QXR0cmlidXRlKGIsXCJcIitjKSl9ZWxzZSBLZihhLGIsdmEoYixjKT9jOm51bGwpfVxuZnVuY3Rpb24gS2YoYSxiLGMpe0hmKGIpJiYobnVsbD09Yz9hLnJlbW92ZUF0dHJpYnV0ZShiKTphLnNldEF0dHJpYnV0ZShiLFwiXCIrYykpfWZ1bmN0aW9uIEpmKGEsYil7dmFyIGM9d2EoYik7Yz8oYj1jLm11dGF0aW9uTWV0aG9kKT9iKGEsdm9pZCAwKTpjLm11c3RVc2VQcm9wZXJ0eT9hW2MucHJvcGVydHlOYW1lXT1jLmhhc0Jvb2xlYW5WYWx1ZT8hMTpcIlwiOmEucmVtb3ZlQXR0cmlidXRlKGMuYXR0cmlidXRlTmFtZSk6YS5yZW1vdmVBdHRyaWJ1dGUoYil9XG5mdW5jdGlvbiBMZihhLGIpe3ZhciBjPWIudmFsdWUsZD1iLmNoZWNrZWQ7cmV0dXJuIEIoe3R5cGU6dm9pZCAwLHN0ZXA6dm9pZCAwLG1pbjp2b2lkIDAsbWF4OnZvaWQgMH0sYix7ZGVmYXVsdENoZWNrZWQ6dm9pZCAwLGRlZmF1bHRWYWx1ZTp2b2lkIDAsdmFsdWU6bnVsbCE9Yz9jOmEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsY2hlY2tlZDpudWxsIT1kP2Q6YS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkfSl9ZnVuY3Rpb24gTWYoYSxiKXt2YXIgYz1iLmRlZmF1bHRWYWx1ZTthLl93cmFwcGVyU3RhdGU9e2luaXRpYWxDaGVja2VkOm51bGwhPWIuY2hlY2tlZD9iLmNoZWNrZWQ6Yi5kZWZhdWx0Q2hlY2tlZCxpbml0aWFsVmFsdWU6bnVsbCE9Yi52YWx1ZT9iLnZhbHVlOmMsY29udHJvbGxlZDpcImNoZWNrYm94XCI9PT1iLnR5cGV8fFwicmFkaW9cIj09PWIudHlwZT9udWxsIT1iLmNoZWNrZWQ6bnVsbCE9Yi52YWx1ZX19XG5mdW5jdGlvbiBOZihhLGIpe2I9Yi5jaGVja2VkO251bGwhPWImJklmKGEsXCJjaGVja2VkXCIsYil9ZnVuY3Rpb24gT2YoYSxiKXtOZihhLGIpO3ZhciBjPWIudmFsdWU7aWYobnVsbCE9YylpZigwPT09YyYmXCJcIj09PWEudmFsdWUpYS52YWx1ZT1cIjBcIjtlbHNlIGlmKFwibnVtYmVyXCI9PT1iLnR5cGUpe2lmKGI9cGFyc2VGbG9hdChhLnZhbHVlKXx8MCxjIT1ifHxjPT1iJiZhLnZhbHVlIT1jKWEudmFsdWU9XCJcIitjfWVsc2UgYS52YWx1ZSE9PVwiXCIrYyYmKGEudmFsdWU9XCJcIitjKTtlbHNlIG51bGw9PWIudmFsdWUmJm51bGwhPWIuZGVmYXVsdFZhbHVlJiZhLmRlZmF1bHRWYWx1ZSE9PVwiXCIrYi5kZWZhdWx0VmFsdWUmJihhLmRlZmF1bHRWYWx1ZT1cIlwiK2IuZGVmYXVsdFZhbHVlKSxudWxsPT1iLmNoZWNrZWQmJm51bGwhPWIuZGVmYXVsdENoZWNrZWQmJihhLmRlZmF1bHRDaGVja2VkPSEhYi5kZWZhdWx0Q2hlY2tlZCl9XG5mdW5jdGlvbiBQZihhLGIpe3N3aXRjaChiLnR5cGUpe2Nhc2UgXCJzdWJtaXRcIjpjYXNlIFwicmVzZXRcIjpicmVhaztjYXNlIFwiY29sb3JcIjpjYXNlIFwiZGF0ZVwiOmNhc2UgXCJkYXRldGltZVwiOmNhc2UgXCJkYXRldGltZS1sb2NhbFwiOmNhc2UgXCJtb250aFwiOmNhc2UgXCJ0aW1lXCI6Y2FzZSBcIndlZWtcIjphLnZhbHVlPVwiXCI7YS52YWx1ZT1hLmRlZmF1bHRWYWx1ZTticmVhaztkZWZhdWx0OmEudmFsdWU9YS52YWx1ZX1iPWEubmFtZTtcIlwiIT09YiYmKGEubmFtZT1cIlwiKTthLmRlZmF1bHRDaGVja2VkPSFhLmRlZmF1bHRDaGVja2VkO2EuZGVmYXVsdENoZWNrZWQ9IWEuZGVmYXVsdENoZWNrZWQ7XCJcIiE9PWImJihhLm5hbWU9Yil9ZnVuY3Rpb24gUWYoYSl7dmFyIGI9XCJcIjthYS5DaGlsZHJlbi5mb3JFYWNoKGEsZnVuY3Rpb24oYSl7bnVsbD09YXx8XCJzdHJpbmdcIiE9PXR5cGVvZiBhJiZcIm51bWJlclwiIT09dHlwZW9mIGF8fChiKz1hKX0pO3JldHVybiBifVxuZnVuY3Rpb24gUmYoYSxiKXthPUIoe2NoaWxkcmVuOnZvaWQgMH0sYik7aWYoYj1RZihiLmNoaWxkcmVuKSlhLmNoaWxkcmVuPWI7cmV0dXJuIGF9ZnVuY3Rpb24gU2YoYSxiLGMsZCl7YT1hLm9wdGlvbnM7aWYoYil7Yj17fTtmb3IodmFyIGU9MDtlPGMubGVuZ3RoO2UrKyliW1wiJFwiK2NbZV1dPSEwO2ZvcihjPTA7YzxhLmxlbmd0aDtjKyspZT1iLmhhc093blByb3BlcnR5KFwiJFwiK2FbY10udmFsdWUpLGFbY10uc2VsZWN0ZWQhPT1lJiYoYVtjXS5zZWxlY3RlZD1lKSxlJiZkJiYoYVtjXS5kZWZhdWx0U2VsZWN0ZWQ9ITApfWVsc2V7Yz1cIlwiK2M7Yj1udWxsO2ZvcihlPTA7ZTxhLmxlbmd0aDtlKyspe2lmKGFbZV0udmFsdWU9PT1jKXthW2VdLnNlbGVjdGVkPSEwO2QmJihhW2VdLmRlZmF1bHRTZWxlY3RlZD0hMCk7cmV0dXJufW51bGwhPT1ifHxhW2VdLmRpc2FibGVkfHwoYj1hW2VdKX1udWxsIT09YiYmKGIuc2VsZWN0ZWQ9ITApfX1cbmZ1bmN0aW9uIFRmKGEsYil7dmFyIGM9Yi52YWx1ZTthLl93cmFwcGVyU3RhdGU9e2luaXRpYWxWYWx1ZTpudWxsIT1jP2M6Yi5kZWZhdWx0VmFsdWUsd2FzTXVsdGlwbGU6ISFiLm11bHRpcGxlfX1mdW5jdGlvbiBVZihhLGIpe251bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw/RShcIjkxXCIpOnZvaWQgMDtyZXR1cm4gQih7fSxiLHt2YWx1ZTp2b2lkIDAsZGVmYXVsdFZhbHVlOnZvaWQgMCxjaGlsZHJlbjpcIlwiK2EuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWV9KX1mdW5jdGlvbiBWZihhLGIpe3ZhciBjPWIudmFsdWU7bnVsbD09YyYmKGM9Yi5kZWZhdWx0VmFsdWUsYj1iLmNoaWxkcmVuLG51bGwhPWImJihudWxsIT1jP0UoXCI5MlwiKTp2b2lkIDAsQXJyYXkuaXNBcnJheShiKSYmKDE+PWIubGVuZ3RoP3ZvaWQgMDpFKFwiOTNcIiksYj1iWzBdKSxjPVwiXCIrYiksbnVsbD09YyYmKGM9XCJcIikpO2EuX3dyYXBwZXJTdGF0ZT17aW5pdGlhbFZhbHVlOlwiXCIrY319XG5mdW5jdGlvbiBXZihhLGIpe3ZhciBjPWIudmFsdWU7bnVsbCE9YyYmKGM9XCJcIitjLGMhPT1hLnZhbHVlJiYoYS52YWx1ZT1jKSxudWxsPT1iLmRlZmF1bHRWYWx1ZSYmKGEuZGVmYXVsdFZhbHVlPWMpKTtudWxsIT1iLmRlZmF1bHRWYWx1ZSYmKGEuZGVmYXVsdFZhbHVlPWIuZGVmYXVsdFZhbHVlKX1mdW5jdGlvbiBYZihhKXt2YXIgYj1hLnRleHRDb250ZW50O2I9PT1hLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlJiYoYS52YWx1ZT1iKX12YXIgWWY9e2h0bWw6XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsbWF0aG1sOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLHN2ZzpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJ9O1xuZnVuY3Rpb24gWmYoYSl7c3dpdGNoKGEpe2Nhc2UgXCJzdmdcIjpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7Y2FzZSBcIm1hdGhcIjpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIjtkZWZhdWx0OnJldHVyblwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwifX1mdW5jdGlvbiAkZihhLGIpe3JldHVybiBudWxsPT1hfHxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIj09PWE/WmYoYik6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPT09YSYmXCJmb3JlaWduT2JqZWN0XCI9PT1iP1wiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiOmF9XG52YXIgYWc9dm9pZCAwLGJnPWZ1bmN0aW9uKGEpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgTVNBcHAmJk1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uP2Z1bmN0aW9uKGIsYyxkLGUpe01TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uKCl7cmV0dXJuIGEoYixjLGQsZSl9KX06YX0oZnVuY3Rpb24oYSxiKXtpZihhLm5hbWVzcGFjZVVSSSE9PVlmLnN2Z3x8XCJpbm5lckhUTUxcImluIGEpYS5pbm5lckhUTUw9YjtlbHNle2FnPWFnfHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2FnLmlubmVySFRNTD1cIlxceDNjc3ZnXFx4M2VcIitiK1wiXFx4M2Mvc3ZnXFx4M2VcIjtmb3IoYj1hZy5maXJzdENoaWxkO2EuZmlyc3RDaGlsZDspYS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpO2Zvcig7Yi5maXJzdENoaWxkOylhLmFwcGVuZENoaWxkKGIuZmlyc3RDaGlsZCl9fSk7XG5mdW5jdGlvbiBjZyhhLGIpe2lmKGIpe3ZhciBjPWEuZmlyc3RDaGlsZDtpZihjJiZjPT09YS5sYXN0Q2hpbGQmJjM9PT1jLm5vZGVUeXBlKXtjLm5vZGVWYWx1ZT1iO3JldHVybn19YS50ZXh0Q29udGVudD1ifVxudmFyIGRnPXthbmltYXRpb25JdGVyYXRpb25Db3VudDohMCxib3JkZXJJbWFnZU91dHNldDohMCxib3JkZXJJbWFnZVNsaWNlOiEwLGJvcmRlckltYWdlV2lkdGg6ITAsYm94RmxleDohMCxib3hGbGV4R3JvdXA6ITAsYm94T3JkaW5hbEdyb3VwOiEwLGNvbHVtbkNvdW50OiEwLGNvbHVtbnM6ITAsZmxleDohMCxmbGV4R3JvdzohMCxmbGV4UG9zaXRpdmU6ITAsZmxleFNocmluazohMCxmbGV4TmVnYXRpdmU6ITAsZmxleE9yZGVyOiEwLGdyaWRSb3c6ITAsZ3JpZFJvd0VuZDohMCxncmlkUm93U3BhbjohMCxncmlkUm93U3RhcnQ6ITAsZ3JpZENvbHVtbjohMCxncmlkQ29sdW1uRW5kOiEwLGdyaWRDb2x1bW5TcGFuOiEwLGdyaWRDb2x1bW5TdGFydDohMCxmb250V2VpZ2h0OiEwLGxpbmVDbGFtcDohMCxsaW5lSGVpZ2h0OiEwLG9wYWNpdHk6ITAsb3JkZXI6ITAsb3JwaGFuczohMCx0YWJTaXplOiEwLHdpZG93czohMCx6SW5kZXg6ITAsem9vbTohMCxmaWxsT3BhY2l0eTohMCxmbG9vZE9wYWNpdHk6ITAsXG5zdG9wT3BhY2l0eTohMCxzdHJva2VEYXNoYXJyYXk6ITAsc3Ryb2tlRGFzaG9mZnNldDohMCxzdHJva2VNaXRlcmxpbWl0OiEwLHN0cm9rZU9wYWNpdHk6ITAsc3Ryb2tlV2lkdGg6ITB9LGVnPVtcIldlYmtpdFwiLFwibXNcIixcIk1velwiLFwiT1wiXTtPYmplY3Qua2V5cyhkZykuZm9yRWFjaChmdW5jdGlvbihhKXtlZy5mb3JFYWNoKGZ1bmN0aW9uKGIpe2I9YithLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Euc3Vic3RyaW5nKDEpO2RnW2JdPWRnW2FdfSl9KTtcbmZ1bmN0aW9uIGZnKGEsYil7YT1hLnN0eWxlO2Zvcih2YXIgYyBpbiBiKWlmKGIuaGFzT3duUHJvcGVydHkoYykpe3ZhciBkPTA9PT1jLmluZGV4T2YoXCItLVwiKTt2YXIgZT1jO3ZhciBmPWJbY107ZT1udWxsPT1mfHxcImJvb2xlYW5cIj09PXR5cGVvZiBmfHxcIlwiPT09Zj9cIlwiOmR8fFwibnVtYmVyXCIhPT10eXBlb2YgZnx8MD09PWZ8fGRnLmhhc093blByb3BlcnR5KGUpJiZkZ1tlXT8oXCJcIitmKS50cmltKCk6ZitcInB4XCI7XCJmbG9hdFwiPT09YyYmKGM9XCJjc3NGbG9hdFwiKTtkP2Euc2V0UHJvcGVydHkoYyxlKTphW2NdPWV9fXZhciBnZz1CKHttZW51aXRlbTohMH0se2FyZWE6ITAsYmFzZTohMCxicjohMCxjb2w6ITAsZW1iZWQ6ITAsaHI6ITAsaW1nOiEwLGlucHV0OiEwLGtleWdlbjohMCxsaW5rOiEwLG1ldGE6ITAscGFyYW06ITAsc291cmNlOiEwLHRyYWNrOiEwLHdicjohMH0pO1xuZnVuY3Rpb24gaGcoYSxiLGMpe2ImJihnZ1thXSYmKG51bGwhPWIuY2hpbGRyZW58fG51bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw/RShcIjEzN1wiLGEsYygpKTp2b2lkIDApLG51bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJihudWxsIT1iLmNoaWxkcmVuP0UoXCI2MFwiKTp2b2lkIDAsXCJvYmplY3RcIj09PXR5cGVvZiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZcIl9faHRtbFwiaW4gYi5kYW5nZXJvdXNseVNldElubmVySFRNTD92b2lkIDA6RShcIjYxXCIpKSxudWxsIT1iLnN0eWxlJiZcIm9iamVjdFwiIT09dHlwZW9mIGIuc3R5bGU/RShcIjYyXCIsYygpKTp2b2lkIDApfVxuZnVuY3Rpb24gaWcoYSxiKXtpZigtMT09PWEuaW5kZXhPZihcIi1cIikpcmV0dXJuXCJzdHJpbmdcIj09PXR5cGVvZiBiLmlzO3N3aXRjaChhKXtjYXNlIFwiYW5ub3RhdGlvbi14bWxcIjpjYXNlIFwiY29sb3ItcHJvZmlsZVwiOmNhc2UgXCJmb250LWZhY2VcIjpjYXNlIFwiZm9udC1mYWNlLXNyY1wiOmNhc2UgXCJmb250LWZhY2UtdXJpXCI6Y2FzZSBcImZvbnQtZmFjZS1mb3JtYXRcIjpjYXNlIFwiZm9udC1mYWNlLW5hbWVcIjpjYXNlIFwibWlzc2luZy1nbHlwaFwiOnJldHVybiExO2RlZmF1bHQ6cmV0dXJuITB9fXZhciBqZz1ZZi5odG1sLGtnPUMudGhhdFJldHVybnMoXCJcIik7XG5mdW5jdGlvbiBsZyhhLGIpe2E9OT09PWEubm9kZVR5cGV8fDExPT09YS5ub2RlVHlwZT9hOmEub3duZXJEb2N1bWVudDt2YXIgYz1IZChhKTtiPVNhW2JdO2Zvcih2YXIgZD0wO2Q8Yi5sZW5ndGg7ZCsrKXt2YXIgZT1iW2RdO2MuaGFzT3duUHJvcGVydHkoZSkmJmNbZV18fChcInRvcFNjcm9sbFwiPT09ZT93ZChcInRvcFNjcm9sbFwiLFwic2Nyb2xsXCIsYSk6XCJ0b3BGb2N1c1wiPT09ZXx8XCJ0b3BCbHVyXCI9PT1lPyh3ZChcInRvcEZvY3VzXCIsXCJmb2N1c1wiLGEpLHdkKFwidG9wQmx1clwiLFwiYmx1clwiLGEpLGMudG9wQmx1cj0hMCxjLnRvcEZvY3VzPSEwKTpcInRvcENhbmNlbFwiPT09ZT8oeWMoXCJjYW5jZWxcIiwhMCkmJndkKFwidG9wQ2FuY2VsXCIsXCJjYW5jZWxcIixhKSxjLnRvcENhbmNlbD0hMCk6XCJ0b3BDbG9zZVwiPT09ZT8oeWMoXCJjbG9zZVwiLCEwKSYmd2QoXCJ0b3BDbG9zZVwiLFwiY2xvc2VcIixhKSxjLnRvcENsb3NlPSEwKTpEZC5oYXNPd25Qcm9wZXJ0eShlKSYmVShlLERkW2VdLGEpLGNbZV09ITApfX1cbnZhciBtZz17dG9wQWJvcnQ6XCJhYm9ydFwiLHRvcENhblBsYXk6XCJjYW5wbGF5XCIsdG9wQ2FuUGxheVRocm91Z2g6XCJjYW5wbGF5dGhyb3VnaFwiLHRvcER1cmF0aW9uQ2hhbmdlOlwiZHVyYXRpb25jaGFuZ2VcIix0b3BFbXB0aWVkOlwiZW1wdGllZFwiLHRvcEVuY3J5cHRlZDpcImVuY3J5cHRlZFwiLHRvcEVuZGVkOlwiZW5kZWRcIix0b3BFcnJvcjpcImVycm9yXCIsdG9wTG9hZGVkRGF0YTpcImxvYWRlZGRhdGFcIix0b3BMb2FkZWRNZXRhZGF0YTpcImxvYWRlZG1ldGFkYXRhXCIsdG9wTG9hZFN0YXJ0OlwibG9hZHN0YXJ0XCIsdG9wUGF1c2U6XCJwYXVzZVwiLHRvcFBsYXk6XCJwbGF5XCIsdG9wUGxheWluZzpcInBsYXlpbmdcIix0b3BQcm9ncmVzczpcInByb2dyZXNzXCIsdG9wUmF0ZUNoYW5nZTpcInJhdGVjaGFuZ2VcIix0b3BTZWVrZWQ6XCJzZWVrZWRcIix0b3BTZWVraW5nOlwic2Vla2luZ1wiLHRvcFN0YWxsZWQ6XCJzdGFsbGVkXCIsdG9wU3VzcGVuZDpcInN1c3BlbmRcIix0b3BUaW1lVXBkYXRlOlwidGltZXVwZGF0ZVwiLHRvcFZvbHVtZUNoYW5nZTpcInZvbHVtZWNoYW5nZVwiLFxudG9wV2FpdGluZzpcIndhaXRpbmdcIn07ZnVuY3Rpb24gbmcoYSxiLGMsZCl7Yz05PT09Yy5ub2RlVHlwZT9jOmMub3duZXJEb2N1bWVudDtkPT09amcmJihkPVpmKGEpKTtkPT09amc/XCJzY3JpcHRcIj09PWE/KGE9Yy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGEuaW5uZXJIVE1MPVwiXFx4M2NzY3JpcHRcXHgzZVxceDNjL3NjcmlwdFxceDNlXCIsYT1hLnJlbW92ZUNoaWxkKGEuZmlyc3RDaGlsZCkpOmE9XCJzdHJpbmdcIj09PXR5cGVvZiBiLmlzP2MuY3JlYXRlRWxlbWVudChhLHtpczpiLmlzfSk6Yy5jcmVhdGVFbGVtZW50KGEpOmE9Yy5jcmVhdGVFbGVtZW50TlMoZCxhKTtyZXR1cm4gYX1mdW5jdGlvbiBvZyhhLGIpe3JldHVybig5PT09Yi5ub2RlVHlwZT9iOmIub3duZXJEb2N1bWVudCkuY3JlYXRlVGV4dE5vZGUoYSl9XG5mdW5jdGlvbiBwZyhhLGIsYyxkKXt2YXIgZT1pZyhiLGMpO3N3aXRjaChiKXtjYXNlIFwiaWZyYW1lXCI6Y2FzZSBcIm9iamVjdFwiOlUoXCJ0b3BMb2FkXCIsXCJsb2FkXCIsYSk7dmFyIGY9YzticmVhaztjYXNlIFwidmlkZW9cIjpjYXNlIFwiYXVkaW9cIjpmb3IoZiBpbiBtZyltZy5oYXNPd25Qcm9wZXJ0eShmKSYmVShmLG1nW2ZdLGEpO2Y9YzticmVhaztjYXNlIFwic291cmNlXCI6VShcInRvcEVycm9yXCIsXCJlcnJvclwiLGEpO2Y9YzticmVhaztjYXNlIFwiaW1nXCI6Y2FzZSBcImltYWdlXCI6VShcInRvcEVycm9yXCIsXCJlcnJvclwiLGEpO1UoXCJ0b3BMb2FkXCIsXCJsb2FkXCIsYSk7Zj1jO2JyZWFrO2Nhc2UgXCJmb3JtXCI6VShcInRvcFJlc2V0XCIsXCJyZXNldFwiLGEpO1UoXCJ0b3BTdWJtaXRcIixcInN1Ym1pdFwiLGEpO2Y9YzticmVhaztjYXNlIFwiZGV0YWlsc1wiOlUoXCJ0b3BUb2dnbGVcIixcInRvZ2dsZVwiLGEpO2Y9YzticmVhaztjYXNlIFwiaW5wdXRcIjpNZihhLGMpO2Y9TGYoYSxjKTtVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpO1xubGcoZCxcIm9uQ2hhbmdlXCIpO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjpmPVJmKGEsYyk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOlRmKGEsYyk7Zj1CKHt9LGMse3ZhbHVlOnZvaWQgMH0pO1UoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSk7bGcoZCxcIm9uQ2hhbmdlXCIpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOlZmKGEsYyk7Zj1VZihhLGMpO1UoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSk7bGcoZCxcIm9uQ2hhbmdlXCIpO2JyZWFrO2RlZmF1bHQ6Zj1jfWhnKGIsZixrZyk7dmFyIGc9ZixoO2ZvcihoIGluIGcpaWYoZy5oYXNPd25Qcm9wZXJ0eShoKSl7dmFyIGs9Z1toXTtcInN0eWxlXCI9PT1oP2ZnKGEsayxrZyk6XCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiPT09aD8oaz1rP2suX19odG1sOnZvaWQgMCxudWxsIT1rJiZiZyhhLGspKTpcImNoaWxkcmVuXCI9PT1oP1wic3RyaW5nXCI9PT10eXBlb2Ygaz8oXCJ0ZXh0YXJlYVwiIT09Ynx8XCJcIiE9PWspJiZjZyhhLGspOlwibnVtYmVyXCI9PT10eXBlb2YgayYmY2coYSxcblwiXCIrayk6XCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIiE9PWgmJlwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCIhPT1oJiZcImF1dG9Gb2N1c1wiIT09aCYmKFJhLmhhc093blByb3BlcnR5KGgpP251bGwhPWsmJmxnKGQsaCk6ZT9LZihhLGgsayk6bnVsbCE9ayYmSWYoYSxoLGspKX1zd2l0Y2goYil7Y2FzZSBcImlucHV0XCI6QmMoYSk7UGYoYSxjKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpCYyhhKTtYZihhLGMpO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjpudWxsIT1jLnZhbHVlJiZhLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsYy52YWx1ZSk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmEubXVsdGlwbGU9ISFjLm11bHRpcGxlO2I9Yy52YWx1ZTtudWxsIT1iP1NmKGEsISFjLm11bHRpcGxlLGIsITEpOm51bGwhPWMuZGVmYXVsdFZhbHVlJiZTZihhLCEhYy5tdWx0aXBsZSxjLmRlZmF1bHRWYWx1ZSwhMCk7YnJlYWs7ZGVmYXVsdDpcImZ1bmN0aW9uXCI9PT10eXBlb2YgZi5vbkNsaWNrJiYoYS5vbmNsaWNrPVxuQyl9fVxuZnVuY3Rpb24gc2coYSxiLGMsZCxlKXt2YXIgZj1udWxsO3N3aXRjaChiKXtjYXNlIFwiaW5wdXRcIjpjPUxmKGEsYyk7ZD1MZihhLGQpO2Y9W107YnJlYWs7Y2FzZSBcIm9wdGlvblwiOmM9UmYoYSxjKTtkPVJmKGEsZCk7Zj1bXTticmVhaztjYXNlIFwic2VsZWN0XCI6Yz1CKHt9LGMse3ZhbHVlOnZvaWQgMH0pO2Q9Qih7fSxkLHt2YWx1ZTp2b2lkIDB9KTtmPVtdO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOmM9VWYoYSxjKTtkPVVmKGEsZCk7Zj1bXTticmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjLm9uQ2xpY2smJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLm9uQ2xpY2smJihhLm9uY2xpY2s9Qyl9aGcoYixkLGtnKTt2YXIgZyxoO2E9bnVsbDtmb3IoZyBpbiBjKWlmKCFkLmhhc093blByb3BlcnR5KGcpJiZjLmhhc093blByb3BlcnR5KGcpJiZudWxsIT1jW2ddKWlmKFwic3R5bGVcIj09PWcpZm9yKGggaW4gYj1jW2ddLGIpYi5oYXNPd25Qcm9wZXJ0eShoKSYmKGF8fChhPXt9KSxhW2hdPVxuXCJcIik7ZWxzZVwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIiE9PWcmJlwiY2hpbGRyZW5cIiE9PWcmJlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1nJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09ZyYmXCJhdXRvRm9jdXNcIiE9PWcmJihSYS5oYXNPd25Qcm9wZXJ0eShnKT9mfHwoZj1bXSk6KGY9Znx8W10pLnB1c2goZyxudWxsKSk7Zm9yKGcgaW4gZCl7dmFyIGs9ZFtnXTtiPW51bGwhPWM/Y1tnXTp2b2lkIDA7aWYoZC5oYXNPd25Qcm9wZXJ0eShnKSYmayE9PWImJihudWxsIT1rfHxudWxsIT1iKSlpZihcInN0eWxlXCI9PT1nKWlmKGIpe2ZvcihoIGluIGIpIWIuaGFzT3duUHJvcGVydHkoaCl8fGsmJmsuaGFzT3duUHJvcGVydHkoaCl8fChhfHwoYT17fSksYVtoXT1cIlwiKTtmb3IoaCBpbiBrKWsuaGFzT3duUHJvcGVydHkoaCkmJmJbaF0hPT1rW2hdJiYoYXx8KGE9e30pLGFbaF09a1toXSl9ZWxzZSBhfHwoZnx8KGY9W10pLGYucHVzaChnLGEpKSxhPWs7ZWxzZVwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PVxuZz8oaz1rP2suX19odG1sOnZvaWQgMCxiPWI/Yi5fX2h0bWw6dm9pZCAwLG51bGwhPWsmJmIhPT1rJiYoZj1mfHxbXSkucHVzaChnLFwiXCIraykpOlwiY2hpbGRyZW5cIj09PWc/Yj09PWt8fFwic3RyaW5nXCIhPT10eXBlb2YgayYmXCJudW1iZXJcIiE9PXR5cGVvZiBrfHwoZj1mfHxbXSkucHVzaChnLFwiXCIrayk6XCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIiE9PWcmJlwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCIhPT1nJiYoUmEuaGFzT3duUHJvcGVydHkoZyk/KG51bGwhPWsmJmxnKGUsZyksZnx8Yj09PWt8fChmPVtdKSk6KGY9Znx8W10pLnB1c2goZyxrKSl9YSYmKGY9Znx8W10pLnB1c2goXCJzdHlsZVwiLGEpO3JldHVybiBmfVxuZnVuY3Rpb24gdGcoYSxiLGMsZCxlKXtcImlucHV0XCI9PT1jJiZcInJhZGlvXCI9PT1lLnR5cGUmJm51bGwhPWUubmFtZSYmTmYoYSxlKTtpZyhjLGQpO2Q9aWcoYyxlKTtmb3IodmFyIGY9MDtmPGIubGVuZ3RoO2YrPTIpe3ZhciBnPWJbZl0saD1iW2YrMV07XCJzdHlsZVwiPT09Zz9mZyhhLGgsa2cpOlwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWc/YmcoYSxoKTpcImNoaWxkcmVuXCI9PT1nP2NnKGEsaCk6ZD9udWxsIT1oP0tmKGEsZyxoKTphLnJlbW92ZUF0dHJpYnV0ZShnKTpudWxsIT1oP0lmKGEsZyxoKTpKZihhLGcpfXN3aXRjaChjKXtjYXNlIFwiaW5wdXRcIjpPZihhLGUpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOldmKGEsZSk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWU9dm9pZCAwLGI9YS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlLGEuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZT0hIWUubXVsdGlwbGUsYz1lLnZhbHVlLG51bGwhPWM/U2YoYSxcbiEhZS5tdWx0aXBsZSxjLCExKTpiIT09ISFlLm11bHRpcGxlJiYobnVsbCE9ZS5kZWZhdWx0VmFsdWU/U2YoYSwhIWUubXVsdGlwbGUsZS5kZWZhdWx0VmFsdWUsITApOlNmKGEsISFlLm11bHRpcGxlLGUubXVsdGlwbGU/W106XCJcIiwhMSkpfX1cbmZ1bmN0aW9uIHVnKGEsYixjLGQsZSl7c3dpdGNoKGIpe2Nhc2UgXCJpZnJhbWVcIjpjYXNlIFwib2JqZWN0XCI6VShcInRvcExvYWRcIixcImxvYWRcIixhKTticmVhaztjYXNlIFwidmlkZW9cIjpjYXNlIFwiYXVkaW9cIjpmb3IodmFyIGYgaW4gbWcpbWcuaGFzT3duUHJvcGVydHkoZikmJlUoZixtZ1tmXSxhKTticmVhaztjYXNlIFwic291cmNlXCI6VShcInRvcEVycm9yXCIsXCJlcnJvclwiLGEpO2JyZWFrO2Nhc2UgXCJpbWdcIjpjYXNlIFwiaW1hZ2VcIjpVKFwidG9wRXJyb3JcIixcImVycm9yXCIsYSk7VShcInRvcExvYWRcIixcImxvYWRcIixhKTticmVhaztjYXNlIFwiZm9ybVwiOlUoXCJ0b3BSZXNldFwiLFwicmVzZXRcIixhKTtVKFwidG9wU3VibWl0XCIsXCJzdWJtaXRcIixhKTticmVhaztjYXNlIFwiZGV0YWlsc1wiOlUoXCJ0b3BUb2dnbGVcIixcInRvZ2dsZVwiLGEpO2JyZWFrO2Nhc2UgXCJpbnB1dFwiOk1mKGEsYyk7VShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKTtsZyhlLFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOlRmKGEsYyk7XG5VKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpO2xnKGUsXCJvbkNoYW5nZVwiKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpWZihhLGMpLFUoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSksbGcoZSxcIm9uQ2hhbmdlXCIpfWhnKGIsYyxrZyk7ZD1udWxsO2Zvcih2YXIgZyBpbiBjKWMuaGFzT3duUHJvcGVydHkoZykmJihmPWNbZ10sXCJjaGlsZHJlblwiPT09Zz9cInN0cmluZ1wiPT09dHlwZW9mIGY/YS50ZXh0Q29udGVudCE9PWYmJihkPVtcImNoaWxkcmVuXCIsZl0pOlwibnVtYmVyXCI9PT10eXBlb2YgZiYmYS50ZXh0Q29udGVudCE9PVwiXCIrZiYmKGQ9W1wiY2hpbGRyZW5cIixcIlwiK2ZdKTpSYS5oYXNPd25Qcm9wZXJ0eShnKSYmbnVsbCE9ZiYmbGcoZSxnKSk7c3dpdGNoKGIpe2Nhc2UgXCJpbnB1dFwiOkJjKGEpO1BmKGEsYyk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6QmMoYSk7WGYoYSxjKTticmVhaztjYXNlIFwic2VsZWN0XCI6Y2FzZSBcIm9wdGlvblwiOmJyZWFrO2RlZmF1bHQ6XCJmdW5jdGlvblwiPT09dHlwZW9mIGMub25DbGljayYmXG4oYS5vbmNsaWNrPUMpfXJldHVybiBkfWZ1bmN0aW9uIHZnKGEsYil7cmV0dXJuIGEubm9kZVZhbHVlIT09Yn1cbnZhciB3Zz1PYmplY3QuZnJlZXplKHtjcmVhdGVFbGVtZW50Om5nLGNyZWF0ZVRleHROb2RlOm9nLHNldEluaXRpYWxQcm9wZXJ0aWVzOnBnLGRpZmZQcm9wZXJ0aWVzOnNnLHVwZGF0ZVByb3BlcnRpZXM6dGcsZGlmZkh5ZHJhdGVkUHJvcGVydGllczp1ZyxkaWZmSHlkcmF0ZWRUZXh0OnZnLHdhcm5Gb3JVbm1hdGNoZWRUZXh0OmZ1bmN0aW9uKCl7fSx3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50OmZ1bmN0aW9uKCl7fSx3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0OmZ1bmN0aW9uKCl7fSx3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQ6ZnVuY3Rpb24oKXt9LHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dDpmdW5jdGlvbigpe30scmVzdG9yZUNvbnRyb2xsZWRTdGF0ZTpmdW5jdGlvbihhLGIsYyl7c3dpdGNoKGIpe2Nhc2UgXCJpbnB1dFwiOk9mKGEsYyk7Yj1jLm5hbWU7aWYoXCJyYWRpb1wiPT09Yy50eXBlJiZudWxsIT1iKXtmb3IoYz1hO2MucGFyZW50Tm9kZTspYz1cbmMucGFyZW50Tm9kZTtjPWMucXVlcnlTZWxlY3RvckFsbChcImlucHV0W25hbWVcXHgzZFwiK0pTT04uc3RyaW5naWZ5KFwiXCIrYikrJ11bdHlwZVxceDNkXCJyYWRpb1wiXScpO2ZvcihiPTA7YjxjLmxlbmd0aDtiKyspe3ZhciBkPWNbYl07aWYoZCE9PWEmJmQuZm9ybT09PWEuZm9ybSl7dmFyIGU9cmIoZCk7ZT92b2lkIDA6RShcIjkwXCIpO0NjKGQpO09mKGQsZSl9fX1icmVhaztjYXNlIFwidGV4dGFyZWFcIjpXZihhLGMpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpiPWMudmFsdWUsbnVsbCE9YiYmU2YoYSwhIWMubXVsdGlwbGUsYiwhMSl9fX0pO25jLmluamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQod2cpO3ZhciB4Zz1udWxsLE1nPW51bGw7ZnVuY3Rpb24gTmcoYSl7cmV0dXJuISghYXx8MSE9PWEubm9kZVR5cGUmJjkhPT1hLm5vZGVUeXBlJiYxMSE9PWEubm9kZVR5cGUmJig4IT09YS5ub2RlVHlwZXx8XCIgcmVhY3QtbW91bnQtcG9pbnQtdW5zdGFibGUgXCIhPT1hLm5vZGVWYWx1ZSkpfVxuZnVuY3Rpb24gT2coYSl7YT1hPzk9PT1hLm5vZGVUeXBlP2EuZG9jdW1lbnRFbGVtZW50OmEuZmlyc3RDaGlsZDpudWxsO3JldHVybiEoIWF8fDEhPT1hLm5vZGVUeXBlfHwhYS5oYXNBdHRyaWJ1dGUoXCJkYXRhLXJlYWN0cm9vdFwiKSl9XG52YXIgWj1vZih7Z2V0Um9vdEhvc3RDb250ZXh0OmZ1bmN0aW9uKGEpe3ZhciBiPWEubm9kZVR5cGU7c3dpdGNoKGIpe2Nhc2UgOTpjYXNlIDExOmE9KGE9YS5kb2N1bWVudEVsZW1lbnQpP2EubmFtZXNwYWNlVVJJOiRmKG51bGwsXCJcIik7YnJlYWs7ZGVmYXVsdDpiPTg9PT1iP2EucGFyZW50Tm9kZTphLGE9Yi5uYW1lc3BhY2VVUkl8fG51bGwsYj1iLnRhZ05hbWUsYT0kZihhLGIpfXJldHVybiBhfSxnZXRDaGlsZEhvc3RDb250ZXh0OmZ1bmN0aW9uKGEsYil7cmV0dXJuICRmKGEsYil9LGdldFB1YmxpY0luc3RhbmNlOmZ1bmN0aW9uKGEpe3JldHVybiBhfSxwcmVwYXJlRm9yQ29tbWl0OmZ1bmN0aW9uKCl7eGc9dGQ7dmFyIGE9ZGEoKTtpZihLZChhKSl7aWYoXCJzZWxlY3Rpb25TdGFydFwiaW4gYSl2YXIgYj17c3RhcnQ6YS5zZWxlY3Rpb25TdGFydCxlbmQ6YS5zZWxlY3Rpb25FbmR9O2Vsc2UgYTp7dmFyIGM9d2luZG93LmdldFNlbGVjdGlvbiYmd2luZG93LmdldFNlbGVjdGlvbigpO1xuaWYoYyYmMCE9PWMucmFuZ2VDb3VudCl7Yj1jLmFuY2hvck5vZGU7dmFyIGQ9Yy5hbmNob3JPZmZzZXQsZT1jLmZvY3VzTm9kZTtjPWMuZm9jdXNPZmZzZXQ7dHJ5e2Iubm9kZVR5cGUsZS5ub2RlVHlwZX1jYXRjaCh6KXtiPW51bGw7YnJlYWsgYX12YXIgZj0wLGc9LTEsaD0tMSxrPTAscT0wLHY9YSx5PW51bGw7Yjpmb3IoOzspe2Zvcih2YXIgdTs7KXt2IT09Ynx8MCE9PWQmJjMhPT12Lm5vZGVUeXBlfHwoZz1mK2QpO3YhPT1lfHwwIT09YyYmMyE9PXYubm9kZVR5cGV8fChoPWYrYyk7Mz09PXYubm9kZVR5cGUmJihmKz12Lm5vZGVWYWx1ZS5sZW5ndGgpO2lmKG51bGw9PT0odT12LmZpcnN0Q2hpbGQpKWJyZWFrO3k9djt2PXV9Zm9yKDs7KXtpZih2PT09YSlicmVhayBiO3k9PT1iJiYrK2s9PT1kJiYoZz1mKTt5PT09ZSYmKytxPT09YyYmKGg9Zik7aWYobnVsbCE9PSh1PXYubmV4dFNpYmxpbmcpKWJyZWFrO3Y9eTt5PXYucGFyZW50Tm9kZX12PXV9Yj0tMT09PWd8fC0xPT09aD9udWxsOlxue3N0YXJ0OmcsZW5kOmh9fWVsc2UgYj1udWxsfWI9Ynx8e3N0YXJ0OjAsZW5kOjB9fWVsc2UgYj1udWxsO01nPXtmb2N1c2VkRWxlbTphLHNlbGVjdGlvblJhbmdlOmJ9O3VkKCExKX0scmVzZXRBZnRlckNvbW1pdDpmdW5jdGlvbigpe3ZhciBhPU1nLGI9ZGEoKSxjPWEuZm9jdXNlZEVsZW0sZD1hLnNlbGVjdGlvblJhbmdlO2lmKGIhPT1jJiZmYShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsYykpe2lmKEtkKGMpKWlmKGI9ZC5zdGFydCxhPWQuZW5kLHZvaWQgMD09PWEmJihhPWIpLFwic2VsZWN0aW9uU3RhcnRcImluIGMpYy5zZWxlY3Rpb25TdGFydD1iLGMuc2VsZWN0aW9uRW5kPU1hdGgubWluKGEsYy52YWx1ZS5sZW5ndGgpO2Vsc2UgaWYod2luZG93LmdldFNlbGVjdGlvbil7Yj13aW5kb3cuZ2V0U2VsZWN0aW9uKCk7dmFyIGU9Y1tFYigpXS5sZW5ndGg7YT1NYXRoLm1pbihkLnN0YXJ0LGUpO2Q9dm9pZCAwPT09ZC5lbmQ/YTpNYXRoLm1pbihkLmVuZCxlKTshYi5leHRlbmQmJmE+XG5kJiYoZT1kLGQ9YSxhPWUpO2U9SmQoYyxhKTt2YXIgZj1KZChjLGQpO2lmKGUmJmYmJigxIT09Yi5yYW5nZUNvdW50fHxiLmFuY2hvck5vZGUhPT1lLm5vZGV8fGIuYW5jaG9yT2Zmc2V0IT09ZS5vZmZzZXR8fGIuZm9jdXNOb2RlIT09Zi5ub2RlfHxiLmZvY3VzT2Zmc2V0IT09Zi5vZmZzZXQpKXt2YXIgZz1kb2N1bWVudC5jcmVhdGVSYW5nZSgpO2cuc2V0U3RhcnQoZS5ub2RlLGUub2Zmc2V0KTtiLnJlbW92ZUFsbFJhbmdlcygpO2E+ZD8oYi5hZGRSYW5nZShnKSxiLmV4dGVuZChmLm5vZGUsZi5vZmZzZXQpKTooZy5zZXRFbmQoZi5ub2RlLGYub2Zmc2V0KSxiLmFkZFJhbmdlKGcpKX19Yj1bXTtmb3IoYT1jO2E9YS5wYXJlbnROb2RlOykxPT09YS5ub2RlVHlwZSYmYi5wdXNoKHtlbGVtZW50OmEsbGVmdDphLnNjcm9sbExlZnQsdG9wOmEuc2Nyb2xsVG9wfSk7aWEoYyk7Zm9yKGM9MDtjPGIubGVuZ3RoO2MrKylhPWJbY10sYS5lbGVtZW50LnNjcm9sbExlZnQ9YS5sZWZ0LGEuZWxlbWVudC5zY3JvbGxUb3A9XG5hLnRvcH1NZz1udWxsO3VkKHhnKTt4Zz1udWxsfSxjcmVhdGVJbnN0YW5jZTpmdW5jdGlvbihhLGIsYyxkLGUpe2E9bmcoYSxiLGMsZCk7YVtRXT1lO2Fbb2JdPWI7cmV0dXJuIGF9LGFwcGVuZEluaXRpYWxDaGlsZDpmdW5jdGlvbihhLGIpe2EuYXBwZW5kQ2hpbGQoYil9LGZpbmFsaXplSW5pdGlhbENoaWxkcmVuOmZ1bmN0aW9uKGEsYixjLGQpe3BnKGEsYixjLGQpO2E6e3N3aXRjaChiKXtjYXNlIFwiYnV0dG9uXCI6Y2FzZSBcImlucHV0XCI6Y2FzZSBcInNlbGVjdFwiOmNhc2UgXCJ0ZXh0YXJlYVwiOmE9ISFjLmF1dG9Gb2N1czticmVhayBhfWE9ITF9cmV0dXJuIGF9LHByZXBhcmVVcGRhdGU6ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gc2coYSxiLGMsZCxlKX0sc2hvdWxkU2V0VGV4dENvbnRlbnQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm5cInRleHRhcmVhXCI9PT1hfHxcInN0cmluZ1wiPT09dHlwZW9mIGIuY2hpbGRyZW58fFwibnVtYmVyXCI9PT10eXBlb2YgYi5jaGlsZHJlbnx8XCJvYmplY3RcIj09PVxudHlwZW9mIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJm51bGwhPT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZcInN0cmluZ1wiPT09dHlwZW9mIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sfSxzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlOmZ1bmN0aW9uKGEsYil7cmV0dXJuISFiLmhpZGRlbn0sY3JlYXRlVGV4dEluc3RhbmNlOmZ1bmN0aW9uKGEsYixjLGQpe2E9b2coYSxiKTthW1FdPWQ7cmV0dXJuIGF9LG5vdzpyZixtdXRhdGlvbjp7Y29tbWl0TW91bnQ6ZnVuY3Rpb24oYSl7YS5mb2N1cygpfSxjb21taXRVcGRhdGU6ZnVuY3Rpb24oYSxiLGMsZCxlKXthW29iXT1lO3RnKGEsYixjLGQsZSl9LHJlc2V0VGV4dENvbnRlbnQ6ZnVuY3Rpb24oYSl7YS50ZXh0Q29udGVudD1cIlwifSxjb21taXRUZXh0VXBkYXRlOmZ1bmN0aW9uKGEsYixjKXthLm5vZGVWYWx1ZT1jfSxhcHBlbmRDaGlsZDpmdW5jdGlvbihhLGIpe2EuYXBwZW5kQ2hpbGQoYil9LGFwcGVuZENoaWxkVG9Db250YWluZXI6ZnVuY3Rpb24oYSxcbmIpezg9PT1hLm5vZGVUeXBlP2EucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYixhKTphLmFwcGVuZENoaWxkKGIpfSxpbnNlcnRCZWZvcmU6ZnVuY3Rpb24oYSxiLGMpe2EuaW5zZXJ0QmVmb3JlKGIsYyl9LGluc2VydEluQ29udGFpbmVyQmVmb3JlOmZ1bmN0aW9uKGEsYixjKXs4PT09YS5ub2RlVHlwZT9hLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGIsYyk6YS5pbnNlcnRCZWZvcmUoYixjKX0scmVtb3ZlQ2hpbGQ6ZnVuY3Rpb24oYSxiKXthLnJlbW92ZUNoaWxkKGIpfSxyZW1vdmVDaGlsZEZyb21Db250YWluZXI6ZnVuY3Rpb24oYSxiKXs4PT09YS5ub2RlVHlwZT9hLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYik6YS5yZW1vdmVDaGlsZChiKX19LGh5ZHJhdGlvbjp7Y2FuSHlkcmF0ZUluc3RhbmNlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIDEhPT1hLm5vZGVUeXBlfHxiLnRvTG93ZXJDYXNlKCkhPT1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk/bnVsbDphfSxjYW5IeWRyYXRlVGV4dEluc3RhbmNlOmZ1bmN0aW9uKGEsXG5iKXtyZXR1cm5cIlwiPT09Ynx8MyE9PWEubm9kZVR5cGU/bnVsbDphfSxnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmc6ZnVuY3Rpb24oYSl7Zm9yKGE9YS5uZXh0U2libGluZzthJiYxIT09YS5ub2RlVHlwZSYmMyE9PWEubm9kZVR5cGU7KWE9YS5uZXh0U2libGluZztyZXR1cm4gYX0sZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQ6ZnVuY3Rpb24oYSl7Zm9yKGE9YS5maXJzdENoaWxkO2EmJjEhPT1hLm5vZGVUeXBlJiYzIT09YS5ub2RlVHlwZTspYT1hLm5leHRTaWJsaW5nO3JldHVybiBhfSxoeWRyYXRlSW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2FbUV09ZjthW29iXT1jO3JldHVybiB1ZyhhLGIsYyxlLGQpfSxoeWRyYXRlVGV4dEluc3RhbmNlOmZ1bmN0aW9uKGEsYixjKXthW1FdPWM7cmV0dXJuIHZnKGEsYil9LGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oKXt9LGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oKXt9LFxuZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RIeWRyYXRlSW5zdGFuY2U6ZnVuY3Rpb24oKXt9LGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2U6ZnVuY3Rpb24oKXt9LGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZTpmdW5jdGlvbigpe319LHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjazpzZixjYW5jZWxEZWZlcnJlZENhbGxiYWNrOnRmLHVzZVN5bmNTY2hlZHVsaW5nOiEwfSk7cmM9Wi5iYXRjaGVkVXBkYXRlcztcbmZ1bmN0aW9uIFBnKGEsYixjLGQsZSl7TmcoYyk/dm9pZCAwOkUoXCIyMDBcIik7dmFyIGY9Yy5fcmVhY3RSb290Q29udGFpbmVyO2lmKGYpWi51cGRhdGVDb250YWluZXIoYixmLGEsZSk7ZWxzZXtkPWR8fE9nKGMpO2lmKCFkKWZvcihmPXZvaWQgMDtmPWMubGFzdENoaWxkOyljLnJlbW92ZUNoaWxkKGYpO3ZhciBnPVouY3JlYXRlQ29udGFpbmVyKGMsZCk7Zj1jLl9yZWFjdFJvb3RDb250YWluZXI9ZztaLnVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24oKXtaLnVwZGF0ZUNvbnRhaW5lcihiLGcsYSxlKX0pfXJldHVybiBaLmdldFB1YmxpY1Jvb3RJbnN0YW5jZShmKX1mdW5jdGlvbiBRZyhhLGIpe3ZhciBjPTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsO05nKGIpP3ZvaWQgMDpFKFwiMjAwXCIpO3JldHVybiBwZihhLGIsbnVsbCxjKX1cbmZ1bmN0aW9uIFJnKGEsYil7dGhpcy5fcmVhY3RSb290Q29udGFpbmVyPVouY3JlYXRlQ29udGFpbmVyKGEsYil9UmcucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihhLGIpe1oudXBkYXRlQ29udGFpbmVyKGEsdGhpcy5fcmVhY3RSb290Q29udGFpbmVyLG51bGwsYil9O1JnLnByb3RvdHlwZS51bm1vdW50PWZ1bmN0aW9uKGEpe1oudXBkYXRlQ29udGFpbmVyKG51bGwsdGhpcy5fcmVhY3RSb290Q29udGFpbmVyLG51bGwsYSl9O1xudmFyIFNnPXtjcmVhdGVQb3J0YWw6UWcsZmluZERPTU5vZGU6ZnVuY3Rpb24oYSl7aWYobnVsbD09YSlyZXR1cm4gbnVsbDtpZigxPT09YS5ub2RlVHlwZSlyZXR1cm4gYTt2YXIgYj1hLl9yZWFjdEludGVybmFsRmliZXI7aWYoYilyZXR1cm4gWi5maW5kSG9zdEluc3RhbmNlKGIpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBhLnJlbmRlcj9FKFwiMTg4XCIpOkUoXCIyMTNcIixPYmplY3Qua2V5cyhhKSl9LGh5ZHJhdGU6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBQZyhudWxsLGEsYiwhMCxjKX0scmVuZGVyOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gUGcobnVsbCxhLGIsITEsYyl9LHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOmZ1bmN0aW9uKGEsYixjLGQpe251bGw9PWF8fHZvaWQgMD09PWEuX3JlYWN0SW50ZXJuYWxGaWJlcj9FKFwiMzhcIik6dm9pZCAwO3JldHVybiBQZyhhLGIsYywhMSxkKX0sdW5tb3VudENvbXBvbmVudEF0Tm9kZTpmdW5jdGlvbihhKXtOZyhhKT92b2lkIDA6XG5FKFwiNDBcIik7cmV0dXJuIGEuX3JlYWN0Um9vdENvbnRhaW5lcj8oWi51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uKCl7UGcobnVsbCxudWxsLGEsITEsZnVuY3Rpb24oKXthLl9yZWFjdFJvb3RDb250YWluZXI9bnVsbH0pfSksITApOiExfSx1bnN0YWJsZV9jcmVhdGVQb3J0YWw6UWcsdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6dGMsdW5zdGFibGVfZGVmZXJyZWRVcGRhdGVzOlouZGVmZXJyZWRVcGRhdGVzLGZsdXNoU3luYzpaLmZsdXNoU3luYyxfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDp7RXZlbnRQbHVnaW5IdWI6bWIsRXZlbnRQbHVnaW5SZWdpc3RyeTpWYSxFdmVudFByb3BhZ2F0b3JzOkNiLFJlYWN0Q29udHJvbGxlZENvbXBvbmVudDpxYyxSZWFjdERPTUNvbXBvbmVudFRyZWU6c2IsUmVhY3RET01FdmVudExpc3RlbmVyOnhkfX07XG5aLmluamVjdEludG9EZXZUb29scyh7ZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6cGIsYnVuZGxlVHlwZTowLHZlcnNpb246XCIxNi4yLjBcIixyZW5kZXJlclBhY2thZ2VOYW1lOlwicmVhY3QtZG9tXCJ9KTt2YXIgVGc9T2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDpTZ30pLFVnPVRnJiZTZ3x8VGc7bW9kdWxlLmV4cG9ydHM9VWdbXCJkZWZhdWx0XCJdP1VnW1wiZGVmYXVsdFwiXTpVZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMTUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpLCByZXF1aXJlKFwiaGlnaGNoYXJ0cy9oaWdoc3RvY2tcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wicmVhY3RcIiwgXCJoaWdoY2hhcnRzL2hpZ2hzdG9ja1wiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJSZWFjdEhpZ2hzdG9ja1wiXSA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpLCByZXF1aXJlKFwiaGlnaGNoYXJ0cy9oaWdoc3RvY2tcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlJlYWN0SGlnaHN0b2NrXCJdID0gZmFjdG9yeShyb290W1wiUmVhY3RcIl0sIHJvb3RbXCJIaWdoY2hhcnRzXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzIzX18pIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyNSk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKHByb2Nlc3MpIHsvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSlcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygwKSkpXG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV81X187XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuXG52YXIgX2Fzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBlbXB0eU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG52YXIgX2ludmFyaWFudCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciB3YXJuaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbn1cblxudmFyIE1JWElOU19LRVkgPSAnbWl4aW5zJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFsbG93IHRoZSBjcmVhdGlvbiBvZiBhbm9ueW1vdXMgZnVuY3Rpb25zIHdoaWNoIGRvIG5vdFxuLy8gaGF2ZSAubmFtZSBzZXQgdG8gdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIGJlaW5nIGFzc2lnbmVkIHRvLlxuZnVuY3Rpb24gaWRlbnRpdHkoZm4pIHtcbiAgcmV0dXJuIGZuO1xufVxuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXM7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHtcbiAgICBwcm9wOiAncHJvcCcsXG4gICAgY29udGV4dDogJ2NvbnRleHQnLFxuICAgIGNoaWxkQ29udGV4dDogJ2NoaWxkIGNvbnRleHQnXG4gIH07XG59IGVsc2Uge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBmYWN0b3J5KFJlYWN0Q29tcG9uZW50LCBpc1ZhbGlkRWxlbWVudCwgUmVhY3ROb29wVXBkYXRlUXVldWUpIHtcbiAgLyoqXG4gICAqIFBvbGljaWVzIHRoYXQgZGVzY3JpYmUgbWV0aG9kcyBpbiBgUmVhY3RDbGFzc0ludGVyZmFjZWAuXG4gICAqL1xuXG4gIHZhciBpbmplY3RlZE1peGlucyA9IFtdO1xuXG4gIC8qKlxuICAgKiBDb21wb3NpdGUgY29tcG9uZW50cyBhcmUgaGlnaGVyLWxldmVsIGNvbXBvbmVudHMgdGhhdCBjb21wb3NlIG90aGVyIGNvbXBvc2l0ZVxuICAgKiBvciBob3N0IGNvbXBvbmVudHMuXG4gICAqXG4gICAqIFRvIGNyZWF0ZSBhIG5ldyB0eXBlIG9mIGBSZWFjdENsYXNzYCwgcGFzcyBhIHNwZWNpZmljYXRpb24gb2ZcbiAgICogeW91ciBuZXcgY2xhc3MgdG8gYFJlYWN0LmNyZWF0ZUNsYXNzYC4gVGhlIG9ubHkgcmVxdWlyZW1lbnQgb2YgeW91ciBjbGFzc1xuICAgKiBzcGVjaWZpY2F0aW9uIGlzIHRoYXQgeW91IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC5cbiAgICpcbiAgICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICByZXR1cm4gPGRpdj5IZWxsbyBXb3JsZDwvZGl2PjtcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogVGhlIGNsYXNzIHNwZWNpZmljYXRpb24gc3VwcG9ydHMgYSBzcGVjaWZpYyBwcm90b2NvbCBvZiBtZXRob2RzIHRoYXQgaGF2ZVxuICAgKiBzcGVjaWFsIG1lYW5pbmcgKGUuZy4gYHJlbmRlcmApLiBTZWUgYFJlYWN0Q2xhc3NJbnRlcmZhY2VgIGZvclxuICAgKiBtb3JlIHRoZSBjb21wcmVoZW5zaXZlIHByb3RvY29sLiBBbnkgb3RoZXIgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBpbiB0aGVcbiAgICogY2xhc3Mgc3BlY2lmaWNhdGlvbiB3aWxsIGJlIGF2YWlsYWJsZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgKlxuICAgKiBAaW50ZXJmYWNlIFJlYWN0Q2xhc3NJbnRlcmZhY2VcbiAgICogQGludGVybmFsXG4gICAqL1xuICB2YXIgUmVhY3RDbGFzc0ludGVyZmFjZSA9IHtcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBNaXhpbiBvYmplY3RzIHRvIGluY2x1ZGUgd2hlbiBkZWZpbmluZyB5b3VyIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBtaXhpbnM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRoYXQgc2hvdWxkIGJlIGRlZmluZWQgb25cbiAgICAgKiB0aGUgY29tcG9uZW50J3MgY29uc3RydWN0b3IgaW5zdGVhZCBvZiBpdHMgcHJvdG90eXBlIChzdGF0aWMgbWV0aG9kcykuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIHN0YXRpY3M6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbml0aW9uIG9mIHByb3AgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBwcm9wVHlwZXM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb250ZXh0VHlwZXM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgdGhpcyBjb21wb25lbnQgc2V0cyBmb3IgaXRzIGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjaGlsZENvbnRleHRUeXBlczogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8vID09PT0gRGVmaW5pdGlvbiBtZXRob2RzID09PT1cblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFZhbHVlcyBpbiB0aGUgbWFwcGluZyB3aWxsIGJlIHNldCBvblxuICAgICAqIGB0aGlzLnByb3BzYCBpZiB0aGF0IHByb3AgaXMgbm90IHNwZWNpZmllZCAoaS5lLiB1c2luZyBhbiBgaW5gIGNoZWNrKS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYmVmb3JlIGBnZXRJbml0aWFsU3RhdGVgIGFuZCB0aGVyZWZvcmUgY2Fubm90IHJlbHlcbiAgICAgKiBvbiBgdGhpcy5zdGF0ZWAgb3IgdXNlIGB0aGlzLnNldFN0YXRlYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBnZXREZWZhdWx0UHJvcHM6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBvbmNlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAgICogYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgYHRoaXMuc3RhdGVgLlxuICAgICAqXG4gICAgICogICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICByZXR1cm4ge1xuICAgICAqICAgICAgIGlzT246IGZhbHNlLFxuICAgICAqICAgICAgIGZvb0JhejogbmV3IEJhekZvbygpXG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBnZXRJbml0aWFsU3RhdGU6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGdldENoaWxkQ29udGV4dDogJ0RFRklORV9NQU5ZX01FUkdFRCcsXG5cbiAgICAvKipcbiAgICAgKiBVc2VzIHByb3BzIGZyb20gYHRoaXMucHJvcHNgIGFuZCBzdGF0ZSBmcm9tIGB0aGlzLnN0YXRlYCB0byByZW5kZXIgdGhlXG4gICAgICogc3RydWN0dXJlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBObyBndWFyYW50ZWVzIGFyZSBtYWRlIGFib3V0IHdoZW4gb3IgaG93IG9mdGVuIHRoaXMgbWV0aG9kIGlzIGludm9rZWQsIHNvXG4gICAgICogaXQgbXVzdCBub3QgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gICAgICpcbiAgICAgKiAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuICAgICAqICAgICByZXR1cm4gPGRpdj5IZWxsbywge25hbWV9ITwvZGl2PjtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICAgICAqIEByZXF1aXJlZFxuICAgICAqL1xuICAgIHJlbmRlcjogJ0RFRklORV9PTkNFJyxcblxuICAgIC8vID09PT0gRGVsZWdhdGUgbWV0aG9kcyA9PT09XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBpbml0aWFsbHkgY3JlYXRlZCBhbmQgYWJvdXQgdG8gYmUgbW91bnRlZC5cbiAgICAgKiBUaGlzIG1heSBoYXZlIHNpZGUgZWZmZWN0cywgYnV0IGFueSBleHRlcm5hbCBzdWJzY3JpcHRpb25zIG9yIGRhdGEgY3JlYXRlZFxuICAgICAqIGJ5IHRoaXMgbWV0aG9kIG11c3QgYmUgY2xlYW5lZCB1cCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgLlxuICAgICAqXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbE1vdW50OiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCBhbmQgaGFzIGEgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEhvd2V2ZXIsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBET00gbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgICAqIGJlZW4gbW91bnRlZCAoaW5pdGlhbGl6ZWQgYW5kIHJlbmRlcmVkKSBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZE1vdW50OiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCByZWNlaXZlcyBuZXcgcHJvcHMuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byByZWFjdCB0byBhIHByb3AgdHJhbnNpdGlvbiBieSB1cGRhdGluZyB0aGVcbiAgICAgKiBzdGF0ZSB1c2luZyBgdGhpcy5zZXRTdGF0ZWAuIEN1cnJlbnQgcHJvcHMgYXJlIGFjY2Vzc2VkIHZpYSBgdGhpcy5wcm9wc2AuXG4gICAgICpcbiAgICAgKiAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICAgKiAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICogICAgICAgbGlrZXNJbmNyZWFzaW5nOiBuZXh0UHJvcHMubGlrZUNvdW50ID4gdGhpcy5wcm9wcy5saWtlQ291bnRcbiAgICAgKiAgICAgfSk7XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGVyZSBpcyBubyBlcXVpdmFsZW50IGBjb21wb25lbnRXaWxsUmVjZWl2ZVN0YXRlYC4gQW4gaW5jb21pbmcgcHJvcFxuICAgICAqIHRyYW5zaXRpb24gbWF5IGNhdXNlIGEgc3RhdGUgY2hhbmdlLCBidXQgdGhlIG9wcG9zaXRlIGlzIG5vdCB0cnVlLiBJZiB5b3VcbiAgICAgKiBuZWVkIGl0LCB5b3UgYXJlIHByb2JhYmx5IGxvb2tpbmcgZm9yIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGlsZSBkZWNpZGluZyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSB1cGRhdGVkIGFzIGEgcmVzdWx0IG9mXG4gICAgICogcmVjZWl2aW5nIG5ldyBwcm9wcywgc3RhdGUgYW5kL29yIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBgcmV0dXJuIGZhbHNlYCB3aGVuIHlvdSdyZSBjZXJ0YWluIHRoYXQgdGhlXG4gICAgICogdHJhbnNpdGlvbiB0byB0aGUgbmV3IHByb3BzL3N0YXRlL2NvbnRleHQgd2lsbCBub3QgcmVxdWlyZSBhIGNvbXBvbmVudFxuICAgICAqIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgICAgKiAgICAgcmV0dXJuICFlcXVhbChuZXh0UHJvcHMsIHRoaXMucHJvcHMpIHx8XG4gICAgICogICAgICAgIWVxdWFsKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkgfHxcbiAgICAgKiAgICAgICAhZXF1YWwobmV4dENvbnRleHQsIHRoaXMuY29udGV4dCk7XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29tcG9uZW50IHNob3VsZCB1cGRhdGUuXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiAnREVGSU5FX09OQ0UnLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gdXBkYXRlIGR1ZSB0byBhIHRyYW5zaXRpb24gZnJvbVxuICAgICAqIGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YCB0byBgbmV4dFByb3BzYCwgYG5leHRTdGF0ZWBcbiAgICAgKiBhbmQgYG5leHRDb250ZXh0YC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHBlcmZvcm0gcHJlcGFyYXRpb24gYmVmb3JlIGFuIHVwZGF0ZSBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBOT1RFOiBZb3UgKipjYW5ub3QqKiB1c2UgYHRoaXMuc2V0U3RhdGUoKWAgaW4gdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxVcGRhdGU6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCdzIERPTSByZXByZXNlbnRhdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICAgKiBiZWVuIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJldlByb3BzXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2U3RhdGVcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDb250ZXh0XG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRVcGRhdGU6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBhbmQgaGF2ZVxuICAgICAqIGl0cyBET00gcmVwcmVzZW50YXRpb24gZGVzdHJveWVkLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gZGVhbGxvY2F0ZSBhbnkgZXh0ZXJuYWwgcmVzb3VyY2VzLlxuICAgICAqXG4gICAgICogTk9URTogVGhlcmUgaXMgbm8gYGNvbXBvbmVudERpZFVubW91bnRgIHNpbmNlIHlvdXIgY29tcG9uZW50IHdpbGwgaGF2ZSBiZWVuXG4gICAgICogZGVzdHJveWVkIGJ5IHRoYXQgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8vID09PT0gQWR2YW5jZWQgbWV0aG9kcyA9PT09XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQncyBjdXJyZW50bHkgbW91bnRlZCBET00gcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAb3ZlcnJpZGFibGVcbiAgICAgKi9cbiAgICB1cGRhdGVDb21wb25lbnQ6ICdPVkVSUklERV9CQVNFJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gY2xhc3Mgc3BlY2lmaWNhdGlvbiBrZXlzIHRvIHNwZWNpYWwgcHJvY2Vzc2luZyBmdW5jdGlvbnMuXG4gICAqXG4gICAqIEFsdGhvdWdoIHRoZXNlIGFyZSBkZWNsYXJlZCBsaWtlIGluc3RhbmNlIHByb3BlcnRpZXMgaW4gdGhlIHNwZWNpZmljYXRpb25cbiAgICogd2hlbiBkZWZpbmluZyBjbGFzc2VzIHVzaW5nIGBSZWFjdC5jcmVhdGVDbGFzc2AsIHRoZXkgYXJlIGFjdHVhbGx5IHN0YXRpY1xuICAgKiBhbmQgYXJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgdGhlIHByb3RvdHlwZS4gRGVzcGl0ZVxuICAgKiBiZWluZyBzdGF0aWMsIHRoZXkgbXVzdCBiZSBkZWZpbmVkIG91dHNpZGUgb2YgdGhlIFwic3RhdGljc1wiIGtleSB1bmRlclxuICAgKiB3aGljaCBhbGwgb3RoZXIgc3RhdGljIG1ldGhvZHMgYXJlIGRlZmluZWQuXG4gICAqL1xuICB2YXIgUkVTRVJWRURfU1BFQ19LRVlTID0ge1xuICAgIGRpc3BsYXlOYW1lOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgZGlzcGxheU5hbWUpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgfSxcbiAgICBtaXhpbnM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBtaXhpbnMpIHtcbiAgICAgIGlmIChtaXhpbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgbWl4aW5zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2hpbGRDb250ZXh0VHlwZXM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcywgJ2NoaWxkQ29udGV4dCcpO1xuICAgICAgfVxuICAgICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPSBfYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMsXG4gICAgICAgIGNoaWxkQ29udGV4dFR5cGVzXG4gICAgICApO1xuICAgIH0sXG4gICAgY29udGV4dFR5cGVzOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcywgJ2NvbnRleHQnKTtcbiAgICAgIH1cbiAgICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyA9IF9hc3NpZ24oXG4gICAgICAgIHt9LFxuICAgICAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMsXG4gICAgICAgIGNvbnRleHRUeXBlc1xuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuICAgICAqIGF1dG9tYXRpYyBtZXJnaW5nLlxuICAgICAqL1xuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIGdldERlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihcbiAgICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMsXG4gICAgICAgICAgZ2V0RGVmYXVsdFByb3BzXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHM7XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wVHlwZXM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzLCAncHJvcCcpO1xuICAgICAgfVxuICAgICAgQ29uc3RydWN0b3IucHJvcFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IucHJvcFR5cGVzLCBwcm9wVHlwZXMpO1xuICAgIH0sXG4gICAgc3RhdGljczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICAgIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKTtcbiAgICB9LFxuICAgIGF1dG9iaW5kOiBmdW5jdGlvbigpIHt9XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCB0eXBlRGVmLCBsb2NhdGlvbikge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHR5cGVEZWYpIHtcbiAgICAgIGlmICh0eXBlRGVmLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAvLyB1c2UgYSB3YXJuaW5nIGluc3RlYWQgb2YgYW4gX2ludmFyaWFudCBzbyBjb21wb25lbnRzXG4gICAgICAgIC8vIGRvbid0IHNob3cgdXAgaW4gcHJvZCBidXQgb25seSBpbiBfX0RFVl9fXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgIHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgK1xuICAgICAgICAgICAgICAnUmVhY3QuUHJvcFR5cGVzLicsXG4gICAgICAgICAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsXG4gICAgICAgICAgICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sXG4gICAgICAgICAgICBwcm9wTmFtZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpIHtcbiAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgID8gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXVxuICAgICAgOiBudWxsO1xuXG4gICAgLy8gRGlzYWxsb3cgb3ZlcnJpZGluZyBvZiBiYXNlIGNsYXNzIG1ldGhvZHMgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgICBpZiAoUmVhY3RDbGFzc01peGluLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBfaW52YXJpYW50KFxuICAgICAgICBzcGVjUG9saWN5ID09PSAnT1ZFUlJJREVfQkFTRScsXG4gICAgICAgICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gb3ZlcnJpZGUgJyArXG4gICAgICAgICAgJ2Alc2AgZnJvbSB5b3VyIGNsYXNzIHNwZWNpZmljYXRpb24uIEVuc3VyZSB0aGF0IHlvdXIgbWV0aG9kIG5hbWVzICcgK1xuICAgICAgICAgICdkbyBub3Qgb3ZlcmxhcCB3aXRoIFJlYWN0IG1ldGhvZHMuJyxcbiAgICAgICAgbmFtZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEaXNhbGxvdyBkZWZpbmluZyBtZXRob2RzIG1vcmUgdGhhbiBvbmNlIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgIHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWScgfHwgc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZX01FUkdFRCcsXG4gICAgICAgICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgK1xuICAgICAgICAgICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgJyArXG4gICAgICAgICAgJ3RvIGEgbWl4aW4uJyxcbiAgICAgICAgbmFtZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWl4aW4gaGVscGVyIHdoaWNoIGhhbmRsZXMgcG9saWN5IHZhbGlkYXRpb24gYW5kIHJlc2VydmVkXG4gICAqIHNwZWNpZmljYXRpb24ga2V5cyB3aGVuIGJ1aWxkaW5nIFJlYWN0IGNsYXNzZXMuXG4gICAqL1xuICBmdW5jdGlvbiBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYykge1xuICAgIGlmICghc3BlYykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHR5cGVvZlNwZWMgPSB0eXBlb2Ygc3BlYztcbiAgICAgICAgdmFyIGlzTWl4aW5WYWxpZCA9IHR5cGVvZlNwZWMgPT09ICdvYmplY3QnICYmIHNwZWMgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgaXNNaXhpblZhbGlkLFxuICAgICAgICAgICAgXCIlczogWW91J3JlIGF0dGVtcHRpbmcgdG8gaW5jbHVkZSBhIG1peGluIHRoYXQgaXMgZWl0aGVyIG51bGwgXCIgK1xuICAgICAgICAgICAgICAnb3Igbm90IGFuIG9iamVjdC4gQ2hlY2sgdGhlIG1peGlucyBpbmNsdWRlZCBieSB0aGUgY29tcG9uZW50LCAnICtcbiAgICAgICAgICAgICAgJ2FzIHdlbGwgYXMgYW55IG1peGlucyB0aGV5IGluY2x1ZGUgdGhlbXNlbHZlcy4gJyArXG4gICAgICAgICAgICAgICdFeHBlY3RlZCBvYmplY3QgYnV0IGdvdCAlcy4nLFxuICAgICAgICAgICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLFxuICAgICAgICAgICAgc3BlYyA9PT0gbnVsbCA/IG51bGwgOiB0eXBlb2ZTcGVjXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX2ludmFyaWFudChcbiAgICAgIHR5cGVvZiBzcGVjICE9PSAnZnVuY3Rpb24nLFxuICAgICAgXCJSZWFjdENsYXNzOiBZb3UncmUgYXR0ZW1wdGluZyB0byBcIiArXG4gICAgICAgICd1c2UgYSBjb21wb25lbnQgY2xhc3Mgb3IgZnVuY3Rpb24gYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSAnICtcbiAgICAgICAgJ3JlZ3VsYXIgb2JqZWN0LidcbiAgICApO1xuICAgIF9pbnZhcmlhbnQoXG4gICAgICAhaXNWYWxpZEVsZW1lbnQoc3BlYyksXG4gICAgICBcIlJlYWN0Q2xhc3M6IFlvdSdyZSBhdHRlbXB0aW5nIHRvIFwiICtcbiAgICAgICAgJ3VzZSBhIGNvbXBvbmVudCBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LidcbiAgICApO1xuXG4gICAgdmFyIHByb3RvID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIHZhciBhdXRvQmluZFBhaXJzID0gcHJvdG8uX19yZWFjdEF1dG9CaW5kUGFpcnM7XG5cbiAgICAvLyBCeSBoYW5kbGluZyBtaXhpbnMgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzLCB3ZSBlbnN1cmUgdGhlIHNhbWVcbiAgICAvLyBjaGFpbmluZyBvcmRlciBpcyBhcHBsaWVkIHRvIG1ldGhvZHMgd2l0aCBERUZJTkVfTUFOWSBwb2xpY3ksIHdoZXRoZXJcbiAgICAvLyBtaXhpbnMgYXJlIGxpc3RlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlc2UgbWV0aG9kcyBpbiB0aGUgc3BlYy5cbiAgICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShNSVhJTlNfS0VZKSkge1xuICAgICAgUkVTRVJWRURfU1BFQ19LRVlTLm1peGlucyhDb25zdHJ1Y3Rvciwgc3BlYy5taXhpbnMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3BlYykge1xuICAgICAgaWYgKCFzcGVjLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gTUlYSU5TX0tFWSkge1xuICAgICAgICAvLyBXZSBoYXZlIGFscmVhZHkgaGFuZGxlZCBtaXhpbnMgaW4gYSBzcGVjaWFsIGNhc2UgYWJvdmUuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcGVydHkgPSBzcGVjW25hbWVdO1xuICAgICAgdmFyIGlzQWxyZWFkeURlZmluZWQgPSBwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSk7XG5cbiAgICAgIGlmIChSRVNFUlZFRF9TUEVDX0tFWVMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgUkVTRVJWRURfU1BFQ19LRVlTW25hbWVdKENvbnN0cnVjdG9yLCBwcm9wZXJ0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZXR1cCBtZXRob2RzIG9uIHByb3RvdHlwZTpcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBtZW1iZXIgbWV0aG9kcyBzaG91bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgYm91bmQ6XG4gICAgICAgIC8vIDEuIEV4cGVjdGVkIFJlYWN0Q2xhc3MgbWV0aG9kcyAoaW4gdGhlIFwiaW50ZXJmYWNlXCIpLlxuICAgICAgICAvLyAyLiBPdmVycmlkZGVuIG1ldGhvZHMgKHRoYXQgd2VyZSBtaXhlZCBpbikuXG4gICAgICAgIHZhciBpc1JlYWN0Q2xhc3NNZXRob2QgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgdmFyIHNob3VsZEF1dG9CaW5kID1cbiAgICAgICAgICBpc0Z1bmN0aW9uICYmXG4gICAgICAgICAgIWlzUmVhY3RDbGFzc01ldGhvZCAmJlxuICAgICAgICAgICFpc0FscmVhZHlEZWZpbmVkICYmXG4gICAgICAgICAgc3BlYy5hdXRvYmluZCAhPT0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNob3VsZEF1dG9CaW5kKSB7XG4gICAgICAgICAgYXV0b0JpbmRQYWlycy5wdXNoKG5hbWUsIHByb3BlcnR5KTtcbiAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV07XG5cbiAgICAgICAgICAgIC8vIFRoZXNlIGNhc2VzIHNob3VsZCBhbHJlYWR5IGJlIGNhdWdodCBieSB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlLlxuICAgICAgICAgICAgX2ludmFyaWFudChcbiAgICAgICAgICAgICAgaXNSZWFjdENsYXNzTWV0aG9kICYmXG4gICAgICAgICAgICAgICAgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnIHx8XG4gICAgICAgICAgICAgICAgICBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknKSxcbiAgICAgICAgICAgICAgJ1JlYWN0Q2xhc3M6IFVuZXhwZWN0ZWQgc3BlYyBwb2xpY3kgJXMgZm9yIGtleSAlcyAnICtcbiAgICAgICAgICAgICAgICAnd2hlbiBtaXhpbmcgaW4gY29tcG9uZW50IHNwZWNzLicsXG4gICAgICAgICAgICAgIHNwZWNQb2xpY3ksXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEZvciBtZXRob2RzIHdoaWNoIGFyZSBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlLCBjYWxsIHRoZSBleGlzdGluZ1xuICAgICAgICAgICAgLy8gbWV0aG9kcyBiZWZvcmUgY2FsbGluZyB0aGUgbmV3IHByb3BlcnR5LCBtZXJnaW5nIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgICAgaWYgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJykge1xuICAgICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gQWRkIHZlcmJvc2UgZGlzcGxheU5hbWUgdG8gdGhlIGZ1bmN0aW9uLCB3aGljaCBoZWxwcyB3aGVuIGxvb2tpbmdcbiAgICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIHNwZWMuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgICBwcm90b1tuYW1lXS5kaXNwbGF5TmFtZSA9IHNwZWMuZGlzcGxheU5hbWUgKyAnXycgKyBuYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICBpZiAoIXN0YXRpY3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgbmFtZSBpbiBzdGF0aWNzKSB7XG4gICAgICB2YXIgcHJvcGVydHkgPSBzdGF0aWNzW25hbWVdO1xuICAgICAgaWYgKCFzdGF0aWNzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNSZXNlcnZlZCA9IG5hbWUgaW4gUkVTRVJWRURfU1BFQ19LRVlTO1xuICAgICAgX2ludmFyaWFudChcbiAgICAgICAgIWlzUmVzZXJ2ZWQsXG4gICAgICAgICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGEgcmVzZXJ2ZWQgJyArXG4gICAgICAgICAgJ3Byb3BlcnR5LCBgJXNgLCB0aGF0IHNob3VsZG5cXCd0IGJlIG9uIHRoZSBcInN0YXRpY3NcIiBrZXkuIERlZmluZSBpdCAnICtcbiAgICAgICAgICAnYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgaW5zdGVhZDsgaXQgd2lsbCBzdGlsbCBiZSBhY2Nlc3NpYmxlIG9uIHRoZSAnICtcbiAgICAgICAgICAnY29uc3RydWN0b3IuJyxcbiAgICAgICAgbmFtZVxuICAgICAgKTtcblxuICAgICAgdmFyIGlzSW5oZXJpdGVkID0gbmFtZSBpbiBDb25zdHJ1Y3RvcjtcbiAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgICFpc0luaGVyaXRlZCxcbiAgICAgICAgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgJyArXG4gICAgICAgICAgJ2Alc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlICcgK1xuICAgICAgICAgICdkdWUgdG8gYSBtaXhpbi4nLFxuICAgICAgICBuYW1lXG4gICAgICApO1xuICAgICAgQ29uc3RydWN0b3JbbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgdHdvIG9iamVjdHMsIGJ1dCB0aHJvdyBpZiBib3RoIGNvbnRhaW4gdGhlIHNhbWUga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb25lIFRoZSBmaXJzdCBvYmplY3QsIHdoaWNoIGlzIG11dGF0ZWQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0d28gVGhlIHNlY29uZCBvYmplY3RcbiAgICogQHJldHVybiB7b2JqZWN0fSBvbmUgYWZ0ZXIgaXQgaGFzIGJlZW4gbXV0YXRlZCB0byBjb250YWluIGV2ZXJ5dGhpbmcgaW4gdHdvLlxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhvbmUsIHR3bykge1xuICAgIF9pbnZhcmlhbnQoXG4gICAgICBvbmUgJiYgdHdvICYmIHR5cGVvZiBvbmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0d28gPT09ICdvYmplY3QnLFxuICAgICAgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogQ2Fubm90IG1lcmdlIG5vbi1vYmplY3RzLidcbiAgICApO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHR3bykge1xuICAgICAgaWYgKHR3by5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgICAgb25lW2tleV0gPT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiAnICtcbiAgICAgICAgICAgICdUcmllZCB0byBtZXJnZSB0d28gb2JqZWN0cyB3aXRoIHRoZSBzYW1lIGtleTogYCVzYC4gVGhpcyBjb25mbGljdCAnICtcbiAgICAgICAgICAgICdtYXkgYmUgZHVlIHRvIGEgbWl4aW47IGluIHBhcnRpY3VsYXIsIHRoaXMgbWF5IGJlIGNhdXNlZCBieSB0d28gJyArXG4gICAgICAgICAgICAnZ2V0SW5pdGlhbFN0YXRlKCkgb3IgZ2V0RGVmYXVsdFByb3BzKCkgbWV0aG9kcyByZXR1cm5pbmcgb2JqZWN0cyAnICtcbiAgICAgICAgICAgICd3aXRoIGNsYXNoaW5nIGtleXMuJyxcbiAgICAgICAgICBrZXlcbiAgICAgICAgKTtcbiAgICAgICAgb25lW2tleV0gPSB0d29ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIG1lcmdlcyB0aGVpciByZXR1cm4gdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZFJlc3VsdCgpIHtcbiAgICAgIHZhciBhID0gb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB2YXIgYiA9IHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgICAgdmFyIGMgPSB7fTtcbiAgICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYSk7XG4gICAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGIpO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIGlnbm9yZXMgdGhlaXIgcmV0dXJuIHZhbGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbihvbmUsIHR3bykge1xuICAgIHJldHVybiBmdW5jdGlvbiBjaGFpbmVkRnVuY3Rpb24oKSB7XG4gICAgICBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgYSBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgTWV0aG9kIHRvIGJlIGJvdW5kLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGJvdW5kIG1ldGhvZC5cbiAgICovXG4gIGZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCkge1xuICAgIHZhciBib3VuZE1ldGhvZCA9IG1ldGhvZC5iaW5kKGNvbXBvbmVudCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBudWxsO1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuY29uc3RydWN0b3IuZGlzcGxheU5hbWU7XG4gICAgICB2YXIgX2JpbmQgPSBib3VuZE1ldGhvZC5iaW5kO1xuICAgICAgYm91bmRNZXRob2QuYmluZCA9IGZ1bmN0aW9uKG5ld1RoaXMpIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLFxuICAgICAgICAgICAgX2tleSA9IDE7XG4gICAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgICAgX2tleSsrXG4gICAgICAgICkge1xuICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlciBpcyB0cnlpbmcgdG8gYmluZCgpIGFuIGF1dG9ib3VuZCBtZXRob2Q7IHdlIGVmZmVjdGl2ZWx5IHdpbGxcbiAgICAgICAgLy8gaWdub3JlIHRoZSB2YWx1ZSBvZiBcInRoaXNcIiB0aGF0IHRoZSB1c2VyIGlzIHRyeWluZyB0byB1c2UsIHNvXG4gICAgICAgIC8vIGxldCdzIHdhcm4uXG4gICAgICAgIGlmIChuZXdUaGlzICE9PSBjb21wb25lbnQgJiYgbmV3VGhpcyAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ2JpbmQoKTogUmVhY3QgY29tcG9uZW50IG1ldGhvZHMgbWF5IG9ubHkgYmUgYm91bmQgdG8gdGhlICcgK1xuICAgICAgICAgICAgICAgICdjb21wb25lbnQgaW5zdGFuY2UuIFNlZSAlcycsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ2JpbmQoKTogWW91IGFyZSBiaW5kaW5nIGEgY29tcG9uZW50IG1ldGhvZCB0byB0aGUgY29tcG9uZW50LiAnICtcbiAgICAgICAgICAgICAgICAnUmVhY3QgZG9lcyB0aGlzIGZvciB5b3UgYXV0b21hdGljYWxseSBpbiBhIGhpZ2gtcGVyZm9ybWFuY2UgJyArXG4gICAgICAgICAgICAgICAgJ3dheSwgc28geW91IGNhbiBzYWZlbHkgcmVtb3ZlIHRoaXMgY2FsbC4gU2VlICVzJyxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWJvdW5kTWV0aG9kID0gX2JpbmQuYXBwbHkoYm91bmRNZXRob2QsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gYXJncztcbiAgICAgICAgcmV0dXJuIHJlYm91bmRNZXRob2Q7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYm91bmRNZXRob2Q7XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgYWxsIGF1dG8tYm91bmQgbWV0aG9kcyBpbiBhIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICAgKi9cbiAgZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kcyhjb21wb25lbnQpIHtcbiAgICB2YXIgcGFpcnMgPSBjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kUGFpcnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIGF1dG9CaW5kS2V5ID0gcGFpcnNbaV07XG4gICAgICB2YXIgbWV0aG9kID0gcGFpcnNbaSArIDFdO1xuICAgICAgY29tcG9uZW50W2F1dG9CaW5kS2V5XSA9IGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIElzTW91bnRlZFByZU1peGluID0ge1xuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX19pc01vdW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgSXNNb3VudGVkUG9zdE1peGluID0ge1xuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX19pc01vdW50ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBtb3JlIHRvIHRoZSBSZWFjdENsYXNzIGJhc2UgY2xhc3MuIFRoZXNlIGFyZSBhbGwgbGVnYWN5IGZlYXR1cmVzIGFuZFxuICAgKiB0aGVyZWZvcmUgbm90IGFscmVhZHkgcGFydCBvZiB0aGUgbW9kZXJuIFJlYWN0Q29tcG9uZW50LlxuICAgKi9cbiAgdmFyIFJlYWN0Q2xhc3NNaXhpbiA9IHtcbiAgICAvKipcbiAgICAgKiBUT0RPOiBUaGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBiZWNhdXNlIHN0YXRlIHNob3VsZCBhbHdheXMga2VlcCBhIGNvbnNpc3RlbnRcbiAgICAgKiB0eXBlIHNpZ25hdHVyZSBhbmQgdGhlIG9ubHkgdXNlIGNhc2UgZm9yIHRoaXMsIGlzIHRvIGF2b2lkIHRoYXQuXG4gICAgICovXG4gICAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbihuZXdTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKHRoaXMsIG5ld1N0YXRlLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGZpbmFsXG4gICAgICovXG4gICAgaXNNb3VudGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgdGhpcy5fX2RpZFdhcm5Jc01vdW50ZWQsXG4gICAgICAgICAgJyVzOiBpc01vdW50ZWQgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwICcgK1xuICAgICAgICAgICAgJ3N1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gY29tcG9uZW50V2lsbFVubW91bnQgdG8gJyArXG4gICAgICAgICAgICAncHJldmVudCBtZW1vcnkgbGVha3MuJyxcbiAgICAgICAgICAodGhpcy5jb25zdHJ1Y3RvciAmJiB0aGlzLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lKSB8fFxuICAgICAgICAgICAgdGhpcy5uYW1lIHx8XG4gICAgICAgICAgICAnQ29tcG9uZW50J1xuICAgICAgICApO1xuICAgICAgICB0aGlzLl9fZGlkV2FybklzTW91bnRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gISF0aGlzLl9faXNNb3VudGVkO1xuICAgIH1cbiAgfTtcblxuICB2YXIgUmVhY3RDbGFzc0NvbXBvbmVudCA9IGZ1bmN0aW9uKCkge307XG4gIF9hc3NpZ24oXG4gICAgUmVhY3RDbGFzc0NvbXBvbmVudC5wcm90b3R5cGUsXG4gICAgUmVhY3RDb21wb25lbnQucHJvdG90eXBlLFxuICAgIFJlYWN0Q2xhc3NNaXhpblxuICApO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIGNvbXBvbmVudCBjbGFzcyBnaXZlbiBhIGNsYXNzIHNwZWNpZmljYXRpb24uXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jcmVhdGVjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3BlYyBDbGFzcyBzcGVjaWZpY2F0aW9uICh3aGljaCBtdXN0IGRlZmluZSBgcmVuZGVyYCkuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBDb21wb25lbnQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzKHNwZWMpIHtcbiAgICAvLyBUbyBrZWVwIG91ciB3YXJuaW5ncyBtb3JlIHVuZGVyc3RhbmRhYmxlLCB3ZSdsbCB1c2UgYSBsaXR0bGUgaGFjayBoZXJlIHRvXG4gICAgLy8gZW5zdXJlIHRoYXQgQ29uc3RydWN0b3IubmFtZSAhPT0gJ0NvbnN0cnVjdG9yJy4gVGhpcyBtYWtlcyBzdXJlIHdlIGRvbid0XG4gICAgLy8gdW5uZWNlc3NhcmlseSBpZGVudGlmeSBhIGNsYXNzIHdpdGhvdXQgZGlzcGxheU5hbWUgYXMgJ0NvbnN0cnVjdG9yJy5cbiAgICB2YXIgQ29uc3RydWN0b3IgPSBpZGVudGl0eShmdW5jdGlvbihwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAgICAgLy8gVGhpcyBjb25zdHJ1Y3RvciBnZXRzIG92ZXJyaWRkZW4gYnkgbW9ja3MuIFRoZSBhcmd1bWVudCBpcyB1c2VkXG4gICAgICAvLyBieSBtb2NrcyB0byBhc3NlcnQgb24gd2hhdCBnZXRzIG1vdW50ZWQuXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgdGhpcyBpbnN0YW5jZW9mIENvbnN0cnVjdG9yLFxuICAgICAgICAgICdTb21ldGhpbmcgaXMgY2FsbGluZyBhIFJlYWN0IGNvbXBvbmVudCBkaXJlY3RseS4gVXNlIGEgZmFjdG9yeSBvciAnICtcbiAgICAgICAgICAgICdKU1ggaW5zdGVhZC4gU2VlOiBodHRwczovL2ZiLm1lL3JlYWN0LWxlZ2FjeWZhY3RvcnknXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdpcmUgdXAgYXV0by1iaW5kaW5nXG4gICAgICBpZiAodGhpcy5fX3JlYWN0QXV0b0JpbmRQYWlycy5sZW5ndGgpIHtcbiAgICAgICAgYmluZEF1dG9CaW5kTWV0aG9kcyh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgICAgIC8vIFJlYWN0Q2xhc3NlcyBkb2Vzbid0IGhhdmUgY29uc3RydWN0b3JzLiBJbnN0ZWFkLCB0aGV5IHVzZSB0aGVcbiAgICAgIC8vIGdldEluaXRpYWxTdGF0ZSBhbmQgY29tcG9uZW50V2lsbE1vdW50IG1ldGhvZHMgZm9yIGluaXRpYWxpemF0aW9uLlxuXG4gICAgICB2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUgPyB0aGlzLmdldEluaXRpYWxTdGF0ZSgpIDogbnVsbDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICB0aGlzLmdldEluaXRpYWxTdGF0ZS5faXNNb2NrRnVuY3Rpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgIHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSksXG4gICAgICAgICclcy5nZXRJbml0aWFsU3RhdGUoKTogbXVzdCByZXR1cm4gYW4gb2JqZWN0IG9yIG51bGwnLFxuICAgICAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnXG4gICAgICApO1xuXG4gICAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIH0pO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ldyBSZWFjdENsYXNzQ29tcG9uZW50KCk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLl9fcmVhY3RBdXRvQmluZFBhaXJzID0gW107XG5cbiAgICBpbmplY3RlZE1peGlucy5mb3JFYWNoKG1peFNwZWNJbnRvQ29tcG9uZW50LmJpbmQobnVsbCwgQ29uc3RydWN0b3IpKTtcblxuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBJc01vdW50ZWRQcmVNaXhpbik7XG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpO1xuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBJc01vdW50ZWRQb3N0TWl4aW4pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZGVmYXVsdFByb3BzIHByb3BlcnR5IGFmdGVyIGFsbCBtaXhpbnMgaGF2ZSBiZWVuIG1lcmdlZC5cbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5kZWZhdWx0UHJvcHMgPSBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMoKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHRhZyB0byBpbmRpY2F0ZSB0aGF0IHRoZSB1c2Ugb2YgdGhlc2UgbWV0aG9kIG5hbWVzIGlzIG9rLFxuICAgICAgLy8gc2luY2UgaXQncyB1c2VkIHdpdGggY3JlYXRlQ2xhc3MuIElmIGl0J3Mgbm90LCB0aGVuIGl0J3MgbGlrZWx5IGFcbiAgICAgIC8vIG1pc3Rha2Ugc28gd2UnbGwgd2FybiB5b3UgdG8gdXNlIHRoZSBzdGF0aWMgcHJvcGVydHksIHByb3BlcnR5XG4gICAgICAvLyBpbml0aWFsaXplciBvciBjb25zdHJ1Y3RvciByZXNwZWN0aXZlbHkuXG4gICAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUpIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIF9pbnZhcmlhbnQoXG4gICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUucmVuZGVyLFxuICAgICAgJ2NyZWF0ZUNsYXNzKC4uLik6IENsYXNzIHNwZWNpZmljYXRpb24gbXVzdCBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuJ1xuICAgICk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRTaG91bGRVcGRhdGUsXG4gICAgICAgICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgK1xuICAgICAgICAgICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICtcbiAgICAgICAgICAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgK1xuICAgICAgICAgICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLFxuICAgICAgICBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCdcbiAgICAgICk7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMsXG4gICAgICAgICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgK1xuICAgICAgICAgICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JyxcbiAgICAgICAgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFJlZHVjZSB0aW1lIHNwZW50IGRvaW5nIGxvb2t1cHMgYnkgc2V0dGluZyB0aGVzZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gUmVhY3RDbGFzc0ludGVyZmFjZSkge1xuICAgICAgaWYgKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlQ2xhc3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMCkpKVxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cblxudmFyIFJlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBmYWN0b3J5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxuaWYgKHR5cGVvZiBSZWFjdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdGhyb3cgRXJyb3IoXG4gICAgJ2NyZWF0ZS1yZWFjdC1jbGFzcyBjb3VsZCBub3QgZmluZCB0aGUgUmVhY3Qgb2JqZWN0LiBJZiB5b3UgYXJlIHVzaW5nIHNjcmlwdCB0YWdzLCAnICtcbiAgICAgICdtYWtlIHN1cmUgdGhhdCBSZWFjdCBpcyBiZWluZyBsb2FkZWQgYmVmb3JlIGNyZWF0ZS1yZWFjdC1jbGFzcy4nXG4gICk7XG59XG5cbi8vIEhhY2sgdG8gZ3JhYiBOb29wVXBkYXRlUXVldWUgZnJvbSBpc29tb3JwaGljIFJlYWN0XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSBuZXcgUmVhY3QuQ29tcG9uZW50KCkudXBkYXRlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICBSZWFjdC5Db21wb25lbnQsXG4gIFJlYWN0LmlzVmFsaWRFbGVtZW50LFxuICBSZWFjdE5vb3BVcGRhdGVRdWV1ZVxuKTtcblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygwKSkpXG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBSZWFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY3JlYXRlUmVhY3RDbGFzcyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG52YXIgUHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG52YXIgd2luID0gdHlwZW9mIGdsb2JhbCA9PT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYXJ0VHlwZSwgSGlnaGNoYXJ0cykge1xuICB2YXIgZGlzcGxheU5hbWUgPSAnSGlnaGNoYXJ0cycgKyBjaGFydFR5cGU7XG4gIHZhciByZXN1bHQgPSBjcmVhdGVSZWFjdENsYXNzKHtcbiAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG5cbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgIGNvbmZpZzogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgIGlzUHVyZUNvbmZpZzogUHJvcFR5cGVzLmJvb2wsXG4gICAgICBuZXZlclJlZmxvdzogUHJvcFR5cGVzLmJvb2wsXG4gICAgICBjYWxsYmFjazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICBkb21Qcm9wczogUHJvcFR5cGVzLm9iamVjdFxuICAgIH0sXG4gICAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2soKSB7fSxcbiAgICAgICAgZG9tUHJvcHM6IHt9XG4gICAgICB9O1xuICAgIH0sXG4gICAgc2V0Q2hhcnRSZWY6IGZ1bmN0aW9uIHNldENoYXJ0UmVmKGNoYXJ0UmVmKSB7XG4gICAgICB0aGlzLmNoYXJ0UmVmID0gY2hhcnRSZWY7XG4gICAgfSxcbiAgICByZW5kZXJDaGFydDogZnVuY3Rpb24gcmVuZGVyQ2hhcnQoY29uZmlnKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpZyBtdXN0IGJlIHNwZWNpZmllZCBmb3IgdGhlICcgKyBkaXNwbGF5TmFtZSArICcgY29tcG9uZW50Jyk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhcnRDb25maWcgPSBjb25maWcuY2hhcnQ7XG4gICAgICB0aGlzLmNoYXJ0ID0gbmV3IEhpZ2hjaGFydHNbY2hhcnRUeXBlXShfZXh0ZW5kcyh7fSwgY29uZmlnLCB7XG4gICAgICAgIGNoYXJ0OiBfZXh0ZW5kcyh7fSwgY2hhcnRDb25maWcsIHtcbiAgICAgICAgICByZW5kZXJUbzogdGhpcy5jaGFydFJlZlxuICAgICAgICB9KVxuICAgICAgfSksIHRoaXMucHJvcHMuY2FsbGJhY2spO1xuXG4gICAgICBpZiAoIXRoaXMucHJvcHMubmV2ZXJSZWZsb3cpIHtcbiAgICAgICAgd2luICYmIHdpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5jaGFydCAmJiBfdGhpcy5jaGFydC5vcHRpb25zICYmIF90aGlzLmNoYXJ0LnJlZmxvdygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgICBpZiAobmV4dFByb3BzLm5ldmVyUmVmbG93IHx8IG5leHRQcm9wcy5pc1B1cmVDb25maWcgJiYgdGhpcy5wcm9wcy5jb25maWcgPT09IG5leHRQcm9wcy5jb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlckNoYXJ0KG5leHRQcm9wcy5jb25maWcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cblxuICAgIGdldENoYXJ0OiBmdW5jdGlvbiBnZXRDaGFydCgpIHtcbiAgICAgIGlmICghdGhpcy5jaGFydCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldENoYXJ0KCkgc2hvdWxkIG5vdCBiZSBjYWxsZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2hhcnQ7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5wcm9wcy5jb25maWcpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB0aGlzLmNoYXJ0LmRlc3Ryb3koKTtcbiAgICB9LFxuXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCBfZXh0ZW5kcyh7IHJlZjogdGhpcy5zZXRDaGFydFJlZiB9LCB0aGlzLnByb3BzLmRvbVByb3BzKSk7XG4gICAgfVxuICB9KTtcblxuICByZXN1bHQuSGlnaGNoYXJ0cyA9IEhpZ2hjaGFydHM7XG4gIHJlc3VsdC53aXRoSGlnaGNoYXJ0cyA9IGZ1bmN0aW9uIChIaWdoY2hhcnRzKSB7XG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzKGNoYXJ0VHlwZSwgSGlnaGNoYXJ0cyk7XG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59O1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMTUpKSlcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGludmFyaWFudCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIHZhciB3YXJuaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpbnZhcmlhbnQodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ3RoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAlc2AuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0pO1xuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCAlcyB0eXBlOiAlcyVzJywgbG9jYXRpb24sIGVycm9yLm1lc3NhZ2UsIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygwKSkpXG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuXG52YXIgZW1wdHlGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgaW52YXJpYW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHNoaW0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBpZiAoc2VjcmV0ID09PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoXG4gICAgICBmYWxzZSxcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gIH07XG4gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gICAgcmV0dXJuIHNoaW07XG4gIH07XG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltLFxuICAgIGV4YWN0OiBnZXRTaGltXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBlbXB0eUZ1bmN0aW9uO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBpbnZhcmlhbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIHdhcm5pbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIGFzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCVzYCBwcm9wIG9uIGAlc2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nLFxuICAgICAgICAgICAgICBwcm9wRnVsbE5hbWUsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAlcyBhdCBpbmRleCAlcy4nLFxuICAgICAgICAgIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMCkpKVxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICBTeW1ib2wuZm9yICYmXG4gICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgIDB4ZWFjNztcblxuICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH07XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSgpO1xufVxuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygwKSkpXG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cbi8qKiovIH0pLFxuLyogMTYgKi8sXG4vKiAxNyAqLyxcbi8qIDE4ICovLFxuLyogMTkgKi8sXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApKCdTdG9ja0NoYXJ0JywgX193ZWJwYWNrX3JlcXVpcmVfXygyMykpO1xuXG4vKioqLyB9KSxcbi8qIDIxICovLFxuLyogMjIgKi8sXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMjNfXztcblxuLyoqKi8gfSksXG4vKiAyNCAqLyxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWhpZ2hjaGFydHMvUmVhY3RIaWdoc3RvY2suanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB7IENvbXBvbmVudCwgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgc3RvcmVTaGFwZSwgc3Vic2NyaXB0aW9uU2hhcGUgfSBmcm9tICcuLi91dGlscy9Qcm9wVHlwZXMnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi4vdXRpbHMvd2FybmluZyc7XG5cbnZhciBkaWRXYXJuQWJvdXRSZWNlaXZpbmdTdG9yZSA9IGZhbHNlO1xuZnVuY3Rpb24gd2FybkFib3V0UmVjZWl2aW5nU3RvcmUoKSB7XG4gIGlmIChkaWRXYXJuQWJvdXRSZWNlaXZpbmdTdG9yZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBkaWRXYXJuQWJvdXRSZWNlaXZpbmdTdG9yZSA9IHRydWU7XG5cbiAgd2FybmluZygnPFByb3ZpZGVyPiBkb2VzIG5vdCBzdXBwb3J0IGNoYW5naW5nIGBzdG9yZWAgb24gdGhlIGZseS4gJyArICdJdCBpcyBtb3N0IGxpa2VseSB0aGF0IHlvdSBzZWUgdGhpcyBlcnJvciBiZWNhdXNlIHlvdSB1cGRhdGVkIHRvICcgKyAnUmVkdXggMi54IGFuZCBSZWFjdCBSZWR1eCAyLnggd2hpY2ggbm8gbG9uZ2VyIGhvdCByZWxvYWQgcmVkdWNlcnMgJyArICdhdXRvbWF0aWNhbGx5LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3QtcmVkdXgvcmVsZWFzZXMvJyArICd0YWcvdjIuMC4wIGZvciB0aGUgbWlncmF0aW9uIGluc3RydWN0aW9ucy4nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVByb3ZpZGVyKCkge1xuICB2YXIgX1Byb3ZpZGVyJGNoaWxkQ29udGV4O1xuXG4gIHZhciBzdG9yZUtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ3N0b3JlJztcbiAgdmFyIHN1YktleSA9IGFyZ3VtZW50c1sxXTtcblxuICB2YXIgc3Vic2NyaXB0aW9uS2V5ID0gc3ViS2V5IHx8IHN0b3JlS2V5ICsgJ1N1YnNjcmlwdGlvbic7XG5cbiAgdmFyIFByb3ZpZGVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoUHJvdmlkZXIsIF9Db21wb25lbnQpO1xuXG4gICAgUHJvdmlkZXIucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgIHZhciBfcmVmO1xuXG4gICAgICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW3N0b3JlS2V5XSA9IHRoaXNbc3RvcmVLZXldLCBfcmVmW3N1YnNjcmlwdGlvbktleV0gPSBudWxsLCBfcmVmO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBQcm92aWRlcihwcm9wcywgY29udGV4dCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb3ZpZGVyKTtcblxuICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSk7XG5cbiAgICAgIF90aGlzW3N0b3JlS2V5XSA9IHByb3BzLnN0b3JlO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFByb3ZpZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFByb3ZpZGVyO1xuICB9KENvbXBvbmVudCk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBQcm92aWRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIChuZXh0UHJvcHMpIHtcbiAgICAgIGlmICh0aGlzW3N0b3JlS2V5XSAhPT0gbmV4dFByb3BzLnN0b3JlKSB7XG4gICAgICAgIHdhcm5BYm91dFJlY2VpdmluZ1N0b3JlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIFByb3ZpZGVyLnByb3BUeXBlcyA9IHtcbiAgICBzdG9yZTogc3RvcmVTaGFwZS5pc1JlcXVpcmVkLFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuZWxlbWVudC5pc1JlcXVpcmVkXG4gIH07XG4gIFByb3ZpZGVyLmNoaWxkQ29udGV4dFR5cGVzID0gKF9Qcm92aWRlciRjaGlsZENvbnRleCA9IHt9LCBfUHJvdmlkZXIkY2hpbGRDb250ZXhbc3RvcmVLZXldID0gc3RvcmVTaGFwZS5pc1JlcXVpcmVkLCBfUHJvdmlkZXIkY2hpbGRDb250ZXhbc3Vic2NyaXB0aW9uS2V5XSA9IHN1YnNjcmlwdGlvblNoYXBlLCBfUHJvdmlkZXIkY2hpbGRDb250ZXgpO1xuXG4gIHJldHVybiBQcm92aWRlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUHJvdmlkZXIoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtcmVkdXgvZXMvY29tcG9uZW50cy9Qcm92aWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuaW1wb3J0IGNvbm5lY3RBZHZhbmNlZCBmcm9tICcuLi9jb21wb25lbnRzL2Nvbm5lY3RBZHZhbmNlZCc7XG5pbXBvcnQgc2hhbGxvd0VxdWFsIGZyb20gJy4uL3V0aWxzL3NoYWxsb3dFcXVhbCc7XG5pbXBvcnQgZGVmYXVsdE1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcyBmcm9tICcuL21hcERpc3BhdGNoVG9Qcm9wcyc7XG5pbXBvcnQgZGVmYXVsdE1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcyBmcm9tICcuL21hcFN0YXRlVG9Qcm9wcyc7XG5pbXBvcnQgZGVmYXVsdE1lcmdlUHJvcHNGYWN0b3JpZXMgZnJvbSAnLi9tZXJnZVByb3BzJztcbmltcG9ydCBkZWZhdWx0U2VsZWN0b3JGYWN0b3J5IGZyb20gJy4vc2VsZWN0b3JGYWN0b3J5JztcblxuLypcbiAgY29ubmVjdCBpcyBhIGZhY2FkZSBvdmVyIGNvbm5lY3RBZHZhbmNlZC4gSXQgdHVybnMgaXRzIGFyZ3MgaW50byBhIGNvbXBhdGlibGVcbiAgc2VsZWN0b3JGYWN0b3J5LCB3aGljaCBoYXMgdGhlIHNpZ25hdHVyZTpcblxuICAgIChkaXNwYXRjaCwgb3B0aW9ucykgPT4gKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSA9PiBuZXh0RmluYWxQcm9wc1xuICBcbiAgY29ubmVjdCBwYXNzZXMgaXRzIGFyZ3MgdG8gY29ubmVjdEFkdmFuY2VkIGFzIG9wdGlvbnMsIHdoaWNoIHdpbGwgaW4gdHVybiBwYXNzIHRoZW0gdG9cbiAgc2VsZWN0b3JGYWN0b3J5IGVhY2ggdGltZSBhIENvbm5lY3QgY29tcG9uZW50IGluc3RhbmNlIGlzIGluc3RhbnRpYXRlZCBvciBob3QgcmVsb2FkZWQuXG5cbiAgc2VsZWN0b3JGYWN0b3J5IHJldHVybnMgYSBmaW5hbCBwcm9wcyBzZWxlY3RvciBmcm9tIGl0cyBtYXBTdGF0ZVRvUHJvcHMsXG4gIG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMsIG1lcmdlUHJvcHMsXG4gIG1lcmdlUHJvcHNGYWN0b3JpZXMsIGFuZCBwdXJlIGFyZ3MuXG5cbiAgVGhlIHJlc3VsdGluZyBmaW5hbCBwcm9wcyBzZWxlY3RvciBpcyBjYWxsZWQgYnkgdGhlIENvbm5lY3QgY29tcG9uZW50IGluc3RhbmNlIHdoZW5ldmVyXG4gIGl0IHJlY2VpdmVzIG5ldyBwcm9wcyBvciBzdG9yZSBzdGF0ZS5cbiAqL1xuXG5mdW5jdGlvbiBtYXRjaChhcmcsIGZhY3RvcmllcywgbmFtZSkge1xuICBmb3IgKHZhciBpID0gZmFjdG9yaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHJlc3VsdCA9IGZhY3Rvcmllc1tpXShhcmcpO1xuICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBvcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIG9mIHR5cGUgJyArIHR5cGVvZiBhcmcgKyAnIGZvciAnICsgbmFtZSArICcgYXJndW1lbnQgd2hlbiBjb25uZWN0aW5nIGNvbXBvbmVudCAnICsgb3B0aW9ucy53cmFwcGVkQ29tcG9uZW50TmFtZSArICcuJyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0cmljdEVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59XG5cbi8vIGNyZWF0ZUNvbm5lY3Qgd2l0aCBkZWZhdWx0IGFyZ3MgYnVpbGRzIHRoZSAnb2ZmaWNpYWwnIGNvbm5lY3QgYmVoYXZpb3IuIENhbGxpbmcgaXQgd2l0aFxuLy8gZGlmZmVyZW50IG9wdGlvbnMgb3BlbnMgdXAgc29tZSB0ZXN0aW5nIGFuZCBleHRlbnNpYmlsaXR5IHNjZW5hcmlvc1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3QoKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIF9yZWYkY29ubmVjdEhPQyA9IF9yZWYuY29ubmVjdEhPQyxcbiAgICAgIGNvbm5lY3RIT0MgPSBfcmVmJGNvbm5lY3RIT0MgPT09IHVuZGVmaW5lZCA/IGNvbm5lY3RBZHZhbmNlZCA6IF9yZWYkY29ubmVjdEhPQyxcbiAgICAgIF9yZWYkbWFwU3RhdGVUb1Byb3BzRiA9IF9yZWYubWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzLFxuICAgICAgbWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzID0gX3JlZiRtYXBTdGF0ZVRvUHJvcHNGID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzIDogX3JlZiRtYXBTdGF0ZVRvUHJvcHNGLFxuICAgICAgX3JlZiRtYXBEaXNwYXRjaFRvUHJvID0gX3JlZi5tYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMsXG4gICAgICBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMgPSBfcmVmJG1hcERpc3BhdGNoVG9Qcm8gPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRNYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMgOiBfcmVmJG1hcERpc3BhdGNoVG9Qcm8sXG4gICAgICBfcmVmJG1lcmdlUHJvcHNGYWN0b3IgPSBfcmVmLm1lcmdlUHJvcHNGYWN0b3JpZXMsXG4gICAgICBtZXJnZVByb3BzRmFjdG9yaWVzID0gX3JlZiRtZXJnZVByb3BzRmFjdG9yID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TWVyZ2VQcm9wc0ZhY3RvcmllcyA6IF9yZWYkbWVyZ2VQcm9wc0ZhY3RvcixcbiAgICAgIF9yZWYkc2VsZWN0b3JGYWN0b3J5ID0gX3JlZi5zZWxlY3RvckZhY3RvcnksXG4gICAgICBzZWxlY3RvckZhY3RvcnkgPSBfcmVmJHNlbGVjdG9yRmFjdG9yeSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFNlbGVjdG9yRmFjdG9yeSA6IF9yZWYkc2VsZWN0b3JGYWN0b3J5O1xuXG4gIHJldHVybiBmdW5jdGlvbiBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKSB7XG4gICAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fSxcbiAgICAgICAgX3JlZjIkcHVyZSA9IF9yZWYyLnB1cmUsXG4gICAgICAgIHB1cmUgPSBfcmVmMiRwdXJlID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZjIkcHVyZSxcbiAgICAgICAgX3JlZjIkYXJlU3RhdGVzRXF1YWwgPSBfcmVmMi5hcmVTdGF0ZXNFcXVhbCxcbiAgICAgICAgYXJlU3RhdGVzRXF1YWwgPSBfcmVmMiRhcmVTdGF0ZXNFcXVhbCA9PT0gdW5kZWZpbmVkID8gc3RyaWN0RXF1YWwgOiBfcmVmMiRhcmVTdGF0ZXNFcXVhbCxcbiAgICAgICAgX3JlZjIkYXJlT3duUHJvcHNFcXVhID0gX3JlZjIuYXJlT3duUHJvcHNFcXVhbCxcbiAgICAgICAgYXJlT3duUHJvcHNFcXVhbCA9IF9yZWYyJGFyZU93blByb3BzRXF1YSA9PT0gdW5kZWZpbmVkID8gc2hhbGxvd0VxdWFsIDogX3JlZjIkYXJlT3duUHJvcHNFcXVhLFxuICAgICAgICBfcmVmMiRhcmVTdGF0ZVByb3BzRXEgPSBfcmVmMi5hcmVTdGF0ZVByb3BzRXF1YWwsXG4gICAgICAgIGFyZVN0YXRlUHJvcHNFcXVhbCA9IF9yZWYyJGFyZVN0YXRlUHJvcHNFcSA9PT0gdW5kZWZpbmVkID8gc2hhbGxvd0VxdWFsIDogX3JlZjIkYXJlU3RhdGVQcm9wc0VxLFxuICAgICAgICBfcmVmMiRhcmVNZXJnZWRQcm9wc0UgPSBfcmVmMi5hcmVNZXJnZWRQcm9wc0VxdWFsLFxuICAgICAgICBhcmVNZXJnZWRQcm9wc0VxdWFsID0gX3JlZjIkYXJlTWVyZ2VkUHJvcHNFID09PSB1bmRlZmluZWQgPyBzaGFsbG93RXF1YWwgOiBfcmVmMiRhcmVNZXJnZWRQcm9wc0UsXG4gICAgICAgIGV4dHJhT3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydwdXJlJywgJ2FyZVN0YXRlc0VxdWFsJywgJ2FyZU93blByb3BzRXF1YWwnLCAnYXJlU3RhdGVQcm9wc0VxdWFsJywgJ2FyZU1lcmdlZFByb3BzRXF1YWwnXSk7XG5cbiAgICB2YXIgaW5pdE1hcFN0YXRlVG9Qcm9wcyA9IG1hdGNoKG1hcFN0YXRlVG9Qcm9wcywgbWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzLCAnbWFwU3RhdGVUb1Byb3BzJyk7XG4gICAgdmFyIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMgPSBtYXRjaChtYXBEaXNwYXRjaFRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcywgJ21hcERpc3BhdGNoVG9Qcm9wcycpO1xuICAgIHZhciBpbml0TWVyZ2VQcm9wcyA9IG1hdGNoKG1lcmdlUHJvcHMsIG1lcmdlUHJvcHNGYWN0b3JpZXMsICdtZXJnZVByb3BzJyk7XG5cbiAgICByZXR1cm4gY29ubmVjdEhPQyhzZWxlY3RvckZhY3RvcnksIF9leHRlbmRzKHtcbiAgICAgIC8vIHVzZWQgaW4gZXJyb3IgbWVzc2FnZXNcbiAgICAgIG1ldGhvZE5hbWU6ICdjb25uZWN0JyxcblxuICAgICAgLy8gdXNlZCB0byBjb21wdXRlIENvbm5lY3QncyBkaXNwbGF5TmFtZSBmcm9tIHRoZSB3cmFwcGVkIGNvbXBvbmVudCdzIGRpc3BsYXlOYW1lLlxuICAgICAgZ2V0RGlzcGxheU5hbWU6IGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdDb25uZWN0KCcgKyBuYW1lICsgJyknO1xuICAgICAgfSxcblxuICAgICAgLy8gaWYgbWFwU3RhdGVUb1Byb3BzIGlzIGZhbHN5LCB0aGUgQ29ubmVjdCBjb21wb25lbnQgZG9lc24ndCBzdWJzY3JpYmUgdG8gc3RvcmUgc3RhdGUgY2hhbmdlc1xuICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzOiBCb29sZWFuKG1hcFN0YXRlVG9Qcm9wcyksXG5cbiAgICAgIC8vIHBhc3NlZCB0aHJvdWdoIHRvIHNlbGVjdG9yRmFjdG9yeVxuICAgICAgaW5pdE1hcFN0YXRlVG9Qcm9wczogaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHM6IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMsXG4gICAgICBpbml0TWVyZ2VQcm9wczogaW5pdE1lcmdlUHJvcHMsXG4gICAgICBwdXJlOiBwdXJlLFxuICAgICAgYXJlU3RhdGVzRXF1YWw6IGFyZVN0YXRlc0VxdWFsLFxuICAgICAgYXJlT3duUHJvcHNFcXVhbDogYXJlT3duUHJvcHNFcXVhbCxcbiAgICAgIGFyZVN0YXRlUHJvcHNFcXVhbDogYXJlU3RhdGVQcm9wc0VxdWFsLFxuICAgICAgYXJlTWVyZ2VkUHJvcHNFcXVhbDogYXJlTWVyZ2VkUHJvcHNFcXVhbFxuXG4gICAgfSwgZXh0cmFPcHRpb25zKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUNvbm5lY3QoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9jb25uZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgYmluZEFjdGlvbkNyZWF0b3JzIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgd3JhcE1hcFRvUHJvcHNDb25zdGFudCwgd3JhcE1hcFRvUHJvcHNGdW5jIH0gZnJvbSAnLi93cmFwTWFwVG9Qcm9wcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNGdW5jdGlvbihtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09ICdmdW5jdGlvbicgPyB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwRGlzcGF0Y2hUb1Byb3BzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJykgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNNaXNzaW5nKG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gIW1hcERpc3BhdGNoVG9Qcm9wcyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoZnVuY3Rpb24gKGRpc3BhdGNoKSB7XG4gICAgcmV0dXJuIHsgZGlzcGF0Y2g6IGRpc3BhdGNoIH07XG4gIH0pIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzT2JqZWN0KG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gbWFwRGlzcGF0Y2hUb1Byb3BzICYmIHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09ICdvYmplY3QnID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChmdW5jdGlvbiAoZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3JzKG1hcERpc3BhdGNoVG9Qcm9wcywgZGlzcGF0Y2gpO1xuICB9KSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgW3doZW5NYXBEaXNwYXRjaFRvUHJvcHNJc0Z1bmN0aW9uLCB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNNaXNzaW5nLCB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNPYmplY3RdO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L21hcERpc3BhdGNoVG9Qcm9wcy5qc1xuLy8gbW9kdWxlIGlkID0gMTU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQsIHdyYXBNYXBUb1Byb3BzRnVuYyB9IGZyb20gJy4vd3JhcE1hcFRvUHJvcHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcFN0YXRlVG9Qcm9wc0lzRnVuY3Rpb24obWFwU3RhdGVUb1Byb3BzKSB7XG4gIHJldHVybiB0eXBlb2YgbWFwU3RhdGVUb1Byb3BzID09PSAnZnVuY3Rpb24nID8gd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFN0YXRlVG9Qcm9wcywgJ21hcFN0YXRlVG9Qcm9wcycpIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcFN0YXRlVG9Qcm9wc0lzTWlzc2luZyhtYXBTdGF0ZVRvUHJvcHMpIHtcbiAgcmV0dXJuICFtYXBTdGF0ZVRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge307XG4gIH0pIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBbd2hlbk1hcFN0YXRlVG9Qcm9wc0lzRnVuY3Rpb24sIHdoZW5NYXBTdGF0ZVRvUHJvcHNJc01pc3NpbmddO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L21hcFN0YXRlVG9Qcm9wcy5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCB2ZXJpZnlQbGFpbk9iamVjdCBmcm9tICcuLi91dGlscy92ZXJpZnlQbGFpbk9iamVjdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0TWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG93blByb3BzLCBzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBNZXJnZVByb3BzRnVuYyhtZXJnZVByb3BzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0TWVyZ2VQcm9wc1Byb3h5KGRpc3BhdGNoLCBfcmVmKSB7XG4gICAgdmFyIGRpc3BsYXlOYW1lID0gX3JlZi5kaXNwbGF5TmFtZSxcbiAgICAgICAgcHVyZSA9IF9yZWYucHVyZSxcbiAgICAgICAgYXJlTWVyZ2VkUHJvcHNFcXVhbCA9IF9yZWYuYXJlTWVyZ2VkUHJvcHNFcXVhbDtcblxuICAgIHZhciBoYXNSdW5PbmNlID0gZmFsc2U7XG4gICAgdmFyIG1lcmdlZFByb3BzID0gdm9pZCAwO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlUHJvcHNQcm94eShzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykge1xuICAgICAgdmFyIG5leHRNZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuXG4gICAgICBpZiAoaGFzUnVuT25jZSkge1xuICAgICAgICBpZiAoIXB1cmUgfHwgIWFyZU1lcmdlZFByb3BzRXF1YWwobmV4dE1lcmdlZFByb3BzLCBtZXJnZWRQcm9wcykpIG1lcmdlZFByb3BzID0gbmV4dE1lcmdlZFByb3BzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFzUnVuT25jZSA9IHRydWU7XG4gICAgICAgIG1lcmdlZFByb3BzID0gbmV4dE1lcmdlZFByb3BzO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB2ZXJpZnlQbGFpbk9iamVjdChtZXJnZWRQcm9wcywgZGlzcGxheU5hbWUsICdtZXJnZVByb3BzJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2hlbk1lcmdlUHJvcHNJc0Z1bmN0aW9uKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBtZXJnZVByb3BzID09PSAnZnVuY3Rpb24nID8gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2hlbk1lcmdlUHJvcHNJc09taXR0ZWQobWVyZ2VQcm9wcykge1xuICByZXR1cm4gIW1lcmdlUHJvcHMgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNZXJnZVByb3BzO1xuICB9IDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBbd2hlbk1lcmdlUHJvcHNJc0Z1bmN0aW9uLCB3aGVuTWVyZ2VQcm9wc0lzT21pdHRlZF07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWVyZ2VQcm9wcy5qc1xuLy8gbW9kdWxlIGlkID0gMTU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuaW1wb3J0IHZlcmlmeVN1YnNlbGVjdG9ycyBmcm9tICcuL3ZlcmlmeVN1YnNlbGVjdG9ycyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbXB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gaW1wdXJlRmluYWxQcm9wc1NlbGVjdG9yKHN0YXRlLCBvd25Qcm9wcykge1xuICAgIHJldHVybiBtZXJnZVByb3BzKG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpLCBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKSwgb3duUHJvcHMpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBfcmVmKSB7XG4gIHZhciBhcmVTdGF0ZXNFcXVhbCA9IF9yZWYuYXJlU3RhdGVzRXF1YWwsXG4gICAgICBhcmVPd25Qcm9wc0VxdWFsID0gX3JlZi5hcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsID0gX3JlZi5hcmVTdGF0ZVByb3BzRXF1YWw7XG5cbiAgdmFyIGhhc1J1bkF0TGVhc3RPbmNlID0gZmFsc2U7XG4gIHZhciBzdGF0ZSA9IHZvaWQgMDtcbiAgdmFyIG93blByb3BzID0gdm9pZCAwO1xuICB2YXIgc3RhdGVQcm9wcyA9IHZvaWQgMDtcbiAgdmFyIGRpc3BhdGNoUHJvcHMgPSB2b2lkIDA7XG4gIHZhciBtZXJnZWRQcm9wcyA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiBoYW5kbGVGaXJzdENhbGwoZmlyc3RTdGF0ZSwgZmlyc3RPd25Qcm9wcykge1xuICAgIHN0YXRlID0gZmlyc3RTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IGZpcnN0T3duUHJvcHM7XG4gICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIGhhc1J1bkF0TGVhc3RPbmNlID0gdHJ1ZTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCkge1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcblxuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcblxuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHMoKSB7XG4gICAgaWYgKG1hcFN0YXRlVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuXG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuXG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXdTdGF0ZSgpIHtcbiAgICB2YXIgbmV4dFN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICB2YXIgc3RhdGVQcm9wc0NoYW5nZWQgPSAhYXJlU3RhdGVQcm9wc0VxdWFsKG5leHRTdGF0ZVByb3BzLCBzdGF0ZVByb3BzKTtcbiAgICBzdGF0ZVByb3BzID0gbmV4dFN0YXRlUHJvcHM7XG5cbiAgICBpZiAoc3RhdGVQcm9wc0NoYW5nZWQpIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG5cbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICB2YXIgcHJvcHNDaGFuZ2VkID0gIWFyZU93blByb3BzRXF1YWwobmV4dE93blByb3BzLCBvd25Qcm9wcyk7XG4gICAgdmFyIHN0YXRlQ2hhbmdlZCA9ICFhcmVTdGF0ZXNFcXVhbChuZXh0U3RhdGUsIHN0YXRlKTtcbiAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IG5leHRPd25Qcm9wcztcblxuICAgIGlmIChwcm9wc0NoYW5nZWQgJiYgc3RhdGVDaGFuZ2VkKSByZXR1cm4gaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSgpO1xuICAgIGlmIChwcm9wc0NoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdQcm9wcygpO1xuICAgIGlmIChzdGF0ZUNoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdTdGF0ZSgpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSB7XG4gICAgcmV0dXJuIGhhc1J1bkF0TGVhc3RPbmNlID8gaGFuZGxlU3Vic2VxdWVudENhbGxzKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSA6IGhhbmRsZUZpcnN0Q2FsbChuZXh0U3RhdGUsIG5leHRPd25Qcm9wcyk7XG4gIH07XG59XG5cbi8vIFRPRE86IEFkZCBtb3JlIGNvbW1lbnRzXG5cbi8vIElmIHB1cmUgaXMgdHJ1ZSwgdGhlIHNlbGVjdG9yIHJldHVybmVkIGJ5IHNlbGVjdG9yRmFjdG9yeSB3aWxsIG1lbW9pemUgaXRzIHJlc3VsdHMsXG4vLyBhbGxvd2luZyBjb25uZWN0QWR2YW5jZWQncyBzaG91bGRDb21wb25lbnRVcGRhdGUgdG8gcmV0dXJuIGZhbHNlIGlmIGZpbmFsXG4vLyBwcm9wcyBoYXZlIG5vdCBjaGFuZ2VkLiBJZiBmYWxzZSwgdGhlIHNlbGVjdG9yIHdpbGwgYWx3YXlzIHJldHVybiBhIG5ld1xuLy8gb2JqZWN0IGFuZCBzaG91bGRDb21wb25lbnRVcGRhdGUgd2lsbCBhbHdheXMgcmV0dXJuIHRydWUuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkoZGlzcGF0Y2gsIF9yZWYyKSB7XG4gIHZhciBpbml0TWFwU3RhdGVUb1Byb3BzID0gX3JlZjIuaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMgPSBfcmVmMi5pbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICAgICAgaW5pdE1lcmdlUHJvcHMgPSBfcmVmMi5pbml0TWVyZ2VQcm9wcyxcbiAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnaW5pdE1hcFN0YXRlVG9Qcm9wcycsICdpbml0TWFwRGlzcGF0Y2hUb1Byb3BzJywgJ2luaXRNZXJnZVByb3BzJ10pO1xuXG4gIHZhciBtYXBTdGF0ZVRvUHJvcHMgPSBpbml0TWFwU3RhdGVUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgdmFyIG1hcERpc3BhdGNoVG9Qcm9wcyA9IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICB2YXIgbWVyZ2VQcm9wcyA9IGluaXRNZXJnZVByb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZlcmlmeVN1YnNlbGVjdG9ycyhtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgb3B0aW9ucy5kaXNwbGF5TmFtZSk7XG4gIH1cblxuICB2YXIgc2VsZWN0b3JGYWN0b3J5ID0gb3B0aW9ucy5wdXJlID8gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkgOiBpbXB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5O1xuXG4gIHJldHVybiBzZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBvcHRpb25zKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9zZWxlY3RvckZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDE1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgd2FybmluZyBmcm9tICcuLi91dGlscy93YXJuaW5nJztcblxuZnVuY3Rpb24gdmVyaWZ5KHNlbGVjdG9yLCBtZXRob2ROYW1lLCBkaXNwbGF5TmFtZSkge1xuICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHZhbHVlIGZvciAnICsgbWV0aG9kTmFtZSArICcgaW4gJyArIGRpc3BsYXlOYW1lICsgJy4nKTtcbiAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAnbWFwU3RhdGVUb1Byb3BzJyB8fCBtZXRob2ROYW1lID09PSAnbWFwRGlzcGF0Y2hUb1Byb3BzJykge1xuICAgIGlmICghc2VsZWN0b3IuaGFzT3duUHJvcGVydHkoJ2RlcGVuZHNPbk93blByb3BzJykpIHtcbiAgICAgIHdhcm5pbmcoJ1RoZSBzZWxlY3RvciBmb3IgJyArIG1ldGhvZE5hbWUgKyAnIG9mICcgKyBkaXNwbGF5TmFtZSArICcgZGlkIG5vdCBzcGVjaWZ5IGEgdmFsdWUgZm9yIGRlcGVuZHNPbk93blByb3BzLicpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2ZXJpZnlTdWJzZWxlY3RvcnMobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZlcmlmeShtYXBTdGF0ZVRvUHJvcHMsICdtYXBTdGF0ZVRvUHJvcHMnLCBkaXNwbGF5TmFtZSk7XG4gIHZlcmlmeShtYXBEaXNwYXRjaFRvUHJvcHMsICdtYXBEaXNwYXRjaFRvUHJvcHMnLCBkaXNwbGF5TmFtZSk7XG4gIHZlcmlmeShtZXJnZVByb3BzLCAnbWVyZ2VQcm9wcycsIGRpc3BsYXlOYW1lKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtcmVkdXgvZXMvY29ubmVjdC92ZXJpZnlTdWJzZWxlY3RvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDE1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vLyBlbmNhcHN1bGF0ZXMgdGhlIHN1YnNjcmlwdGlvbiBsb2dpYyBmb3IgY29ubmVjdGluZyBhIGNvbXBvbmVudCB0byB0aGUgcmVkdXggc3RvcmUsIGFzXG4vLyB3ZWxsIGFzIG5lc3Rpbmcgc3Vic2NyaXB0aW9ucyBvZiBkZXNjZW5kYW50IGNvbXBvbmVudHMsIHNvIHRoYXQgd2UgY2FuIGVuc3VyZSB0aGVcbi8vIGFuY2VzdG9yIGNvbXBvbmVudHMgcmUtcmVuZGVyIGJlZm9yZSBkZXNjZW5kYW50c1xuXG52YXIgQ0xFQVJFRCA9IG51bGw7XG52YXIgbnVsbExpc3RlbmVycyA9IHtcbiAgbm90aWZ5OiBmdW5jdGlvbiBub3RpZnkoKSB7fVxufTtcblxuZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCkge1xuICAvLyB0aGUgY3VycmVudC9uZXh0IHBhdHRlcm4gaXMgY29waWVkIGZyb20gcmVkdXgncyBjcmVhdGVTdG9yZSBjb2RlLlxuICAvLyBUT0RPOiByZWZhY3RvcitleHBvc2UgdGhhdCBjb2RlIHRvIGJlIHJldXNhYmxlIGhlcmU/XG4gIHZhciBjdXJyZW50ID0gW107XG4gIHZhciBuZXh0ID0gW107XG5cbiAgcmV0dXJuIHtcbiAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBuZXh0ID0gQ0xFQVJFRDtcbiAgICAgIGN1cnJlbnQgPSBDTEVBUkVEO1xuICAgIH0sXG4gICAgbm90aWZ5OiBmdW5jdGlvbiBub3RpZnkoKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudCA9IG5leHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsaXN0ZW5lcnNbaV0oKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfSxcbiAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICBpZiAobmV4dCA9PT0gY3VycmVudCkgbmV4dCA9IGN1cnJlbnQuc2xpY2UoKTtcbiAgICAgIG5leHQucHVzaChsaXN0ZW5lcik7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKCFpc1N1YnNjcmliZWQgfHwgY3VycmVudCA9PT0gQ0xFQVJFRCkgcmV0dXJuO1xuICAgICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAobmV4dCA9PT0gY3VycmVudCkgbmV4dCA9IGN1cnJlbnQuc2xpY2UoKTtcbiAgICAgICAgbmV4dC5zcGxpY2UobmV4dC5pbmRleE9mKGxpc3RlbmVyKSwgMSk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKHN0b3JlLCBwYXJlbnRTdWIsIG9uU3RhdGVDaGFuZ2UpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3Vic2NyaXB0aW9uKTtcblxuICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB0aGlzLnBhcmVudFN1YiA9IHBhcmVudFN1YjtcbiAgICB0aGlzLm9uU3RhdGVDaGFuZ2UgPSBvblN0YXRlQ2hhbmdlO1xuICAgIHRoaXMudW5zdWJzY3JpYmUgPSBudWxsO1xuICAgIHRoaXMubGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgfVxuXG4gIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuYWRkTmVzdGVkU3ViID0gZnVuY3Rpb24gYWRkTmVzdGVkU3ViKGxpc3RlbmVyKSB7XG4gICAgdGhpcy50cnlTdWJzY3JpYmUoKTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgfTtcblxuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLm5vdGlmeU5lc3RlZFN1YnMgPSBmdW5jdGlvbiBub3RpZnlOZXN0ZWRTdWJzKCkge1xuICAgIHRoaXMubGlzdGVuZXJzLm5vdGlmeSgpO1xuICB9O1xuXG4gIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuaXNTdWJzY3JpYmVkID0gZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMudW5zdWJzY3JpYmUpO1xuICB9O1xuXG4gIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudHJ5U3Vic2NyaWJlID0gZnVuY3Rpb24gdHJ5U3Vic2NyaWJlKCkge1xuICAgIGlmICghdGhpcy51bnN1YnNjcmliZSkge1xuICAgICAgdGhpcy51bnN1YnNjcmliZSA9IHRoaXMucGFyZW50U3ViID8gdGhpcy5wYXJlbnRTdWIuYWRkTmVzdGVkU3ViKHRoaXMub25TdGF0ZUNoYW5nZSkgOiB0aGlzLnN0b3JlLnN1YnNjcmliZSh0aGlzLm9uU3RhdGVDaGFuZ2UpO1xuXG4gICAgICB0aGlzLmxpc3RlbmVycyA9IGNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbigpO1xuICAgIH1cbiAgfTtcblxuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnRyeVVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdHJ5VW5zdWJzY3JpYmUoKSB7XG4gICAgaWYgKHRoaXMudW5zdWJzY3JpYmUpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUgPSBudWxsO1xuICAgICAgdGhpcy5saXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgIHRoaXMubGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKTtcblxuZXhwb3J0IHsgU3Vic2NyaXB0aW9uIGFzIGRlZmF1bHQgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtcmVkdXgvZXMvdXRpbHMvU3Vic2NyaXB0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChpcyhvYmpBLCBvYmpCKSkgcmV0dXJuIHRydWU7XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093bi5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1yZWR1eC9lcy91dGlscy9zaGFsbG93RXF1YWwuanNcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMi4wJztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ107XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfQ0FMTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuY2FsbCcpIDogMHhlYWM4O1xudmFyIFJFQUNUX1JFVFVSTl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucmV0dXJuJykgOiAweGVhYzk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBXQVJOSU5HOiBETyBOT1QgbWFudWFsbHkgcmVxdWlyZSB0aGlzIG1vZHVsZS5cbiAqIFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgYGludmFyaWFudCguLi4pYCB1c2VkIGJ5IHRoZSBlcnJvciBjb2RlIHN5c3RlbVxuICogYW5kIHdpbGwgX29ubHlfIGJlIHJlcXVpcmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGJhYmVsIHBhc3MuXG4gKiBJdCBhbHdheXMgdGhyb3dzLlxuICovXG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyAnLicgKyBjYWxsZXJOYW1lO1xuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuXFxuXFxuUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpIDogdm9pZCAwO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgLy8gRHVwbGljYXRlZCBmcm9tIENvbXBvbmVudC5cbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG5mdW5jdGlvbiBBc3luY0NvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gQ29tcG9uZW50LlxuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIGFzeW5jQ29tcG9uZW50UHJvdG90eXBlID0gQXN5bmNDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFzeW5jQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKGFzeW5jQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbmFzeW5jQ29tcG9uZW50UHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9IHRydWU7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcblxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcblxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pO1xuICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTtcbiAgICAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIHByb3BzID0ge307XG5cbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLiQkdHlwZW9mID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBSZWFjdEVsZW1lbnRzIG9mIGEgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZmFjdG9yeVxuICovXG5cblxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmO1xuICAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcblxuICAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIGNvbXBvbmVudC5cbiAqIEBmaW5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcblxue1xuICAvLyBDb21wb25lbnQgdGhhdCBpcyBiZWluZyB3b3JrZWQgb25cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuICAgIGlmIChpbXBsKSB7XG4gICAgICByZXR1cm4gaW1wbCgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxudmFyIFBPT0xfU0laRSA9IDEwO1xudmFyIHRyYXZlcnNlQ29udGV4dFBvb2wgPSBbXTtcbmZ1bmN0aW9uIGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IHRyYXZlcnNlQ29udGV4dFBvb2wucG9wKCk7XG4gICAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbWFwRnVuY3Rpb247XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gICAgcmV0dXJuIHRyYXZlcnNlQ29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBtYXBSZXN1bHQsXG4gICAgICBrZXlQcmVmaXg6IGtleVByZWZpeCxcbiAgICAgIGZ1bmM6IG1hcEZ1bmN0aW9uLFxuICAgICAgY29udGV4dDogbWFwQ29udGV4dCxcbiAgICAgIGNvdW50OiAwXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCkge1xuICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGggPCBQT09MX1NJWkUpIHtcbiAgICB0cmF2ZXJzZUNvbnRleHRQb29sLnB1c2godHJhdmVyc2VDb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nICsgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSAnJyArIGNoaWxkcmVuO1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50ICE9PSBudWxsICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChudWxsLCBudWxsLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXG4gICAgICBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpIDogdm9pZCAwO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG57XG4gIHZhciBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG5cbiAgdmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG5cbiAgdmFyIGdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyNlbXB0eSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJyN0ZXh0JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICByZXR1cm4gJ1JlYWN0LkZyYWdtZW50JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZSB8fCBlbGVtZW50LnR5cGUubmFtZSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnO1xuICAgIGlmIChjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXREaXNwbGF5TmFtZShjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCk7XG4gICAgICB2YXIgb3duZXIgPSBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fb3duZXI7XG4gICAgICBzdGFjayArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIGdldENvbXBvbmVudE5hbWUob3duZXIpKTtcbiAgICB9XG4gICAgc3RhY2sgKz0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBWQUxJRF9GUkFHTUVOVF9QUk9QUyA9IG5ldyBNYXAoW1snY2hpbGRyZW4nLCB0cnVlXSwgWydrZXknLCB0cnVlXV0pO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudFByb3BzLl9fc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudFByb3BzLl9fc291cmNlO1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSAnXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lcikgKyAnLic7XG4gIH1cblxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4lcycsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIHZhciBwcm9wVHlwZXMgPSBjb21wb25lbnRDbGFzcy5wcm9wVHlwZXM7XG4gIGlmIChwcm9wVHlwZXMpIHtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0pO1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbiAgfSBlbHNlIGlmIChjb21wb25lbnRDbGFzcy5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIG5hbWUgfHwgJ1Vua25vd24nKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZnJhZ21lbnQ7XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBpZiAoIVZBTElEX0ZSQUdNRU5UX1BST1BTLmhhcyhrZXkpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJXMnLCBrZXksIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yWydyZXR1cm4nXSkge1xuICAgICAgICBfaXRlcmF0b3JbJ3JldHVybiddKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJXMnLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG5cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHR5cGUgPT09ICdzeW1ib2wnIHx8IHR5cGVvZiB0eXBlID09PSAnbnVtYmVyJztcbiAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0ocHJvcHMpO1xuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgaW5mbyArPSBnZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG5cbiAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3ltYm9sJyAmJiB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG52YXIgUmVhY3QgPSB7XG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBtYXBDaGlsZHJlbixcbiAgICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gICAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gICAgdG9BcnJheTogdG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUHVyZUNvbXBvbmVudCxcbiAgdW5zdGFibGVfQXN5bmNDb21wb25lbnQ6IEFzeW5jQ29tcG9uZW50LFxuXG4gIEZyYWdtZW50OiBSRUFDVF9GUkFHTUVOVF9UWVBFLFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uLFxuICBpc1ZhbGlkRWxlbWVudDogaXNWYWxpZEVsZW1lbnQsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOiB7XG4gICAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gICAgYXNzaWduOiBfYXNzaWduXG4gIH1cbn07XG5cbntcbiAgX2Fzc2lnbihSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCwge1xuICAgIC8vIFRoZXNlIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gcHJvZHVjdGlvbi5cbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lOiBSZWFjdERlYnVnQ3VycmVudEZyYW1lLFxuICAgIC8vIFNoaW0gZm9yIFJlYWN0IERPTSAxNi4wLjAgd2hpY2ggc3RpbGwgZGVzdHJ1Y3R1cmVkIChidXQgbm90IHVzZWQpIHRoaXMuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LjAuXG4gICAgUmVhY3RDb21wb25lbnRUcmVlSG9vazoge31cbiAgfSk7XG59XG5cblxuXG52YXIgUmVhY3QkMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdFxufSk7XG5cbnZhciBSZWFjdCQzID0gKCBSZWFjdCQyICYmIFJlYWN0ICkgfHwgUmVhY3QkMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3QgPSBSZWFjdCQzWydkZWZhdWx0J10gPyBSZWFjdCQzWydkZWZhdWx0J10gOiBSZWFjdCQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0O1xuICB9KSgpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMi4wXG4gKiByZWFjdC5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0Jzt2YXIgbT1yZXF1aXJlKFwib2JqZWN0LWFzc2lnblwiKSxuPXJlcXVpcmUoXCJmYmpzL2xpYi9lbXB0eU9iamVjdFwiKSxwPXJlcXVpcmUoXCJmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uXCIpLHE9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sW1wiZm9yXCJdLHI9cT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5lbGVtZW50XCIpOjYwMTAzLHQ9cT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5jYWxsXCIpOjYwMTA0LHU9cT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5yZXR1cm5cIik6NjAxMDUsdj1xP1N5bWJvbFtcImZvclwiXShcInJlYWN0LnBvcnRhbFwiKTo2MDEwNix3PXE/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuZnJhZ21lbnRcIik6NjAxMDcseD1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3I7XG5mdW5jdGlvbiB5KGEpe2Zvcih2YXIgYj1hcmd1bWVudHMubGVuZ3RoLTEsZT1cIk1pbmlmaWVkIFJlYWN0IGVycm9yICNcIithK1wiOyB2aXNpdCBodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudFxceDNkXCIrYSxjPTA7YzxiO2MrKyllKz1cIlxceDI2YXJnc1tdXFx4M2RcIitlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2MrMV0pO2I9RXJyb3IoZStcIiBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuXCIpO2IubmFtZT1cIkludmFyaWFudCBWaW9sYXRpb25cIjtiLmZyYW1lc1RvUG9wPTE7dGhyb3cgYjt9XG52YXIgej17aXNNb3VudGVkOmZ1bmN0aW9uKCl7cmV0dXJuITF9LGVucXVldWVGb3JjZVVwZGF0ZTpmdW5jdGlvbigpe30sZW5xdWV1ZVJlcGxhY2VTdGF0ZTpmdW5jdGlvbigpe30sZW5xdWV1ZVNldFN0YXRlOmZ1bmN0aW9uKCl7fX07ZnVuY3Rpb24gQShhLGIsZSl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1uO3RoaXMudXBkYXRlcj1lfHx6fUEucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9e307QS5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24oYSxiKXtcIm9iamVjdFwiIT09dHlwZW9mIGEmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiZudWxsIT1hP3koXCI4NVwiKTp2b2lkIDA7dGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLGEsYixcInNldFN0YXRlXCIpfTtBLnByb3RvdHlwZS5mb3JjZVVwZGF0ZT1mdW5jdGlvbihhKXt0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsYSxcImZvcmNlVXBkYXRlXCIpfTtcbmZ1bmN0aW9uIEIoYSxiLGUpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9bjt0aGlzLnVwZGF0ZXI9ZXx8en1mdW5jdGlvbiBDKCl7fUMucHJvdG90eXBlPUEucHJvdG90eXBlO3ZhciBEPUIucHJvdG90eXBlPW5ldyBDO0QuY29uc3RydWN0b3I9QjttKEQsQS5wcm90b3R5cGUpO0QuaXNQdXJlUmVhY3RDb21wb25lbnQ9ITA7ZnVuY3Rpb24gRShhLGIsZSl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1uO3RoaXMudXBkYXRlcj1lfHx6fXZhciBGPUUucHJvdG90eXBlPW5ldyBDO0YuY29uc3RydWN0b3I9RTttKEYsQS5wcm90b3R5cGUpO0YudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50PSEwO0YucmVuZGVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW59O3ZhciBHPXtjdXJyZW50Om51bGx9LEg9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxJPXtrZXk6ITAscmVmOiEwLF9fc2VsZjohMCxfX3NvdXJjZTohMH07XG5mdW5jdGlvbiBKKGEsYixlKXt2YXIgYyxkPXt9LGc9bnVsbCxrPW51bGw7aWYobnVsbCE9Yilmb3IoYyBpbiB2b2lkIDAhPT1iLnJlZiYmKGs9Yi5yZWYpLHZvaWQgMCE9PWIua2V5JiYoZz1cIlwiK2Iua2V5KSxiKUguY2FsbChiLGMpJiYhSS5oYXNPd25Qcm9wZXJ0eShjKSYmKGRbY109YltjXSk7dmFyIGY9YXJndW1lbnRzLmxlbmd0aC0yO2lmKDE9PT1mKWQuY2hpbGRyZW49ZTtlbHNlIGlmKDE8Zil7Zm9yKHZhciBoPUFycmF5KGYpLGw9MDtsPGY7bCsrKWhbbF09YXJndW1lbnRzW2wrMl07ZC5jaGlsZHJlbj1ofWlmKGEmJmEuZGVmYXVsdFByb3BzKWZvcihjIGluIGY9YS5kZWZhdWx0UHJvcHMsZil2b2lkIDA9PT1kW2NdJiYoZFtjXT1mW2NdKTtyZXR1cm57JCR0eXBlb2Y6cix0eXBlOmEsa2V5OmcscmVmOmsscHJvcHM6ZCxfb3duZXI6Ry5jdXJyZW50fX1mdW5jdGlvbiBLKGEpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJmEuJCR0eXBlb2Y9PT1yfVxuZnVuY3Rpb24gZXNjYXBlKGEpe3ZhciBiPXtcIlxceDNkXCI6XCJcXHgzZDBcIixcIjpcIjpcIlxceDNkMlwifTtyZXR1cm5cIiRcIisoXCJcIithKS5yZXBsYWNlKC9bPTpdL2csZnVuY3Rpb24oYSl7cmV0dXJuIGJbYV19KX12YXIgTD0vXFwvKy9nLE09W107ZnVuY3Rpb24gTihhLGIsZSxjKXtpZihNLmxlbmd0aCl7dmFyIGQ9TS5wb3AoKTtkLnJlc3VsdD1hO2Qua2V5UHJlZml4PWI7ZC5mdW5jPWU7ZC5jb250ZXh0PWM7ZC5jb3VudD0wO3JldHVybiBkfXJldHVybntyZXN1bHQ6YSxrZXlQcmVmaXg6YixmdW5jOmUsY29udGV4dDpjLGNvdW50OjB9fWZ1bmN0aW9uIE8oYSl7YS5yZXN1bHQ9bnVsbDthLmtleVByZWZpeD1udWxsO2EuZnVuYz1udWxsO2EuY29udGV4dD1udWxsO2EuY291bnQ9MDsxMD5NLmxlbmd0aCYmTS5wdXNoKGEpfVxuZnVuY3Rpb24gUChhLGIsZSxjKXt2YXIgZD10eXBlb2YgYTtpZihcInVuZGVmaW5lZFwiPT09ZHx8XCJib29sZWFuXCI9PT1kKWE9bnVsbDt2YXIgZz0hMTtpZihudWxsPT09YSlnPSEwO2Vsc2Ugc3dpdGNoKGQpe2Nhc2UgXCJzdHJpbmdcIjpjYXNlIFwibnVtYmVyXCI6Zz0hMDticmVhaztjYXNlIFwib2JqZWN0XCI6c3dpdGNoKGEuJCR0eXBlb2Ype2Nhc2UgcjpjYXNlIHQ6Y2FzZSB1OmNhc2UgdjpnPSEwfX1pZihnKXJldHVybiBlKGMsYSxcIlwiPT09Yj9cIi5cIitRKGEsMCk6YiksMTtnPTA7Yj1cIlwiPT09Yj9cIi5cIjpiK1wiOlwiO2lmKEFycmF5LmlzQXJyYXkoYSkpZm9yKHZhciBrPTA7azxhLmxlbmd0aDtrKyspe2Q9YVtrXTt2YXIgZj1iK1EoZCxrKTtnKz1QKGQsZixlLGMpfWVsc2UgaWYobnVsbD09PWF8fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgYT9mPW51bGw6KGY9eCYmYVt4XXx8YVtcIkBAaXRlcmF0b3JcIl0sZj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgZj9mOm51bGwpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBmKWZvcihhPVxuZi5jYWxsKGEpLGs9MDshKGQ9YS5uZXh0KCkpLmRvbmU7KWQ9ZC52YWx1ZSxmPWIrUShkLGsrKyksZys9UChkLGYsZSxjKTtlbHNlXCJvYmplY3RcIj09PWQmJihlPVwiXCIrYSx5KFwiMzFcIixcIltvYmplY3QgT2JqZWN0XVwiPT09ZT9cIm9iamVjdCB3aXRoIGtleXMge1wiK09iamVjdC5rZXlzKGEpLmpvaW4oXCIsIFwiKStcIn1cIjplLFwiXCIpKTtyZXR1cm4gZ31mdW5jdGlvbiBRKGEsYil7cmV0dXJuXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSYmbnVsbCE9YS5rZXk/ZXNjYXBlKGEua2V5KTpiLnRvU3RyaW5nKDM2KX1mdW5jdGlvbiBSKGEsYil7YS5mdW5jLmNhbGwoYS5jb250ZXh0LGIsYS5jb3VudCsrKX1cbmZ1bmN0aW9uIFMoYSxiLGUpe3ZhciBjPWEucmVzdWx0LGQ9YS5rZXlQcmVmaXg7YT1hLmZ1bmMuY2FsbChhLmNvbnRleHQsYixhLmNvdW50KyspO0FycmF5LmlzQXJyYXkoYSk/VChhLGMsZSxwLnRoYXRSZXR1cm5zQXJndW1lbnQpOm51bGwhPWEmJihLKGEpJiYoYj1kKyghYS5rZXl8fGImJmIua2V5PT09YS5rZXk/XCJcIjooXCJcIithLmtleSkucmVwbGFjZShMLFwiJFxceDI2L1wiKStcIi9cIikrZSxhPXskJHR5cGVvZjpyLHR5cGU6YS50eXBlLGtleTpiLHJlZjphLnJlZixwcm9wczphLnByb3BzLF9vd25lcjphLl9vd25lcn0pLGMucHVzaChhKSl9ZnVuY3Rpb24gVChhLGIsZSxjLGQpe3ZhciBnPVwiXCI7bnVsbCE9ZSYmKGc9KFwiXCIrZSkucmVwbGFjZShMLFwiJFxceDI2L1wiKStcIi9cIik7Yj1OKGIsZyxjLGQpO251bGw9PWF8fFAoYSxcIlwiLFMsYik7TyhiKX1cbnZhciBVPXtDaGlsZHJlbjp7bWFwOmZ1bmN0aW9uKGEsYixlKXtpZihudWxsPT1hKXJldHVybiBhO3ZhciBjPVtdO1QoYSxjLG51bGwsYixlKTtyZXR1cm4gY30sZm9yRWFjaDpmdW5jdGlvbihhLGIsZSl7aWYobnVsbD09YSlyZXR1cm4gYTtiPU4obnVsbCxudWxsLGIsZSk7bnVsbD09YXx8UChhLFwiXCIsUixiKTtPKGIpfSxjb3VudDpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09YT8wOlAoYSxcIlwiLHAudGhhdFJldHVybnNOdWxsLG51bGwpfSx0b0FycmF5OmZ1bmN0aW9uKGEpe3ZhciBiPVtdO1QoYSxiLG51bGwscC50aGF0UmV0dXJuc0FyZ3VtZW50KTtyZXR1cm4gYn0sb25seTpmdW5jdGlvbihhKXtLKGEpP3ZvaWQgMDp5KFwiMTQzXCIpO3JldHVybiBhfX0sQ29tcG9uZW50OkEsUHVyZUNvbXBvbmVudDpCLHVuc3RhYmxlX0FzeW5jQ29tcG9uZW50OkUsRnJhZ21lbnQ6dyxjcmVhdGVFbGVtZW50OkosY2xvbmVFbGVtZW50OmZ1bmN0aW9uKGEsYixlKXt2YXIgYz1tKHt9LGEucHJvcHMpLFxuZD1hLmtleSxnPWEucmVmLGs9YS5fb3duZXI7aWYobnVsbCE9Yil7dm9pZCAwIT09Yi5yZWYmJihnPWIucmVmLGs9Ry5jdXJyZW50KTt2b2lkIDAhPT1iLmtleSYmKGQ9XCJcIitiLmtleSk7aWYoYS50eXBlJiZhLnR5cGUuZGVmYXVsdFByb3BzKXZhciBmPWEudHlwZS5kZWZhdWx0UHJvcHM7Zm9yKGggaW4gYilILmNhbGwoYixoKSYmIUkuaGFzT3duUHJvcGVydHkoaCkmJihjW2hdPXZvaWQgMD09PWJbaF0mJnZvaWQgMCE9PWY/ZltoXTpiW2hdKX12YXIgaD1hcmd1bWVudHMubGVuZ3RoLTI7aWYoMT09PWgpYy5jaGlsZHJlbj1lO2Vsc2UgaWYoMTxoKXtmPUFycmF5KGgpO2Zvcih2YXIgbD0wO2w8aDtsKyspZltsXT1hcmd1bWVudHNbbCsyXTtjLmNoaWxkcmVuPWZ9cmV0dXJueyQkdHlwZW9mOnIsdHlwZTphLnR5cGUsa2V5OmQscmVmOmcscHJvcHM6Yyxfb3duZXI6a319LGNyZWF0ZUZhY3Rvcnk6ZnVuY3Rpb24oYSl7dmFyIGI9Si5iaW5kKG51bGwsYSk7Yi50eXBlPWE7cmV0dXJuIGJ9LFxuaXNWYWxpZEVsZW1lbnQ6Syx2ZXJzaW9uOlwiMTYuMi4wXCIsX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6e1JlYWN0Q3VycmVudE93bmVyOkcsYXNzaWduOm19fSxWPU9iamVjdC5mcmVlemUoe2RlZmF1bHQ6VX0pLFc9ViYmVXx8Vjttb2R1bGUuZXhwb3J0cz1XW1wiZGVmYXVsdFwiXT9XW1wiZGVmYXVsdFwiXTpXO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0L2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLnByaW50QnVmZmVyID0gcHJpbnRCdWZmZXI7XG5cbnZhciBfaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG52YXIgX2RpZmYgPSByZXF1aXJlKCcuL2RpZmYnKTtcblxudmFyIF9kaWZmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RpZmYpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxuLyoqXG4gKiBHZXQgbG9nIGxldmVsIHN0cmluZyBiYXNlZCBvbiBzdXBwbGllZCBwYXJhbXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZyB8IGZ1bmN0aW9uIHwgb2JqZWN0fSBsZXZlbCAtIGNvbnNvbGVbbGV2ZWxdXG4gKiBAcGFyYW0ge29iamVjdH0gYWN0aW9uIC0gc2VsZWN0ZWQgYWN0aW9uXG4gKiBAcGFyYW0ge2FycmF5fSBwYXlsb2FkIC0gc2VsZWN0ZWQgcGF5bG9hZFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBsb2cgZW50cnkgdHlwZVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGxldmVsXG4gKi9cbmZ1bmN0aW9uIGdldExvZ0xldmVsKGxldmVsLCBhY3Rpb24sIHBheWxvYWQsIHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlb2YgbGV2ZWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGxldmVsKSkge1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gdHlwZW9mIGxldmVsW3R5cGVdID09PSAnZnVuY3Rpb24nID8gbGV2ZWxbdHlwZV0uYXBwbHkobGV2ZWwsIF90b0NvbnN1bWFibGVBcnJheShwYXlsb2FkKSkgOiBsZXZlbFt0eXBlXTtcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gbGV2ZWwoYWN0aW9uKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGxldmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUaXRsZUZvcm1hdHRlcihvcHRpb25zKSB7XG4gIHZhciB0aW1lc3RhbXAgPSBvcHRpb25zLnRpbWVzdGFtcCxcbiAgICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcblxuXG4gIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uLCB0aW1lLCB0b29rKSB7XG4gICAgdmFyIHBhcnRzID0gWydhY3Rpb24nXTtcblxuICAgIHBhcnRzLnB1c2goJyVjJyArIFN0cmluZyhhY3Rpb24udHlwZSkpO1xuICAgIGlmICh0aW1lc3RhbXApIHBhcnRzLnB1c2goJyVjQCAnICsgdGltZSk7XG4gICAgaWYgKGR1cmF0aW9uKSBwYXJ0cy5wdXNoKCclYyhpbiAnICsgdG9vay50b0ZpeGVkKDIpICsgJyBtcyknKTtcblxuICAgIHJldHVybiBwYXJ0cy5qb2luKCcgJyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByaW50QnVmZmVyKGJ1ZmZlciwgb3B0aW9ucykge1xuICB2YXIgbG9nZ2VyID0gb3B0aW9ucy5sb2dnZXIsXG4gICAgICBhY3Rpb25UcmFuc2Zvcm1lciA9IG9wdGlvbnMuYWN0aW9uVHJhbnNmb3JtZXIsXG4gICAgICBfb3B0aW9ucyR0aXRsZUZvcm1hdHQgPSBvcHRpb25zLnRpdGxlRm9ybWF0dGVyLFxuICAgICAgdGl0bGVGb3JtYXR0ZXIgPSBfb3B0aW9ucyR0aXRsZUZvcm1hdHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRUaXRsZUZvcm1hdHRlcihvcHRpb25zKSA6IF9vcHRpb25zJHRpdGxlRm9ybWF0dCxcbiAgICAgIGNvbGxhcHNlZCA9IG9wdGlvbnMuY29sbGFwc2VkLFxuICAgICAgY29sb3JzID0gb3B0aW9ucy5jb2xvcnMsXG4gICAgICBsZXZlbCA9IG9wdGlvbnMubGV2ZWwsXG4gICAgICBkaWZmID0gb3B0aW9ucy5kaWZmO1xuXG5cbiAgYnVmZmVyLmZvckVhY2goZnVuY3Rpb24gKGxvZ0VudHJ5LCBrZXkpIHtcbiAgICB2YXIgc3RhcnRlZCA9IGxvZ0VudHJ5LnN0YXJ0ZWQsXG4gICAgICAgIHN0YXJ0ZWRUaW1lID0gbG9nRW50cnkuc3RhcnRlZFRpbWUsXG4gICAgICAgIGFjdGlvbiA9IGxvZ0VudHJ5LmFjdGlvbixcbiAgICAgICAgcHJldlN0YXRlID0gbG9nRW50cnkucHJldlN0YXRlLFxuICAgICAgICBlcnJvciA9IGxvZ0VudHJ5LmVycm9yO1xuICAgIHZhciB0b29rID0gbG9nRW50cnkudG9vayxcbiAgICAgICAgbmV4dFN0YXRlID0gbG9nRW50cnkubmV4dFN0YXRlO1xuXG4gICAgdmFyIG5leHRFbnRyeSA9IGJ1ZmZlcltrZXkgKyAxXTtcblxuICAgIGlmIChuZXh0RW50cnkpIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRFbnRyeS5wcmV2U3RhdGU7XG4gICAgICB0b29rID0gbmV4dEVudHJ5LnN0YXJ0ZWQgLSBzdGFydGVkO1xuICAgIH1cblxuICAgIC8vIE1lc3NhZ2VcbiAgICB2YXIgZm9ybWF0dGVkQWN0aW9uID0gYWN0aW9uVHJhbnNmb3JtZXIoYWN0aW9uKTtcbiAgICB2YXIgaXNDb2xsYXBzZWQgPSB0eXBlb2YgY29sbGFwc2VkID09PSAnZnVuY3Rpb24nID8gY29sbGFwc2VkKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgfSwgYWN0aW9uLCBsb2dFbnRyeSkgOiBjb2xsYXBzZWQ7XG5cbiAgICB2YXIgZm9ybWF0dGVkVGltZSA9ICgwLCBfaGVscGVycy5mb3JtYXRUaW1lKShzdGFydGVkVGltZSk7XG4gICAgdmFyIHRpdGxlQ1NTID0gY29sb3JzLnRpdGxlID8gJ2NvbG9yOiAnICsgY29sb3JzLnRpdGxlKGZvcm1hdHRlZEFjdGlvbikgKyAnOycgOiAnJztcbiAgICB2YXIgaGVhZGVyQ1NTID0gWydjb2xvcjogZ3JheTsgZm9udC13ZWlnaHQ6IGxpZ2h0ZXI7J107XG4gICAgaGVhZGVyQ1NTLnB1c2godGl0bGVDU1MpO1xuICAgIGlmIChvcHRpb25zLnRpbWVzdGFtcCkgaGVhZGVyQ1NTLnB1c2goJ2NvbG9yOiBncmF5OyBmb250LXdlaWdodDogbGlnaHRlcjsnKTtcbiAgICBpZiAob3B0aW9ucy5kdXJhdGlvbikgaGVhZGVyQ1NTLnB1c2goJ2NvbG9yOiBncmF5OyBmb250LXdlaWdodDogbGlnaHRlcjsnKTtcbiAgICB2YXIgdGl0bGUgPSB0aXRsZUZvcm1hdHRlcihmb3JtYXR0ZWRBY3Rpb24sIGZvcm1hdHRlZFRpbWUsIHRvb2spO1xuXG4gICAgLy8gUmVuZGVyXG4gICAgdHJ5IHtcbiAgICAgIGlmIChpc0NvbGxhcHNlZCkge1xuICAgICAgICBpZiAoY29sb3JzLnRpdGxlKSBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQuYXBwbHkobG9nZ2VyLCBbJyVjICcgKyB0aXRsZV0uY29uY2F0KGhlYWRlckNTUykpO2Vsc2UgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKHRpdGxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjb2xvcnMudGl0bGUpIGxvZ2dlci5ncm91cC5hcHBseShsb2dnZXIsIFsnJWMgJyArIHRpdGxlXS5jb25jYXQoaGVhZGVyQ1NTKSk7ZWxzZSBsb2dnZXIuZ3JvdXAodGl0bGUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlci5sb2codGl0bGUpO1xuICAgIH1cblxuICAgIHZhciBwcmV2U3RhdGVMZXZlbCA9IGdldExvZ0xldmVsKGxldmVsLCBmb3JtYXR0ZWRBY3Rpb24sIFtwcmV2U3RhdGVdLCAncHJldlN0YXRlJyk7XG4gICAgdmFyIGFjdGlvbkxldmVsID0gZ2V0TG9nTGV2ZWwobGV2ZWwsIGZvcm1hdHRlZEFjdGlvbiwgW2Zvcm1hdHRlZEFjdGlvbl0sICdhY3Rpb24nKTtcbiAgICB2YXIgZXJyb3JMZXZlbCA9IGdldExvZ0xldmVsKGxldmVsLCBmb3JtYXR0ZWRBY3Rpb24sIFtlcnJvciwgcHJldlN0YXRlXSwgJ2Vycm9yJyk7XG4gICAgdmFyIG5leHRTdGF0ZUxldmVsID0gZ2V0TG9nTGV2ZWwobGV2ZWwsIGZvcm1hdHRlZEFjdGlvbiwgW25leHRTdGF0ZV0sICduZXh0U3RhdGUnKTtcblxuICAgIGlmIChwcmV2U3RhdGVMZXZlbCkge1xuICAgICAgaWYgKGNvbG9ycy5wcmV2U3RhdGUpIGxvZ2dlcltwcmV2U3RhdGVMZXZlbF0oJyVjIHByZXYgc3RhdGUnLCAnY29sb3I6ICcgKyBjb2xvcnMucHJldlN0YXRlKHByZXZTdGF0ZSkgKyAnOyBmb250LXdlaWdodDogYm9sZCcsIHByZXZTdGF0ZSk7ZWxzZSBsb2dnZXJbcHJldlN0YXRlTGV2ZWxdKCdwcmV2IHN0YXRlJywgcHJldlN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uTGV2ZWwpIHtcbiAgICAgIGlmIChjb2xvcnMuYWN0aW9uKSBsb2dnZXJbYWN0aW9uTGV2ZWxdKCclYyBhY3Rpb24gICAgJywgJ2NvbG9yOiAnICsgY29sb3JzLmFjdGlvbihmb3JtYXR0ZWRBY3Rpb24pICsgJzsgZm9udC13ZWlnaHQ6IGJvbGQnLCBmb3JtYXR0ZWRBY3Rpb24pO2Vsc2UgbG9nZ2VyW2FjdGlvbkxldmVsXSgnYWN0aW9uICAgICcsIGZvcm1hdHRlZEFjdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yICYmIGVycm9yTGV2ZWwpIHtcbiAgICAgIGlmIChjb2xvcnMuZXJyb3IpIGxvZ2dlcltlcnJvckxldmVsXSgnJWMgZXJyb3IgICAgICcsICdjb2xvcjogJyArIGNvbG9ycy5lcnJvcihlcnJvciwgcHJldlN0YXRlKSArICc7IGZvbnQtd2VpZ2h0OiBib2xkOycsIGVycm9yKTtlbHNlIGxvZ2dlcltlcnJvckxldmVsXSgnZXJyb3IgICAgICcsIGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dFN0YXRlTGV2ZWwpIHtcbiAgICAgIGlmIChjb2xvcnMubmV4dFN0YXRlKSBsb2dnZXJbbmV4dFN0YXRlTGV2ZWxdKCclYyBuZXh0IHN0YXRlJywgJ2NvbG9yOiAnICsgY29sb3JzLm5leHRTdGF0ZShuZXh0U3RhdGUpICsgJzsgZm9udC13ZWlnaHQ6IGJvbGQnLCBuZXh0U3RhdGUpO2Vsc2UgbG9nZ2VyW25leHRTdGF0ZUxldmVsXSgnbmV4dCBzdGF0ZScsIG5leHRTdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGRpZmYpIHtcbiAgICAgICgwLCBfZGlmZjIuZGVmYXVsdCkocHJldlN0YXRlLCBuZXh0U3RhdGUsIGxvZ2dlciwgaXNDb2xsYXBzZWQpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXIubG9nKCdcXHUyMDE0XFx1MjAxNCBsb2cgZW5kIFxcdTIwMTRcXHUyMDE0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVkdXgtbG9nZ2VyL2xpYi9jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGxldmVsOiBcImxvZ1wiLFxuICBsb2dnZXI6IGNvbnNvbGUsXG4gIGxvZ0Vycm9yczogdHJ1ZSxcbiAgY29sbGFwc2VkOiB1bmRlZmluZWQsXG4gIHByZWRpY2F0ZTogdW5kZWZpbmVkLFxuICBkdXJhdGlvbjogZmFsc2UsXG4gIHRpbWVzdGFtcDogdHJ1ZSxcbiAgc3RhdGVUcmFuc2Zvcm1lcjogZnVuY3Rpb24gc3RhdGVUcmFuc2Zvcm1lcihzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfSxcbiAgYWN0aW9uVHJhbnNmb3JtZXI6IGZ1bmN0aW9uIGFjdGlvblRyYW5zZm9ybWVyKGFjdGlvbikge1xuICAgIHJldHVybiBhY3Rpb247XG4gIH0sXG4gIGVycm9yVHJhbnNmb3JtZXI6IGZ1bmN0aW9uIGVycm9yVHJhbnNmb3JtZXIoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH0sXG4gIGNvbG9yczoge1xuICAgIHRpdGxlOiBmdW5jdGlvbiB0aXRsZSgpIHtcbiAgICAgIHJldHVybiBcImluaGVyaXRcIjtcbiAgICB9LFxuICAgIHByZXZTdGF0ZTogZnVuY3Rpb24gcHJldlN0YXRlKCkge1xuICAgICAgcmV0dXJuIFwiIzlFOUU5RVwiO1xuICAgIH0sXG4gICAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCIjMDNBOUY0XCI7XG4gICAgfSxcbiAgICBuZXh0U3RhdGU6IGZ1bmN0aW9uIG5leHRTdGF0ZSgpIHtcbiAgICAgIHJldHVybiBcIiM0Q0FGNTBcIjtcbiAgICB9LFxuICAgIGVycm9yOiBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICAgIHJldHVybiBcIiNGMjA0MDRcIjtcbiAgICB9XG4gIH0sXG4gIGRpZmY6IGZhbHNlLFxuICBkaWZmUHJlZGljYXRlOiB1bmRlZmluZWQsXG5cbiAgLy8gRGVwcmVjYXRlZCBvcHRpb25zXG4gIHRyYW5zZm9ybWVyOiB1bmRlZmluZWRcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWR1eC1sb2dnZXIvbGliL2RlZmF1bHRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGlmZkxvZ2dlcjtcblxudmFyIF9kZWVwRGlmZiA9IHJlcXVpcmUoJ2RlZXAtZGlmZicpO1xuXG52YXIgX2RlZXBEaWZmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZXBEaWZmKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbGl0Yml0L2RpZmYjZGlmZmVyZW5jZXNcbnZhciBkaWN0aW9uYXJ5ID0ge1xuICAnRSc6IHtcbiAgICBjb2xvcjogJyMyMTk2RjMnLFxuICAgIHRleHQ6ICdDSEFOR0VEOidcbiAgfSxcbiAgJ04nOiB7XG4gICAgY29sb3I6ICcjNENBRjUwJyxcbiAgICB0ZXh0OiAnQURERUQ6J1xuICB9LFxuICAnRCc6IHtcbiAgICBjb2xvcjogJyNGNDQzMzYnLFxuICAgIHRleHQ6ICdERUxFVEVEOidcbiAgfSxcbiAgJ0EnOiB7XG4gICAgY29sb3I6ICcjMjE5NkYzJyxcbiAgICB0ZXh0OiAnQVJSQVk6J1xuICB9XG59O1xuXG5mdW5jdGlvbiBzdHlsZShraW5kKSB7XG4gIHJldHVybiAnY29sb3I6ICcgKyBkaWN0aW9uYXJ5W2tpbmRdLmNvbG9yICsgJzsgZm9udC13ZWlnaHQ6IGJvbGQnO1xufVxuXG5mdW5jdGlvbiByZW5kZXIoZGlmZikge1xuICB2YXIga2luZCA9IGRpZmYua2luZCxcbiAgICAgIHBhdGggPSBkaWZmLnBhdGgsXG4gICAgICBsaHMgPSBkaWZmLmxocyxcbiAgICAgIHJocyA9IGRpZmYucmhzLFxuICAgICAgaW5kZXggPSBkaWZmLmluZGV4LFxuICAgICAgaXRlbSA9IGRpZmYuaXRlbTtcblxuXG4gIHN3aXRjaCAoa2luZCkge1xuICAgIGNhc2UgJ0UnOlxuICAgICAgcmV0dXJuIFtwYXRoLmpvaW4oJy4nKSwgbGhzLCAnXFx1MjE5MicsIHJoc107XG4gICAgY2FzZSAnTic6XG4gICAgICByZXR1cm4gW3BhdGguam9pbignLicpLCByaHNdO1xuICAgIGNhc2UgJ0QnOlxuICAgICAgcmV0dXJuIFtwYXRoLmpvaW4oJy4nKV07XG4gICAgY2FzZSAnQSc6XG4gICAgICByZXR1cm4gW3BhdGguam9pbignLicpICsgJ1snICsgaW5kZXggKyAnXScsIGl0ZW1dO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gW107XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlmZkxvZ2dlcihwcmV2U3RhdGUsIG5ld1N0YXRlLCBsb2dnZXIsIGlzQ29sbGFwc2VkKSB7XG4gIHZhciBkaWZmID0gKDAsIF9kZWVwRGlmZjIuZGVmYXVsdCkocHJldlN0YXRlLCBuZXdTdGF0ZSk7XG5cbiAgdHJ5IHtcbiAgICBpZiAoaXNDb2xsYXBzZWQpIHtcbiAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZCgnZGlmZicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZ3JvdXAoJ2RpZmYnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2dnZXIubG9nKCdkaWZmJyk7XG4gIH1cblxuICBpZiAoZGlmZikge1xuICAgIGRpZmYuZm9yRWFjaChmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgdmFyIGtpbmQgPSBlbGVtLmtpbmQ7XG5cbiAgICAgIHZhciBvdXRwdXQgPSByZW5kZXIoZWxlbSk7XG5cbiAgICAgIGxvZ2dlci5sb2cuYXBwbHkobG9nZ2VyLCBbJyVjICcgKyBkaWN0aW9uYXJ5W2tpbmRdLnRleHQsIHN0eWxlKGtpbmQpXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG91dHB1dCkpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBsb2dnZXIubG9nKCdcXHUyMDE0XFx1MjAxNCBubyBkaWZmIFxcdTIwMTRcXHUyMDE0Jyk7XG4gIH1cblxuICB0cnkge1xuICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyLmxvZygnXFx1MjAxNFxcdTIwMTQgZGlmZiBlbmQgXFx1MjAxNFxcdTIwMTQgJyk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWR1eC1sb2dnZXIvbGliL2RpZmYuanNcbi8vIG1vZHVsZSBpZCA9IDE2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmxvZ2dlciA9IGV4cG9ydHMuZGVmYXVsdHMgPSB1bmRlZmluZWQ7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG52YXIgX2hlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxudmFyIF9kZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxudmFyIF9kZWZhdWx0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZhdWx0cyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogQ3JlYXRlcyBsb2dnZXIgd2l0aCBmb2xsb3dpbmcgb3B0aW9uc1xuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgbG9nZ2VyXG4gKiBAcGFyYW0ge3N0cmluZyB8IGZ1bmN0aW9uIHwgb2JqZWN0fSBvcHRpb25zLmxldmVsIC0gY29uc29sZVtsZXZlbF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5kdXJhdGlvbiAtIHByaW50IGR1cmF0aW9uIG9mIGVhY2ggYWN0aW9uP1xuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnRpbWVzdGFtcCAtIHByaW50IHRpbWVzdGFtcCB3aXRoIGVhY2ggYWN0aW9uP1xuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuY29sb3JzIC0gY3VzdG9tIGNvbG9yc1xuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMubG9nZ2VyIC0gaW1wbGVtZW50YXRpb24gb2YgdGhlIGBjb25zb2xlYCBBUElcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5sb2dFcnJvcnMgLSBzaG91bGQgZXJyb3JzIGluIGFjdGlvbiBleGVjdXRpb24gYmUgY2F1Z2h0LCBsb2dnZWQsIGFuZCByZS10aHJvd24/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY29sbGFwc2VkIC0gaXMgZ3JvdXAgY29sbGFwc2VkP1xuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnByZWRpY2F0ZSAtIGNvbmRpdGlvbiB3aGljaCByZXNvbHZlcyBsb2dnZXIgYmVoYXZpb3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuc3RhdGVUcmFuc2Zvcm1lciAtIHRyYW5zZm9ybSBzdGF0ZSBiZWZvcmUgcHJpbnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuYWN0aW9uVHJhbnNmb3JtZXIgLSB0cmFuc2Zvcm0gYWN0aW9uIGJlZm9yZSBwcmludFxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5lcnJvclRyYW5zZm9ybWVyIC0gdHJhbnNmb3JtIGVycm9yIGJlZm9yZSBwcmludFxuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gbG9nZ2VyIG1pZGRsZXdhcmVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgdmFyIGxvZ2dlck9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgX2RlZmF1bHRzMi5kZWZhdWx0LCBvcHRpb25zKTtcblxuICB2YXIgbG9nZ2VyID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXIsXG4gICAgICB0cmFuc2Zvcm1lciA9IGxvZ2dlck9wdGlvbnMudHJhbnNmb3JtZXIsXG4gICAgICBzdGF0ZVRyYW5zZm9ybWVyID0gbG9nZ2VyT3B0aW9ucy5zdGF0ZVRyYW5zZm9ybWVyLFxuICAgICAgZXJyb3JUcmFuc2Zvcm1lciA9IGxvZ2dlck9wdGlvbnMuZXJyb3JUcmFuc2Zvcm1lcixcbiAgICAgIHByZWRpY2F0ZSA9IGxvZ2dlck9wdGlvbnMucHJlZGljYXRlLFxuICAgICAgbG9nRXJyb3JzID0gbG9nZ2VyT3B0aW9ucy5sb2dFcnJvcnMsXG4gICAgICBkaWZmUHJlZGljYXRlID0gbG9nZ2VyT3B0aW9ucy5kaWZmUHJlZGljYXRlO1xuXG4gIC8vIFJldHVybiBpZiAnY29uc29sZScgb2JqZWN0IGlzIG5vdCBkZWZpbmVkXG5cbiAgaWYgKHR5cGVvZiBsb2dnZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBpZiAodHJhbnNmb3JtZXIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdPcHRpb24gXFwndHJhbnNmb3JtZXJcXCcgaXMgZGVwcmVjYXRlZCwgdXNlIFxcJ3N0YXRlVHJhbnNmb3JtZXJcXCcgaW5zdGVhZCEnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gIH1cblxuICAvLyBEZXRlY3QgaWYgJ2NyZWF0ZUxvZ2dlcicgd2FzIHBhc3NlZCBkaXJlY3RseSB0byAnYXBwbHlNaWRkbGV3YXJlJy5cbiAgaWYgKG9wdGlvbnMuZ2V0U3RhdGUgJiYgb3B0aW9ucy5kaXNwYXRjaCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5lcnJvcignW3JlZHV4LWxvZ2dlcl0gcmVkdXgtbG9nZ2VyIG5vdCBpbnN0YWxsZWQuIE1ha2Ugc3VyZSB0byBwYXNzIGxvZ2dlciBpbnN0YW5jZSBhcyBtaWRkbGV3YXJlOlxcblxcbi8vIExvZ2dlciB3aXRoIGRlZmF1bHQgb3B0aW9uc1xcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXFwncmVkdXgtbG9nZ2VyXFwnXFxuY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZShcXG4gIHJlZHVjZXIsXFxuICBhcHBseU1pZGRsZXdhcmUobG9nZ2VyKVxcbilcXG5cXG5cXG4vLyBPciB5b3UgY2FuIGNyZWF0ZSB5b3VyIG93biBsb2dnZXIgd2l0aCBjdXN0b20gb3B0aW9ucyBodHRwOi8vYml0Lmx5L3JlZHV4LWxvZ2dlci1vcHRpb25zXFxuaW1wb3J0IGNyZWF0ZUxvZ2dlciBmcm9tIFxcJ3JlZHV4LWxvZ2dlclxcJ1xcblxcbmNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih7XFxuICAvLyAuLi5vcHRpb25zXFxufSk7XFxuXFxuY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZShcXG4gIHJlZHVjZXIsXFxuICBhcHBseU1pZGRsZXdhcmUobG9nZ2VyKVxcbilcXG4nKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGxvZ0J1ZmZlciA9IFtdO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBnZXRTdGF0ZSA9IF9yZWYuZ2V0U3RhdGU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIHByZWRpY2F0ZSBmdW5jdGlvbiByZXR1cm5zICdmYWxzZSdcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgPT09ICdmdW5jdGlvbicgJiYgIXByZWRpY2F0ZShnZXRTdGF0ZSwgYWN0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nRW50cnkgPSB7fTtcbiAgICAgICAgbG9nQnVmZmVyLnB1c2gobG9nRW50cnkpO1xuXG4gICAgICAgIGxvZ0VudHJ5LnN0YXJ0ZWQgPSBfaGVscGVycy50aW1lci5ub3coKTtcbiAgICAgICAgbG9nRW50cnkuc3RhcnRlZFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBsb2dFbnRyeS5wcmV2U3RhdGUgPSBzdGF0ZVRyYW5zZm9ybWVyKGdldFN0YXRlKCkpO1xuICAgICAgICBsb2dFbnRyeS5hY3Rpb24gPSBhY3Rpb247XG5cbiAgICAgICAgdmFyIHJldHVybmVkVmFsdWUgPSB2b2lkIDA7XG4gICAgICAgIGlmIChsb2dFcnJvcnMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuZWRWYWx1ZSA9IG5leHQoYWN0aW9uKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dFbnRyeS5lcnJvciA9IGVycm9yVHJhbnNmb3JtZXIoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybmVkVmFsdWUgPSBuZXh0KGFjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBsb2dFbnRyeS50b29rID0gX2hlbHBlcnMudGltZXIubm93KCkgLSBsb2dFbnRyeS5zdGFydGVkO1xuICAgICAgICBsb2dFbnRyeS5uZXh0U3RhdGUgPSBzdGF0ZVRyYW5zZm9ybWVyKGdldFN0YXRlKCkpO1xuXG4gICAgICAgIHZhciBkaWZmID0gbG9nZ2VyT3B0aW9ucy5kaWZmICYmIHR5cGVvZiBkaWZmUHJlZGljYXRlID09PSAnZnVuY3Rpb24nID8gZGlmZlByZWRpY2F0ZShnZXRTdGF0ZSwgYWN0aW9uKSA6IGxvZ2dlck9wdGlvbnMuZGlmZjtcblxuICAgICAgICAoMCwgX2NvcmUucHJpbnRCdWZmZXIpKGxvZ0J1ZmZlciwgX2V4dGVuZHMoe30sIGxvZ2dlck9wdGlvbnMsIHsgZGlmZjogZGlmZiB9KSk7XG4gICAgICAgIGxvZ0J1ZmZlci5sZW5ndGggPSAwO1xuXG4gICAgICAgIGlmIChsb2dFbnRyeS5lcnJvcikgdGhyb3cgbG9nRW50cnkuZXJyb3I7XG4gICAgICAgIHJldHVybiByZXR1cm5lZFZhbHVlO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xufVxuXG52YXIgZGVmYXVsdExvZ2dlciA9IGNyZWF0ZUxvZ2dlcigpO1xuXG5leHBvcnRzLmRlZmF1bHRzID0gX2RlZmF1bHRzMi5kZWZhdWx0O1xuZXhwb3J0cy5sb2dnZXIgPSBkZWZhdWx0TG9nZ2VyO1xuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlTG9nZ2VyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVkdXgtbG9nZ2VyL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCBjb21wb3NlIGZyb20gJy4vY29tcG9zZSc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0b3JlIGVuaGFuY2VyIHRoYXQgYXBwbGllcyBtaWRkbGV3YXJlIHRvIHRoZSBkaXNwYXRjaCBtZXRob2RcbiAqIG9mIHRoZSBSZWR1eCBzdG9yZS4gVGhpcyBpcyBoYW5keSBmb3IgYSB2YXJpZXR5IG9mIHRhc2tzLCBzdWNoIGFzIGV4cHJlc3NpbmdcbiAqIGFzeW5jaHJvbm91cyBhY3Rpb25zIGluIGEgY29uY2lzZSBtYW5uZXIsIG9yIGxvZ2dpbmcgZXZlcnkgYWN0aW9uIHBheWxvYWQuXG4gKlxuICogU2VlIGByZWR1eC10aHVua2AgcGFja2FnZSBhcyBhbiBleGFtcGxlIG9mIHRoZSBSZWR1eCBtaWRkbGV3YXJlLlxuICpcbiAqIEJlY2F1c2UgbWlkZGxld2FyZSBpcyBwb3RlbnRpYWxseSBhc3luY2hyb25vdXMsIHRoaXMgc2hvdWxkIGJlIHRoZSBmaXJzdFxuICogc3RvcmUgZW5oYW5jZXIgaW4gdGhlIGNvbXBvc2l0aW9uIGNoYWluLlxuICpcbiAqIE5vdGUgdGhhdCBlYWNoIG1pZGRsZXdhcmUgd2lsbCBiZSBnaXZlbiB0aGUgYGRpc3BhdGNoYCBhbmQgYGdldFN0YXRlYCBmdW5jdGlvbnNcbiAqIGFzIG5hbWVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBtaWRkbGV3YXJlcyBUaGUgbWlkZGxld2FyZSBjaGFpbiB0byBiZSBhcHBsaWVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHN0b3JlIGVuaGFuY2VyIGFwcGx5aW5nIHRoZSBtaWRkbGV3YXJlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseU1pZGRsZXdhcmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtaWRkbGV3YXJlcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1pZGRsZXdhcmVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjcmVhdGVTdG9yZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKSB7XG4gICAgICB2YXIgc3RvcmUgPSBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpO1xuICAgICAgdmFyIF9kaXNwYXRjaCA9IHN0b3JlLmRpc3BhdGNoO1xuICAgICAgdmFyIGNoYWluID0gW107XG5cbiAgICAgIHZhciBtaWRkbGV3YXJlQVBJID0ge1xuICAgICAgICBnZXRTdGF0ZTogc3RvcmUuZ2V0U3RhdGUsXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gX2Rpc3BhdGNoKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjaGFpbiA9IG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgICAgICByZXR1cm4gbWlkZGxld2FyZShtaWRkbGV3YXJlQVBJKTtcbiAgICAgIH0pO1xuICAgICAgX2Rpc3BhdGNoID0gY29tcG9zZS5hcHBseSh1bmRlZmluZWQsIGNoYWluKShzdG9yZS5kaXNwYXRjaCk7XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RvcmUsIHtcbiAgICAgICAgZGlzcGF0Y2g6IF9kaXNwYXRjaFxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVkdXgvZXMvYXBwbHlNaWRkbGV3YXJlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2goYWN0aW9uQ3JlYXRvci5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvbiBjcmVhdG9ycywgaW50byBhbiBvYmplY3Qgd2l0aCB0aGVcbiAqIHNhbWUga2V5cywgYnV0IHdpdGggZXZlcnkgZnVuY3Rpb24gd3JhcHBlZCBpbnRvIGEgYGRpc3BhdGNoYCBjYWxsIHNvIHRoZXlcbiAqIG1heSBiZSBpbnZva2VkIGRpcmVjdGx5LiBUaGlzIGlzIGp1c3QgYSBjb252ZW5pZW5jZSBtZXRob2QsIGFzIHlvdSBjYW4gY2FsbFxuICogYHN0b3JlLmRpc3BhdGNoKE15QWN0aW9uQ3JlYXRvcnMuZG9Tb21ldGhpbmcoKSlgIHlvdXJzZWxmIGp1c3QgZmluZS5cbiAqXG4gKiBGb3IgY29udmVuaWVuY2UsIHlvdSBjYW4gYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCxcbiAqIGFuZCBnZXQgYSBmdW5jdGlvbiBpbiByZXR1cm4uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IGFjdGlvbkNyZWF0b3JzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvblxuICogY3JlYXRvciBmdW5jdGlvbnMuIE9uZSBoYW5keSB3YXkgdG8gb2J0YWluIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzYFxuICogc3ludGF4LiBZb3UgbWF5IGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXNwYXRjaCBUaGUgYGRpc3BhdGNoYCBmdW5jdGlvbiBhdmFpbGFibGUgb24geW91ciBSZWR1eFxuICogc3RvcmUuXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufE9iamVjdH0gVGhlIG9iamVjdCBtaW1pY2tpbmcgdGhlIG9yaWdpbmFsIG9iamVjdCwgYnV0IHdpdGhcbiAqIGV2ZXJ5IGFjdGlvbiBjcmVhdG9yIHdyYXBwZWQgaW50byB0aGUgYGRpc3BhdGNoYCBjYWxsLiBJZiB5b3UgcGFzc2VkIGFcbiAqIGZ1bmN0aW9uIGFzIGBhY3Rpb25DcmVhdG9yc2AsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBhbHNvIGJlIGEgc2luZ2xlXG4gKiBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCkge1xuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzICE9PSAnb2JqZWN0JyB8fCBhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYmluZEFjdGlvbkNyZWF0b3JzIGV4cGVjdGVkIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uLCBpbnN0ZWFkIHJlY2VpdmVkICcgKyAoYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgYWN0aW9uQ3JlYXRvcnMpICsgJy4gJyArICdEaWQgeW91IHdyaXRlIFwiaW1wb3J0IEFjdGlvbkNyZWF0b3JzIGZyb21cIiBpbnN0ZWFkIG9mIFwiaW1wb3J0ICogYXMgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiPycpO1xuICB9XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhY3Rpb25DcmVhdG9ycyk7XG4gIHZhciBib3VuZEFjdGlvbkNyZWF0b3JzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIHZhciBhY3Rpb25DcmVhdG9yID0gYWN0aW9uQ3JlYXRvcnNba2V5XTtcbiAgICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJvdW5kQWN0aW9uQ3JlYXRvcnNba2V5XSA9IGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kQWN0aW9uQ3JlYXRvcnM7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlZHV4L2VzL2JpbmRBY3Rpb25DcmVhdG9ycy5qc1xuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEFjdGlvblR5cGVzIH0gZnJvbSAnLi9jcmVhdGVTdG9yZSc7XG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICdsb2Rhc2gtZXMvaXNQbGFpbk9iamVjdCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuL3V0aWxzL3dhcm5pbmcnO1xuXG5mdW5jdGlvbiBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShrZXksIGFjdGlvbikge1xuICB2YXIgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcbiAgdmFyIGFjdGlvbk5hbWUgPSBhY3Rpb25UeXBlICYmICdcIicgKyBhY3Rpb25UeXBlLnRvU3RyaW5nKCkgKyAnXCInIHx8ICdhbiBhY3Rpb24nO1xuXG4gIHJldHVybiAnR2l2ZW4gYWN0aW9uICcgKyBhY3Rpb25OYW1lICsgJywgcmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkLiAnICsgJ1RvIGlnbm9yZSBhbiBhY3Rpb24sIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS4gJyArICdJZiB5b3Ugd2FudCB0aGlzIHJlZHVjZXIgdG8gaG9sZCBubyB2YWx1ZSwgeW91IGNhbiByZXR1cm4gbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC4nO1xufVxuXG5mdW5jdGlvbiBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKGlucHV0U3RhdGUsIHJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSkge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBhcmd1bWVudE5hbWUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IEFjdGlvblR5cGVzLklOSVQgPyAncHJlbG9hZGVkU3RhdGUgYXJndW1lbnQgcGFzc2VkIHRvIGNyZWF0ZVN0b3JlJyA6ICdwcmV2aW91cyBzdGF0ZSByZWNlaXZlZCBieSB0aGUgcmVkdWNlcic7XG5cbiAgaWYgKHJlZHVjZXJLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnU3RvcmUgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIHJlZHVjZXIuIE1ha2Ugc3VyZSB0aGUgYXJndW1lbnQgcGFzc2VkICcgKyAndG8gY29tYmluZVJlZHVjZXJzIGlzIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIHJlZHVjZXJzLic7XG4gIH1cblxuICBpZiAoIWlzUGxhaW5PYmplY3QoaW5wdXRTdGF0ZSkpIHtcbiAgICByZXR1cm4gJ1RoZSAnICsgYXJndW1lbnROYW1lICsgJyBoYXMgdW5leHBlY3RlZCB0eXBlIG9mIFwiJyArIHt9LnRvU3RyaW5nLmNhbGwoaW5wdXRTdGF0ZSkubWF0Y2goL1xccyhbYS16fEEtWl0rKS8pWzFdICsgJ1wiLiBFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nICcgKyAoJ2tleXM6IFwiJyArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiJyk7XG4gIH1cblxuICB2YXIgdW5leHBlY3RlZEtleXMgPSBPYmplY3Qua2V5cyhpbnB1dFN0YXRlKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhcmVkdWNlcnMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhdW5leHBlY3RlZEtleUNhY2hlW2tleV07XG4gIH0pO1xuXG4gIHVuZXhwZWN0ZWRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldID0gdHJ1ZTtcbiAgfSk7XG5cbiAgaWYgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gJ1VuZXhwZWN0ZWQgJyArICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAxID8gJ2tleXMnIDogJ2tleScpICsgJyAnICsgKCdcIicgKyB1bmV4cGVjdGVkS2V5cy5qb2luKCdcIiwgXCInKSArICdcIiBmb3VuZCBpbiAnICsgYXJndW1lbnROYW1lICsgJy4gJykgKyAnRXhwZWN0ZWQgdG8gZmluZCBvbmUgb2YgdGhlIGtub3duIHJlZHVjZXIga2V5cyBpbnN0ZWFkOiAnICsgKCdcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRSZWR1Y2VyU2hhcGUocmVkdWNlcnMpIHtcbiAgT2JqZWN0LmtleXMocmVkdWNlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciByZWR1Y2VyID0gcmVkdWNlcnNba2V5XTtcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gcmVkdWNlcih1bmRlZmluZWQsIHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcblxuICAgIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLiAnICsgJ0lmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXIgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCAnICsgJ2V4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgJyArICdub3QgYmUgdW5kZWZpbmVkLiBJZiB5b3UgZG9uXFwndCB3YW50IHRvIHNldCBhIHZhbHVlIGZvciB0aGlzIHJlZHVjZXIsICcgKyAneW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9ICdAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OXycgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoJycpLmpvaW4oJy4nKTtcbiAgICBpZiAodHlwZW9mIHJlZHVjZXIodW5kZWZpbmVkLCB7IHR5cGU6IHR5cGUgfSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIHByb2JlZCB3aXRoIGEgcmFuZG9tIHR5cGUuICcgKyAoJ0RvblxcJ3QgdHJ5IHRvIGhhbmRsZSAnICsgQWN0aW9uVHlwZXMuSU5JVCArICcgb3Igb3RoZXIgYWN0aW9ucyBpbiBcInJlZHV4LypcIiAnKSArICduYW1lc3BhY2UuIFRoZXkgYXJlIGNvbnNpZGVyZWQgcHJpdmF0ZS4gSW5zdGVhZCwgeW91IG11c3QgcmV0dXJuIHRoZSAnICsgJ2N1cnJlbnQgc3RhdGUgZm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHVubGVzcyBpdCBpcyB1bmRlZmluZWQsICcgKyAnaW4gd2hpY2ggY2FzZSB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUsIHJlZ2FyZGxlc3Mgb2YgdGhlICcgKyAnYWN0aW9uIHR5cGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLCBidXQgY2FuIGJlIG51bGwuJyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBkaWZmZXJlbnQgcmVkdWNlciBmdW5jdGlvbnMsIGludG8gYSBzaW5nbGVcbiAqIHJlZHVjZXIgZnVuY3Rpb24uIEl0IHdpbGwgY2FsbCBldmVyeSBjaGlsZCByZWR1Y2VyLCBhbmQgZ2F0aGVyIHRoZWlyIHJlc3VsdHNcbiAqIGludG8gYSBzaW5nbGUgc3RhdGUgb2JqZWN0LCB3aG9zZSBrZXlzIGNvcnJlc3BvbmQgdG8gdGhlIGtleXMgb2YgdGhlIHBhc3NlZFxuICogcmVkdWNlciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlZHVjZXJzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgY29ycmVzcG9uZCB0byBkaWZmZXJlbnRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBjb21iaW5lZCBpbnRvIG9uZS4gT25lIGhhbmR5IHdheSB0byBvYnRhaW5cbiAqIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzIHJlZHVjZXJzYCBzeW50YXguIFRoZSByZWR1Y2VycyBtYXkgbmV2ZXIgcmV0dXJuXG4gKiB1bmRlZmluZWQgZm9yIGFueSBhY3Rpb24uIEluc3RlYWQsIHRoZXkgc2hvdWxkIHJldHVybiB0aGVpciBpbml0aWFsIHN0YXRlXG4gKiBpZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZW0gd2FzIHVuZGVmaW5lZCwgYW5kIHRoZSBjdXJyZW50IHN0YXRlIGZvciBhbnlcbiAqIHVucmVjb2duaXplZCBhY3Rpb24uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHJlZHVjZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGV2ZXJ5IHJlZHVjZXIgaW5zaWRlIHRoZVxuICogcGFzc2VkIG9iamVjdCwgYW5kIGJ1aWxkcyBhIHN0YXRlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgZmluYWxSZWR1Y2VycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IHJlZHVjZXJLZXlzW2ldO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2FybmluZygnTm8gcmVkdWNlciBwcm92aWRlZCBmb3Iga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmluYWxSZWR1Y2Vyc1trZXldID0gcmVkdWNlcnNba2V5XTtcbiAgICB9XG4gIH1cbiAgdmFyIGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcblxuICB2YXIgdW5leHBlY3RlZEtleUNhY2hlID0gdm9pZCAwO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZSA9IHt9O1xuICB9XG5cbiAgdmFyIHNoYXBlQXNzZXJ0aW9uRXJyb3IgPSB2b2lkIDA7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UmVkdWNlclNoYXBlKGZpbmFsUmVkdWNlcnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2hhcGVBc3NlcnRpb25FcnJvciA9IGU7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gY29tYmluYXRpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzWzFdO1xuXG4gICAgaWYgKHNoYXBlQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICAgIHRocm93IHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKTtcbiAgICAgIGlmICh3YXJuaW5nTWVzc2FnZSkge1xuICAgICAgICB3YXJuaW5nKHdhcm5pbmdNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBuZXh0U3RhdGUgPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZmluYWxSZWR1Y2VyS2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfa2V5ID0gZmluYWxSZWR1Y2VyS2V5c1tfaV07XG4gICAgICB2YXIgcmVkdWNlciA9IGZpbmFsUmVkdWNlcnNbX2tleV07XG4gICAgICB2YXIgcHJldmlvdXNTdGF0ZUZvcktleSA9IHN0YXRlW19rZXldO1xuICAgICAgdmFyIG5leHRTdGF0ZUZvcktleSA9IHJlZHVjZXIocHJldmlvdXNTdGF0ZUZvcktleSwgYWN0aW9uKTtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFN0YXRlRm9yS2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2UoX2tleSwgYWN0aW9uKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBuZXh0U3RhdGVbX2tleV0gPSBuZXh0U3RhdGVGb3JLZXk7XG4gICAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBuZXh0U3RhdGVGb3JLZXkgIT09IHByZXZpb3VzU3RhdGVGb3JLZXk7XG4gICAgfVxuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gbmV4dFN0YXRlIDogc3RhdGU7XG4gIH07XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlZHV4L2VzL2NvbWJpbmVSZWR1Y2Vycy5qc1xuLy8gbW9kdWxlIGlkID0gMTY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvaW5kZXgnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wb255ZmlsbCA9IHJlcXVpcmUoJy4vcG9ueWZpbGwuanMnKTtcblxudmFyIF9wb255ZmlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb255ZmlsbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHJvb3Q7IC8qIGdsb2JhbCB3aW5kb3cgKi9cblxuXG5pZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gbW9kdWxlO1xufSBlbHNlIHtcbiAgcm9vdCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG59XG5cbnZhciByZXN1bHQgPSAoMCwgX3BvbnlmaWxsMlsnZGVmYXVsdCddKShyb290KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHJlc3VsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3ltYm9sLW9ic2VydmFibGUvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsO1xuZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcblx0dmFyIHJlc3VsdDtcblx0dmFyIF9TeW1ib2wgPSByb290LlN5bWJvbDtcblxuXHRpZiAodHlwZW9mIF9TeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcblx0XHRpZiAoX1N5bWJvbC5vYnNlcnZhYmxlKSB7XG5cdFx0XHRyZXN1bHQgPSBfU3ltYm9sLm9ic2VydmFibGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9IF9TeW1ib2woJ29ic2VydmFibGUnKTtcblx0XHRcdF9TeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3ltYm9sLW9ic2VydmFibGUvbGliL3BvbnlmaWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0cmltO1xuXG5mdW5jdGlvbiB0cmltKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xufVxuXG5leHBvcnRzLmxlZnQgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpO1xufTtcblxuZXhwb3J0cy5yaWdodCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3RyaW0vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB3aW5kb3cgPSByZXF1aXJlKFwiZ2xvYmFsL3dpbmRvd1wiKVxudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKFwiaXMtZnVuY3Rpb25cIilcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKFwicGFyc2UtaGVhZGVyc1wiKVxudmFyIHh0ZW5kID0gcmVxdWlyZShcInh0ZW5kXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlWEhSXG5jcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgfHwgbm9vcFxuY3JlYXRlWEhSLlhEb21haW5SZXF1ZXN0ID0gXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiAobmV3IGNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCgpKSA/IGNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCA6IHdpbmRvdy5YRG9tYWluUmVxdWVzdFxuXG5mb3JFYWNoQXJyYXkoW1wiZ2V0XCIsIFwicHV0XCIsIFwicG9zdFwiLCBcInBhdGNoXCIsIFwiaGVhZFwiLCBcImRlbGV0ZVwiXSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgY3JlYXRlWEhSW21ldGhvZCA9PT0gXCJkZWxldGVcIiA/IFwiZGVsXCIgOiBtZXRob2RdID0gZnVuY3Rpb24odXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBvcHRpb25zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgICAgICBvcHRpb25zLm1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgICAgIHJldHVybiBfY3JlYXRlWEhSKG9wdGlvbnMpXG4gICAgfVxufSlcblxuZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFycmF5LCBpdGVyYXRvcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0b3IoYXJyYXlbaV0pXG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0VtcHR5KG9iail7XG4gICAgZm9yKHZhciBpIGluIG9iail7XG4gICAgICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciBwYXJhbXMgPSB1cmlcblxuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgICBpZiAodHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcGFyYW1zID0ge3VyaTp1cml9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMgPSB4dGVuZChvcHRpb25zLCB7dXJpOiB1cml9KVxuICAgIH1cblxuICAgIHBhcmFtcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgcmV0dXJuIHBhcmFtc1xufVxuXG5mdW5jdGlvbiBjcmVhdGVYSFIodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIG9wdGlvbnMgPSBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgcmV0dXJuIF9jcmVhdGVYSFIob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVhIUihvcHRpb25zKSB7XG4gICAgaWYodHlwZW9mIG9wdGlvbnMuY2FsbGJhY2sgPT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWxsYmFjayBhcmd1bWVudCBtaXNzaW5nXCIpXG4gICAgfVxuXG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlXG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2JPbmNlKGVyciwgcmVzcG9uc2UsIGJvZHkpe1xuICAgICAgICBpZighY2FsbGVkKXtcbiAgICAgICAgICAgIGNhbGxlZCA9IHRydWVcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soZXJyLCByZXNwb25zZSwgYm9keSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChsb2FkRnVuYywgMClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJvZHkoKSB7XG4gICAgICAgIC8vIENocm9tZSB3aXRoIHJlcXVlc3RUeXBlPWJsb2IgdGhyb3dzIGVycm9ycyBhcnJvdW5kIHdoZW4gZXZlbiB0ZXN0aW5nIGFjY2VzcyB0byByZXNwb25zZVRleHRcbiAgICAgICAgdmFyIGJvZHkgPSB1bmRlZmluZWRcblxuICAgICAgICBpZiAoeGhyLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICBib2R5ID0geGhyLnJlc3BvbnNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0geGhyLnJlc3BvbnNlVGV4dCB8fCBnZXRYbWwoeGhyKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSnNvbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib2R5XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJyb3JGdW5jKGV2dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFRpbWVyKVxuICAgICAgICBpZighKGV2dCBpbnN0YW5jZW9mIEVycm9yKSl7XG4gICAgICAgICAgICBldnQgPSBuZXcgRXJyb3IoXCJcIiArIChldnQgfHwgXCJVbmtub3duIFhNTEh0dHBSZXF1ZXN0IEVycm9yXCIpIClcbiAgICAgICAgfVxuICAgICAgICBldnQuc3RhdHVzQ29kZSA9IDBcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGV2dCwgZmFpbHVyZVJlc3BvbnNlKVxuICAgIH1cblxuICAgIC8vIHdpbGwgbG9hZCB0aGUgZGF0YSAmIHByb2Nlc3MgdGhlIHJlc3BvbnNlIGluIGEgc3BlY2lhbCByZXNwb25zZSBvYmplY3RcbiAgICBmdW5jdGlvbiBsb2FkRnVuYygpIHtcbiAgICAgICAgaWYgKGFib3J0ZWQpIHJldHVyblxuICAgICAgICB2YXIgc3RhdHVzXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpXG4gICAgICAgIGlmKG9wdGlvbnMudXNlWERSICYmIHhoci5zdGF0dXM9PT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vSUU4IENPUlMgR0VUIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZG9lc24ndCBoYXZlIGEgc3RhdHVzIGZpZWxkLCBidXQgYm9keSBpcyBmaW5lXG4gICAgICAgICAgICBzdGF0dXMgPSAyMDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICh4aHIuc3RhdHVzID09PSAxMjIzID8gMjA0IDogeGhyLnN0YXR1cylcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzcG9uc2UgPSBmYWlsdXJlUmVzcG9uc2VcbiAgICAgICAgdmFyIGVyciA9IG51bGxcblxuICAgICAgICBpZiAoc3RhdHVzICE9PSAwKXtcbiAgICAgICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGdldEJvZHkoKSxcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXMsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgdXJsOiB1cmksXG4gICAgICAgICAgICAgICAgcmF3UmVxdWVzdDogeGhyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKXsgLy9yZW1lbWJlciB4aHIgY2FuIGluIGZhY3QgYmUgWERSIGZvciBDT1JTIGluIElFXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycyA9IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoXCJJbnRlcm5hbCBYTUxIdHRwUmVxdWVzdCBFcnJvclwiKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIHJlc3BvbnNlLCByZXNwb25zZS5ib2R5KVxuICAgIH1cblxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociB8fCBudWxsXG5cbiAgICBpZiAoIXhocikge1xuICAgICAgICBpZiAob3B0aW9ucy5jb3JzIHx8IG9wdGlvbnMudXNlWERSKSB7XG4gICAgICAgICAgICB4aHIgPSBuZXcgY3JlYXRlWEhSLlhEb21haW5SZXF1ZXN0KClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB4aHIgPSBuZXcgY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlcbiAgICB2YXIgYWJvcnRlZFxuICAgIHZhciB1cmkgPSB4aHIudXJsID0gb3B0aW9ucy51cmkgfHwgb3B0aW9ucy51cmxcbiAgICB2YXIgbWV0aG9kID0geGhyLm1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCJcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keSB8fCBvcHRpb25zLmRhdGFcbiAgICB2YXIgaGVhZGVycyA9IHhoci5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9XG4gICAgdmFyIHN5bmMgPSAhIW9wdGlvbnMuc3luY1xuICAgIHZhciBpc0pzb24gPSBmYWxzZVxuICAgIHZhciB0aW1lb3V0VGltZXJcbiAgICB2YXIgZmFpbHVyZVJlc3BvbnNlID0ge1xuICAgICAgICBib2R5OiB1bmRlZmluZWQsXG4gICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICBzdGF0dXNDb2RlOiAwLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgdXJsOiB1cmksXG4gICAgICAgIHJhd1JlcXVlc3Q6IHhoclxuICAgIH1cblxuICAgIGlmIChcImpzb25cIiBpbiBvcHRpb25zICYmIG9wdGlvbnMuanNvbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgaXNKc29uID0gdHJ1ZVxuICAgICAgICBoZWFkZXJzW1wiYWNjZXB0XCJdIHx8IGhlYWRlcnNbXCJBY2NlcHRcIl0gfHwgKGhlYWRlcnNbXCJBY2NlcHRcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIikgLy9Eb24ndCBvdmVycmlkZSBleGlzdGluZyBhY2NlcHQgaGVhZGVyIGRlY2xhcmVkIGJ5IHVzZXJcbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gXCJHRVRcIiAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdIHx8IGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gfHwgKGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIikgLy9Eb24ndCBvdmVycmlkZSBleGlzdGluZyBhY2NlcHQgaGVhZGVyIGRlY2xhcmVkIGJ5IHVzZXJcbiAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmpzb24gPT09IHRydWUgPyBib2R5IDogb3B0aW9ucy5qc29uKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHJlYWR5c3RhdGVjaGFuZ2VcbiAgICB4aHIub25sb2FkID0gbG9hZEZ1bmNcbiAgICB4aHIub25lcnJvciA9IGVycm9yRnVuY1xuICAgIC8vIElFOSBtdXN0IGhhdmUgb25wcm9ncmVzcyBiZSBzZXQgdG8gYSB1bmlxdWUgZnVuY3Rpb24uXG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElFIG11c3QgZGllXG4gICAgfVxuICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgfVxuICAgIHhoci5vbnRpbWVvdXQgPSBlcnJvckZ1bmNcbiAgICB4aHIub3BlbihtZXRob2QsIHVyaSwgIXN5bmMsIG9wdGlvbnMudXNlcm5hbWUsIG9wdGlvbnMucGFzc3dvcmQpXG4gICAgLy9oYXMgdG8gYmUgYWZ0ZXIgb3BlblxuICAgIGlmKCFzeW5jKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIW9wdGlvbnMud2l0aENyZWRlbnRpYWxzXG4gICAgfVxuICAgIC8vIENhbm5vdCBzZXQgdGltZW91dCB3aXRoIHN5bmMgcmVxdWVzdFxuICAgIC8vIG5vdCBzZXR0aW5nIHRpbWVvdXQgb24gdGhlIHhociBvYmplY3QsIGJlY2F1c2Ugb2Ygb2xkIHdlYmtpdHMgZXRjLiBub3QgaGFuZGxpbmcgdGhhdCBjb3JyZWN0bHlcbiAgICAvLyBib3RoIG5wbSdzIHJlcXVlc3QgYW5kIGpxdWVyeSAxLnggdXNlIHRoaXMga2luZCBvZiB0aW1lb3V0LCBzbyB0aGlzIGlzIGJlaW5nIGNvbnNpc3RlbnRcbiAgICBpZiAoIXN5bmMgJiYgb3B0aW9ucy50aW1lb3V0ID4gMCApIHtcbiAgICAgICAgdGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKGFib3J0ZWQpIHJldHVyblxuICAgICAgICAgICAgYWJvcnRlZCA9IHRydWUvL0lFOSBtYXkgc3RpbGwgY2FsbCByZWFkeXN0YXRlY2hhbmdlXG4gICAgICAgICAgICB4aHIuYWJvcnQoXCJ0aW1lb3V0XCIpXG4gICAgICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcihcIlhNTEh0dHBSZXF1ZXN0IHRpbWVvdXRcIilcbiAgICAgICAgICAgIGUuY29kZSA9IFwiRVRJTUVET1VUXCJcbiAgICAgICAgICAgIGVycm9yRnVuYyhlKVxuICAgICAgICB9LCBvcHRpb25zLnRpbWVvdXQgKVxuICAgIH1cblxuICAgIGlmICh4aHIuc2V0UmVxdWVzdEhlYWRlcikge1xuICAgICAgICBmb3Ioa2V5IGluIGhlYWRlcnMpe1xuICAgICAgICAgICAgaWYoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5oZWFkZXJzICYmICFpc0VtcHR5KG9wdGlvbnMuaGVhZGVycykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVhZGVycyBjYW5ub3QgYmUgc2V0IG9uIGFuIFhEb21haW5SZXF1ZXN0IG9iamVjdFwiKVxuICAgIH1cblxuICAgIGlmIChcInJlc3BvbnNlVHlwZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IG9wdGlvbnMucmVzcG9uc2VUeXBlXG4gICAgfVxuXG4gICAgaWYgKFwiYmVmb3JlU2VuZFwiIGluIG9wdGlvbnMgJiZcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuYmVmb3JlU2VuZCA9PT0gXCJmdW5jdGlvblwiXG4gICAgKSB7XG4gICAgICAgIG9wdGlvbnMuYmVmb3JlU2VuZCh4aHIpXG4gICAgfVxuXG4gICAgLy8gTWljcm9zb2Z0IEVkZ2UgYnJvd3NlciBzZW5kcyBcInVuZGVmaW5lZFwiIHdoZW4gc2VuZCBpcyBjYWxsZWQgd2l0aCB1bmRlZmluZWQgdmFsdWUuXG4gICAgLy8gWE1MSHR0cFJlcXVlc3Qgc3BlYyBzYXlzIHRvIHBhc3MgbnVsbCBhcyBib2R5IHRvIGluZGljYXRlIG5vIGJvZHlcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25hdWd0dXIveGhyL2lzc3Vlcy8xMDAuXG4gICAgeGhyLnNlbmQoYm9keSB8fCBudWxsKVxuXG4gICAgcmV0dXJuIHhoclxuXG5cbn1cblxuZnVuY3Rpb24gZ2V0WG1sKHhocikge1xuICAgIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVhNTFxuICAgIH1cbiAgICB2YXIgZmlyZWZveEJ1Z1Rha2VuRWZmZWN0ID0geGhyLnJlc3BvbnNlWE1MICYmIHhoci5yZXNwb25zZVhNTC5kb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgPT09IFwicGFyc2VyZXJyb3JcIlxuICAgIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSBcIlwiICYmICFmaXJlZm94QnVnVGFrZW5FZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVhNTFxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3hoci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgdGFyZ2V0ID0ge31cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34veHRlbmQvaW1tdXRhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==